<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/mem0mem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mem0mem_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mem0mem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The memory management.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0rnd_8h_source.html">ut0rnd.h</a>&quot;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &quot;mem0mem.ic&quot;</code><br />
</div>
<p><a href="mem0mem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__block__info__t.html">mem_block_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The info structure stored at the beginning of a heap block.  <a href="structmem__block__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmem__heap__allocator.html">mem_heap_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ wrapper class to the mem_heap_t routines, so that it can be used as an STL allocator.  <a href="classmem__heap__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__heap__allocator_1_1rebind.html">mem_heap_allocator&lt; T &gt;::rebind&lt; U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocators are required to supply the below template class member which enables the possibility of obtaining a related allocator, parametrized in terms of a different type.  <a href="structmem__heap__allocator_1_1rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac7fc6050ef7fde046b8aa0af92c2afae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ac7fc6050ef7fde046b8aa0af92c2afae">MEM_HEAP_DYNAMIC</a>&#160;&#160;&#160;0 /* the most common type */</td></tr>
<tr class="memdesc:ac7fc6050ef7fde046b8aa0af92c2afae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of allocation for memory heaps: DYNAMIC means allocation from the dynamic memory pool of the C compiler, BUFFER means allocation from the buffer pool; the latter method is used for very big heaps.  <a href="#ac7fc6050ef7fde046b8aa0af92c2afae">More...</a><br /></td></tr>
<tr class="separator:ac7fc6050ef7fde046b8aa0af92c2afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2623d2577c63e89bd0173f928be08e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ad2623d2577c63e89bd0173f928be08e9">MEM_HEAP_BUFFER</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad2623d2577c63e89bd0173f928be08e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6621ead8a647eed62fbd8a311a62330c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a6621ead8a647eed62fbd8a311a62330c">MEM_HEAP_BTR_SEARCH</a></td></tr>
<tr class="separator:a6621ead8a647eed62fbd8a311a62330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d3586895796c6473e46aa6a64bd998"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a47d3586895796c6473e46aa6a64bd998">MEM_HEAP_FOR_BTR_SEARCH</a>&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#a6621ead8a647eed62fbd8a311a62330c">MEM_HEAP_BTR_SEARCH</a> | <a class="el" href="mem0mem_8h.html#ad2623d2577c63e89bd0173f928be08e9">MEM_HEAP_BUFFER</a>)</td></tr>
<tr class="memdesc:a47d3586895796c6473e46aa6a64bd998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different type of heaps in terms of which data structure is using them.  <a href="#a47d3586895796c6473e46aa6a64bd998">More...</a><br /></td></tr>
<tr class="separator:a47d3586895796c6473e46aa6a64bd998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1e03a482e10cf25756bb96b3368bc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a7c1e03a482e10cf25756bb96b3368bc2">MEM_HEAP_FOR_PAGE_HASH</a>&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#ac7fc6050ef7fde046b8aa0af92c2afae">MEM_HEAP_DYNAMIC</a>)</td></tr>
<tr class="separator:a7c1e03a482e10cf25756bb96b3368bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e266b884663510a1c569492edfc3a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a83e266b884663510a1c569492edfc3a4">MEM_HEAP_FOR_RECV_SYS</a>&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#ad2623d2577c63e89bd0173f928be08e9">MEM_HEAP_BUFFER</a>)</td></tr>
<tr class="separator:a83e266b884663510a1c569492edfc3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a390063fcee97542cade99064c3014"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a68a390063fcee97542cade99064c3014">MEM_HEAP_FOR_LOCK_HEAP</a>&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#ad2623d2577c63e89bd0173f928be08e9">MEM_HEAP_BUFFER</a>)</td></tr>
<tr class="separator:a68a390063fcee97542cade99064c3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07412b5b33ff3b94be36b581449cbeb7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a07412b5b33ff3b94be36b581449cbeb7">MEM_BLOCK_START_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:a07412b5b33ff3b94be36b581449cbeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following start size is used for the first block in the memory heap if the size is not specified, i.e., 0 is given as the parameter in the call of create.  <a href="#a07412b5b33ff3b94be36b581449cbeb7">More...</a><br /></td></tr>
<tr class="separator:a07412b5b33ff3b94be36b581449cbeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff86ded019fa67facacc67b8a615001b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#aff86ded019fa67facacc67b8a615001b">MEM_BLOCK_STANDARD_SIZE</a>&#160;&#160;&#160;(UNIV_PAGE_SIZE &gt;= 16384 ? 8000 : <a class="el" href="mem0mem_8h.html#a737ff56ffe835fe44b1a133a459141e8">MEM_MAX_ALLOC_IN_BUF</a>)</td></tr>
<tr class="separator:aff86ded019fa67facacc67b8a615001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737ff56ffe835fe44b1a133a459141e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a737ff56ffe835fe44b1a133a459141e8">MEM_MAX_ALLOC_IN_BUF</a></td></tr>
<tr class="memdesc:a737ff56ffe835fe44b1a133a459141e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a memory heap is allowed to grow into the buffer pool, the following is the maximum size for a single allocated buffer (from UNIV_PAGE_SIZE we subtract MEM_BLOCK_HEADER_SIZE and 2*MEM_NO_MANS_LAND since it's something we always need to put.  <a href="#a737ff56ffe835fe44b1a133a459141e8">More...</a><br /></td></tr>
<tr class="separator:a737ff56ffe835fe44b1a133a459141e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7b62c25aebf6193733524a9c39b363"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ace7b62c25aebf6193733524a9c39b363">MEM_SPACE_NEEDED</a>(N)&#160;&#160;&#160;<a class="el" href="ut0ut_8h.html#adb061a676254d8943de08e15cafa062a">ut_calc_align</a>(N + 2 * <a class="el" href="mem0mem_8h.html#ab1afefd3dbd5d14757c0a1abbc60c98b">MEM_NO_MANS_LAND</a>, UNIV_MEM_ALIGNMENT)</td></tr>
<tr class="memdesc:ace7b62c25aebf6193733524a9c39b363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space needed when allocating for a user a field of length N.  <a href="#ace7b62c25aebf6193733524a9c39b363">More...</a><br /></td></tr>
<tr class="separator:ace7b62c25aebf6193733524a9c39b363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662a9010a693fdd2b2adfa7da05f31af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a662a9010a693fdd2b2adfa7da05f31af">mem_heap_create</a>(size)&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a234843bd6492a2d6fcb981fe499db409">mem_heap_create_func</a>((size), __FILE__, __LINE__, <a class="el" href="mem0mem_8h.html#ac7fc6050ef7fde046b8aa0af92c2afae">MEM_HEAP_DYNAMIC</a>)</td></tr>
<tr class="memdesc:a662a9010a693fdd2b2adfa7da05f31af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for memory heap creation.  <a href="#a662a9010a693fdd2b2adfa7da05f31af">More...</a><br /></td></tr>
<tr class="separator:a662a9010a693fdd2b2adfa7da05f31af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2155726a10ea605c67711eeaf436901b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a2155726a10ea605c67711eeaf436901b">mem_heap_create_typed</a>(size,  type)&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a234843bd6492a2d6fcb981fe499db409">mem_heap_create_func</a>((size), __FILE__, __LINE__, (type))</td></tr>
<tr class="memdesc:a2155726a10ea605c67711eeaf436901b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for memory heap creation.  <a href="#a2155726a10ea605c67711eeaf436901b">More...</a><br /></td></tr>
<tr class="separator:a2155726a10ea605c67711eeaf436901b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339a3734708830e0bee01de7eaf96715"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a339a3734708830e0bee01de7eaf96715">MEM_BLOCK_MAGIC_N</a>&#160;&#160;&#160;0x445566778899AABB</td></tr>
<tr class="separator:a339a3734708830e0bee01de7eaf96715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708a8efd990e3d65c4446d992cb6ee4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a708a8efd990e3d65c4446d992cb6ee4d">MEM_FREED_BLOCK_MAGIC_N</a>&#160;&#160;&#160;0xBBAA998877665544</td></tr>
<tr class="separator:a708a8efd990e3d65c4446d992cb6ee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a2ed79ee7aa82b1c09651e1047eda1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ad6a2ed79ee7aa82b1c09651e1047eda1">MEM_BLOCK_HEADER_SIZE</a>&#160;&#160;&#160;<a class="el" href="ut0ut_8h.html#adb061a676254d8943de08e15cafa062a">ut_calc_align</a>(sizeof(<a class="el" href="structmem__block__info__t.html">mem_block_info_t</a>), UNIV_MEM_ALIGNMENT)</td></tr>
<tr class="separator:ad6a2ed79ee7aa82b1c09651e1047eda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5e3855e50a4a7a806a1f012dbb63e0f5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmem__block__info__t.html">mem_block_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a5e3855e50a4a7a806a1f012dbb63e0f5">mem_block_t</a></td></tr>
<tr class="memdesc:a5e3855e50a4a7a806a1f012dbb63e0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block of a memory heap consists of the info structure followed by an area of memory.  <a href="#a5e3855e50a4a7a806a1f012dbb63e0f5">More...</a><br /></td></tr>
<tr class="separator:a5e3855e50a4a7a806a1f012dbb63e0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a10a74bdb0acc8a530dd6ec3c8538a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="mem0mem_8h.html#a5e3855e50a4a7a806a1f012dbb63e0f5">mem_block_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a></td></tr>
<tr class="memdesc:a29a10a74bdb0acc8a530dd6ec3c8538a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory heap is a nonempty linear list of memory blocks.  <a href="#a29a10a74bdb0acc8a530dd6ec3c8538a">More...</a><br /></td></tr>
<tr class="separator:a29a10a74bdb0acc8a530dd6ec3c8538a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a234843bd6492a2d6fcb981fe499db409"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a234843bd6492a2d6fcb981fe499db409">mem_heap_create_func</a> (ulint size, const char *file_name, ulint line, ulint type)</td></tr>
<tr class="memdesc:a234843bd6492a2d6fcb981fe499db409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memory heap.  <a href="#a234843bd6492a2d6fcb981fe499db409">More...</a><br /></td></tr>
<tr class="separator:a234843bd6492a2d6fcb981fe499db409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e166189dad6edee64fed934900ca42"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a67e166189dad6edee64fed934900ca42">mem_heap_free</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a67e166189dad6edee64fed934900ca42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the space occupied by a memory heap.  <a href="#a67e166189dad6edee64fed934900ca42">More...</a><br /></td></tr>
<tr class="separator:a67e166189dad6edee64fed934900ca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8162d816aada62ef8f84c83b6787befa"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8162d816aada62ef8f84c83b6787befa">mem_heap_zalloc</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a8162d816aada62ef8f84c83b6787befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and zero-fills n bytes of memory from a memory heap.  <a href="#a8162d816aada62ef8f84c83b6787befa">More...</a><br /></td></tr>
<tr class="separator:a8162d816aada62ef8f84c83b6787befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f7ee9ca3354fdd5bc633f5ae7b9421"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a92f7ee9ca3354fdd5bc633f5ae7b9421">mem_heap_alloc</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a92f7ee9ca3354fdd5bc633f5ae7b9421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates n bytes of memory from a memory heap.  <a href="#a92f7ee9ca3354fdd5bc633f5ae7b9421">More...</a><br /></td></tr>
<tr class="separator:a92f7ee9ca3354fdd5bc633f5ae7b9421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86da5f1414a8bb3f80e50321a8e55e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#abf86da5f1414a8bb3f80e50321a8e55e">mem_heap_get_heap_top</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:abf86da5f1414a8bb3f80e50321a8e55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the heap top.  <a href="#abf86da5f1414a8bb3f80e50321a8e55e">More...</a><br /></td></tr>
<tr class="separator:abf86da5f1414a8bb3f80e50321a8e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b274fd0d860517ff623eef01a6a099a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8b274fd0d860517ff623eef01a6a099a">mem_heap_free_heap_top</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *old_top)</td></tr>
<tr class="memdesc:a8b274fd0d860517ff623eef01a6a099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the space in a memory heap exceeding the pointer given.  <a href="#a8b274fd0d860517ff623eef01a6a099a">More...</a><br /></td></tr>
<tr class="separator:a8b274fd0d860517ff623eef01a6a099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ae9a39a4d557c68977578bd0db3fa8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a98ae9a39a4d557c68977578bd0db3fa8">mem_heap_empty</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a98ae9a39a4d557c68977578bd0db3fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties a memory heap.  <a href="#a98ae9a39a4d557c68977578bd0db3fa8">More...</a><br /></td></tr>
<tr class="separator:a98ae9a39a4d557c68977578bd0db3fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854d0114bb14a2fc66685af99642c4f2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a854d0114bb14a2fc66685af99642c4f2">mem_heap_get_top</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a854d0114bb14a2fc66685af99642c4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the topmost element in a memory heap.  <a href="#a854d0114bb14a2fc66685af99642c4f2">More...</a><br /></td></tr>
<tr class="separator:a854d0114bb14a2fc66685af99642c4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259d7aa8e5bc6dc6f073219a9b808cb6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a259d7aa8e5bc6dc6f073219a9b808cb6">mem_heap_is_top</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const void *buf, ulint buf_sz)</td></tr>
<tr class="memdesc:a259d7aa8e5bc6dc6f073219a9b808cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given chunk of memory is the topmost element stored in the heap.  <a href="#a259d7aa8e5bc6dc6f073219a9b808cb6">More...</a><br /></td></tr>
<tr class="separator:a259d7aa8e5bc6dc6f073219a9b808cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063bdb06a243805ec2e4d1c6e9a195ae"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a063bdb06a243805ec2e4d1c6e9a195ae">mem_heap_replace</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const void *top, ulint top_sz, ulint new_sz)</td></tr>
<tr class="memdesc:a063bdb06a243805ec2e4d1c6e9a195ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new chunk of memory from a memory heap, possibly discarding the topmost element.  <a href="#a063bdb06a243805ec2e4d1c6e9a195ae">More...</a><br /></td></tr>
<tr class="separator:a063bdb06a243805ec2e4d1c6e9a195ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e608d24cfd7947ad1ed2747cb91844d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a9e608d24cfd7947ad1ed2747cb91844d">mem_heap_dup_replace</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const void *top, ulint top_sz, const void *data, ulint data_sz)</td></tr>
<tr class="memdesc:a9e608d24cfd7947ad1ed2747cb91844d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new chunk of memory from a memory heap, possibly discarding the topmost element and then copy the specified data to it.  <a href="#a9e608d24cfd7947ad1ed2747cb91844d">More...</a><br /></td></tr>
<tr class="separator:a9e608d24cfd7947ad1ed2747cb91844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1643d88d755bdea1dc16d25356f0f9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#abd1643d88d755bdea1dc16d25356f0f9">mem_heap_strdup_replace</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const void *top, ulint top_sz, const char *str)</td></tr>
<tr class="memdesc:abd1643d88d755bdea1dc16d25356f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new chunk of memory from a memory heap, possibly discarding the topmost element and then copy the specified string to it.  <a href="#abd1643d88d755bdea1dc16d25356f0f9">More...</a><br /></td></tr>
<tr class="separator:abd1643d88d755bdea1dc16d25356f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbaa90de4133e744d809cfd6c764046"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a0bbaa90de4133e744d809cfd6c764046">mem_heap_free_top</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a0bbaa90de4133e744d809cfd6c764046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the topmost element in a memory heap.  <a href="#a0bbaa90de4133e744d809cfd6c764046">More...</a><br /></td></tr>
<tr class="separator:a0bbaa90de4133e744d809cfd6c764046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469829136569041fbd26404dd7af7e08"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a469829136569041fbd26404dd7af7e08">mem_heap_get_size</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a469829136569041fbd26404dd7af7e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the space in bytes occupied by a memory heap.  <a href="#a469829136569041fbd26404dd7af7e08">More...</a><br /></td></tr>
<tr class="separator:a469829136569041fbd26404dd7af7e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ee2ae09b8776ea6f7b258d94ee276"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ad40ee2ae09b8776ea6f7b258d94ee276">mem_strdup</a> (const char *str)</td></tr>
<tr class="memdesc:ad40ee2ae09b8776ea6f7b258d94ee276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a NUL-terminated string.  <a href="#ad40ee2ae09b8776ea6f7b258d94ee276">More...</a><br /></td></tr>
<tr class="separator:ad40ee2ae09b8776ea6f7b258d94ee276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601462ebfa8661c981f405734f77cf22"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a601462ebfa8661c981f405734f77cf22">mem_strdupl</a> (const char *str, ulint len)</td></tr>
<tr class="memdesc:a601462ebfa8661c981f405734f77cf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a NUL-terminated copy of a nonterminated string.  <a href="#a601462ebfa8661c981f405734f77cf22">More...</a><br /></td></tr>
<tr class="separator:a601462ebfa8661c981f405734f77cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9d72e0a1ce278f0e5909478287e627"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#aca9d72e0a1ce278f0e5909478287e627">mem_heap_strdup</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const char *str)</td></tr>
<tr class="memdesc:aca9d72e0a1ce278f0e5909478287e627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a NUL-terminated string, allocated from a memory heap.  <a href="#aca9d72e0a1ce278f0e5909478287e627">More...</a><br /></td></tr>
<tr class="separator:aca9d72e0a1ce278f0e5909478287e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb6550c0724daf639e0cef00b7b5b63"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a4cb6550c0724daf639e0cef00b7b5b63">mem_heap_strdupl</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const char *str, ulint len)</td></tr>
<tr class="memdesc:a4cb6550c0724daf639e0cef00b7b5b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a NUL-terminated copy of a nonterminated string, allocated from a memory heap.  <a href="#a4cb6550c0724daf639e0cef00b7b5b63">More...</a><br /></td></tr>
<tr class="separator:a4cb6550c0724daf639e0cef00b7b5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5505375da8a5e8f643142ff03a6943"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#aed5505375da8a5e8f643142ff03a6943">mem_heap_strcat</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const char *s1, const char *s2)</td></tr>
<tr class="memdesc:aed5505375da8a5e8f643142ff03a6943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two strings and return the result, using a memory heap.  <a href="#aed5505375da8a5e8f643142ff03a6943">More...</a><br /></td></tr>
<tr class="separator:aed5505375da8a5e8f643142ff03a6943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043b5b8f1671dbd679f050b2d2710fad"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a043b5b8f1671dbd679f050b2d2710fad">mem_heap_dup</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const void *data, ulint len)</td></tr>
<tr class="memdesc:a043b5b8f1671dbd679f050b2d2710fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a block of data, allocated from a memory heap.  <a href="#a043b5b8f1671dbd679f050b2d2710fad">More...</a><br /></td></tr>
<tr class="separator:a043b5b8f1671dbd679f050b2d2710fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce7fe200d5032ac70022bcacf069b93"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a5ce7fe200d5032ac70022bcacf069b93">mem_heap_printf</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const char *format,...)</td></tr>
<tr class="memdesc:a5ce7fe200d5032ac70022bcacf069b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple sprintf replacement that dynamically allocates the space for the formatted string from the given heap.  <a href="#a5ce7fe200d5032ac70022bcacf069b93">More...</a><br /></td></tr>
<tr class="separator:a5ce7fe200d5032ac70022bcacf069b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8d70f52d884a443bb998859238e36d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#aba8d70f52d884a443bb998859238e36d">mem_block_validate</a> (const <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:aba8d70f52d884a443bb998859238e36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that an object is a memory heap (or a block of it)  <a href="#aba8d70f52d884a443bb998859238e36d">More...</a><br /></td></tr>
<tr class="separator:aba8d70f52d884a443bb998859238e36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce51a1388d68ca7e55c7b23e2ab5882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#abce51a1388d68ca7e55c7b23e2ab5882">mem_heap_validate</a> (const <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:abce51a1388d68ca7e55c7b23e2ab5882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the contents of a memory heap.  <a href="#abce51a1388d68ca7e55c7b23e2ab5882">More...</a><br /></td></tr>
<tr class="separator:abce51a1388d68ca7e55c7b23e2ab5882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37949e7bab014f857942ef3a787d7565"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a37949e7bab014f857942ef3a787d7565"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a37949e7bab014f857942ef3a787d7565">operator==</a> (const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;left, const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="separator:a37949e7bab014f857942ef3a787d7565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3175d9b2bd7736138e50b3925bc39584"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3175d9b2bd7736138e50b3925bc39584"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a3175d9b2bd7736138e50b3925bc39584">operator!=</a> (const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;left, const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="separator:a3175d9b2bd7736138e50b3925bc39584"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab1afefd3dbd5d14757c0a1abbc60c98b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ab1afefd3dbd5d14757c0a1abbc60c98b">MEM_NO_MANS_LAND</a> = 16</td></tr>
<tr class="separator:ab1afefd3dbd5d14757c0a1abbc60c98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873c7b8e81020e6d2aeac1dc9d58d52f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a873c7b8e81020e6d2aeac1dc9d58d52f">MEM_NO_MANS_LAND_BEFORE_BYTE</a> = 0xCE</td></tr>
<tr class="separator:a873c7b8e81020e6d2aeac1dc9d58d52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23423da35e1ef19533b31bb15483be7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ad23423da35e1ef19533b31bb15483be7">MEM_NO_MANS_LAND_AFTER_BYTE</a> = 0xDF</td></tr>
<tr class="separator:ad23423da35e1ef19533b31bb15483be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The memory management. </p>
<p>Created 6/9/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad6a2ed79ee7aa82b1c09651e1047eda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a2ed79ee7aa82b1c09651e1047eda1">&#9670;&nbsp;</a></span>MEM_BLOCK_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_BLOCK_HEADER_SIZE&#160;&#160;&#160;<a class="el" href="ut0ut_8h.html#adb061a676254d8943de08e15cafa062a">ut_calc_align</a>(sizeof(<a class="el" href="structmem__block__info__t.html">mem_block_info_t</a>), UNIV_MEM_ALIGNMENT)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a339a3734708830e0bee01de7eaf96715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339a3734708830e0bee01de7eaf96715">&#9670;&nbsp;</a></span>MEM_BLOCK_MAGIC_N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_BLOCK_MAGIC_N&#160;&#160;&#160;0x445566778899AABB</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff86ded019fa67facacc67b8a615001b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff86ded019fa67facacc67b8a615001b">&#9670;&nbsp;</a></span>MEM_BLOCK_STANDARD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_BLOCK_STANDARD_SIZE&#160;&#160;&#160;(UNIV_PAGE_SIZE &gt;= 16384 ? 8000 : <a class="el" href="mem0mem_8h.html#a737ff56ffe835fe44b1a133a459141e8">MEM_MAX_ALLOC_IN_BUF</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07412b5b33ff3b94be36b581449cbeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07412b5b33ff3b94be36b581449cbeb7">&#9670;&nbsp;</a></span>MEM_BLOCK_START_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_BLOCK_START_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following start size is used for the first block in the memory heap if the size is not specified, i.e., 0 is given as the parameter in the call of create. </p>
<p>The standard size is the maximum (payload) size of the blocks used for allocations of small buffers. </p>

</div>
</div>
<a id="a708a8efd990e3d65c4446d992cb6ee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708a8efd990e3d65c4446d992cb6ee4d">&#9670;&nbsp;</a></span>MEM_FREED_BLOCK_MAGIC_N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_FREED_BLOCK_MAGIC_N&#160;&#160;&#160;0xBBAA998877665544</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6621ead8a647eed62fbd8a311a62330c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6621ead8a647eed62fbd8a311a62330c">&#9670;&nbsp;</a></span>MEM_HEAP_BTR_SEARCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_BTR_SEARCH</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2 <span class="comment">/* this flag can optionally be     \</span></div><div class="line"><span class="comment">    ORed to MEM_HEAP_BUFFER, in which  \</span></div><div class="line"><span class="comment">    case heap-&gt;free_block is used in   \</span></div><div class="line"><span class="comment">    some cases for memory allocations, \</span></div><div class="line"><span class="comment">    and if it&#39;s NULL, the memory       \</span></div><div class="line"><span class="comment">    allocation functions can return    \</span></div><div class="line"><span class="comment">    NULL. */</span></div></div><!-- fragment -->
</div>
</div>
<a id="ad2623d2577c63e89bd0173f928be08e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2623d2577c63e89bd0173f928be08e9">&#9670;&nbsp;</a></span>MEM_HEAP_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_BUFFER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a662a9010a693fdd2b2adfa7da05f31af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662a9010a693fdd2b2adfa7da05f31af">&#9670;&nbsp;</a></span>mem_heap_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_heap_create</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a234843bd6492a2d6fcb981fe499db409">mem_heap_create_func</a>((size), __FILE__, __LINE__, <a class="el" href="mem0mem_8h.html#ac7fc6050ef7fde046b8aa0af92c2afae">MEM_HEAP_DYNAMIC</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for memory heap creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Desired start block size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2155726a10ea605c67711eeaf436901b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2155726a10ea605c67711eeaf436901b">&#9670;&nbsp;</a></span>mem_heap_create_typed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_heap_create_typed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a234843bd6492a2d6fcb981fe499db409">mem_heap_create_func</a>((size), __FILE__, __LINE__, (type))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for memory heap creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Desired start block size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Heap type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7fc6050ef7fde046b8aa0af92c2afae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fc6050ef7fde046b8aa0af92c2afae">&#9670;&nbsp;</a></span>MEM_HEAP_DYNAMIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_DYNAMIC&#160;&#160;&#160;0 /* the most common type */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of allocation for memory heaps: DYNAMIC means allocation from the dynamic memory pool of the C compiler, BUFFER means allocation from the buffer pool; the latter method is used for very big heaps. </p>

</div>
</div>
<a id="a47d3586895796c6473e46aa6a64bd998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d3586895796c6473e46aa6a64bd998">&#9670;&nbsp;</a></span>MEM_HEAP_FOR_BTR_SEARCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_FOR_BTR_SEARCH&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#a6621ead8a647eed62fbd8a311a62330c">MEM_HEAP_BTR_SEARCH</a> | <a class="el" href="mem0mem_8h.html#ad2623d2577c63e89bd0173f928be08e9">MEM_HEAP_BUFFER</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different type of heaps in terms of which data structure is using them. </p>

</div>
</div>
<a id="a68a390063fcee97542cade99064c3014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a390063fcee97542cade99064c3014">&#9670;&nbsp;</a></span>MEM_HEAP_FOR_LOCK_HEAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_FOR_LOCK_HEAP&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#ad2623d2577c63e89bd0173f928be08e9">MEM_HEAP_BUFFER</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c1e03a482e10cf25756bb96b3368bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1e03a482e10cf25756bb96b3368bc2">&#9670;&nbsp;</a></span>MEM_HEAP_FOR_PAGE_HASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_FOR_PAGE_HASH&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#ac7fc6050ef7fde046b8aa0af92c2afae">MEM_HEAP_DYNAMIC</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83e266b884663510a1c569492edfc3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e266b884663510a1c569492edfc3a4">&#9670;&nbsp;</a></span>MEM_HEAP_FOR_RECV_SYS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_FOR_RECV_SYS&#160;&#160;&#160;(<a class="el" href="mem0mem_8h.html#ad2623d2577c63e89bd0173f928be08e9">MEM_HEAP_BUFFER</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a737ff56ffe835fe44b1a133a459141e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737ff56ffe835fe44b1a133a459141e8">&#9670;&nbsp;</a></span>MEM_MAX_ALLOC_IN_BUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_MAX_ALLOC_IN_BUF</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((UNIV_PAGE_SIZE - <a class="code" href="mem0mem_8h.html#ad6a2ed79ee7aa82b1c09651e1047eda1">MEM_BLOCK_HEADER_SIZE</a> - 2 * <a class="code" href="mem0mem_8h.html#ab1afefd3dbd5d14757c0a1abbc60c98b">MEM_NO_MANS_LAND</a>) &amp; \</div><div class="line">   ~(UNIV_MEM_ALIGNMENT - 1))</div><div class="ttc" id="mem0mem_8h_html_ab1afefd3dbd5d14757c0a1abbc60c98b"><div class="ttname"><a href="mem0mem_8h.html#ab1afefd3dbd5d14757c0a1abbc60c98b">MEM_NO_MANS_LAND</a></div><div class="ttdeci">const int MEM_NO_MANS_LAND</div><div class="ttdef"><b>Definition:</b> mem0mem.h:101</div></div>
<div class="ttc" id="mem0mem_8h_html_ad6a2ed79ee7aa82b1c09651e1047eda1"><div class="ttname"><a href="mem0mem_8h.html#ad6a2ed79ee7aa82b1c09651e1047eda1">MEM_BLOCK_HEADER_SIZE</a></div><div class="ttdeci">#define MEM_BLOCK_HEADER_SIZE</div><div class="ttdef"><b>Definition:</b> mem0mem.h:390</div></div>
</div><!-- fragment -->
<p>If a memory heap is allowed to grow into the buffer pool, the following is the maximum size for a single allocated buffer (from UNIV_PAGE_SIZE we subtract MEM_BLOCK_HEADER_SIZE and 2*MEM_NO_MANS_LAND since it's something we always need to put. </p>
<p>Since in MEM_SPACE_NEEDED we round n to the next multiple of UNIV_MEM_ALINGMENT, we need to cut from the rest the part that cannot be divided by UNIV_MEM_ALINGMENT): </p>

</div>
</div>
<a id="ace7b62c25aebf6193733524a9c39b363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7b62c25aebf6193733524a9c39b363">&#9670;&nbsp;</a></span>MEM_SPACE_NEEDED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_SPACE_NEEDED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0ut_8h.html#adb061a676254d8943de08e15cafa062a">ut_calc_align</a>(N + 2 * <a class="el" href="mem0mem_8h.html#ab1afefd3dbd5d14757c0a1abbc60c98b">MEM_NO_MANS_LAND</a>, UNIV_MEM_ALIGNMENT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Space needed when allocating for a user a field of length N. </p>
<p>The space is allocated only in multiples of UNIV_MEM_ALIGNMENT. In debug mode contains two areas of no mans lands before and after the buffer requested. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5e3855e50a4a7a806a1f012dbb63e0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3855e50a4a7a806a1f012dbb63e0f5">&#9670;&nbsp;</a></span>mem_block_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmem__block__info__t.html">mem_block_info_t</a> <a class="el" href="mem0mem_8h.html#a5e3855e50a4a7a806a1f012dbb63e0f5">mem_block_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A block of a memory heap consists of the info structure followed by an area of memory. </p>

</div>
</div>
<a id="a29a10a74bdb0acc8a530dd6ec3c8538a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a10a74bdb0acc8a530dd6ec3c8538a">&#9670;&nbsp;</a></span>mem_heap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="mem0mem_8h.html#a5e3855e50a4a7a806a1f012dbb63e0f5">mem_block_t</a> <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A memory heap is a nonempty linear list of memory blocks. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aba8d70f52d884a443bb998859238e36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8d70f52d884a443bb998859238e36d">&#9670;&nbsp;</a></span>mem_block_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_block_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that an object is a memory heap (or a block of it) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92f7ee9ca3354fdd5bc633f5ae7b9421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f7ee9ca3354fdd5bc633f5ae7b9421">&#9670;&nbsp;</a></span>mem_heap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates n bytes of memory from a memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated storage, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) </dd></dl>

</div>
</div>
<a id="a234843bd6492a2d6fcb981fe499db409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234843bd6492a2d6fcb981fe499db409">&#9670;&nbsp;</a></span>mem_heap_create_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a>* mem_heap_create_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memory heap. </p>
<p>NOTE: Use the corresponding macros instead of this function. A single user buffer of 'size' will fit in the block. 0 creates a default size block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Desired start block size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>File name where created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Heap type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: memory heap, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) </dd></dl>

</div>
</div>
<a id="a043b5b8f1671dbd679f050b2d2710fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043b5b8f1671dbd679f050b2d2710fad">&#9670;&nbsp;</a></span>mem_heap_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mem_heap_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a block of data, allocated from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the data in: length of data, in bytes</dd>
<dd>
own: a copy of the data </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where copy is allocated </td></tr>
    <tr><td class="paramname">data</td><td>in: data to be copied </td></tr>
    <tr><td class="paramname">len</td><td>in: length of data, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e608d24cfd7947ad1ed2747cb91844d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e608d24cfd7947ad1ed2747cb91844d">&#9670;&nbsp;</a></span>mem_heap_dup_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_dup_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>top_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>data_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new chunk of memory from a memory heap, possibly discarding the topmost element and then copy the specified data to it. </p>
<p>If the memory chunk specified with (top, top_sz) is the topmost element, then it will be discarded, otherwise it will be left untouched and this function will be equivalent to mem_heap_dup(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>chunk to discard if possible </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_sz</td><td>size of top in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>new data to duplicate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_sz</td><td>size of data in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated storage, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) </dd></dl>

</div>
</div>
<a id="a98ae9a39a4d557c68977578bd0db3fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ae9a39a4d557c68977578bd0db3fa8">&#9670;&nbsp;</a></span>mem_heap_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empties a memory heap. </p>
<p>The first memory block of the heap is not freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>heap to empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67e166189dad6edee64fed934900ca42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e166189dad6edee64fed934900ca42">&#9670;&nbsp;</a></span>mem_heap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the space occupied by a memory heap. </p>
<p>NOTE: Use the corresponding macro instead of this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Heap to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b274fd0d860517ff623eef01a6a099a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b274fd0d860517ff623eef01a6a099a">&#9670;&nbsp;</a></span>mem_heap_free_heap_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_heap_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>old_top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the space in a memory heap exceeding the pointer given. </p>
<p>The pointer must have been acquired from mem_heap_get_heap_top. The first memory block of the heap is not freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>heap from which to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_top</td><td>pointer to old top of heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbaa90de4133e744d809cfd6c764046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbaa90de4133e744d809cfd6c764046">&#9670;&nbsp;</a></span>mem_heap_free_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the topmost element in a memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of the topmost element The size of the element must be given. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf86da5f1414a8bb3f80e50321a8e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf86da5f1414a8bb3f80e50321a8e55e">&#9670;&nbsp;</a></span>mem_heap_get_heap_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* mem_heap_get_heap_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the heap top. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the heap top </dd></dl>

</div>
</div>
<a id="a469829136569041fbd26404dd7af7e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469829136569041fbd26404dd7af7e08">&#9670;&nbsp;</a></span>mem_heap_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint mem_heap_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the space in bytes occupied by a memory heap. </p>
<p>in: heap </p>

</div>
</div>
<a id="a854d0114bb14a2fc66685af99642c4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854d0114bb14a2fc66685af99642c4f2">&#9670;&nbsp;</a></span>mem_heap_get_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_get_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the topmost element in a memory heap. </p>
<p>The size of the element must be given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of the topmost element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the topmost element </dd></dl>

</div>
</div>
<a id="a259d7aa8e5bc6dc6f073219a9b808cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259d7aa8e5bc6dc6f073219a9b808cb6">&#9670;&nbsp;</a></span>mem_heap_is_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> mem_heap_is_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given chunk of memory is the topmost element stored in the heap. </p>
<p>If this is the case, then calling mem_heap_free_top() would free that element from the heap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>presumed topmost element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_sz</td><td>size of buf in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if topmost </dd></dl>

</div>
</div>
<a id="a5ce7fe200d5032ac70022bcacf069b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce7fe200d5032ac70022bcacf069b93">&#9670;&nbsp;</a></span>mem_heap_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mem_heap_printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple sprintf replacement that dynamically allocates the space for the formatted string from the given heap. </p>
<p>This supports a very limited set of the printf syntax: types 's' and 'u' and length modifier 'l' (which is required for the 'u' type). </p><dl class="section return"><dt>Returns</dt><dd>heap-allocated formatted string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">format</td><td>in: format string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063bdb06a243805ec2e4d1c6e9a195ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063bdb06a243805ec2e4d1c6e9a195ae">&#9670;&nbsp;</a></span>mem_heap_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>top_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>new_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new chunk of memory from a memory heap, possibly discarding the topmost element. </p>
<p>If the memory chunk specified with (top, top_sz) is the topmost element, then it will be discarded, otherwise it will be left untouched and this function will be equivallent to mem_heap_alloc(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>chunk to discard if possible </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_sz</td><td>size of top in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_sz</td><td>desired size of the new chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated storage, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) </dd></dl>

</div>
</div>
<a id="aed5505375da8a5e8f643142ff03a6943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5505375da8a5e8f643142ff03a6943">&#9670;&nbsp;</a></span>mem_heap_strcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mem_heap_strcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two strings and return the result, using a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>own: the result in: string 2</dd>
<dd>
own: the result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where string is allocated </td></tr>
    <tr><td class="paramname">s1</td><td>in: string 1 </td></tr>
    <tr><td class="paramname">s2</td><td>in: string 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9d72e0a1ce278f0e5909478287e627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9d72e0a1ce278f0e5909478287e627">&#9670;&nbsp;</a></span>mem_heap_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mem_heap_strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates a NUL-terminated string, allocated from a memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap where string is allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string </dd></dl>

</div>
</div>
<a id="abd1643d88d755bdea1dc16d25356f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1643d88d755bdea1dc16d25356f0f9">&#9670;&nbsp;</a></span>mem_heap_strdup_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_heap_strdup_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>top_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new chunk of memory from a memory heap, possibly discarding the topmost element and then copy the specified string to it. </p>
<p>If the memory chunk specified with (top, top_sz) is the topmost element, then it will be discarded, otherwise it will be left untouched and this function will be equivalent to mem_heap_strdup(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>chunk to discard if possible </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_sz</td><td>size of top in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>new data to duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated string, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) </dd></dl>

</div>
</div>
<a id="a4cb6550c0724daf639e0cef00b7b5b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb6550c0724daf639e0cef00b7b5b63">&#9670;&nbsp;</a></span>mem_heap_strdupl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_heap_strdupl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a NUL-terminated copy of a nonterminated string, allocated from a memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap where string is allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of str, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string </dd></dl>

</div>
</div>
<a id="abce51a1388d68ca7e55c7b23e2ab5882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce51a1388d68ca7e55c7b23e2ab5882">&#9670;&nbsp;</a></span>mem_heap_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mem_heap_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the contents of a memory heap. </p>
<p>Checks a memory heap for consistency, prints the contents if any error is detected. A fatal error is logged if an error is detected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap to validate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8162d816aada62ef8f84c83b6787befa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8162d816aada62ef8f84c83b6787befa">&#9670;&nbsp;</a></span>mem_heap_zalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_zalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and zero-fills n bytes of memory from a memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated, zero-filled storage </dd></dl>

</div>
</div>
<a id="ad40ee2ae09b8776ea6f7b258d94ee276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40ee2ae09b8776ea6f7b258d94ee276">&#9670;&nbsp;</a></span>mem_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates a NUL-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with ut_free </dd></dl>

</div>
</div>
<a id="a601462ebfa8661c981f405734f77cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601462ebfa8661c981f405734f77cf22">&#9670;&nbsp;</a></span>mem_strdupl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_strdupl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a NUL-terminated copy of a nonterminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of str, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with ut_free </dd></dl>

</div>
</div>
<a id="a3175d9b2bd7736138e50b3925bc39584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3175d9b2bd7736138e50b3925bc39584">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="rpl__rli_8h.html#a7762c4d9bacdce0c790e43bd8313fe72">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37949e7bab014f857942ef3a787d7565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37949e7bab014f857942ef3a787d7565">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab1afefd3dbd5d14757c0a1abbc60c98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1afefd3dbd5d14757c0a1abbc60c98b">&#9670;&nbsp;</a></span>MEM_NO_MANS_LAND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int MEM_NO_MANS_LAND = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad23423da35e1ef19533b31bb15483be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23423da35e1ef19533b31bb15483be7">&#9670;&nbsp;</a></span>MEM_NO_MANS_LAND_AFTER_BYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> MEM_NO_MANS_LAND_AFTER_BYTE = 0xDF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a873c7b8e81020e6d2aeac1dc9d58d52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873c7b8e81020e6d2aeac1dc9d58d52f">&#9670;&nbsp;</a></span>MEM_NO_MANS_LAND_BEFORE_BYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> MEM_NO_MANS_LAND_BEFORE_BYTE = 0xCE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="mem0mem_8h.html">mem0mem.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
