<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Filesort_buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classFilesort__buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFilesort__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Filesort_buffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Buffer used for storing records to be sorted.  
 <a href="classFilesort__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="filesort__utils_8h_source.html">filesort_utils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:affbb298a57c615a56ef181acba61e515"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#affbb298a57c615a56ef181acba61e515">Filesort_buffer</a> ()</td></tr>
<tr class="separator:affbb298a57c615a56ef181acba61e515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0a4332094b2074a7b01641a449cad7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a8e0a4332094b2074a7b01641a449cad7">sort_buffer</a> (<a class="el" href="classSort__param.html">Sort_param</a> *param, size_t num_input_rows, size_t max_output_rows)</td></tr>
<tr class="memdesc:a8e0a4332094b2074a7b01641a449cad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort me...  <a href="#a8e0a4332094b2074a7b01641a449cad7">More...</a><br /></td></tr>
<tr class="separator:a8e0a4332094b2074a7b01641a449cad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d20fb6855d3772aa0583af831173752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a3d20fb6855d3772aa0583af831173752">reset</a> ()</td></tr>
<tr class="memdesc:a3d20fb6855d3772aa0583af831173752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the buffer for the next batch of records to process.  <a href="#a3d20fb6855d3772aa0583af831173752">More...</a><br /></td></tr>
<tr class="separator:a3d20fb6855d3772aa0583af831173752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee298f9fc03682727cc994c592547db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBounds__checked__array.html">Bounds_checked_array</a>&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#aee298f9fc03682727cc994c592547db5">get_next_record_pointer</a> (size_t min_size)</td></tr>
<tr class="memdesc:aee298f9fc03682727cc994c592547db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where should the next record be stored?  <a href="#aee298f9fc03682727cc994c592547db5">More...</a><br /></td></tr>
<tr class="separator:aee298f9fc03682727cc994c592547db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f375f658f6911906a7d835562e3bf4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a9f375f658f6911906a7d835562e3bf4d">commit_used_memory</a> (size_t num_bytes)</td></tr>
<tr class="separator:a9f375f658f6911906a7d835562e3bf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f7fe2f56e21182af6a0df03dadd3ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a41f7fe2f56e21182af6a0df03dadd3ce">preallocate_records</a> (size_t num_records)</td></tr>
<tr class="memdesc:a41f7fe2f56e21182af6a0df03dadd3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any existing rows and allocates <code>num_records</code> maximum-sized rows (call get_sorted_record() to get their pointers).  <a href="#a41f7fe2f56e21182af6a0df03dadd3ce">More...</a><br /></td></tr>
<tr class="separator:a41f7fe2f56e21182af6a0df03dadd3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f707da8839611eb33462e5431f3885"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#ac2f707da8839611eb33462e5431f3885">max_size_in_bytes</a> () const</td></tr>
<tr class="separator:ac2f707da8839611eb33462e5431f3885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a78af586f5141ee65793abd0e8751"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a7d7a78af586f5141ee65793abd0e8751">peak_memory_used</a> () const</td></tr>
<tr class="memdesc:a7d7a78af586f5141ee65793abd0e8751"><td class="mdescLeft">&#160;</td><td class="mdescRight">How much memory has been allocated (counting both the sort buffer and the record pointers) at most since last call to clear_peak_memory_used().  <a href="#a7d7a78af586f5141ee65793abd0e8751">More...</a><br /></td></tr>
<tr class="separator:a7d7a78af586f5141ee65793abd0e8751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a120748b86f4fd4ad199d6bdacdbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a883a120748b86f4fd4ad199d6bdacdbf">clear_peak_memory_used</a> ()</td></tr>
<tr class="memdesc:a883a120748b86f4fd4ad199d6bdacdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See peak_memory_used.  <a href="#a883a120748b86f4fd4ad199d6bdacdbf">More...</a><br /></td></tr>
<tr class="separator:a883a120748b86f4fd4ad199d6bdacdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d14b71fe80410f6cd2b038ab8380c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#ae3d14b71fe80410f6cd2b038ab8380c0">set_max_size</a> (size_t max_size, size_t record_length)</td></tr>
<tr class="memdesc:ae3d14b71fe80410f6cd2b038ab8380c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the memory limit for the sort buffer before starting to add records.  <a href="#ae3d14b71fe80410f6cd2b038ab8380c0">More...</a><br /></td></tr>
<tr class="separator:ae3d14b71fe80410f6cd2b038ab8380c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967d857a913b61ef3957d094ac227eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a967d857a913b61ef3957d094ac227eca">free_sort_buffer</a> ()</td></tr>
<tr class="memdesc:a967d857a913b61ef3957d094ac227eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all memory.  <a href="#a967d857a913b61ef3957d094ac227eca">More...</a><br /></td></tr>
<tr class="separator:a967d857a913b61ef3957d094ac227eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab833d1ea135e1651b55087cbe923dbf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#ab833d1ea135e1651b55087cbe923dbf5">get_sort_keys</a> ()</td></tr>
<tr class="memdesc:ab833d1ea135e1651b55087cbe923dbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of record pointers as a contiguous array.  <a href="#ab833d1ea135e1651b55087cbe923dbf5">More...</a><br /></td></tr>
<tr class="separator:ab833d1ea135e1651b55087cbe923dbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed0776222f258c09ec2a11a11aa6e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#abed0776222f258c09ec2a11a11aa6e93">get_sorted_record</a> (size_t ix)</td></tr>
<tr class="memdesc:abed0776222f258c09ec2a11a11aa6e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets sorted record number ix.  <a href="#abed0776222f258c09ec2a11a11aa6e93">More...</a><br /></td></tr>
<tr class="separator:abed0776222f258c09ec2a11a11aa6e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59961e0c040572632e5d0d5cfdeb4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBounds__checked__array.html">Bounds_checked_array</a>&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#aa59961e0c040572632e5d0d5cfdeb4ea">get_contiguous_buffer</a> ()</td></tr>
<tr class="memdesc:aa59961e0c040572632e5d0d5cfdeb4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all rows, then returns a contiguous buffer of maximum size.  <a href="#aa59961e0c040572632e5d0d5cfdeb4ea">More...</a><br /></td></tr>
<tr class="separator:aa59961e0c040572632e5d0d5cfdeb4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab2894fdbf5cc8bc2e847be259175cc84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#ab2894fdbf5cc8bc2e847be259175cc84">allocate_block</a> (size_t num_bytes)</td></tr>
<tr class="memdesc:ab2894fdbf5cc8bc2e847be259175cc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new block with space for at least <code>num_bytes</code> bytes.  <a href="#ab2894fdbf5cc8bc2e847be259175cc84">More...</a><br /></td></tr>
<tr class="separator:ab2894fdbf5cc8bc2e847be259175cc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf2033c8c697d97424b5b6d07f72371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#addf2033c8c697d97424b5b6d07f72371">allocate_sized_block</a> (size_t num_bytes)</td></tr>
<tr class="memdesc:addf2033c8c697d97424b5b6d07f72371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new block of exactly <code>block_size</code> bytes, and sets it as the current block.  <a href="#addf2033c8c697d97424b5b6d07f72371">More...</a><br /></td></tr>
<tr class="separator:addf2033c8c697d97424b5b6d07f72371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d08f9c0dd117244f4e845aee376568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a34d08f9c0dd117244f4e845aee376568">update_peak_memory_used</a> () const</td></tr>
<tr class="memdesc:a34d08f9c0dd117244f4e845aee376568"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_peak_memory_used.  <a href="#a34d08f9c0dd117244f4e845aee376568">More...</a><br /></td></tr>
<tr class="separator:a34d08f9c0dd117244f4e845aee376568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7837e82fc631a903f85b96f6cbd17aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilesort__buffer.html">Filesort_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a7837e82fc631a903f85b96f6cbd17aa9">operator=</a> (const <a class="el" href="classFilesort__buffer.html">Filesort_buffer</a> &amp;rhs)=delete</td></tr>
<tr class="separator:a7837e82fc631a903f85b96f6cbd17aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fd1b14a20aec3dbb6ec9d41cf47edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilesort__buffer.html">Filesort_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#aa4fd1b14a20aec3dbb6ec9d41cf47edd">operator=</a> (<a class="el" href="classFilesort__buffer.html">Filesort_buffer</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:aa4fd1b14a20aec3dbb6ec9d41cf47edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af1a77fb86758b22d6ee644f20b3c5cb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#af1a77fb86758b22d6ee644f20b3c5cb0">m_next_rec_ptr</a></td></tr>
<tr class="memdesc:af1a77fb86758b22d6ee644f20b3c5cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next record will be inserted here.  <a href="#af1a77fb86758b22d6ee644f20b3c5cb0">More...</a><br /></td></tr>
<tr class="separator:af1a77fb86758b22d6ee644f20b3c5cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e32c5fd5190a34556bbefe893e50027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a9e32c5fd5190a34556bbefe893e50027">m_current_block_end</a></td></tr>
<tr class="memdesc:a9e32c5fd5190a34556bbefe893e50027"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit of the current block, exclusive.  <a href="#a9e32c5fd5190a34556bbefe893e50027">More...</a><br /></td></tr>
<tr class="separator:a9e32c5fd5190a34556bbefe893e50027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb2c4f698ec3685fe9cdce695f8670"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="map__helpers_8h.html#ab9bfec3d68fe066cd76cd78c5039d012">unique_ptr_my_free</a>&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>[]&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a39eb2c4f698ec3685fe9cdce695f8670">m_blocks</a></td></tr>
<tr class="memdesc:a39eb2c4f698ec3685fe9cdce695f8670"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory blocks used for the actual data.  <a href="#a39eb2c4f698ec3685fe9cdce695f8670">More...</a><br /></td></tr>
<tr class="separator:a39eb2c4f698ec3685fe9cdce695f8670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c448c2a52bb2f9631759b219dae9eb5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a2c448c2a52bb2f9631759b219dae9eb5">m_record_pointers</a></td></tr>
<tr class="memdesc:a2c448c2a52bb2f9631759b219dae9eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the beginning of each record.  <a href="#a2c448c2a52bb2f9631759b219dae9eb5">More...</a><br /></td></tr>
<tr class="separator:a2c448c2a52bb2f9631759b219dae9eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017b567397fbf84c32c637aa6192daeb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a017b567397fbf84c32c637aa6192daeb">m_max_record_length</a></td></tr>
<tr class="memdesc:a017b567397fbf84c32c637aa6192daeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worst-case length of each record.  <a href="#a017b567397fbf84c32c637aa6192daeb">More...</a><br /></td></tr>
<tr class="separator:a017b567397fbf84c32c637aa6192daeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f930f256d20c1b0e59ea82be890e580"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a4f930f256d20c1b0e59ea82be890e580">m_max_size_in_bytes</a></td></tr>
<tr class="memdesc:a4f930f256d20c1b0e59ea82be890e580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bytes we are allowed to allocate in all.  <a href="#a4f930f256d20c1b0e59ea82be890e580">More...</a><br /></td></tr>
<tr class="separator:a4f930f256d20c1b0e59ea82be890e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dc2470347de70158f5bd07503fc422"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a23dc2470347de70158f5bd07503fc422">m_current_block_size</a></td></tr>
<tr class="memdesc:a23dc2470347de70158f5bd07503fc422"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the current memory block (m_blocks.back()), in bytes (or 0 if no block).  <a href="#a23dc2470347de70158f5bd07503fc422">More...</a><br /></td></tr>
<tr class="separator:a23dc2470347de70158f5bd07503fc422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4279bfa37e49e9e337b0fc5711c9d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#ade4279bfa37e49e9e337b0fc5711c9d8">m_space_used_other_blocks</a></td></tr>
<tr class="memdesc:ade4279bfa37e49e9e337b0fc5711c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of all blocks except the current one, not including record pointers.  <a href="#ade4279bfa37e49e9e337b0fc5711c9d8">More...</a><br /></td></tr>
<tr class="separator:ade4279bfa37e49e9e337b0fc5711c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cc8fe11f34dcba696aef5ce72f33cb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilesort__buffer.html#a62cc8fe11f34dcba696aef5ce72f33cb">m_peak_memory_used</a> {0}</td></tr>
<tr class="memdesc:a62cc8fe11f34dcba696aef5ce72f33cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest amount of total memory we've been using since last call to clear_peak_memory_used().  <a href="#a62cc8fe11f34dcba696aef5ce72f33cb">More...</a><br /></td></tr>
<tr class="separator:a62cc8fe11f34dcba696aef5ce72f33cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Buffer used for storing records to be sorted. </p>
<p>The records are stored in a series of buffers that are allocated incrementally, growing 50% each time, similar to how a MEM_ROOT works. This allows the user to set a large maximum buffer size without getting huge allocations for sorting small result sets. It means that if you actually <em>do</em> use the entire buffer, there will be more allocations than one large allocation up-front, but this is a worthwhile tradeoff (those allocation will tend to disappear into the cost of actually getting all the rows and sorting them).</p>
<p>In addition, Filesort_buffer stores a vector of pointers to the beginning of each record. It is these pointers that are actually sorted in filesort. If the records are small, this can add up to overhead on top of the amount of memory the user expected to use. We <em>do</em> take already allocated pointers into account when calculating how big a new block can be, so the amount of badness is bounded:</p>
<p>Assume that we have set maximum record size to infinity, but that in practice, they are are about the smallest size possible (4-byte sort key plus 4-byte rowid) and that we are on a 64-bit system. Then, the worst possible overhead is that we use as much space on pointers as the size of the last (largest) block. We can look at the two possible extremes:</p>
<ul>
<li>Smallest possible sort buffer (32 kB): 32 kB overhead.</li>
<li>A huge sort buffer (x kB): If the last block is y kB, the total size will be y + 2/3y + (2/3)Â²y + ... = 3y, which means the last block is 1/3 of the total size. Thus, pointer overhead will be no worse than 33%.</li>
</ul>
<p>In most practical cases, it will be much better than this. In particular, even when allocating a block (where we don't yet know how many records will fit), we allow space for the record pointers we'd need given maximum-sized rows.</p>
<p>The buffer must be kept available for multiple executions of the same sort operation, so one can call reset() for reuse. Again similar to MEM_ROOT, this keeps the last (largest) block and discards the others. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="affbb298a57c615a56ef181acba61e515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbb298a57c615a56ef181acba61e515">&#9670;&nbsp;</a></span>Filesort_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Filesort_buffer::Filesort_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab2894fdbf5cc8bc2e847be259175cc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2894fdbf5cc8bc2e847be259175cc84">&#9670;&nbsp;</a></span>allocate_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Filesort_buffer::allocate_block </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new block with space for at least <code>num_bytes</code> bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the allocation failed (including if m_max_size_in_bytes was exceeded). </dd></dl>

</div>
</div>
<a id="addf2033c8c697d97424b5b6d07f72371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf2033c8c697d97424b5b6d07f72371">&#9670;&nbsp;</a></span>allocate_sized_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Filesort_buffer::allocate_sized_block </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new block of exactly <code>block_size</code> bytes, and sets it as the current block. </p>
<p>Does not check m_max_size_in_bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the allocation failed </dd></dl>

</div>
</div>
<a id="a883a120748b86f4fd4ad199d6bdacdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883a120748b86f4fd4ad199d6bdacdbf">&#9670;&nbsp;</a></span>clear_peak_memory_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Filesort_buffer::clear_peak_memory_used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See peak_memory_used. </p>

</div>
</div>
<a id="a9f375f658f6911906a7d835562e3bf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f375f658f6911906a7d835562e3bf4d">&#9670;&nbsp;</a></span>commit_used_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Filesort_buffer::commit_used_memory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a967d857a913b61ef3957d094ac227eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967d857a913b61ef3957d094ac227eca">&#9670;&nbsp;</a></span>free_sort_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Filesort_buffer::free_sort_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all memory. </p>
<p>Unlike reset(), which keeps one block for future use, this actually releases all blocks. It is intended to release memory in an error situation, for final shutdown, or if even the largest block will not be large enough for future allocations.</p>
<p>You do not need to call this if you are destroying the object anyway. </p>

</div>
</div>
<a id="aa59961e0c040572632e5d0d5cfdeb4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59961e0c040572632e5d0d5cfdeb4ea">&#9670;&nbsp;</a></span>get_contiguous_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBounds__checked__array.html">Bounds_checked_array</a>&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &gt; Filesort_buffer::get_contiguous_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all rows, then returns a contiguous buffer of maximum size. </p>
<p>(This may or may not involve allocation.) This is for reusing the memory for merge buffers, which requires the memory to be a single contiguous chunk; one could in theory adjust merging to allow using multiple buffers like sorting does, but once we need to merge, that means we've hit disk anyway (or at the very least, need to talk to the OS' buffer cache), and the cost of a single allocation is small compared to I/O.</p>
<p>If you use this memory area, you cannot also use the Filesort_buffer to store sort records (get_next_record_pointer etc.); that would use the same memory.</p>
<p>Can return nullptr, if allocation fails. </p>

</div>
</div>
<a id="aee298f9fc03682727cc994c592547db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee298f9fc03682727cc994c592547db5">&#9670;&nbsp;</a></span>get_next_record_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBounds__checked__array.html">Bounds_checked_array</a>&lt;<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt; Filesort_buffer::get_next_record_pointer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Where should the next record be stored? </p>
<p>If a block is returned, it is always at least "min_size" bytes long. If the returned block is not large enough for your purposes, call get_next_record_pointer() again with a larger value of min_size than the size you got back. Just increasing the size by one byte is fine; the class will still try to make exponentially larger blocks each time.</p>
<p>If there's no room for a record of the given size, returns nullptr.</p>
<p>After you've written data to the given record, call commit_used_memory() with the number of bytes you've actually written. This ensures it will not get reused for subsequent records. </p>

</div>
</div>
<a id="ab833d1ea135e1651b55087cbe923dbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab833d1ea135e1651b55087cbe923dbf5">&#9670;&nbsp;</a></span>get_sort_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>** Filesort_buffer::get_sort_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of record pointers as a contiguous array. </p>
<p>Will be invalidated by calling get_next_record_pointer() or otherwise changing the number of records. </p>

</div>
</div>
<a id="abed0776222f258c09ec2a11a11aa6e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed0776222f258c09ec2a11a11aa6e93">&#9670;&nbsp;</a></span>get_sorted_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* Filesort_buffer::get_sorted_record </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets sorted record number ix. </p>
<dl class="section see"><dt>See also</dt><dd>get_sort_keys() Only valid after buffer has been sorted! </dd></dl>

</div>
</div>
<a id="ac2f707da8839611eb33462e5431f3885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f707da8839611eb33462e5431f3885">&#9670;&nbsp;</a></span>max_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::max_size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7837e82fc631a903f85b96f6cbd17aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7837e82fc631a903f85b96f6cbd17aa9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilesort__buffer.html">Filesort_buffer</a>&amp; Filesort_buffer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilesort__buffer.html">Filesort_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4fd1b14a20aec3dbb6ec9d41cf47edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fd1b14a20aec3dbb6ec9d41cf47edd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilesort__buffer.html">Filesort_buffer</a>&amp; Filesort_buffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFilesort__buffer.html">Filesort_buffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d7a78af586f5141ee65793abd0e8751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7a78af586f5141ee65793abd0e8751">&#9670;&nbsp;</a></span>peak_memory_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::peak_memory_used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How much memory has been allocated (counting both the sort buffer and the record pointers) at most since last call to clear_peak_memory_used(). </p>
<p>Note in particular that reset() and free_sort_buffer() does <em>not</em> zero this counter. </p>

</div>
</div>
<a id="a41f7fe2f56e21182af6a0df03dadd3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f7fe2f56e21182af6a0df03dadd3ce">&#9670;&nbsp;</a></span>preallocate_records()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Filesort_buffer::preallocate_records </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_records</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any existing rows and allocates <code>num_records</code> maximum-sized rows (call get_sorted_record() to get their pointers). </p>
<p>This is somewhat more efficient than calling reset() and then get_next_record_pointer() repeatedly, as it guarantees that at most one allocation is needed.</p>
<dl class="section return"><dt>Returns</dt><dd>true on memory allocation error, including if the allocated size would exceed max_size_in_bytes(). </dd></dl>

</div>
</div>
<a id="a3d20fb6855d3772aa0583af831173752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d20fb6855d3772aa0583af831173752">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Filesort_buffer::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares the buffer for the next batch of records to process. </p>

</div>
</div>
<a id="ae3d14b71fe80410f6cd2b038ab8380c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d14b71fe80410f6cd2b038ab8380c0">&#9670;&nbsp;</a></span>set_max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Filesort_buffer::set_max_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>record_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the memory limit for the sort buffer before starting to add records. </p>
<p>If trying to allocate space for a new row (in get_next_record_pointer) would take us past the set limit, allocation will fail. Note that we can go a bit over this limit due to having to store record pointers; see the class comment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size</td><td>Maximum size of the sort buffer, in bytes. </td></tr>
    <tr><td class="paramname">record_length</td><td>Worst-case size of each record, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e0a4332094b2074a7b01641a449cad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0a4332094b2074a7b01641a449cad7">&#9670;&nbsp;</a></span>sort_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::sort_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSort__param.html">Sort_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_input_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_output_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort me... </p>
<dl class="section return"><dt>Returns</dt><dd>Number of records, after any deduplication </dd></dl>

</div>
</div>
<a id="a34d08f9c0dd117244f4e845aee376568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d08f9c0dd117244f4e845aee376568">&#9670;&nbsp;</a></span>update_peak_memory_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Filesort_buffer::update_peak_memory_used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_peak_memory_used. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39eb2c4f698ec3685fe9cdce695f8670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eb2c4f698ec3685fe9cdce695f8670">&#9670;&nbsp;</a></span>m_blocks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="map__helpers_8h.html#ab9bfec3d68fe066cd76cd78c5039d012">unique_ptr_my_free</a>&lt;<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>[]&gt; &gt; Filesort_buffer::m_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The memory blocks used for the actual data. </p>

</div>
</div>
<a id="a9e32c5fd5190a34556bbefe893e50027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e32c5fd5190a34556bbefe893e50027">&#9670;&nbsp;</a></span>m_current_block_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* Filesort_buffer::m_current_block_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The limit of the current block, exclusive. </p>

</div>
</div>
<a id="a23dc2470347de70158f5bd07503fc422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dc2470347de70158f5bd07503fc422">&#9670;&nbsp;</a></span>m_current_block_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::m_current_block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the current memory block (m_blocks.back()), in bytes (or 0 if no block). </p>
<p>If nothing has been allocated from the block yet, the invariant m_next_rec_ptr + m_current_block_size == m_current_block_end holds. </p>

</div>
</div>
<a id="a017b567397fbf84c32c637aa6192daeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017b567397fbf84c32c637aa6192daeb">&#9670;&nbsp;</a></span>m_max_record_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::m_max_record_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worst-case length of each record. </p>

</div>
</div>
<a id="a4f930f256d20c1b0e59ea82be890e580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f930f256d20c1b0e59ea82be890e580">&#9670;&nbsp;</a></span>m_max_size_in_bytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::m_max_size_in_bytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of bytes we are allowed to allocate in all. </p>

</div>
</div>
<a id="af1a77fb86758b22d6ee644f20b3c5cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a77fb86758b22d6ee644f20b3c5cb0">&#9670;&nbsp;</a></span>m_next_rec_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* Filesort_buffer::m_next_rec_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next record will be inserted here. </p>

</div>
</div>
<a id="a62cc8fe11f34dcba696aef5ce72f33cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cc8fe11f34dcba696aef5ce72f33cb">&#9670;&nbsp;</a></span>m_peak_memory_used</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::m_peak_memory_used {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The largest amount of total memory we've been using since last call to clear_peak_memory_used(). </p>
<p>This is updated lazily so that we don't need to do the calculations for every record (and thus is mutable). The only point where it <em>must</em> be explicitly updated (by calling update_peak_memory_used()), except when being asked for the value, is right before we deallocate memory, as otherwise, there could be a peak we had forgotten. </p>

</div>
</div>
<a id="a2c448c2a52bb2f9631759b219dae9eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c448c2a52bb2f9631759b219dae9eb5">&#9670;&nbsp;</a></span>m_record_pointers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&gt; Filesort_buffer::m_record_pointers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the beginning of each record. </p>

</div>
</div>
<a id="ade4279bfa37e49e9e337b0fc5711c9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4279bfa37e49e9e337b0fc5711c9d8">&#9670;&nbsp;</a></span>m_space_used_other_blocks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Filesort_buffer::m_space_used_other_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total size of all blocks except the current one, not including record pointers. </p>
<p>Used for bookkeeping how far away we are from reaching m_max_size_in_bytes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="filesort__utils_8h_source.html">filesort_utils.h</a></li>
<li>sql/<a class="el" href="filesort__utils_8cc.html">filesort_utils.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classFilesort__buffer.html">Filesort_buffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
