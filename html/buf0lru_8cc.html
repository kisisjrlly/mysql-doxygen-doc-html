<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/buf/buf0lru.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('buf0lru_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0lru.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The database buffer replacement algorithm.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buddy_8h_source.html">buf0buddy.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0dblwr_8h_source.html">buf0dblwr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0flu_8h_source.html">buf0flu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0rea_8h_source.html">buf0rea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0stats_8h_source.html">buf0stats.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0event_8h_source.html">os0event.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0file_8h_source.html">os0file.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0rnd_8h_source.html">ut0rnd.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4126c969aa70e6b3b1511e854f9425fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a4126c969aa70e6b3b1511e854f9425fe">BUF_LRU_OLD_TOLERANCE</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:a4126c969aa70e6b3b1511e854f9425fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of blocks from the LRU_old pointer onward, including the block pointed to, must be buf_pool-&gt;LRU_old_ratio/BUF_LRU_OLD_RATIO_DIV of the whole LRU list length, except that the tolerance defined below is allowed.  <a href="#a4126c969aa70e6b3b1511e854f9425fe">More...</a><br /></td></tr>
<tr class="separator:a4126c969aa70e6b3b1511e854f9425fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ae522780fb5a46bf2f9e4fe7b8a3ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a04ae522780fb5a46bf2f9e4fe7b8a3ec">BUF_LRU_NON_OLD_MIN_LEN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a04ae522780fb5a46bf2f9e4fe7b8a3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum amount of non-old blocks when the LRU_old list exists (that is, when there are more than BUF_LRU_OLD_MIN_LEN blocks).  <a href="#a04ae522780fb5a46bf2f9e4fe7b8a3ec">More...</a><br /></td></tr>
<tr class="separator:a04ae522780fb5a46bf2f9e4fe7b8a3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aae0a3a63ccd3bccb8a1a69b5da38bf9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#aae0a3a63ccd3bccb8a1a69b5da38bf9c">buf_LRU_block_remove_hashed</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> zip, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ignore_content)</td></tr>
<tr class="memdesc:aae0a3a63ccd3bccb8a1a69b5da38bf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a block out of the LRU list and page hash table.  <a href="#aae0a3a63ccd3bccb8a1a69b5da38bf9c">More...</a><br /></td></tr>
<tr class="separator:aae0a3a63ccd3bccb8a1a69b5da38bf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab233f0431f27c3a625ba58885478f460"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ab233f0431f27c3a625ba58885478f460">buf_LRU_block_free_hashed_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:ab233f0431f27c3a625ba58885478f460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a file page whose has no hash index to the free list.  <a href="#ab233f0431f27c3a625ba58885478f460">More...</a><br /></td></tr>
<tr class="separator:ab233f0431f27c3a625ba58885478f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aac8fc7a20735bf5fca809492639f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#aa1aac8fc7a20735bf5fca809492639f7">incr_LRU_size_in_bytes</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:aa1aac8fc7a20735bf5fca809492639f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases LRU size in bytes with page size inline function.  <a href="#aa1aac8fc7a20735bf5fca809492639f7">More...</a><br /></td></tr>
<tr class="separator:aa1aac8fc7a20735bf5fca809492639f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b72ad753812794778dfbf22a961ce4"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a89b72ad753812794778dfbf22a961ce4">buf_LRU_evict_from_unzip_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a89b72ad753812794778dfbf22a961ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the unzip_LRU list should be used for evicting a victim instead of the general LRU list.  <a href="#a89b72ad753812794778dfbf22a961ce4">More...</a><br /></td></tr>
<tr class="separator:a89b72ad753812794778dfbf22a961ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a887f386a3aebaef28e214940d8dd81"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a5a887f386a3aebaef28e214940d8dd81">buf_LRU_drop_page_hash_batch</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, const <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> *arr, ulint <a class="el" href="myisam__ftdump_8cc.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>)</td></tr>
<tr class="memdesc:a5a887f386a3aebaef28e214940d8dd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to drop page hash index on a batch of pages belonging to a particular space id.  <a href="#a5a887f386a3aebaef28e214940d8dd81">More...</a><br /></td></tr>
<tr class="separator:a5a887f386a3aebaef28e214940d8dd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59aae3215cbe8c336a2fa42cd6933af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ad59aae3215cbe8c336a2fa42cd6933af">buf_LRU_drop_page_hash_for_tablespace</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id)</td></tr>
<tr class="memdesc:ad59aae3215cbe8c336a2fa42cd6933af"><td class="mdescLeft">&#160;</td><td class="mdescRight">When doing a DROP TABLE/DISCARD TABLESPACE we have to drop all page hash index entries belonging to that table.  <a href="#ad59aae3215cbe8c336a2fa42cd6933af">More...</a><br /></td></tr>
<tr class="separator:ad59aae3215cbe8c336a2fa42cd6933af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13799cb1b1a524bc8822470be5fb4b7d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a13799cb1b1a524bc8822470be5fb4b7d">buf_flush_yield</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a13799cb1b1a524bc8822470be5fb4b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">While flushing (or removing dirty) pages from a tablespace we don't want to hog the CPU and resources.  <a href="#a13799cb1b1a524bc8822470be5fb4b7d">More...</a><br /></td></tr>
<tr class="separator:a13799cb1b1a524bc8822470be5fb4b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87147b1362ff170b6e6487b4f035cc8d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a87147b1362ff170b6e6487b4f035cc8d">buf_flush_try_yield</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, ulint processed, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *must_restart)</td></tr>
<tr class="memdesc:a87147b1362ff170b6e6487b4f035cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have hogged the resources for too long then release the LRU list and flush list mutexes and do a thread yield.  <a href="#a87147b1362ff170b6e6487b4f035cc8d">More...</a><br /></td></tr>
<tr class="separator:a87147b1362ff170b6e6487b4f035cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1120597f6728f89b9395b701a2fa84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a8d1120597f6728f89b9395b701a2fa84">buf_flush_or_remove_page</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="suite__stubs_8h.html#aae477e2a5594b8ee2d1e3b58f01c2374">flush</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *must_restart)</td></tr>
<tr class="memdesc:a8d1120597f6728f89b9395b701a2fa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single page from a given tablespace inside a specific buffer pool instance.  <a href="#a8d1120597f6728f89b9395b701a2fa84">More...</a><br /></td></tr>
<tr class="separator:a8d1120597f6728f89b9395b701a2fa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8069ccef53db5a44470e5cf66553090a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a8069ccef53db5a44470e5cf66553090a">buf_flush_or_remove_pages</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="classFlushObserver.html">FlushObserver</a> *observer, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="suite__stubs_8h.html#aae477e2a5594b8ee2d1e3b58f01c2374">flush</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a8069ccef53db5a44470e5cf66553090a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all dirty pages belonging to a given tablespace inside a specific buffer pool instance when we are deleting the data file(s) of that tablespace.  <a href="#a8069ccef53db5a44470e5cf66553090a">More...</a><br /></td></tr>
<tr class="separator:a8069ccef53db5a44470e5cf66553090a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2decf002a873c4115dd2eadca10a2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a8c2decf002a873c4115dd2eadca10a2b">buf_flush_dirty_pages</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="classFlushObserver.html">FlushObserver</a> *observer, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="suite__stubs_8h.html#aae477e2a5594b8ee2d1e3b58f01c2374">flush</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> strict)</td></tr>
<tr class="memdesc:a8c2decf002a873c4115dd2eadca10a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove or flush all the dirty pages that belong to a given tablespace inside a specific buffer pool instance.  <a href="#a8c2decf002a873c4115dd2eadca10a2b">More...</a><br /></td></tr>
<tr class="separator:a8c2decf002a873c4115dd2eadca10a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49de1d0496720815bff53a8f4a0ff01"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ad49de1d0496720815bff53a8f4a0ff01">buf_LRU_remove_all_pages</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>)</td></tr>
<tr class="memdesc:ad49de1d0496720815bff53a8f4a0ff01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all pages that belong to a given tablespace inside a specific buffer pool instance when we are DISCARDing the tablespace.  <a href="#ad49de1d0496720815bff53a8f4a0ff01">More...</a><br /></td></tr>
<tr class="separator:ad49de1d0496720815bff53a8f4a0ff01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2351a9c4ac567c902c68055fead36d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ae2351a9c4ac567c902c68055fead36d8">buf_LRU_remove_pages</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a> buf_remove, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> strict)</td></tr>
<tr class="memdesc:ae2351a9c4ac567c902c68055fead36d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pages belonging to a given tablespace inside a specific buffer pool instance when we are deleting the data file(s) of that tablespace.  <a href="#ae2351a9c4ac567c902c68055fead36d8">More...</a><br /></td></tr>
<tr class="separator:ae2351a9c4ac567c902c68055fead36d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e203649f43994ebdc50ab30c5121976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a4e203649f43994ebdc50ab30c5121976">buf_LRU_flush_or_remove_pages</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a> buf_remove, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> strict)</td></tr>
<tr class="memdesc:a4e203649f43994ebdc50ab30c5121976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all dirty pages or removes all pages belonging to a given tablespace.  <a href="#a4e203649f43994ebdc50ab30c5121976">More...</a><br /></td></tr>
<tr class="separator:a4e203649f43994ebdc50ab30c5121976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71034f6a657d17a7b12f924484f5f4b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a71034f6a657d17a7b12f924484f5f4b9">buf_LRU_insert_zip_clean</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a71034f6a657d17a7b12f924484f5f4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a compressed block into buf_pool-&gt;zip_clean in the LRU order.  <a href="#a71034f6a657d17a7b12f924484f5f4b9">More...</a><br /></td></tr>
<tr class="separator:a71034f6a657d17a7b12f924484f5f4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fd22ba71157a92d253c40a8448ded7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a05fd22ba71157a92d253c40a8448ded7">buf_LRU_free_from_unzip_LRU_list</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan_all)</td></tr>
<tr class="memdesc:a05fd22ba71157a92d253c40a8448ded7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to free an uncompressed page of a compressed block from the unzip LRU list.  <a href="#a05fd22ba71157a92d253c40a8448ded7">More...</a><br /></td></tr>
<tr class="separator:a05fd22ba71157a92d253c40a8448ded7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719b85b92f67e9db4004a66726a053d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a719b85b92f67e9db4004a66726a053d9">buf_LRU_free_from_common_LRU_list</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan_all)</td></tr>
<tr class="memdesc:a719b85b92f67e9db4004a66726a053d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to free a clean page from the common LRU list.  <a href="#a719b85b92f67e9db4004a66726a053d9">More...</a><br /></td></tr>
<tr class="separator:a719b85b92f67e9db4004a66726a053d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd67b9190c8f7b9d270e50c888160c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#aa5bd67b9190c8f7b9d270e50c888160c">buf_LRU_scan_and_free_block</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan_all)</td></tr>
<tr class="memdesc:aa5bd67b9190c8f7b9d270e50c888160c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to free a replaceable block.  <a href="#aa5bd67b9190c8f7b9d270e50c888160c">More...</a><br /></td></tr>
<tr class="separator:aa5bd67b9190c8f7b9d270e50c888160c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab515ca10b95a13c8fcac45f492b6e855"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ab515ca10b95a13c8fcac45f492b6e855">buf_LRU_buf_pool_running_out</a> (void)</td></tr>
<tr class="memdesc:ab515ca10b95a13c8fcac45f492b6e855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if less than 25 % of the buffer pool in any instance is available.  <a href="#ab515ca10b95a13c8fcac45f492b6e855">More...</a><br /></td></tr>
<tr class="separator:ab515ca10b95a13c8fcac45f492b6e855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437daab4f8f29da688cb649950f3c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#aa437daab4f8f29da688cb649950f3c5b">buf_LRU_get_free_only</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:aa437daab4f8f29da688cb649950f3c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free block from the buf_pool.  <a href="#aa437daab4f8f29da688cb649950f3c5b">More...</a><br /></td></tr>
<tr class="separator:aa437daab4f8f29da688cb649950f3c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe8fd1ba7995d2e7a9cb19980286779"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#afbe8fd1ba7995d2e7a9cb19980286779">buf_LRU_check_size_of_non_data_objects</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:afbe8fd1ba7995d2e7a9cb19980286779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks how much of buf_pool is occupied by non-data objects like AHI, lock heaps etc.  <a href="#afbe8fd1ba7995d2e7a9cb19980286779">More...</a><br /></td></tr>
<tr class="separator:afbe8fd1ba7995d2e7a9cb19980286779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02f0192cd5a3751396b3c023a37b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a4b02f0192cd5a3751396b3c023a37b9e">buf_LRU_get_free_block</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a4b02f0192cd5a3751396b3c023a37b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free block from the buf_pool.  <a href="#a4b02f0192cd5a3751396b3c023a37b9e">More...</a><br /></td></tr>
<tr class="separator:a4b02f0192cd5a3751396b3c023a37b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae753be1c5d30d3567b9885438562595c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ae753be1c5d30d3567b9885438562595c">buf_LRU_old_adjust_len</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:ae753be1c5d30d3567b9885438562595c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the LRU_old pointer so that the length of the old blocks list is inside the allowed limits.  <a href="#ae753be1c5d30d3567b9885438562595c">More...</a><br /></td></tr>
<tr class="separator:ae753be1c5d30d3567b9885438562595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b95488fd9ee1861af487ba4a26bd18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a27b95488fd9ee1861af487ba4a26bd18">buf_LRU_old_init</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a27b95488fd9ee1861af487ba4a26bd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the old blocks pointer in the LRU list.  <a href="#a27b95488fd9ee1861af487ba4a26bd18">More...</a><br /></td></tr>
<tr class="separator:a27b95488fd9ee1861af487ba4a26bd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c13c10929949b917c703526e2e2b09b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a7c13c10929949b917c703526e2e2b09b">buf_unzip_LRU_remove_block_if_needed</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a7c13c10929949b917c703526e2e2b09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block from the unzip_LRU list if it belonged to the list.  <a href="#a7c13c10929949b917c703526e2e2b09b">More...</a><br /></td></tr>
<tr class="separator:a7c13c10929949b917c703526e2e2b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7322b3f6632a7980efd30fdd388975e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a7322b3f6632a7980efd30fdd388975e7">buf_LRU_adjust_hp</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a7322b3f6632a7980efd30fdd388975e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust LRU hazard pointers if needed.  <a href="#a7322b3f6632a7980efd30fdd388975e7">More...</a><br /></td></tr>
<tr class="separator:a7322b3f6632a7980efd30fdd388975e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8c77e1f9c272a0e93aad0a3fe91b47"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#add8c77e1f9c272a0e93aad0a3fe91b47">buf_LRU_remove_block</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:add8c77e1f9c272a0e93aad0a3fe91b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a block from the LRU list.  <a href="#add8c77e1f9c272a0e93aad0a3fe91b47">More...</a><br /></td></tr>
<tr class="separator:add8c77e1f9c272a0e93aad0a3fe91b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e495c4bde95a1ffeee80477589c19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#aa2e495c4bde95a1ffeee80477589c19c">buf_unzip_LRU_add_block</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ibool old)</td></tr>
<tr class="memdesc:aa2e495c4bde95a1ffeee80477589c19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a block to the LRU list of decompressed zip pages.  <a href="#aa2e495c4bde95a1ffeee80477589c19c">More...</a><br /></td></tr>
<tr class="separator:aa2e495c4bde95a1ffeee80477589c19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b61f4589214186bc49224785ec09be"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a37b61f4589214186bc49224785ec09be">buf_LRU_add_block_low</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, ibool old)</td></tr>
<tr class="memdesc:a37b61f4589214186bc49224785ec09be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a block to the LRU list.  <a href="#a37b61f4589214186bc49224785ec09be">More...</a><br /></td></tr>
<tr class="separator:a37b61f4589214186bc49224785ec09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37acd1d770ff94c59155beb100720d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a0b37acd1d770ff94c59155beb100720d">buf_LRU_add_block</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, ibool old)</td></tr>
<tr class="memdesc:a0b37acd1d770ff94c59155beb100720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a block to the LRU list.  <a href="#a0b37acd1d770ff94c59155beb100720d">More...</a><br /></td></tr>
<tr class="separator:a0b37acd1d770ff94c59155beb100720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a541c8810f1079a8f69ce67efb3dd48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a5a541c8810f1079a8f69ce67efb3dd48">buf_LRU_make_block_young</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a5a541c8810f1079a8f69ce67efb3dd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a block to the start of the LRU list.  <a href="#a5a541c8810f1079a8f69ce67efb3dd48">More...</a><br /></td></tr>
<tr class="separator:a5a541c8810f1079a8f69ce67efb3dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da9010d067c9ed107d9639a365939ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a4da9010d067c9ed107d9639a365939ed">buf_LRU_make_block_old</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a4da9010d067c9ed107d9639a365939ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a block to the end of the LRU list.  <a href="#a4da9010d067c9ed107d9639a365939ed">More...</a><br /></td></tr>
<tr class="separator:a4da9010d067c9ed107d9639a365939ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944b5fe6a7102d6cdfd20c1c8baed0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ab944b5fe6a7102d6cdfd20c1c8baed0e">buf_LRU_free_page</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> zip)</td></tr>
<tr class="memdesc:ab944b5fe6a7102d6cdfd20c1c8baed0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to free a block.  <a href="#ab944b5fe6a7102d6cdfd20c1c8baed0e">More...</a><br /></td></tr>
<tr class="separator:ab944b5fe6a7102d6cdfd20c1c8baed0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81143c182cdc5ce2aeb5033dd435018e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a81143c182cdc5ce2aeb5033dd435018e">buf_LRU_block_free_non_file_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a81143c182cdc5ce2aeb5033dd435018e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a block back to the free list.  <a href="#a81143c182cdc5ce2aeb5033dd435018e">More...</a><br /></td></tr>
<tr class="separator:a81143c182cdc5ce2aeb5033dd435018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273f4959459f79c4f47fc8e626251f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a273f4959459f79c4f47fc8e626251f3a">buf_LRU_free_one_page</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> zip, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ignore_content)</td></tr>
<tr class="memdesc:a273f4959459f79c4f47fc8e626251f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one page from LRU list and put it to free list.  <a href="#a273f4959459f79c4f47fc8e626251f3a">More...</a><br /></td></tr>
<tr class="separator:a273f4959459f79c4f47fc8e626251f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f613dd7915970c53ecf5e3d9892c03"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ad9f613dd7915970c53ecf5e3d9892c03">buf_LRU_old_ratio_update_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> old_pct, ibool adjust)</td></tr>
<tr class="memdesc:ad9f613dd7915970c53ecf5e3d9892c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates buf_pool-&gt;LRU_old_ratio for one buffer pool instance.  <a href="#ad9f613dd7915970c53ecf5e3d9892c03">More...</a><br /></td></tr>
<tr class="separator:ad9f613dd7915970c53ecf5e3d9892c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf0d5ba597c72a2c4dca148c74a498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a6fbf0d5ba597c72a2c4dca148c74a498">buf_LRU_old_ratio_update</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> old_pct, ibool adjust)</td></tr>
<tr class="memdesc:a6fbf0d5ba597c72a2c4dca148c74a498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates buf_pool-&gt;LRU_old_ratio.  <a href="#a6fbf0d5ba597c72a2c4dca148c74a498">More...</a><br /></td></tr>
<tr class="separator:a6fbf0d5ba597c72a2c4dca148c74a498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97799d0b01ded04c3a9530c29f7a009f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a97799d0b01ded04c3a9530c29f7a009f">buf_LRU_stat_update</a> (void)</td></tr>
<tr class="memdesc:a97799d0b01ded04c3a9530c29f7a009f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the historical stats that we are collecting for LRU eviction policy at the end of each interval.  <a href="#a97799d0b01ded04c3a9530c29f7a009f">More...</a><br /></td></tr>
<tr class="separator:a97799d0b01ded04c3a9530c29f7a009f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce6bc9aa57e8f74d2d0a7ab14813a45"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a2ce6bc9aa57e8f74d2d0a7ab14813a45">buf_LRU_validate_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a2ce6bc9aa57e8f74d2d0a7ab14813a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the LRU list for one buffer pool instance.  <a href="#a2ce6bc9aa57e8f74d2d0a7ab14813a45">More...</a><br /></td></tr>
<tr class="separator:a2ce6bc9aa57e8f74d2d0a7ab14813a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1658f4c7b393310ce247257ead0fbf"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a3a1658f4c7b393310ce247257ead0fbf">buf_LRU_validate</a> (void)</td></tr>
<tr class="memdesc:a3a1658f4c7b393310ce247257ead0fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the LRU list.  <a href="#a3a1658f4c7b393310ce247257ead0fbf">More...</a><br /></td></tr>
<tr class="separator:a3a1658f4c7b393310ce247257ead0fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e1eb294afb942b4db2830b3fed03a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ad2e1eb294afb942b4db2830b3fed03a0">buf_LRU_print_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:ad2e1eb294afb942b4db2830b3fed03a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the LRU list for one buffer pool instance.  <a href="#ad2e1eb294afb942b4db2830b3fed03a0">More...</a><br /></td></tr>
<tr class="separator:ad2e1eb294afb942b4db2830b3fed03a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94a8fa767c16d5922987d25bcfc2daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#ae94a8fa767c16d5922987d25bcfc2daf">buf_LRU_print</a> (void)</td></tr>
<tr class="memdesc:ae94a8fa767c16d5922987d25bcfc2daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the LRU list.  <a href="#ae94a8fa767c16d5922987d25bcfc2daf">More...</a><br /></td></tr>
<tr class="separator:ae94a8fa767c16d5922987d25bcfc2daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1e7f63101ebdf26cb1bc717720f7861d"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a1e7f63101ebdf26cb1bc717720f7861d">BUF_LRU_DROP_SEARCH_SIZE</a> = 1024</td></tr>
<tr class="memdesc:a1e7f63101ebdf26cb1bc717720f7861d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When dropping the search hash index entries before deleting an ibd file, we build a local array of pages belonging to that tablespace in the buffer pool.  <a href="#a1e7f63101ebdf26cb1bc717720f7861d">More...</a><br /></td></tr>
<tr class="separator:a1e7f63101ebdf26cb1bc717720f7861d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf25c17a54b04d8f4015af80e3445aa"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#adaf25c17a54b04d8f4015af80e3445aa">BUF_LRU_SEARCH_SCAN_THRESHOLD</a> = 100</td></tr>
<tr class="memdesc:adaf25c17a54b04d8f4015af80e3445aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">We scan these many blocks when looking for a clean page to evict during LRU eviction.  <a href="#adaf25c17a54b04d8f4015af80e3445aa">More...</a><br /></td></tr>
<tr class="separator:adaf25c17a54b04d8f4015af80e3445aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e872fcaca7c32648aab73441ad4a9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a17e872fcaca7c32648aab73441ad4a9a">buf_lru_switched_on_innodb_mon</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:a17e872fcaca7c32648aab73441ad4a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we switch on the InnoDB monitor because there are too few available frames in the buffer pool, we set this to TRUE.  <a href="#a17e872fcaca7c32648aab73441ad4a9a">More...</a><br /></td></tr>
<tr class="separator:a17e872fcaca7c32648aab73441ad4a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a360e853324cadc3c37b75d025630f57c"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a360e853324cadc3c37b75d025630f57c">BUF_LRU_STAT_N_INTERVAL</a> = 50</td></tr>
<tr class="memdesc:a360e853324cadc3c37b75d025630f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">These statistics are not 'of' LRU but 'for' LRU.  <a href="#a360e853324cadc3c37b75d025630f57c">More...</a><br /></td></tr>
<tr class="separator:a360e853324cadc3c37b75d025630f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177f273f1aabebbb5a26e31a3e3c65f8"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a177f273f1aabebbb5a26e31a3e3c65f8">BUF_LRU_IO_TO_UNZIP_FACTOR</a> = 50</td></tr>
<tr class="memdesc:a177f273f1aabebbb5a26e31a3e3c65f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Co-efficient with which we multiply I/O operations to equate them with page_zip_decompress() operations.  <a href="#a177f273f1aabebbb5a26e31a3e3c65f8">More...</a><br /></td></tr>
<tr class="separator:a177f273f1aabebbb5a26e31a3e3c65f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7606ab4ed3d1e44c3f98562dba232013"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a7606ab4ed3d1e44c3f98562dba232013">buf_LRU_stat_arr</a> [<a class="el" href="buf0lru_8cc.html#a360e853324cadc3c37b75d025630f57c">BUF_LRU_STAT_N_INTERVAL</a>]</td></tr>
<tr class="memdesc:a7606ab4ed3d1e44c3f98562dba232013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampled values buf_LRU_stat_cur.  <a href="#a7606ab4ed3d1e44c3f98562dba232013">More...</a><br /></td></tr>
<tr class="separator:a7606ab4ed3d1e44c3f98562dba232013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f254b6fdc5772e32e2492c5f34583b"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a71f254b6fdc5772e32e2492c5f34583b">buf_LRU_stat_arr_ind</a></td></tr>
<tr class="memdesc:a71f254b6fdc5772e32e2492c5f34583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cursor to buf_LRU_stat_arr[] that is updated in a round-robin fashion.  <a href="#a71f254b6fdc5772e32e2492c5f34583b">More...</a><br /></td></tr>
<tr class="separator:a71f254b6fdc5772e32e2492c5f34583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa535da980a8fb505f33884c4d838e65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#aa535da980a8fb505f33884c4d838e65b">buf_LRU_stat_cur</a></td></tr>
<tr class="memdesc:aa535da980a8fb505f33884c4d838e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current operation counters.  <a href="#aa535da980a8fb505f33884c4d838e65b">More...</a><br /></td></tr>
<tr class="separator:aa535da980a8fb505f33884c4d838e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875cfab89124f0c3eee966035fd211e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a875cfab89124f0c3eee966035fd211e8">buf_LRU_stat_sum</a></td></tr>
<tr class="memdesc:a875cfab89124f0c3eee966035fd211e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Running sum of past values of buf_LRU_stat_cur.  <a href="#a875cfab89124f0c3eee966035fd211e8">More...</a><br /></td></tr>
<tr class="separator:a875cfab89124f0c3eee966035fd211e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Heuristics for detecting index scan</div></td></tr>
<tr class="memitem:a22fb54c3fd2164554f62ef7b3c100607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8cc.html#a22fb54c3fd2164554f62ef7b3c100607">buf_LRU_old_threshold_ms</a></td></tr>
<tr class="memdesc:a22fb54c3fd2164554f62ef7b3c100607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move blocks to "new" LRU list only if the first access was at least this many milliseconds ago.  <a href="#a22fb54c3fd2164554f62ef7b3c100607">More...</a><br /></td></tr>
<tr class="separator:a22fb54c3fd2164554f62ef7b3c100607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer replacement algorithm. </p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a04ae522780fb5a46bf2f9e4fe7b8a3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ae522780fb5a46bf2f9e4fe7b8a3ec">&#9670;&nbsp;</a></span>BUF_LRU_NON_OLD_MIN_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_NON_OLD_MIN_LEN&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum amount of non-old blocks when the LRU_old list exists (that is, when there are more than BUF_LRU_OLD_MIN_LEN blocks). </p>
<dl class="section see"><dt>See also</dt><dd>buf_LRU_old_adjust_len </dd></dl>

</div>
</div>
<a id="a4126c969aa70e6b3b1511e854f9425fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4126c969aa70e6b3b1511e854f9425fe">&#9670;&nbsp;</a></span>BUF_LRU_OLD_TOLERANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_TOLERANCE&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of blocks from the LRU_old pointer onward, including the block pointed to, must be buf_pool-&gt;LRU_old_ratio/BUF_LRU_OLD_RATIO_DIV of the whole LRU list length, except that the tolerance defined below is allowed. </p>
<p>Note that the tolerance must be small enough such that for even the BUF_LRU_OLD_MIN_LEN long LRU list, the LRU_old pointer is not allowed to point to either end of the LRU list. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8c2decf002a873c4115dd2eadca10a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2decf002a873c4115dd2eadca10a2b">&#9670;&nbsp;</a></span>buf_flush_dirty_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_dirty_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlushObserver.html">FlushObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>strict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove or flush all the dirty pages that belong to a given tablespace inside a specific buffer pool instance. </p>
<p>The pages will remain in the LRU list and will be evicted from the LRU list as they age and move towards the tail of the LRU list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>space id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observer</td><td>flush observer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>flush to disk if true, otherwise remove the pages without flushing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction to check if the operation must be interrupted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>true, if no page from tablespace can be in buffer pool just after flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d1120597f6728f89b9395b701a2fa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1120597f6728f89b9395b701a2fa84">&#9670;&nbsp;</a></span>buf_flush_or_remove_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_or_remove_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>must_restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a single page from a given tablespace inside a specific buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>bpage to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>flush to disk if true but don't remove else remove without flushing to disk </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">must_restart</td><td>flag if must restart the flush list scan </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if page was removed. </dd></dl>

</div>
</div>
<a id="a8069ccef53db5a44470e5cf66553090a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8069ccef53db5a44470e5cf66553090a">&#9670;&nbsp;</a></span>buf_flush_or_remove_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> buf_flush_or_remove_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlushObserver.html">FlushObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all dirty pages belonging to a given tablespace inside a specific buffer pool instance when we are deleting the data file(s) of that tablespace. </p>
<p>The pages still remain a part of LRU and are evicted from the list as they age towards the tail of the LRU. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>space id for which to remove or flush pages </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observer</td><td>flush observer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>flush to disk if true but don't remove, otherwise remove without flushing to disk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction to check if the operation must be interrupted, can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>if all freed </td></tr>
    <tr><td class="paramname">DB_FAIL</td><td>if not all freed </td></tr>
    <tr><td class="paramname">DB_INTERRUPTED</td><td>if the transaction was interrupted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87147b1362ff170b6e6487b4f035cc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87147b1362ff170b6e6487b4f035cc8d">&#9670;&nbsp;</a></span>buf_flush_try_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_try_yield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>processed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>must_restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we have hogged the resources for too long then release the LRU list and flush list mutexes and do a thread yield. </p>
<p>Set the current page to "sticky" so that it is not relocated during the yield. </p><dl class="section return"><dt>Returns</dt><dd>true if yielded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in/out: bpage to remove </td></tr>
    <tr><td class="paramname">processed</td><td>in: number of pages processed </td></tr>
    <tr><td class="paramname">must_restart</td><td>in/out: if true, we have to restart the flush list scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13799cb1b1a524bc8822470be5fb4b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13799cb1b1a524bc8822470be5fb4b7d">&#9670;&nbsp;</a></span>buf_flush_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_yield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While flushing (or removing dirty) pages from a tablespace we don't want to hog the CPU and resources. </p>
<p>Release the LRU list and block mutexes and try to force a context switch. Then reacquire the same mutexes. The current page is "fixed" before the release of the mutexes and then "unfixed" again once we have reacquired the mutexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>current page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b37acd1d770ff94c59155beb100720d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37acd1d770ff94c59155beb100720d">&#9670;&nbsp;</a></span>buf_LRU_add_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_add_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a block to the LRU list. </p>
<p>Please make sure that the page_size is already set when invoking the function, so that we can get correct page_size from the buffer page when adding a block into LRU </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: control block </td></tr>
    <tr><td class="paramname">old</td><td>in: TRUE if should be put to the old blocks in the LRU list, else put to the start; if the LRU list is very short, the block is added to the start, regardless of this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37b61f4589214186bc49224785ec09be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b61f4589214186bc49224785ec09be">&#9670;&nbsp;</a></span>buf_LRU_add_block_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_LRU_add_block_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a block to the LRU list. </p>
<p>Please make sure that the page_size is already set when invoking the function, so that we can get correct page_size from the buffer page when adding a block into LRU </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old</td><td>TRUE if should be put to the old blocks in the LRU list, else put to the start; if the LRU list is very short, the block is added to the start, regardless of this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7322b3f6632a7980efd30fdd388975e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7322b3f6632a7980efd30fdd388975e7">&#9670;&nbsp;</a></span>buf_LRU_adjust_hp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_adjust_hp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust LRU hazard pointers if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>Buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>Control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab233f0431f27c3a625ba58885478f460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab233f0431f27c3a625ba58885478f460">&#9670;&nbsp;</a></span>buf_LRU_block_free_hashed_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_block_free_hashed_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts a file page whose has no hash index to the free list. </p>
<p>in: block, must contain a file page and be in a state where it can be freed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block, must contain a file page and be in a state where it can be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81143c182cdc5ce2aeb5033dd435018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81143c182cdc5ce2aeb5033dd435018e">&#9670;&nbsp;</a></span>buf_LRU_block_free_non_file_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_block_free_non_file_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a block back to the free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>block must not contain a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae0a3a63ccd3bccb8a1a69b5da38bf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0a3a63ccd3bccb8a1a69b5da38bf9c">&#9670;&nbsp;</a></span>buf_LRU_block_remove_hashed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_LRU_block_remove_hashed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a block out of the LRU list and page hash table. </p>
<p>If the block is compressed-only (BUF_BLOCK_ZIP_PAGE), the object will be freed.</p>
<p>The caller must hold buf_pool-&gt;LRU_list_mutex, the buf_page_get_mutex() mutex and the appropriate hash_lock. This function will release the buf_page_get_mutex() and the hash_lock.</p>
<p>If a compressed page is freed other compressed pages may be relocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>block, must contain a file page and be in a state where it can be freed; there may or may not be a hash index to the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zip</td><td>true if should remove also the compressed page of an uncompressed page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_content</td><td>true if should ignore page content, since it could be not initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if BUF_BLOCK_FILE_PAGE was removed from page_hash. The caller needs to free the page to the free list </td></tr>
    <tr><td class="paramname">false</td><td>if BUF_BLOCK_ZIP_PAGE was removed from page_hash. In this case the block is already returned to the buddy allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab515ca10b95a13c8fcac45f492b6e855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515ca10b95a13c8fcac45f492b6e855">&#9670;&nbsp;</a></span>buf_LRU_buf_pool_running_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_LRU_buf_pool_running_out </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if less than 25 % of the buffer pool in any instance is available. </p>
<p>Returns TRUE if less than 25 % of the buffer pool is available.</p>
<p>This can be used in heuristics to prevent huge transactions eating up the whole buffer pool for their locks. </p><dl class="section return"><dt>Returns</dt><dd>true if less than 25 % of buffer pool left </dd></dl>

</div>
</div>
<a id="afbe8fd1ba7995d2e7a9cb19980286779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe8fd1ba7995d2e7a9cb19980286779">&#9670;&nbsp;</a></span>buf_LRU_check_size_of_non_data_objects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_check_size_of_non_data_objects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks how much of buf_pool is occupied by non-data objects like AHI, lock heaps etc. </p>
<p>Depending on the size of non-data objects this function will either assert or issue a warning and switch on the status monitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a887f386a3aebaef28e214940d8dd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a887f386a3aebaef28e214940d8dd81">&#9670;&nbsp;</a></span>buf_LRU_drop_page_hash_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_drop_page_hash_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to drop page hash index on a batch of pages belonging to a particular space id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>space id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>array of page_no </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of entries in array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad59aae3215cbe8c336a2fa42cd6933af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59aae3215cbe8c336a2fa42cd6933af">&#9670;&nbsp;</a></span>buf_LRU_drop_page_hash_for_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_drop_page_hash_for_tablespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When doing a DROP TABLE/DISCARD TABLESPACE we have to drop all page hash index entries belonging to that table. </p>
<p>This function tries to do that in batch. Note that this is a 'best effort' attempt and does not guarantee that ALL hash entries will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89b72ad753812794778dfbf22a961ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b72ad753812794778dfbf22a961ce4">&#9670;&nbsp;</a></span>buf_LRU_evict_from_unzip_LRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_LRU_evict_from_unzip_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the unzip_LRU list should be used for evicting a victim instead of the general LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if should use unzip_LRU </dd></dl>

</div>
</div>
<a id="a4e203649f43994ebdc50ab30c5121976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e203649f43994ebdc50ab30c5121976">&#9670;&nbsp;</a></span>buf_LRU_flush_or_remove_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_flush_or_remove_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a>&#160;</td>
          <td class="paramname"><em>buf_remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>strict</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes all dirty pages or removes all pages belonging to a given tablespace. </p>
<p>A PROBLEM: if readahead is being started, what guarantees that it will not try to read in pages after this operation has completed? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>tablespace ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_remove</td><td>remove or flush strategy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>to check if the operation must be interrupted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>true, if no page from tablespace can be in buffer pool just after flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a719b85b92f67e9db4004a66726a053d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719b85b92f67e9db4004a66726a053d9">&#9670;&nbsp;</a></span>buf_LRU_free_from_common_LRU_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_LRU_free_from_common_LRU_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to free a clean page from the common LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_all</td><td>scan whole LRU list if true, otherwise scan only up to BUF_LRU_SEARCH_SCAN_THRESHOLD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if freed </dd></dl>

</div>
</div>
<a id="a05fd22ba71157a92d253c40a8448ded7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fd22ba71157a92d253c40a8448ded7">&#9670;&nbsp;</a></span>buf_LRU_free_from_unzip_LRU_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_LRU_free_from_unzip_LRU_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to free an uncompressed page of a compressed block from the unzip LRU list. </p>
<p>The compressed page is preserved, and it need not be clean. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_all</td><td>scan whole LRU list if true, otherwise scan only srv_LRU_scan_depth / 2 blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if freed </dd></dl>

</div>
</div>
<a id="a273f4959459f79c4f47fc8e626251f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273f4959459f79c4f47fc8e626251f3a">&#9670;&nbsp;</a></span>buf_LRU_free_one_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_free_one_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove one page from LRU list and put it to free list. </p>
<p>The caller must hold the LRU list and block mutexes and have page hash latched in X. The latch and the block mutexes will be released. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>block, must contain a file page and be in a state where it can be freed; there may or may not be a hash index to the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zip</td><td>true if should remove also the compressed page of an uncompressed page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_content</td><td>true if should ignore page content, since it could be not initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab944b5fe6a7102d6cdfd20c1c8baed0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab944b5fe6a7102d6cdfd20c1c8baed0e">&#9670;&nbsp;</a></span>buf_LRU_free_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_LRU_free_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to free a block. </p>
<p>If bpage is a descriptor of a compressed-only page, the descriptor object will be freed as well. NOTE: this function may temporarily release and relock the buf_page_get_mutex(). Furthermore, the page frame will no longer be accessible via bpage. If this function returns true, it will also release the LRU list mutex. The caller must hold the LRU list and buf_page_get_mutex() mutexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>block to be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zip</td><td>true if should remove also the compressed page of an uncompressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if freed, false otherwise. </dd></dl>

</div>
</div>
<a id="a4b02f0192cd5a3751396b3c023a37b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02f0192cd5a3751396b3c023a37b9e">&#9670;&nbsp;</a></span>buf_LRU_get_free_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_LRU_get_free_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free block from the buf_pool. </p>
<p>The block is taken off the free list. If free list is empty, blocks are moved from the end of the LRU list to the free list. This function is called from a user thread when it needs a clean block to read in a page. Note that we only ever get a block from the free list. Even when we flush a page or find a page in LRU scan we put it to free list to be used. iteration 0: get a block from free list, success:done if buf_pool-&gt;try_LRU_scan is set scan LRU up to srv_LRU_scan_depth to find a clean block the above will put the block on free list success:retry the free list flush one dirty page from tail of LRU to disk the above will put the block on free list success: retry the free list iteration 1: same as iteration 0 except: scan whole LRU list scan LRU list even if buf_pool-&gt;try_LRU_scan is not set iteration &gt; 1: same as iteration 1 but sleep 10ms </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the free control block, in state BUF_BLOCK_READY_FOR_USE </dd></dl>

</div>
</div>
<a id="aa437daab4f8f29da688cb649950f3c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa437daab4f8f29da688cb649950f3c5b">&#9670;&nbsp;</a></span>buf_LRU_get_free_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_LRU_get_free_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free block from the buf_pool. </p>
<p>The block is taken off the free list. If it is empty, returns NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a free control block, or NULL if the buf_block-&gt;free list is empty </dd></dl>

</div>
</div>
<a id="a71034f6a657d17a7b12f924484f5f4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71034f6a657d17a7b12f924484f5f4b9">&#9670;&nbsp;</a></span>buf_LRU_insert_zip_clean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_insert_zip_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a compressed block into buf_pool-&gt;zip_clean in the LRU order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4da9010d067c9ed107d9639a365939ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da9010d067c9ed107d9639a365939ed">&#9670;&nbsp;</a></span>buf_LRU_make_block_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_make_block_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a block to the end of the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a541c8810f1079a8f69ce67efb3dd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a541c8810f1079a8f69ce67efb3dd48">&#9670;&nbsp;</a></span>buf_LRU_make_block_young()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_make_block_young </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a block to the start of the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae753be1c5d30d3567b9885438562595c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae753be1c5d30d3567b9885438562595c">&#9670;&nbsp;</a></span>buf_LRU_old_adjust_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_LRU_old_adjust_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the LRU_old pointer so that the length of the old blocks list is inside the allowed limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27b95488fd9ee1861af487ba4a26bd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b95488fd9ee1861af487ba4a26bd18">&#9670;&nbsp;</a></span>buf_LRU_old_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_old_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the old blocks pointer in the LRU list. </p>
<p>This function should be called when the LRU list grows to BUF_LRU_OLD_MIN_LEN length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fbf0d5ba597c72a2c4dca148c74a498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbf0d5ba597c72a2c4dca148c74a498">&#9670;&nbsp;</a></span>buf_LRU_old_ratio_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> buf_LRU_old_ratio_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>old_pct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates buf_pool-&gt;LRU_old_ratio. </p>
<dl class="section return"><dt>Returns</dt><dd>updated old_pct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_pct</td><td>in: Reserve this percentage of the buffer pool for "old" blocks. </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE=adjust the LRU list; FALSE=just assign buf_pool-&gt;LRU_old_ratio during the initialization of InnoDB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9f613dd7915970c53ecf5e3d9892c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f613dd7915970c53ecf5e3d9892c03">&#9670;&nbsp;</a></span>buf_LRU_old_ratio_update_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> buf_LRU_old_ratio_update_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>old_pct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates buf_pool-&gt;LRU_old_ratio for one buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_pct</td><td>Reserve this percentage of the buffer pool for "old" blocks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adjust</td><td>TRUE=adjust the LRU list; FALSE=just assign buf_pool-&gt;LRU_old_ratio during the initialization of InnoDB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>updated old_pct </dd></dl>

</div>
</div>
<a id="ae94a8fa767c16d5922987d25bcfc2daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94a8fa767c16d5922987d25bcfc2daf">&#9670;&nbsp;</a></span>buf_LRU_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the LRU list. </p>

</div>
</div>
<a id="ad2e1eb294afb942b4db2830b3fed03a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e1eb294afb942b4db2830b3fed03a0">&#9670;&nbsp;</a></span>buf_LRU_print_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_print_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the LRU list for one buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad49de1d0496720815bff53a8f4a0ff01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49de1d0496720815bff53a8f4a0ff01">&#9670;&nbsp;</a></span>buf_LRU_remove_all_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_remove_all_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all pages that belong to a given tablespace inside a specific buffer pool instance when we are DISCARDing the tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add8c77e1f9c272a0e93aad0a3fe91b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8c77e1f9c272a0e93aad0a3fe91b47">&#9670;&nbsp;</a></span>buf_LRU_remove_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_LRU_remove_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a block from the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2351a9c4ac567c902c68055fead36d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2351a9c4ac567c902c68055fead36d8">&#9670;&nbsp;</a></span>buf_LRU_remove_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_remove_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a>&#160;</td>
          <td class="paramname"><em>buf_remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>strict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove pages belonging to a given tablespace inside a specific buffer pool instance when we are deleting the data file(s) of that tablespace. </p>
<p>The pages still remain a part of LRU and are evicted from the list as they age towards the tail of the LRU only if buf_remove is BUF_REMOVE_FLUSH_NO_WRITE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">buf_remove</td><td>in: remove or flush strategy </td></tr>
    <tr><td class="paramname">trx</td><td>to check if the operation must be interrupted </td></tr>
    <tr><td class="paramname">strict</td><td>in: true if no page from tablespace can be in buffer pool just after flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5bd67b9190c8f7b9d270e50c888160c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bd67b9190c8f7b9d270e50c888160c">&#9670;&nbsp;</a></span>buf_LRU_scan_and_free_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_LRU_scan_and_free_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to free a replaceable block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_all</td><td>scan whole LRU list if ture, otherwise scan only BUF_LRU_SEARCH_SCAN_THRESHOLD blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if found and freed </dd></dl>

</div>
</div>
<a id="a97799d0b01ded04c3a9530c29f7a009f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97799d0b01ded04c3a9530c29f7a009f">&#9670;&nbsp;</a></span>buf_LRU_stat_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_stat_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the historical stats that we are collecting for LRU eviction policy at the end of each interval. </p>

</div>
</div>
<a id="a3a1658f4c7b393310ce247257ead0fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1658f4c7b393310ce247257ead0fbf">&#9670;&nbsp;</a></span>buf_LRU_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_LRU_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the LRU list. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a2ce6bc9aa57e8f74d2d0a7ab14813a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce6bc9aa57e8f74d2d0a7ab14813a45">&#9670;&nbsp;</a></span>buf_LRU_validate_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_LRU_validate_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the LRU list for one buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e495c4bde95a1ffeee80477589c19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e495c4bde95a1ffeee80477589c19c">&#9670;&nbsp;</a></span>buf_unzip_LRU_add_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_unzip_LRU_add_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a block to the LRU list of decompressed zip pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old</td><td>TRUE if should be put to the end of the list, else put to the start </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c13c10929949b917c703526e2e2b09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c13c10929949b917c703526e2e2b09b">&#9670;&nbsp;</a></span>buf_unzip_LRU_remove_block_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_unzip_LRU_remove_block_if_needed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a block from the unzip_LRU list if it belonged to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1aac8fc7a20735bf5fca809492639f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1aac8fc7a20735bf5fca809492639f7">&#9670;&nbsp;</a></span>incr_LRU_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void incr_LRU_size_in_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases LRU size in bytes with page size inline function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1e7f63101ebdf26cb1bc717720f7861d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7f63101ebdf26cb1bc717720f7861d">&#9670;&nbsp;</a></span>BUF_LRU_DROP_SEARCH_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_LRU_DROP_SEARCH_SIZE = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When dropping the search hash index entries before deleting an ibd file, we build a local array of pages belonging to that tablespace in the buffer pool. </p>
<p>Following is the size of that array. We also release buf_pool-&gt;LRU_list_mutex after scanning this many pages of the flush_list when dropping a table. This is to ensure that other threads are not blocked for extended period of time when using very large buffer pools. </p>

</div>
</div>
<a id="a177f273f1aabebbb5a26e31a3e3c65f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177f273f1aabebbb5a26e31a3e3c65f8">&#9670;&nbsp;</a></span>BUF_LRU_IO_TO_UNZIP_FACTOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_LRU_IO_TO_UNZIP_FACTOR = 50</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Co-efficient with which we multiply I/O operations to equate them with page_zip_decompress() operations. </p>

</div>
</div>
<a id="a22fb54c3fd2164554f62ef7b3c100607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fb54c3fd2164554f62ef7b3c100607">&#9670;&nbsp;</a></span>buf_LRU_old_threshold_ms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> buf_LRU_old_threshold_ms</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move blocks to "new" LRU list only if the first access was at least this many milliseconds ago. </p>
<p>Not protected by any mutex or latch. </p>

</div>
</div>
<a id="adaf25c17a54b04d8f4015af80e3445aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf25c17a54b04d8f4015af80e3445aa">&#9670;&nbsp;</a></span>BUF_LRU_SEARCH_SCAN_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_LRU_SEARCH_SCAN_THRESHOLD = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We scan these many blocks when looking for a clean page to evict during LRU eviction. </p>

</div>
</div>
<a id="a7606ab4ed3d1e44c3f98562dba232013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7606ab4ed3d1e44c3f98562dba232013">&#9670;&nbsp;</a></span>buf_LRU_stat_arr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a> buf_LRU_stat_arr[<a class="el" href="buf0lru_8cc.html#a360e853324cadc3c37b75d025630f57c">BUF_LRU_STAT_N_INTERVAL</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sampled values buf_LRU_stat_cur. </p>
<p>Not protected by any mutex. Updated by buf_LRU_stat_update(). </p>

</div>
</div>
<a id="a71f254b6fdc5772e32e2492c5f34583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f254b6fdc5772e32e2492c5f34583b">&#9670;&nbsp;</a></span>buf_LRU_stat_arr_ind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_LRU_stat_arr_ind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cursor to buf_LRU_stat_arr[] that is updated in a round-robin fashion. </p>

</div>
</div>
<a id="aa535da980a8fb505f33884c4d838e65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa535da980a8fb505f33884c4d838e65b">&#9670;&nbsp;</a></span>buf_LRU_stat_cur</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a> buf_LRU_stat_cur</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current operation counters. </p>
<p>Not protected by any mutex. Cleared by buf_LRU_stat_update(). </p>

</div>
</div>
<a id="a360e853324cadc3c37b75d025630f57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360e853324cadc3c37b75d025630f57c">&#9670;&nbsp;</a></span>BUF_LRU_STAT_N_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_LRU_STAT_N_INTERVAL = 50</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These statistics are not 'of' LRU but 'for' LRU. </p>
<p>We keep count of I/O and page_zip_decompress() operations. Based on the statistics, buf_LRU_evict_from_unzip_LRU() decides if we want to evict from unzip_LRU or the regular LRU. From unzip_LRU, we will only evict the uncompressed frame (meaning we can evict dirty blocks as well). From the regular LRU, we will evict the entire block (i.e.: both the uncompressed and compressed data), which must be clean. Number of intervals for which we keep the history of these stats. Each interval is 1 second, defined by the rate at which srv_error_monitor_thread() calls buf_LRU_stat_update(). </p>

</div>
</div>
<a id="a875cfab89124f0c3eee966035fd211e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875cfab89124f0c3eee966035fd211e8">&#9670;&nbsp;</a></span>buf_LRU_stat_sum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a> buf_LRU_stat_sum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Running sum of past values of buf_LRU_stat_cur. </p>
<p>Updated by buf_LRU_stat_update(). Not Protected by any mutex. </p>

</div>
</div>
<a id="a17e872fcaca7c32648aab73441ad4a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e872fcaca7c32648aab73441ad4a9a">&#9670;&nbsp;</a></span>buf_lru_switched_on_innodb_mon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_lru_switched_on_innodb_mon = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we switch on the InnoDB monitor because there are too few available frames in the buffer pool, we set this to TRUE. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_19e7dc57837d445aa8a255d4d3e40a16.html">buf</a></li><li class="navelem"><a class="el" href="buf0lru_8cc.html">buf0lru.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
