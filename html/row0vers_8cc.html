<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/row/row0vers.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('row0vers_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">row0vers.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Row versions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="current__thd_8h_source.html">current_thd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="read0read_8h_source.html">read0read.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0ext_8h_source.html">row0ext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0vers_8h_source.html">row0vers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0purge_8h_source.html">trx0purge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0rec_8h_source.html">trx0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0roll_8h_source.html">trx0roll.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0rseg_8h_source.html">trx0rseg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acab984e820913e48182b74da5dfd2c9e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#acab984e820913e48182b74da5dfd2c9e">row_vers_non_vc_index_entry_match</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *ientry1, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *ientry2, ulint *n_non_v_col)</td></tr>
<tr class="memdesc:acab984e820913e48182b74da5dfd2c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether all non-virtual columns in a index entries match.  <a href="#acab984e820913e48182b74da5dfd2c9e">More...</a><br /></td></tr>
<tr class="separator:acab984e820913e48182b74da5dfd2c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41bd36adf046d841f05e606f1523913"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#ae41bd36adf046d841f05e606f1523913">row_clust_vers_matches_sec</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const clust_index, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const clust_rec, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *const clust_vrow, const ulint *const clust_offsets, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const sec_index, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const sec_rec, const ulint *const sec_offsets, const ulint comp, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> looking_for_match, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *const heap)</td></tr>
<tr class="memdesc:ae41bd36adf046d841f05e606f1523913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a particular version of a record from clustered index matches the secondary index record.  <a href="#ae41bd36adf046d841f05e606f1523913">More...</a><br /></td></tr>
<tr class="separator:ae41bd36adf046d841f05e606f1523913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8694df2a63fc87209212d3072be37e59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a8694df2a63fc87209212d3072be37e59">row_vers_find_matching</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> looking_for_match, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const clust_index, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const clust_rec, ulint *&amp;clust_offsets, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const sec_index, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const sec_rec, const ulint *const sec_offsets, const ulint comp, const <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="structmtr__t.html">mtr_t</a> *const mtr, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&amp;heap)</td></tr>
<tr class="memdesc:a8694df2a63fc87209212d3072be37e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops through the history of clustered index record in the undo log, stopping after the first version which was not created by the given active transaction, and reports if it found a version which satisfies criterion specified by looking_for_match.  <a href="#a8694df2a63fc87209212d3072be37e59">More...</a><br /></td></tr>
<tr class="separator:a8694df2a63fc87209212d3072be37e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48b753e07dbffacc103caf59324364d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#aa48b753e07dbffacc103caf59324364d">row_vers_impl_x_locked_low</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const clust_rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const clust_index, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const sec_rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const sec_index, const ulint *const sec_offsets, <a class="el" href="structmtr__t.html">mtr_t</a> *const mtr)</td></tr>
<tr class="memdesc:aa48b753e07dbffacc103caf59324364d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if an active transaction has inserted or modified a secondary index record.  <a href="#aa48b753e07dbffacc103caf59324364d">More...</a><br /></td></tr>
<tr class="separator:aa48b753e07dbffacc103caf59324364d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873759f07eb21517ec8ab89593ce5b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a873759f07eb21517ec8ab89593ce5b56">row_vers_impl_x_locked</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:a873759f07eb21517ec8ab89593ce5b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if an active transaction has inserted or modified a secondary index record.  <a href="#a873759f07eb21517ec8ab89593ce5b56">More...</a><br /></td></tr>
<tr class="separator:a873759f07eb21517ec8ab89593ce5b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35483f4b5cff91482e61316f170e068e"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a35483f4b5cff91482e61316f170e068e">row_vers_must_preserve_del_marked</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, const <a class="el" href="structtable__name__t.html">table_name_t</a> &amp;<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a35483f4b5cff91482e61316f170e068e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if we must preserve a delete marked earlier version of a clustered index record, because it is &gt;= the purge view.  <a href="#a35483f4b5cff91482e61316f170e068e">More...</a><br /></td></tr>
<tr class="separator:a35483f4b5cff91482e61316f170e068e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5bfebba11f8fe3c591cc3600125d54"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a9d5bfebba11f8fe3c591cc3600125d54">row_vers_build_clust_v_col</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *row, <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a9d5bfebba11f8fe3c591cc3600125d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">build virtual column value from current cluster index record data  <a href="#a9d5bfebba11f8fe3c591cc3600125d54">More...</a><br /></td></tr>
<tr class="separator:a9d5bfebba11f8fe3c591cc3600125d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20948ab430de39a36e2248243df85e3a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a20948ab430de39a36e2248243df85e3a">row_vers_build_cur_vrow_low</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> in_purge, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, ulint *clust_offsets, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *v_heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> **vrow, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a20948ab430de39a36e2248243df85e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build latest virtual column data from undo log.  <a href="#a20948ab430de39a36e2248243df85e3a">More...</a><br /></td></tr>
<tr class="separator:a20948ab430de39a36e2248243df85e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8560bb1054506a4c586bf7d66ae27c67"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a8560bb1054506a4c586bf7d66ae27c67">row_vers_vc_matches_cluster</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> in_purge, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *icentry, <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, ulint *clust_offsets, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *ientry, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *v_heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> **vrow, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a8560bb1054506a4c586bf7d66ae27c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a virtual column value index secondary virtual index matches that of current cluster index record, which is recreated from information stored in undo log.  <a href="#a8560bb1054506a4c586bf7d66ae27c67">More...</a><br /></td></tr>
<tr class="separator:a8560bb1054506a4c586bf7d66ae27c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e58d20de8521a8c88d6191510abf35"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a14e58d20de8521a8c88d6191510abf35">row_vers_build_cur_vrow</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> in_purge, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, ulint **clust_offsets, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *ientry, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *v_heap, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a14e58d20de8521a8c88d6191510abf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a dtuple contains virtual column data for current cluster index.  <a href="#a14e58d20de8521a8c88d6191510abf35">More...</a><br /></td></tr>
<tr class="separator:a14e58d20de8521a8c88d6191510abf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57036a4dfd7783df64cfb508aacee69a"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a57036a4dfd7783df64cfb508aacee69a">row_vers_old_has_index_entry</a> (ibool also_curr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *ientry, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id)</td></tr>
<tr class="memdesc:a57036a4dfd7783df64cfb508aacee69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds out if a version of the record, where the version &gt;= the current purge view, should have ientry as its secondary index entry.  <a href="#a57036a4dfd7783df64cfb508aacee69a">More...</a><br /></td></tr>
<tr class="separator:a57036a4dfd7783df64cfb508aacee69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1334e2cba78bf467fd5f0808b8348c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#ae1334e2cba78bf467fd5f0808b8348c2">row_vers_build_for_consistent_read</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint **offsets, <a class="el" href="classReadView.html">ReadView</a> *view, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offset_heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *in_heap, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **old_vers, const <a class="el" href="structdtuple__t.html">dtuple_t</a> **vrow, <a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *lob_undo)</td></tr>
<tr class="memdesc:ae1334e2cba78bf467fd5f0808b8348c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the version of a clustered index record which a consistent read should see.  <a href="#ae1334e2cba78bf467fd5f0808b8348c2">More...</a><br /></td></tr>
<tr class="separator:ae1334e2cba78bf467fd5f0808b8348c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c74453c995cfc90fb0eeca017f47144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0vers_8cc.html#a7c74453c995cfc90fb0eeca017f47144">row_vers_build_for_semi_consistent_read</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offset_heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *in_heap, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **old_vers, const <a class="el" href="structdtuple__t.html">dtuple_t</a> **vrow)</td></tr>
<tr class="memdesc:a7c74453c995cfc90fb0eeca017f47144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the last committed version of a clustered index record, which should be seen by a semi-consistent read.  <a href="#a7c74453c995cfc90fb0eeca017f47144">More...</a><br /></td></tr>
<tr class="separator:a7c74453c995cfc90fb0eeca017f47144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Row versions. </p>
<p>Created 2/6/1997 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae41bd36adf046d841f05e606f1523913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41bd36adf046d841f05e606f1523913">&#9670;&nbsp;</a></span>row_clust_vers_matches_sec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_clust_vers_matches_sec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *const&#160;</td>
          <td class="paramname"><em>clust_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>sec_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const&#160;</td>
          <td class="paramname"><em>sec_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *const&#160;</td>
          <td class="paramname"><em>sec_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>looking_for_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *const&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a particular version of a record from clustered index matches the secondary index record. </p>
<p>The match occurs if and only if two condition hold: 1) the clust_rec exists and is not delete marked 2) the values in columns in clust_rec match those in sec_rec Please note that the delete marker on sec_rec does not play any role in this definition! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_rec</td><td>the clustered index record, can be null or delete marked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_vrow</td><td>the values of virtual columns, can be NULL if the clust_rec was stored in undo log by operation that did not change any secondary index column (and was not a DELETE operation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_offsets</td><td>the offsets for clust_rec, rec_get_offsets(clust_rec, clust_index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_index</td><td>the secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_rec</td><td>the secondary index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_offsets</td><td>the offsets for secondary index record, rec_get_offsets(sec_rec, sec_index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>the compression flag for both the clustered and the secondary index, as both are assumed equal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">looking_for_match</td><td>are we looking for match? false means that we are looking for non-match </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>the heap to be used for all allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the clust_rec matches sec_rec </dd></dl>
<p>If we could not find a clust_rec version, it means it either never existed or was garbage collected, in either case we can interpret it as the row not being present at that point in time. Similarly, if it is delete marked. In all this cases, we report that there is no match. </p><pre class="fragment">If the index involves virtual columns, then we can relay on the assumption
</pre><p> that <code>trx_undo_prev_version_build</code> will try to retrieve clust_vrow, and the only reason it can not retrieve it is because there was no change to any of the indexed columns. In particular this should mean, that the answer to the question "does this clust_rec match sec_row?" did not change, and we can return the same value as before, which was !looking_for_match. We know it was not looking_for_match because in such case the loop would stop.</p>
<p>There are some difficulties we should take into consideration here:</p>
<ol type="1">
<li>It could be the case that there was no "previous iteration". Indeed, it can happen, that this is the first call. If we got to this line, it means that there are at least two versions of the clustered index row: the most recent, which we don't see, and the one passed here as <code>clust_rec</code>, which we know has all the important columns equal to the most recent one. Moreover, we know that <code>clust_rec</code> is not delete marked. We also know, that the most recent version is also not delete marked, because, if it was delete marked, then the most recent change would be a DELETE operation, and in such cases we always undo log the values of columns, yet <code>clust_vrow</code> is null. So, the most recent version, and the version just before it, not only have the same values of indexed columns, but also the same delete mark. If so, then it is impossible, that this particular change created, or removed a secondary index entry. Therefore we need to continue the loop, and to do so we have to return the opposite of what the loop is searching for, thus !looking_for_match.</li>
</ol>
<p>Here's a bit different argument, perhaps more persuasive in case we want to prove that the returned value correctly answers the question "does clust_rec
match the sec_rec?". Consider two cases, depending on sec_rec delete mark:</p>
<p>A) sec_rec is delete marked In this case, looking_for_match is set to true, thus we are about to return false. So, our claim is that clust_rec does not match sec_rec. For consider for a moment the opposite, that clust_rec does match sec_rec - it would follow, that also the most recent version matches sec_rec, as it has the same values of columns, and delete mark. But then, we have that two most recent versions of the clustered index record are not delete marked and match the secondary index record, yet for some reason the change was not synchronized to the secondary index, which is still delete marked! This contradicts the assumption that at most one most recent change is not synchronized to the secondary index.</p>
<p>B) sec_rec is not delete marked In this case, looking_for_match is set to false, thus we are about to return true. So, our claim is that clust_rec does match sec_rec. For consider for a moment the opposite, that clust_rec doesn't match sec_rec - it would follow, that also the most recent version doesn't match sec_rec, as it has the same values of columns, and delete mark. But then, we have that two most recent versions of the clustered index record do not match the secondary index record, yet for some reason the change was not synchronized to the secondary index, which is still not delete marked! This contradicts the assumption that at most one most recent change is not synchronized to the secondary index.</p>
<ol type="1">
<li>It could (hypothetically) be the case that in previous iteration the answer was different, because the two versions differ in delete mark</li>
</ol>
<p>Again, before getting here we've already established that <code>clust_rec</code> is not delete marked, and if <code>clust_vrow</code> is missing, then it must mean that the later version is also not delete marked, as otherwise we would have to log all columns to the undo log</p>
<p>Reconstruct all the columns </p><pre class="fragment">If the reconstructed values do not match the secondary index then we know
</pre><p> we should report no match. We compare the strings in binary mode to make it more robust, because a thread which has changed "a" to "A" should prevent concurrent transactions from peeking into the new binary representation, say via CONVERT(column_name, binary). </p>

</div>
</div>
<a id="a9d5bfebba11f8fe3c591cc3600125d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5bfebba11f8fe3c591cc3600125d54">&#9670;&nbsp;</a></span>row_vers_build_clust_v_col()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_vers_build_clust_v_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>build virtual column value from current cluster index record data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">row</td><td>the cluster index row in dtuple form </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>heap used to build virtual dtuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e58d20de8521a8c88d6191510abf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e58d20de8521a8c88d6191510abf35">&#9670;&nbsp;</a></span>row_vers_build_cur_vrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structdtuple__t.html">dtuple_t</a>* row_vers_build_cur_vrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>in_purge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>clust_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>ientry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>v_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a dtuple contains virtual column data for current cluster index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_purge</td><td>called by purge thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>cluster index rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>cluster index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_offsets</td><td>cluster rec offset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ientry</td><td>secondary index rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll_ptr</td><td>roll_ptr for the purge record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>transaction ID on the purging record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>heap memory </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v_heap</td><td>heap memory to keep virtual colum dtuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr holding the latch on rec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dtuple contains virtual column data </dd></dl>

</div>
</div>
<a id="a20948ab430de39a36e2248243df85e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20948ab430de39a36e2248243df85e3a">&#9670;&nbsp;</a></span>row_vers_build_cur_vrow_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_vers_build_cur_vrow_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>in_purge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>clust_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>v_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> **&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build latest virtual column data from undo log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_purge</td><td>whether this is the purge thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>clustered index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">clust_offsets</td><td>offsets on the clustered index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll_ptr</td><td>the rollback pointer for the purging record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>trx id for the purging record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v_heap</td><td>heap used to build vrow </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrow</td><td>dtuple holding the virtual rows </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>mtr holding the latch on rec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1334e2cba78bf467fd5f0808b8348c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1334e2cba78bf467fd5f0808b8348c2">&#9670;&nbsp;</a></span>row_vers_build_for_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_vers_build_for_consistent_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classReadView.html">ReadView</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offset_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>in_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>old_vers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> **&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *&#160;</td>
          <td class="paramname"><em>lob_undo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the version of a clustered index record which a consistent read should see. </p>
<p>We assume that the trx id stored in rec is such that the consistent read should not see rec in its present version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record in a clustered index; the caller must have a latch on the page; this latch locks the top of the stack of versions of this records </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr holding the latch on rec; it will also hold the latch on purge_view </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>offsets returned by rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">view</td><td>the consistent read view </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offset_heap</td><td>memory heap from which the offsets are allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_heap</td><td>memory heap from which the memory for *old_vers is allocated; memory for possible intermediate versions is allocated and freed locally within the function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_vers</td><td>old version, or NULL if the history is missing or the record does not exist in the view, that is, it was freshly inserted afterwards. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrow</td><td>reports virtual column info if any </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lob_undo</td><td>undo log to be applied to blobs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_MISSING_HISTORY </dd></dl>

</div>
</div>
<a id="a7c74453c995cfc90fb0eeca017f47144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c74453c995cfc90fb0eeca017f47144">&#9670;&nbsp;</a></span>row_vers_build_for_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_vers_build_for_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offset_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>in_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>old_vers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> **&#160;</td>
          <td class="paramname"><em>vrow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the last committed version of a clustered index record, which should be seen by a semi-consistent read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Record in a clustered index; the caller must have a latch on the page; this latch locks the top of the stack of versions of this records </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction holding the latch on rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The clustered index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>Offsets returned by rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offset_heap</td><td>Memory heap from which the offsets are allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_heap</td><td>Memory heap from which the memory for *old_vers is allocated; memory for possible intermediate versions is allocated and freed locally within the function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_vers</td><td>Rec, old version, or null if the record does not exist in the view, that is, it was freshly inserted afterwards </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrow</td><td>Virtual row, old version, or null if it is not updated in the view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8694df2a63fc87209212d3072be37e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8694df2a63fc87209212d3072be37e59">&#9670;&nbsp;</a></span>row_vers_find_matching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_vers_find_matching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>looking_for_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&amp;&#160;</td>
          <td class="paramname"><em>clust_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>sec_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const&#160;</td>
          <td class="paramname"><em>sec_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *const&#160;</td>
          <td class="paramname"><em>sec_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *const&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loops through the history of clustered index record in the undo log, stopping after the first version which was not created by the given active transaction, and reports if it found a version which satisfies criterion specified by looking_for_match. </p>
<p>If looking_for_match is true, it searches for a version which matches the secondary index record. Otherwise it searches for a version which does not match. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">looking_for_match</td><td>are we looking for match? false means that we are looking for non-match </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_rec</td><td>the clustered index record, can be null or delete marked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_offsets</td><td>the offsets for clust_rec, rec_get_offsets(clust_rec, clust_index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_index</td><td>the secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_rec</td><td>the secondary index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_offsets</td><td>the offsets for secondary index record, rec_get_offsets(sec_rec, sec_index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>the compression flag for both the clustered and the secondary index, as both are assumed equal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>the active transaction which created the most recent version of clustered index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>the mtr inside which we are operating </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>the heap to be used for all allocations. This heap might get deallocated, and a newly allocated one will be returned, along with its ownership </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff a version of the clust_rec which is in relation specified by looking_for_match to the given sec_rec is found among versions created by trx_id or the one version before them </dd></dl>

</div>
</div>
<a id="a873759f07eb21517ec8ab89593ce5b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873759f07eb21517ec8ab89593ce5b56">&#9670;&nbsp;</a></span>row_vers_impl_x_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrx__t.html">trx_t</a>* row_vers_impl_x_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds out if an active transaction has inserted or modified a secondary index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record in a secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if committed, else the active transaction id; NOTE that this function can return false positives but never false negatives. The caller must confirm all positive results by checking if the trx is still active. </dd></dl>

</div>
</div>
<a id="aa48b753e07dbffacc103caf59324364d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48b753e07dbffacc103caf59324364d">&#9670;&nbsp;</a></span>row_vers_impl_x_locked_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structtrx__t.html">trx_t</a>* row_vers_impl_x_locked_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const&#160;</td>
          <td class="paramname"><em>sec_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>sec_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *const&#160;</td>
          <td class="paramname"><em>sec_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *const&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds out if an active transaction has inserted or modified a secondary index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_rec</td><td>Clustered index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>The clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_rec</td><td>Secondary index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_index</td><td>The secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_offsets</td><td>Rec_get_offsets(sec_rec, sec_index) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if committed, else the active transaction id; NOTE that this function can return false positives but never false negatives. The caller must confirm all positive results by calling checking if the trx is still active. </dd></dl>
<p>Here's my best understanding of what this code is doing.</p>
<p>When we call this function we already have <code>sec_rec</code> - a row from secondary index <code>sec_index</code>, which includes:</p><ul>
<li>obviously the values of columns mentioned in secondary index definition, in particular materialized values of virtual columns</li>
<li>primary key columns not mentioned explicitly in secondary index definition,</li>
<li>information about row format (<code>comp</code>)</li>
<li>information if the row is delete marked or not (<code>rec_del</code>: 32 or 0)</li>
</ul>
<p>We assume that this <code>sec_rec</code> really is a record in the secondary index, as opposed to some artificially "made up" sequence of bytes. Moreover we assume that this secondary index row is currently latched (not to be confused with "locked"), so that <code>sec_rec</code> is the most current state of this row.</p>
<p>Also, we assume, that rows in secondary index are either added, or removed, (or delete marked, or delete un-marked) but never modified. Moreover, we assume, that each of these secondary index operations is done after the primary (clustered) index was modified, to reflect the new state of affairs.</p>
<p>We assume that <code>clust_rec</code> is the current version of the clustered index record to which the secondary record <code>sec_rec</code> points to.</p>
<p>To be more precise:</p>
<p>Let S[f] mean value of field f in the secondary index record S. Let C[t][f] mean value of field f in version t of clustered record C, where we use consecutive natural numbers to denote versions: t=0,1,...,current_version.</p>
<p>Note: secondary index is not versioned</p>
<p>Let S.deleted and C[t].deleted be delete markers of these records.</p>
<p>Definition 1. We say that secondary index row S <code>points-to</code> a clustered index row C if and only if: S[pkey] = C[t][pkey] for each primary key column pkey (for any version t)</p>
<p>Note: it does not matter which version t we pick, as for our purposes primary key fields may be thought as immutable (say, we emulate their modification by combination of delete + insert).</p>
<p>Definition 2. We say that secondary index row S <code>matches</code> a clustered index row C in version t if and only if: (S[f] = C[t][f] for each column f) and not (C[t].deleted)</p>
<p>Note: In the above definition f might be a virtual column. Note: There might be multiple versions which a single S <code>matches</code>, for example when a transaction modifies a row back and forth, or changes columns which are not indexed by secondary index. Note: The definition of <code>matches</code> does not depend on S.deleted</p>
<p>Definition 3. We say that secondary index row S <code>corresponds-to</code> a clustered index row C in version t if and only if: (not(S.deleted) and (S <code>matches</code> C[t])) or (S.deleted and not (S <code>matches</code> C[t]))</p>
<p>In other words, S <code>corresponds-to</code> C[t] means that the state of secondary index row S is synchronized with the state of the row in clustered index in version t.</p>
<p>Assumption 1. (S <code>corresponds-to</code> C[current_version]) or (S <code>corresponds-to</code> C[current_version-1]) In other words, <code>sec_rec</code> <code>corresponds-to</code> either the most current_version of the primary record it <code>points-to</code> (i.e. the changes in the clustered index were synchronized to the secondary index), or the current_version-1 - (i.e. the changes in the clustered index was not synchronized to the secondary index yet). This belief is supported by reading the source code and observation that to modify secondary index, one has to modify clustered index first, and modifying clustered index and later secondary index requires holding (implicit or explicit) lock on the clustered index record, so there is at most one transaction operating on any given clustered index row, and thus at most one change "unsynchronized" to secondary index yet.</p>
<p>An equivalent formulation of Assumption 1 in terms of <code>matches</code> is: (not(S.deleted) =&gt; ((S <code>matches</code> C[current_version]) or (S <code>matches</code> C[current_version-1])) ) and ( S.deleted =&gt; not((S <code>matches</code> C[current_version]) and (S <code>matches</code> C[current_version-1])) ) So, a non-deleted S implies that one of the two most recent versions <code>matches</code> it, and a deleted S, means that at least one of the two most recent versions does not <code>match</code> it.</p>
<p>Definition 4. We say that S <code>could-be-authored-by</code> a clustered index row C in version t if and only if: (S <code>corresponds-to</code> C[t]) and !(S <code>corresponds-to</code> C[t-1])</p>
<p>This can be equivalently expressed using <code>matches</code> relation as: (not(S.deleted) and (S <code>matches</code> C[t]) and not(S <code>matches</code> C[t-1])) or (S.deleted and not(S <code>matches</code> C[t]) and (S <code>matches</code> C[t-1]))</p>
<p>Definition 5. We say that secondary index row S <code>was-authored-by</code> a clustered index row C in version t if and only if: (S <code>could-be-authored-by</code> C[t]) and (for each v &gt; t. not(S <code>could-be-authored-by</code> C[v])) So, t is the latest version in which S <code>could-be-authored-by</code> C[t].</p>
<p>Equivalently, one can define <code>was-authored-by</code> in terms of <code>matches</code>, by identifying the most recent version t for which <code>matches</code> relation between S and C[t] has changed in the right direction, that is, in case S.deleted we search for the first change from (S <code>matches</code> C[t-1]) to not(S <code>matches</code> C[t]), while in case of not(S.deleted) we search for the first change from not(S <code>matches</code> C[t-1]) to (S <code>matches</code> C[t]).</p>
<p>We are now ready to explain precisely what the call to row_vers_impl_x_locked_low(C=<code>clust_rec</code>,...,S=<code>sec_rec</code>,...) tries to achieve.</p>
<h1>Post-condition of row_vers_impl_x_locked_low: </h1>
<p>If there is t, such that S <code>was-authored-by</code> C[t], and C[t].trx_id is active then the return value is C[t].trx_id. Otherwise the return value is 0.</p>
<h1>Explanation of the algorithm in row_vers_impl_x_locked_low: </h1>
<p>The implementation is tricky, as it tries hard to avoid ever looking at the C[current_version], instead looking only at older versions. (One reason for this effort, IMHO, is that virtual columns might be expensive to materialize, and are not stored in clustered index at all. Another reason, I guess, might be to have only one way of reading data - from undo log). Take a moment to realize that this is wonderful that it's even possible, as this is not apparent from the Def 5! After all it might well be the case that the <code>t</code> we are looking for is equal to <code>current_version</code> in which case the definition of <code>was-authored-by</code> used naively would require us to check if S <code>matches</code> C[current_version], which in turn done naively forces us to look at fields of C[current_version]!</p>
<p>So, how can we do that without ever looking at C[current_version] fields?</p>
<p>We start by reading C[current_version].trx_id, and this is the only piece of information we read from current_version. We store that in <code>trx_id</code> variable.</p>
<p>We check if <code>trx_id</code> is active.</p>
<p>If <code>trx_id</code> is not active, then we know that we can return 0. Why? Because it is impossible for any other C[t].trx_id to be still active, if the most recent trx to modify the record is already inactive.</p>
<p>From now on we assume that <code>trx_id</code> is active.</p>
<p>We observe that the definition of S <code>was-authored-by</code> C[t] requires not(S <code>corresponds-to</code> C[t-1]). So, one thing we can use to filter interesting versions, is to proceed through most recent versions t=current_version, current_version-1, ... until we find the first t, such that not(S <code>corresponds-to</code> C[t-1]). Surprisingly this is the only condition we have to check! Why? Observe, that it must also be the case that (S <code>corresponds-to</code> C[t]), because we either have tested that explicitly in the previous step of the loop or in case of first iteration, it follows from Assumption 1. This means, that (S <code>could-be-authored-by</code> C[t]), and since the t is maximal, we have (S <code>was-authored-by</code> C[t]).</p>
<p>Therefore our algorithm is to simply loop over versions t, as long as C[t].trx_id = trx_id, and stop as soon as not(S <code>corresponds-to</code> C[t-1]) in which case the answer is yes, or if we can't find such a version, the answer is no.</p>
<p>The reality is however much more complicated, as it needs to deal with: A) incomplete history of versions (we remove old undo log entries from tail) B) missing information about virtual columns (we don't log values of virtual columns to undo log if they had not changed)</p>
<p>I'll explain our approach to these two problems in comments at the place they are handled. </p>

</div>
</div>
<a id="a35483f4b5cff91482e61316f170e068e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35483f4b5cff91482e61316f170e068e">&#9670;&nbsp;</a></span>row_vers_must_preserve_del_marked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_vers_must_preserve_del_marked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtable__name__t.html">table_name_t</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds out if we must preserve a delete marked earlier version of a clustered index record, because it is &gt;= the purge view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Transaction id in the version </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Table name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction holding the latch on the clustered index record; it will also hold the latch on purge_view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if earlier version should be preserved </dd></dl>

</div>
</div>
<a id="acab984e820913e48182b74da5dfd2c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab984e820913e48182b74da5dfd2c9e">&#9670;&nbsp;</a></span>row_vers_non_vc_index_entry_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_vers_non_vc_index_entry_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>ientry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>ientry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_non_v_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether all non-virtual columns in a index entries match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ientry1</td><td>first index entry to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ientry2</td><td>second index entry to compare </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_non_v_col</td><td>number of non-virtual columns in the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all matches, false otherwise </dd></dl>

</div>
</div>
<a id="a57036a4dfd7783df64cfb508aacee69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57036a4dfd7783df64cfb508aacee69a">&#9670;&nbsp;</a></span>row_vers_old_has_index_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_vers_old_has_index_entry </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>also_curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>ientry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds out if a version of the record, where the version &gt;= the current purge view, should have ientry as its secondary index entry. </p>
<p>We check if there is any not delete marked version of the record where the trx id &gt;= purge view, and the secondary index entry and ientry are identified in the alphabetical ordering; exactly in this case we return TRUE. </p><dl class="section return"><dt>Returns</dt><dd>true if earlier version should have </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">also_curr</td><td>in: TRUE if also rec is included in the versions to search; otherwise only versions prior to it are searched </td></tr>
    <tr><td class="paramname">rec</td><td>in: record in the clustered index; the caller must have a latch on the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr holding the latch on rec; it will also hold the latch on purge_view </td></tr>
    <tr><td class="paramname">index</td><td>in: the secondary index </td></tr>
    <tr><td class="paramname">ientry</td><td>in: the secondary index entry </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll_ptr for the purge record </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction ID on the purging record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8560bb1054506a4c586bf7d66ae27c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8560bb1054506a4c586bf7d66ae27c67">&#9670;&nbsp;</a></span>row_vers_vc_matches_cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_vers_vc_matches_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>in_purge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>icentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>clust_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>ientry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>v_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> **&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a virtual column value index secondary virtual index matches that of current cluster index record, which is recreated from information stored in undo log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_purge</td><td>called by purge thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record in the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">icentry</td><td>the index entry built from a cluster row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>cluster index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_offsets</td><td>offsets on the cluster record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ientry</td><td>the secondary index entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll_ptr</td><td>the rollback pointer for the purging record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>trx id for the purging record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v_heap</td><td>heap used to build virtual dtuple </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrow</td><td>dtuple holding the virtual rows (if needed) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr holding the latch on rec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if matches, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_4dd6d22ab21a818a66544a670705c483.html">row</a></li><li class="navelem"><a class="el" href="row0vers_8cc.html">row0vers.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
