<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: MDL_lock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classMDL__lock.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMDL__lock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MDL_lock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The lock context.  
 <a href="classMDL__lock.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct which defines how different types of locks are handled for a specific MDL_lock.  <a href="structMDL__lock_1_1MDL__lock__strategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af49d3a2db62c2c6dda844e0d4531ab12"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a></td></tr>
<tr class="separator:af49d3a2db62c2c6dda844e0d4531ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cdf73e78c2f3288e20676e9ec19ea5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classI__P__List.html#ae93e3648df7beb86049f429074a451cf">Ticket_list::List::Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a32cdf73e78c2f3288e20676e9ec19ea5">Ticket_iterator</a></td></tr>
<tr class="separator:a32cdf73e78c2f3288e20676e9ec19ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc52a5a78b9a3b911e91c2fcb932981a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="my__inttypes_8h.html#a9c0acdcb1b083d30069a62cee1ece644">longlong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a></td></tr>
<tr class="separator:afc52a5a78b9a3b911e91c2fcb932981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc63c21b6c75b3087cd273bc5125e9d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#acc63c21b6c75b3087cd273bc5125e9d0">incompatible_granted_types_bitmap</a> () const</td></tr>
<tr class="separator:acc63c21b6c75b3087cd273bc5125e9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90ab350d28e755dcfa69d90004de7aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa90ab350d28e755dcfa69d90004de7aa">incompatible_waiting_types_bitmap</a> () const</td></tr>
<tr class="separator:aa90ab350d28e755dcfa69d90004de7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbc9d77579dd73637b2cc95b7fc249f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#afbbc9d77579dd73637b2cc95b7fc249f">get_incompatible_waiting_types_bitmap_idx</a> () const</td></tr>
<tr class="memdesc:afbbc9d77579dd73637b2cc95b7fc249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of priority matrice in MDL_lock_strategy::m_waiting_incompatible array which corresponds to current values of the m_piglet_lock_count and m_hog_lock_count counters and the max_write_lock_count threshold.  <a href="#afbbc9d77579dd73637b2cc95b7fc249f">More...</a><br /></td></tr>
<tr class="separator:afbbc9d77579dd73637b2cc95b7fc249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2be5e68445003d7a516849f2bceb18c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ab2be5e68445003d7a516849f2bceb18c">switch_incompatible_waiting_types_bitmap_if_needed</a> ()</td></tr>
<tr class="memdesc:ab2be5e68445003d7a516849f2bceb18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch priority matrice for the MDL_lock object if m_piglet_lock_count or/ and m_hog_lock_count counters have crossed max_write_lock_count threshold.  <a href="#ab2be5e68445003d7a516849f2bceb18c">More...</a><br /></td></tr>
<tr class="separator:ab2be5e68445003d7a516849f2bceb18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7707e02d9695b5694336787a622b0060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7707e02d9695b5694336787a622b0060">has_pending_conflicting_lock</a> (<a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a> type)</td></tr>
<tr class="memdesc:a7707e02d9695b5694336787a622b0060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have any pending locks which conflict with existing shared lock.  <a href="#a7707e02d9695b5694336787a622b0060">More...</a><br /></td></tr>
<tr class="separator:a7707e02d9695b5694336787a622b0060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8e8e3b98525a6c8de14a745dd3ce8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a8d8e8e3b98525a6c8de14a745dd3ce8f">can_grant_lock</a> (<a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a> type, const <a class="el" href="classMDL__context.html">MDL_context</a> *requestor_ctx) const</td></tr>
<tr class="memdesc:a8d8e8e3b98525a6c8de14a745dd3ce8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if request for the metadata lock can be satisfied given its current state.  <a href="#a8d8e8e3b98525a6c8de14a745dd3ce8f">More...</a><br /></td></tr>
<tr class="separator:a8d8e8e3b98525a6c8de14a745dd3ce8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07003cc6619a99b6cc36f564c62e4e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a07003cc6619a99b6cc36f564c62e4e94">reschedule_waiters</a> ()</td></tr>
<tr class="memdesc:a07003cc6619a99b6cc36f564c62e4e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine waiting contexts which requests for the lock can be satisfied, grant lock to them and wake them up.  <a href="#a07003cc6619a99b6cc36f564c62e4e94">More...</a><br /></td></tr>
<tr class="separator:a07003cc6619a99b6cc36f564c62e4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7100ea62bb9af3e959d8a81ba11d4bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7100ea62bb9af3e959d8a81ba11d4bcb">remove_ticket</a> (<a class="el" href="classMDL__context.html">MDL_context</a> *ctx, <a class="el" href="structLF__PINS.html">LF_PINS</a> *pins, <a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::*<a class="el" href="myisampack_8cc.html#aeea358856f1967fb51e985be8ded2b7a">queue</a>, <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="memdesc:a7100ea62bb9af3e959d8a81ba11d4bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a ticket from waiting or pending queue and wakeup up waiters.  <a href="#a7100ea62bb9af3e959d8a81ba11d4bcb">More...</a><br /></td></tr>
<tr class="separator:a7100ea62bb9af3e959d8a81ba11d4bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e5025d3f3cff97923bc283c715566d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a56e5025d3f3cff97923bc283c715566d">visit_subgraph</a> (<a class="el" href="classMDL__ticket.html">MDL_ticket</a> *waiting_ticket, <a class="el" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *gvisitor)</td></tr>
<tr class="memdesc:a56e5025d3f3cff97923bc283c715566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of recursive traversal of the wait-for graph in search for deadlocks.  <a href="#a56e5025d3f3cff97923bc283c715566d">More...</a><br /></td></tr>
<tr class="separator:a56e5025d3f3cff97923bc283c715566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eddfbd81b16d050a7a7d5a31e4242c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a1eddfbd81b16d050a7a7d5a31e4242c6">needs_notification</a> (const <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket) const</td></tr>
<tr class="separator:a1eddfbd81b16d050a7a7d5a31e4242c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b6aaea388daf444e3f2c0d31362b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a20b6aaea388daf444e3f2c0d31362b15">notify_conflicting_locks</a> (<a class="el" href="classMDL__context.html">MDL_context</a> *ctx)</td></tr>
<tr class="separator:a20b6aaea388daf444e3f2c0d31362b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb8fcb19fe7323eb0044ebb78258c75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a5bb8fcb19fe7323eb0044ebb78258c75">needs_connection_check</a> () const</td></tr>
<tr class="separator:a5bb8fcb19fe7323eb0044ebb78258c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af5a6e02d50241f9c6417a01572c4ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7af5a6e02d50241f9c6417a01572c4ee">is_affected_by_max_write_lock_count</a> () const</td></tr>
<tr class="separator:a7af5a6e02d50241f9c6417a01572c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f1b569ef4a8405826d9bc9720205c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a39f1b569ef4a8405826d9bc9720205c0">count_piglets_and_hogs</a> (<a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a> type)</td></tr>
<tr class="memdesc:a39f1b569ef4a8405826d9bc9720205c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we just have granted a lock of "piglet" or "hog" type and there are pending lower priority locks, increase the appropriate counter.  <a href="#a39f1b569ef4a8405826d9bc9720205c0">More...</a><br /></td></tr>
<tr class="separator:a39f1b569ef4a8405826d9bc9720205c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2a62914d438aa6e97a50fc8050c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa5f2a62914d438aa6e97a50fc8050c74">get_unobtrusive_lock_increment</a> (<a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a> type) const</td></tr>
<tr class="separator:aa5f2a62914d438aa6e97a50fc8050c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0438fd341e3bedb63452c44ec95a00ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a0438fd341e3bedb63452c44ec95a00ff">is_obtrusive_lock</a> (<a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a> type) const</td></tr>
<tr class="memdesc:a0438fd341e3bedb63452c44ec95a00ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type of lock requested is "obtrusive" type of lock.  <a href="#a0438fd341e3bedb63452c44ec95a00ff">More...</a><br /></td></tr>
<tr class="separator:a0438fd341e3bedb63452c44ec95a00ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d77e8b91c3f09ac46adb6dccf7a460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a44d77e8b91c3f09ac46adb6dccf7a460">fast_path_granted_bitmap</a> () const</td></tr>
<tr class="memdesc:a44d77e8b91c3f09ac46adb6dccf7a460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return set of types of lock requests which were granted using "fast path" algorithm in the bitmap_t form.  <a href="#a44d77e8b91c3f09ac46adb6dccf7a460">More...</a><br /></td></tr>
<tr class="separator:a44d77e8b91c3f09ac46adb6dccf7a460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9c4ffed74256bb57fca7619d141bf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aeb9c4ffed74256bb57fca7619d141bf4">MDL_lock</a> ()</td></tr>
<tr class="memdesc:aeb9c4ffed74256bb57fca7619d141bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do "expensive" part of MDL_lock object initialization, Called by LF_ALLOCATOR for each newly malloc()'ed MDL_lock object, is not called in cases when LF_ALLOCATOR decides to reuse object which was returned to it earlier.  <a href="#aeb9c4ffed74256bb57fca7619d141bf4">More...</a><br /></td></tr>
<tr class="separator:aeb9c4ffed74256bb57fca7619d141bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f6326006b7c7ba179075c82707d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aaa2f6326006b7c7ba179075c82707d59">reinit</a> (const <a class="el" href="structMDL__key.html">MDL_key</a> *mdl_key)</td></tr>
<tr class="memdesc:aaa2f6326006b7c7ba179075c82707d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize initialization or re-initialize MDL_lock returned from LF_ALLOCATOR's cache to represent object identified by provided key.  <a href="#aaa2f6326006b7c7ba179075c82707d59">More...</a><br /></td></tr>
<tr class="separator:aaa2f6326006b7c7ba179075c82707d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae131729deb3f268f6d0a4f1e16b26c62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ae131729deb3f268f6d0a4f1e16b26c62">~MDL_lock</a> ()</td></tr>
<tr class="separator:ae131729deb3f268f6d0a4f1e16b26c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada93a4c2a1f01792f9c3e352dbf900fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ada93a4c2a1f01792f9c3e352dbf900fc">get_lock_owner</a> () const</td></tr>
<tr class="memdesc:ada93a4c2a1f01792f9c3e352dbf900fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first MDL_context which owns the lock.  <a href="#ada93a4c2a1f01792f9c3e352dbf900fc">More...</a><br /></td></tr>
<tr class="separator:ada93a4c2a1f01792f9c3e352dbf900fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716b40d532b18db6c2527d1a46908c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a716b40d532b18db6c2527d1a46908c29">fast_path_state_cas</a> (<a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> *old_state, <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> new_state)</td></tr>
<tr class="memdesc:a716b40d532b18db6c2527d1a46908c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for atomic compare-and-swap operation on m_fast_path_state member which enforces locking and other invariants.  <a href="#a716b40d532b18db6c2527d1a46908c29">More...</a><br /></td></tr>
<tr class="separator:a716b40d532b18db6c2527d1a46908c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc838e4678e75b56554e1ca142439dce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#afc838e4678e75b56554e1ca142439dce">fast_path_state_add</a> (<a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:afc838e4678e75b56554e1ca142439dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for atomic add operation on m_fast_path_state member which enforces locking and other invariants.  <a href="#afc838e4678e75b56554e1ca142439dce">More...</a><br /></td></tr>
<tr class="separator:afc838e4678e75b56554e1ca142439dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedaf89f7d4526d4d59c170fed9ffe2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aeedaf89f7d4526d4d59c170fed9ffe2a">fast_path_state_reset</a> ()</td></tr>
<tr class="memdesc:aeedaf89f7d4526d4d59c170fed9ffe2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for resetting m_fast_path_state enforcing locking invariants.  <a href="#aeedaf89f7d4526d4d59c170fed9ffe2a">More...</a><br /></td></tr>
<tr class="separator:aeedaf89f7d4526d4d59c170fed9ffe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa6cbff270ec3afad0feba7e97e9747bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa6cbff270ec3afad0feba7e97e9747bb">needs_hton_notification</a> (<a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a> mdl_namespace)</td></tr>
<tr class="memdesc:aa6cbff270ec3afad0feba7e97e9747bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether object belongs to namespace which requires storage engine to be notified before acquiring and after releasing exclusive lock.  <a href="#aa6cbff270ec3afad0feba7e97e9747bb">More...</a><br /></td></tr>
<tr class="separator:aa6cbff270ec3afad0feba7e97e9747bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8424d2f478663117e7ac5e435840342"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa8424d2f478663117e7ac5e435840342">get_unobtrusive_lock_increment</a> (const <a class="el" href="classMDL__request.html">MDL_request</a> *request)</td></tr>
<tr class="separator:aa8424d2f478663117e7ac5e435840342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8389ffdedfe45d4fdc22624a3ad84a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMDL__lock.html">MDL_lock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a3d8389ffdedfe45d4fdc22624a3ad84a">create</a> (const <a class="el" href="structMDL__key.html">MDL_key</a> *<a class="el" href="classMDL__lock.html#aefb48179bc3f6ef64c213b253c379da4">key</a>)</td></tr>
<tr class="memdesc:a3d8389ffdedfe45d4fdc22624a3ad84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary functions needed for creation/destruction of MDL_lock objects.  <a href="#a3d8389ffdedfe45d4fdc22624a3ad84a">More...</a><br /></td></tr>
<tr class="separator:a3d8389ffdedfe45d4fdc22624a3ad84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25c48d98250c1603a5c55eeace3986"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a0b25c48d98250c1603a5c55eeace3986">destroy</a> (<a class="el" href="classMDL__lock.html">MDL_lock</a> *lock)</td></tr>
<tr class="separator:a0b25c48d98250c1603a5c55eeace3986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb12eb628c61dff9c9c3bbb4ce6faef4"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#adb12eb628c61dff9c9c3bbb4ce6faef4">get_strategy</a> (const <a class="el" href="structMDL__key.html">MDL_key</a> &amp;<a class="el" href="classMDL__lock.html#aefb48179bc3f6ef64c213b253c379da4">key</a>)</td></tr>
<tr class="memdesc:adb12eb628c61dff9c9c3bbb4ce6faef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MDL lock strategy corresponding to MDL key.  <a href="#adb12eb628c61dff9c9c3bbb4ce6faef4">More...</a><br /></td></tr>
<tr class="separator:adb12eb628c61dff9c9c3bbb4ce6faef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5ce95948e006dbe957792a4be80928"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a8d5ce95948e006dbe957792a4be80928">scoped_lock_fast_path_granted_bitmap</a> (const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;lock)</td></tr>
<tr class="memdesc:a8d5ce95948e006dbe957792a4be80928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bitmap of "unobtrusive" locks granted using "fast path" algorithm for scoped locks.  <a href="#a8d5ce95948e006dbe957792a4be80928">More...</a><br /></td></tr>
<tr class="separator:a8d5ce95948e006dbe957792a4be80928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382145d0f9b0f94a05ef03edbe922054"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a382145d0f9b0f94a05ef03edbe922054">object_lock_needs_notification</a> (const <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="memdesc:a382145d0f9b0f94a05ef03edbe922054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we are requesting X lock on the object, so threads holding conflicting S/SH metadata locks on it need to be notified.  <a href="#a382145d0f9b0f94a05ef03edbe922054">More...</a><br /></td></tr>
<tr class="separator:a382145d0f9b0f94a05ef03edbe922054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30406c0d7d46396e15c4ca66abc6fc7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa30406c0d7d46396e15c4ca66abc6fc7">object_lock_notify_conflicting_locks</a> (<a class="el" href="classMDL__context.html">MDL_context</a> *ctx, <a class="el" href="classMDL__lock.html">MDL_lock</a> *lock)</td></tr>
<tr class="memdesc:aa30406c0d7d46396e15c4ca66abc6fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify threads holding S/SH metadata locks on an object, which conflict with a pending X lock.  <a href="#aa30406c0d7d46396e15c4ca66abc6fc7">More...</a><br /></td></tr>
<tr class="separator:aa30406c0d7d46396e15c4ca66abc6fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580d9a0d9be93f90361cee67d0b4199f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a580d9a0d9be93f90361cee67d0b4199f">object_lock_fast_path_granted_bitmap</a> (const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;lock)</td></tr>
<tr class="memdesc:a580d9a0d9be93f90361cee67d0b4199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bitmap of "unobtrusive" locks granted using "fast path" algorithm for per-object locks.  <a href="#a580d9a0d9be93f90361cee67d0b4199f">More...</a><br /></td></tr>
<tr class="separator:a580d9a0d9be93f90361cee67d0b4199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab1e1914e48faa93ba2e862cddfc274"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a1ab1e1914e48faa93ba2e862cddfc274">object_lock_needs_connection_check</a> (const <a class="el" href="classMDL__lock.html">MDL_lock</a> *lock)</td></tr>
<tr class="memdesc:a1ab1e1914e48faa93ba2e862cddfc274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if MDL_lock object represents user-level lock,locking service lock or acl cache lock, so threads waiting for it need to check if connection is lost and abort waiting when it is.  <a href="#a1ab1e1914e48faa93ba2e862cddfc274">More...</a><br /></td></tr>
<tr class="separator:a1ab1e1914e48faa93ba2e862cddfc274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aefb48179bc3f6ef64c213b253c379da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMDL__key.html">MDL_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aefb48179bc3f6ef64c213b253c379da4">key</a></td></tr>
<tr class="memdesc:aefb48179bc3f6ef64c213b253c379da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key of the object (data) being protected.  <a href="#aefb48179bc3f6ef64c213b253c379da4">More...</a><br /></td></tr>
<tr class="separator:aefb48179bc3f6ef64c213b253c379da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1308b4506d8cb6d754b4f173e3aa4962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__prlock__t.html">mysql_prlock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">m_rwlock</a></td></tr>
<tr class="memdesc:a1308b4506d8cb6d754b4f173e3aa4962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write lock protecting this lock context.  <a href="#a1308b4506d8cb6d754b4f173e3aa4962">More...</a><br /></td></tr>
<tr class="separator:a1308b4506d8cb6d754b4f173e3aa4962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188dd53561f6cf6148277512b706ea74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a188dd53561f6cf6148277512b706ea74">m_granted</a></td></tr>
<tr class="memdesc:a188dd53561f6cf6148277512b706ea74"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of granted tickets for this lock.  <a href="#a188dd53561f6cf6148277512b706ea74">More...</a><br /></td></tr>
<tr class="separator:a188dd53561f6cf6148277512b706ea74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4443cad6b484e2af5c816949ddb209dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a4443cad6b484e2af5c816949ddb209dc">m_waiting</a></td></tr>
<tr class="memdesc:a4443cad6b484e2af5c816949ddb209dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tickets for contexts waiting to acquire a lock.  <a href="#a4443cad6b484e2af5c816949ddb209dc">More...</a><br /></td></tr>
<tr class="separator:a4443cad6b484e2af5c816949ddb209dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef26eb4cf46309c494135291a82e20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7ef26eb4cf46309c494135291a82e20c">m_obtrusive_locks_granted_waiting_count</a></td></tr>
<tr class="memdesc:a7ef26eb4cf46309c494135291a82e20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of granted or waiting lock requests of "obtrusive" type.  <a href="#a7ef26eb4cf46309c494135291a82e20c">More...</a><br /></td></tr>
<tr class="separator:a7ef26eb4cf46309c494135291a82e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02937012711c410ef3a00f941e7f26b"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ae02937012711c410ef3a00f941e7f26b">m_fast_path_state</a></td></tr>
<tr class="memdesc:ae02937012711c410ef3a00f941e7f26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination of IS_DESTROYED/HAS_OBTRUSIVE/HAS_SLOW_PATH flags and packed counters of specific types of "unobtrusive" locks which were granted using "fast path".  <a href="#ae02937012711c410ef3a00f941e7f26b">More...</a><br /></td></tr>
<tr class="separator:ae02937012711c410ef3a00f941e7f26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a214605da83d57ac8d69c1f1c4854d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a67a214605da83d57ac8d69c1f1c4854d">m_strategy</a></td></tr>
<tr class="memdesc:a67a214605da83d57ac8d69c1f1c4854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to strategy object which defines how different types of lock requests should be handled for the namespace to which this lock belongs.  <a href="#a67a214605da83d57ac8d69c1f1c4854d">More...</a><br /></td></tr>
<tr class="separator:a67a214605da83d57ac8d69c1f1c4854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1627af1fd21d2ae76c27b39901e574a3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a1627af1fd21d2ae76c27b39901e574a3">IS_DESTROYED</a> = 1ULL &lt;&lt; 62</td></tr>
<tr class="memdesc:a1627af1fd21d2ae76c27b39901e574a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag in MDL_lock::m_fast_path_state that indicates that the MDL_lock object was marked for destruction and will be destroyed once all threads referencing to it through hazard pointers have unpinned it.  <a href="#a1627af1fd21d2ae76c27b39901e574a3">More...</a><br /></td></tr>
<tr class="separator:a1627af1fd21d2ae76c27b39901e574a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e55394e253bd9d0988c9a7ab243a39"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ac0e55394e253bd9d0988c9a7ab243a39">HAS_OBTRUSIVE</a> = 1ULL &lt;&lt; 61</td></tr>
<tr class="memdesc:ac0e55394e253bd9d0988c9a7ab243a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag in MDL_lock::m_fast_path_state that indicates that there are "obtrusive" locks which are granted, waiting or for which we are about to check if they can be granted.  <a href="#ac0e55394e253bd9d0988c9a7ab243a39">More...</a><br /></td></tr>
<tr class="separator:ac0e55394e253bd9d0988c9a7ab243a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace80291dc2f7786288cdf1cec54bcb55"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ace80291dc2f7786288cdf1cec54bcb55">HAS_SLOW_PATH</a> = 1ULL &lt;&lt; 60</td></tr>
<tr class="memdesc:ace80291dc2f7786288cdf1cec54bcb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag in MDL_lock::m_fast_path_state that indicates that there are "slow" path locks which are granted, waiting or for which we are about to check if they can be granted.  <a href="#ace80291dc2f7786288cdf1cec54bcb55">More...</a><br /></td></tr>
<tr class="separator:ace80291dc2f7786288cdf1cec54bcb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb101565637f92f74d4a84bdc53fa5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#abaeb101565637f92f74d4a84bdc53fa5">MDL_OBJECT_HOG_LOCK_TYPES</a></td></tr>
<tr class="memdesc:abaeb101565637f92f74d4a84bdc53fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmap with "hog" lock types for object locks.  <a href="#abaeb101565637f92f74d4a84bdc53fa5">More...</a><br /></td></tr>
<tr class="separator:abaeb101565637f92f74d4a84bdc53fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7a092b4b9aa426597f599feb6bb19b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aed7a092b4b9aa426597f599feb6bb19b">m_scoped_lock_strategy</a></td></tr>
<tr class="memdesc:aed7a092b4b9aa426597f599feb6bb19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy instances to be used with scoped metadata locks (i.e.  <a href="#aed7a092b4b9aa426597f599feb6bb19b">More...</a><br /></td></tr>
<tr class="separator:aed7a092b4b9aa426597f599feb6bb19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed94b58baea6bf2e22b76566aa513b3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a6ed94b58baea6bf2e22b76566aa513b3">m_object_lock_strategy</a></td></tr>
<tr class="memdesc:a6ed94b58baea6bf2e22b76566aa513b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy instance for per-object locks.  <a href="#a6ed94b58baea6bf2e22b76566aa513b3">More...</a><br /></td></tr>
<tr class="separator:a6ed94b58baea6bf2e22b76566aa513b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab173b2eb68fdd6de02d9e4e8a0c94405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ab173b2eb68fdd6de02d9e4e8a0c94405">m_hog_lock_count</a></td></tr>
<tr class="memdesc:ab173b2eb68fdd6de02d9e4e8a0c94405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times high priority, "hog" lock requests (X, SNRW, SNW) have been granted while lower priority lock requests (all other types) were waiting.  <a href="#ab173b2eb68fdd6de02d9e4e8a0c94405">More...</a><br /></td></tr>
<tr class="separator:ab173b2eb68fdd6de02d9e4e8a0c94405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f177eeae90b5de66b37eab32fd563a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#af4f177eeae90b5de66b37eab32fd563a">m_piglet_lock_count</a></td></tr>
<tr class="memdesc:af4f177eeae90b5de66b37eab32fd563a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times high priority, "piglet" lock requests (SW) have been granted while locks requests with lower priority (SRO) were waiting.  <a href="#af4f177eeae90b5de66b37eab32fd563a">More...</a><br /></td></tr>
<tr class="separator:af4f177eeae90b5de66b37eab32fd563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7494018498e1e1d1ed3dfcf1f367b2ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7494018498e1e1d1ed3dfcf1f367b2ed">m_current_waiting_incompatible_idx</a></td></tr>
<tr class="memdesc:a7494018498e1e1d1ed3dfcf1f367b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of one of the MDL_lock_strategy::m_waiting_incompatible arrays which represents the current priority matrice.  <a href="#a7494018498e1e1d1ed3dfcf1f367b2ed">More...</a><br /></td></tr>
<tr class="separator:a7494018498e1e1d1ed3dfcf1f367b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The lock context. </p>
<p>Created internally for an acquired lock. For a given name, there exists only one MDL_lock instance, and it exists only when the lock has been granted. Can be seen as an MDL subsystem's version of TABLE_SHARE.</p>
<p>This is an abstract class which lacks information about compatibility rules for lock types. They should be specified in its descendants. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af49d3a2db62c2c6dda844e0d4531ab12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49d3a2db62c2c6dda844e0d4531ab12">&#9670;&nbsp;</a></span>bitmap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">MDL_lock::bitmap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc52a5a78b9a3b911e91c2fcb932981a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc52a5a78b9a3b911e91c2fcb932981a">&#9670;&nbsp;</a></span>fast_path_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="my__inttypes_8h.html#a9c0acdcb1b083d30069a62cee1ece644">longlong</a> <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">MDL_lock::fast_path_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32cdf73e78c2f3288e20676e9ec19ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cdf73e78c2f3288e20676e9ec19ea5">&#9670;&nbsp;</a></span>Ticket_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classI__P__List.html#ae93e3648df7beb86049f429074a451cf">Ticket_list::List::Iterator</a> <a class="el" href="classMDL__lock.html#a32cdf73e78c2f3288e20676e9ec19ea5">MDL_lock::Ticket_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeb9c4ffed74256bb57fca7619d141bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9c4ffed74256bb57fca7619d141bf4">&#9670;&nbsp;</a></span>MDL_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MDL_lock::MDL_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do "expensive" part of MDL_lock object initialization, Called by LF_ALLOCATOR for each newly malloc()'ed MDL_lock object, is not called in cases when LF_ALLOCATOR decides to reuse object which was returned to it earlier. </p>
<p>"Full" initialization happens later by calling MDL_lock::reinit(). So </p><dl class="section see"><dt>See also</dt><dd>MDL_lock::reiniti() </dd></dl>

</div>
</div>
<a id="ae131729deb3f268f6d0a4f1e16b26c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae131729deb3f268f6d0a4f1e16b26c62">&#9670;&nbsp;</a></span>~MDL_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MDL_lock::~MDL_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d8e8e3b98525a6c8de14a745dd3ce8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8e8e3b98525a6c8de14a745dd3ce8f">&#9670;&nbsp;</a></span>can_grant_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::can_grant_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a>&#160;</td>
          <td class="paramname"><em>type_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>requestor_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if request for the metadata lock can be satisfied given its current state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_arg</td><td>The requested lock type. </td></tr>
    <tr><td class="paramname">requestor_ctx</td><td>The MDL context of the requestor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Lock request can be satisfied </td></tr>
    <tr><td class="paramname">false</td><td>There is some conflicting lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In cases then current context already has "stronger" type of lock on the object it will be automatically granted thanks to usage of the MDL_context::find_ticket() method. </dd></dl>

</div>
</div>
<a id="a39f1b569ef4a8405826d9bc9720205c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f1b569ef4a8405826d9bc9720205c0">&#9670;&nbsp;</a></span>count_piglets_and_hogs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::count_piglets_and_hogs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we just have granted a lock of "piglet" or "hog" type and there are pending lower priority locks, increase the appropriate counter. </p>
<p>If this counter now exceeds the max_write_lock_count threshold, switch priority matrice for the MDL_lock object.</p>
<dl class="section return"><dt>Returns</dt><dd>true - if priority matrice has been changed, false - otherwise. </dd></dl>

</div>
</div>
<a id="a3d8389ffdedfe45d4fdc22624a3ad84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8389ffdedfe45d4fdc22624a3ad84a">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock.html">MDL_lock</a> * MDL_lock::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMDL__key.html">MDL_key</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary functions needed for creation/destruction of MDL_lock objects. </p>

</div>
</div>
<a id="a0b25c48d98250c1603a5c55eeace3986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b25c48d98250c1603a5c55eeace3986">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__lock.html">MDL_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44d77e8b91c3f09ac46adb6dccf7a460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d77e8b91c3f09ac46adb6dccf7a460">&#9670;&nbsp;</a></span>fast_path_granted_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a> MDL_lock::fast_path_granted_bitmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return set of types of lock requests which were granted using "fast path" algorithm in the bitmap_t form. </p>
<p>This method is only called from MDL_lock::can_grant_lock() and its return value is only important when we are trying to figure out if we can grant an obtrusive lock. But this means that the HAS_OBTRUSIVE flag is set so all changes to m_fast_path_state happen under protection of MDL_lock::m_rwlock (see invariant [INV1]). Since can_grant_lock() is called only when MDL_lock::m_rwlock is held, it is safe to do an ordinary read of m_fast_path_state here. </p>

</div>
</div>
<a id="afc838e4678e75b56554e1ca142439dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc838e4678e75b56554e1ca142439dce">&#9670;&nbsp;</a></span>fast_path_state_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> MDL_lock::fast_path_state_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for atomic add operation on m_fast_path_state member which enforces locking and other invariants. </p>

</div>
</div>
<a id="a716b40d532b18db6c2527d1a46908c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716b40d532b18db6c2527d1a46908c29">&#9670;&nbsp;</a></span>fast_path_state_cas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::fast_path_state_cas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> *&#160;</td>
          <td class="paramname"><em>old_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for atomic compare-and-swap operation on m_fast_path_state member which enforces locking and other invariants. </p>

</div>
</div>
<a id="aeedaf89f7d4526d4d59c170fed9ffe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedaf89f7d4526d4d59c170fed9ffe2a">&#9670;&nbsp;</a></span>fast_path_state_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::fast_path_state_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for resetting m_fast_path_state enforcing locking invariants. </p>

</div>
</div>
<a id="afbbc9d77579dd73637b2cc95b7fc249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbc9d77579dd73637b2cc95b7fc249f">&#9670;&nbsp;</a></span>get_incompatible_waiting_types_bitmap_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> MDL_lock::get_incompatible_waiting_types_bitmap_idx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get index of priority matrice in MDL_lock_strategy::m_waiting_incompatible array which corresponds to current values of the m_piglet_lock_count and m_hog_lock_count counters and the max_write_lock_count threshold. </p>

</div>
</div>
<a id="ada93a4c2a1f01792f9c3e352dbf900fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada93a4c2a1f01792f9c3e352dbf900fc">&#9670;&nbsp;</a></span>get_lock_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__context.html">MDL_context</a> * MDL_lock::get_lock_owner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first MDL_context which owns the lock. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first MDL_context which has acquired the lock NULL if there are no such contexts.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method works properly only for locks acquired using "slow" path. It won't return context if it has used "fast" path to acquire the lock. </dd></dl>

</div>
</div>
<a id="adb12eb628c61dff9c9c3bbb4ce6faef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb12eb628c61dff9c9c3bbb4ce6faef4">&#9670;&nbsp;</a></span>get_strategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a>* MDL_lock::get_strategy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMDL__key.html">MDL_key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get MDL lock strategy corresponding to MDL key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Reference to MDL_key object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of strategy scoped or object corresponding to MDL key. </dd></dl>

</div>
</div>
<a id="aa8424d2f478663117e7ac5e435840342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8424d2f478663117e7ac5e435840342">&#9670;&nbsp;</a></span>get_unobtrusive_lock_increment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">MDL_lock::fast_path_state_t</a> MDL_lock::get_unobtrusive_lock_increment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>"Fast path" increment for request for "unobtrusive" type of lock, 0 - if it is request for "obtrusive" type of lock.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We split all lock types for each of MDL namespaces in two sets:</dd></dl>
<p>A) "unobtrusive" lock types 1) Each type from this set should be compatible with all other types from the set (including itself). 2) These types should be common for DML operations</p>
<p>Our goal is to optimize acquisition and release of locks of this type by avoiding complex checks and manipulations on m_waiting/ m_granted bitmaps/lists. We replace them with a check of and increment/decrement of integer counters. We call the latter type of acquisition/release "fast path". Use of "fast path" reduces the size of critical section associated with MDL_lock::m_rwlock lock in the common case and thus increases scalability.</p>
<p>The amount by which acquisition/release of specific type "unobtrusive" lock increases/decreases packed counter in MDL_lock::m_fast_path_state is returned by this function.</p>
<p>B) "obtrusive" lock types 1) Granted or pending lock of those type is incompatible with some other types of locks or with itself. 2) Not common for DML operations</p>
<p>These locks have to be always acquired involving manipulations on m_waiting/m_granted bitmaps/lists, i.e. we have to use "slow path" for them. Moreover in the presence of active/pending locks from "obtrusive" set we have to acquire using "slow path" even locks of "unobtrusive" type.</p>
<dl class="section see"><dt>See also</dt><dd>MDL_scoped_lock::m_unobtrusive_lock_increment and </dd>
<dd>
MDL_object_lock::m_unobtrusive_lock_increment for definitions of these sets for scoped and per-object locks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>"Fast path" increment for request for "unobtrusive" type of lock, 0 - if it is request for "obtrusive" type of lock.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Description at method declaration for more details. </dd></dl>

</div>
</div>
<a id="aa5f2a62914d438aa6e97a50fc8050c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f2a62914d438aa6e97a50fc8050c74">&#9670;&nbsp;</a></span>get_unobtrusive_lock_increment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> MDL_lock::get_unobtrusive_lock_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>"Fast path" increment if type of lock is "unobtrusive" type, 0 - if it is "obtrusive" type of lock. </dd></dl>

</div>
</div>
<a id="a7707e02d9695b5694336787a622b0060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7707e02d9695b5694336787a622b0060">&#9670;&nbsp;</a></span>has_pending_conflicting_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::has_pending_conflicting_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we have any pending locks which conflict with existing shared lock. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The ticket must match an acquired lock.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is a conflicting lock request, false otherwise. </dd></dl>

</div>
</div>
<a id="acc63c21b6c75b3087cd273bc5125e9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc63c21b6c75b3087cd273bc5125e9d0">&#9670;&nbsp;</a></span>incompatible_granted_types_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a>* MDL_lock::incompatible_granted_types_bitmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa90ab350d28e755dcfa69d90004de7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90ab350d28e755dcfa69d90004de7aa">&#9670;&nbsp;</a></span>incompatible_waiting_types_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a>* MDL_lock::incompatible_waiting_types_bitmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7af5a6e02d50241f9c6417a01572c4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af5a6e02d50241f9c6417a01572c4ee">&#9670;&nbsp;</a></span>is_affected_by_max_write_lock_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::is_affected_by_max_write_lock_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0438fd341e3bedb63452c44ec95a00ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0438fd341e3bedb63452c44ec95a00ff">&#9670;&nbsp;</a></span>is_obtrusive_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::is_obtrusive_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccb">enum_mdl_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if type of lock requested is "obtrusive" type of lock. </p>
<dl class="section see"><dt>See also</dt><dd>MDL_lock::get_unobtrusive_lock_increment() description. </dd></dl>

</div>
</div>
<a id="a5bb8fcb19fe7323eb0044ebb78258c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb8fcb19fe7323eb0044ebb78258c75">&#9670;&nbsp;</a></span>needs_connection_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::needs_connection_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6cbff270ec3afad0feba7e97e9747bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cbff270ec3afad0feba7e97e9747bb">&#9670;&nbsp;</a></span>needs_hton_notification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::needs_hton_notification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a>&#160;</td>
          <td class="paramname"><em>mdl_namespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether object belongs to namespace which requires storage engine to be notified before acquiring and after releasing exclusive lock. </p>

</div>
</div>
<a id="a1eddfbd81b16d050a7a7d5a31e4242c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eddfbd81b16d050a7a7d5a31e4242c6">&#9670;&nbsp;</a></span>needs_notification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::needs_notification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20b6aaea388daf444e3f2c0d31362b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b6aaea388daf444e3f2c0d31362b15">&#9670;&nbsp;</a></span>notify_conflicting_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::notify_conflicting_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a580d9a0d9be93f90361cee67d0b4199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580d9a0d9be93f90361cee67d0b4199f">&#9670;&nbsp;</a></span>object_lock_fast_path_granted_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a> MDL_lock::object_lock_fast_path_granted_bitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get bitmap of "unobtrusive" locks granted using "fast path" algorithm for per-object locks. </p>
<dl class="section see"><dt>See also</dt><dd>MDL_lock::fast_path_granted_bitmap() for explanation about why it is safe to use non-atomic read of MDL_lock::m_fast_path_state here. </dd></dl>

</div>
</div>
<a id="a1ab1e1914e48faa93ba2e862cddfc274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab1e1914e48faa93ba2e862cddfc274">&#9670;&nbsp;</a></span>object_lock_needs_connection_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::object_lock_needs_connection_check </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__lock.html">MDL_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if MDL_lock object represents user-level lock,locking service lock or acl cache lock, so threads waiting for it need to check if connection is lost and abort waiting when it is. </p>

</div>
</div>
<a id="a382145d0f9b0f94a05ef03edbe922054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382145d0f9b0f94a05ef03edbe922054">&#9670;&nbsp;</a></span>object_lock_needs_notification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::object_lock_needs_notification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if we are requesting X lock on the object, so threads holding conflicting S/SH metadata locks on it need to be notified. </p>
<dl class="section see"><dt>See also</dt><dd>MDL_lock::object_lock_notify_conflicting_locks. </dd></dl>

</div>
</div>
<a id="aa30406c0d7d46396e15c4ca66abc6fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30406c0d7d46396e15c4ca66abc6fc7">&#9670;&nbsp;</a></span>object_lock_notify_conflicting_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::object_lock_notify_conflicting_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__lock.html">MDL_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify threads holding S/SH metadata locks on an object, which conflict with a pending X lock. </p>
<dl class="section note"><dt>Note</dt><dd>Currently this method is guaranteed to notify shared lock owners which have MDL_context::m_needs_thr_lock_abort flag set (as for others conficting locks might have been acquired on "fast path" and thus might be absent from list of granted locks). This is OK as notification for other contexts is anyway no-op now.</dd>
<dd>
We don't notify threads holding other than S/SH types of conflicting locks on the object since notification should not be needed and anyway will be no-op for them (unless they also hold S/SH locks on the object).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>MDL_context for current thread. </td></tr>
    <tr><td class="paramname">lock</td><td>MDL_lock object representing lock which is to be acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa2f6326006b7c7ba179075c82707d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f6326006b7c7ba179075c82707d59">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMDL__key.html">MDL_key</a> *&#160;</td>
          <td class="paramname"><em>mdl_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize initialization or re-initialize MDL_lock returned from LF_ALLOCATOR's cache to represent object identified by provided key. </p>
<dl class="section note"><dt>Note</dt><dd>All non-static MDL_lock members: 1) either have to be reinitialized here (like IS_DESTROYED flag in MDL_lock::m_fast_path_state). 2) or need to be initialized in constructor AND returned to their pristine state once they are removed from MDL_map container (like MDL_lock::m_granted or MDL_lock::m_rwlock). Otherwise it is possible that we will end up in situation when "new" (actually reused) MDL_lock object inserted in LF_HASH will inherit some values from old object. </dd></dl>

</div>
</div>
<a id="a7100ea62bb9af3e959d8a81ba11d4bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7100ea62bb9af3e959d8a81ba11d4bcb">&#9670;&nbsp;</a></span>remove_ticket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::remove_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLF__PINS.html">LF_PINS</a> *&#160;</td>
          <td class="paramname"><em>pins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::*&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a ticket from waiting or pending queue and wakeup up waiters. </p>

</div>
</div>
<a id="a07003cc6619a99b6cc36f564c62e4e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07003cc6619a99b6cc36f564c62e4e94">&#9670;&nbsp;</a></span>reschedule_waiters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::reschedule_waiters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine waiting contexts which requests for the lock can be satisfied, grant lock to them and wake them up. </p>
<dl class="section note"><dt>Note</dt><dd>Together with MDL_lock::add_ticket() this method implements fair scheduling among requests with the same priority. It tries to grant lock from the head of waiters list, while add_ticket() adds new requests to the back of this list. </dd></dl>

</div>
</div>
<a id="a8d5ce95948e006dbe957792a4be80928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5ce95948e006dbe957792a4be80928">&#9670;&nbsp;</a></span>scoped_lock_fast_path_granted_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a> MDL_lock::scoped_lock_fast_path_granted_bitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get bitmap of "unobtrusive" locks granted using "fast path" algorithm for scoped locks. </p>
<dl class="section see"><dt>See also</dt><dd>MDL_lock::fast_path_granted_bitmap() for explanation about why it is safe to use non-atomic read of MDL_lock::m_fast_path_state here. </dd></dl>

</div>
</div>
<a id="ab2be5e68445003d7a516849f2bceb18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2be5e68445003d7a516849f2bceb18c">&#9670;&nbsp;</a></span>switch_incompatible_waiting_types_bitmap_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::switch_incompatible_waiting_types_bitmap_if_needed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch priority matrice for the MDL_lock object if m_piglet_lock_count or/ and m_hog_lock_count counters have crossed max_write_lock_count threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>true - if priority matrice has been changed, false - otherwise. </dd></dl>

</div>
</div>
<a id="a56e5025d3f3cff97923bc283c715566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e5025d3f3cff97923bc283c715566d">&#9670;&nbsp;</a></span>visit_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MDL_lock::visit_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>waiting_ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *&#160;</td>
          <td class="paramname"><em>gvisitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A fragment of recursive traversal of the wait-for graph in search for deadlocks. </p>
<p>Direct the deadlock visitor to all contexts that own the lock the current node in the wait-for graph is waiting for. As long as the initial node is remembered in the visitor, a deadlock is found when the same node is seen twice. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac0e55394e253bd9d0988c9a7ab243a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e55394e253bd9d0988c9a7ab243a39">&#9670;&nbsp;</a></span>HAS_OBTRUSIVE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> MDL_lock::HAS_OBTRUSIVE = 1ULL &lt;&lt; 61</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag in MDL_lock::m_fast_path_state that indicates that there are "obtrusive" locks which are granted, waiting or for which we are about to check if they can be granted. </p>
<p>Corresponds to "MDL_lock::m_obtrusive_locks_granted_waiting_count == 0" predicate. Set using atomic compare-and-swap AND under protection of MDL_lock::m_rwlock lock. Thanks to this can be read either by using atomic compare-and-swap OR using ordinary read under protection of MDL_lock::m_rwlock lock.</p>
<p>Invariant [INV1]: When this flag is set all changes to m_fast_path_state member has to be done under protection of m_rwlock lock. </p>

</div>
</div>
<a id="ace80291dc2f7786288cdf1cec54bcb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace80291dc2f7786288cdf1cec54bcb55">&#9670;&nbsp;</a></span>HAS_SLOW_PATH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> MDL_lock::HAS_SLOW_PATH = 1ULL &lt;&lt; 60</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag in MDL_lock::m_fast_path_state that indicates that there are "slow" path locks which are granted, waiting or for which we are about to check if they can be granted. </p>
<p>Corresponds to MDL_lock::m_granted/m_waiting lists being non-empty (except special case in MDL_context::try_acquire_lock()). Set using atomic compare-and-swap AND under protection of m_rwlock lock. The latter is necessary because value of this flag needs to be synchronized with contents of MDL_lock::m_granted/m_waiting lists. </p>

</div>
</div>
<a id="a1627af1fd21d2ae76c27b39901e574a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1627af1fd21d2ae76c27b39901e574a3">&#9670;&nbsp;</a></span>IS_DESTROYED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a> MDL_lock::IS_DESTROYED = 1ULL &lt;&lt; 62</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag in MDL_lock::m_fast_path_state that indicates that the MDL_lock object was marked for destruction and will be destroyed once all threads referencing to it through hazard pointers have unpinned it. </p>
<p>Set using atomic compare-and-swap AND under protection of MDL_lock::m_rwlock lock. Thanks to this can be read either by using atomic compare-and-swap OR using ordinary read under protection of MDL_lock::m_rwlock lock. </p>

</div>
</div>
<a id="aefb48179bc3f6ef64c213b253c379da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb48179bc3f6ef64c213b253c379da4">&#9670;&nbsp;</a></span>key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMDL__key.html">MDL_key</a> MDL_lock::key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The key of the object (data) being protected. </p>

</div>
</div>
<a id="a7494018498e1e1d1ed3dfcf1f367b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7494018498e1e1d1ed3dfcf1f367b2ed">&#9670;&nbsp;</a></span>m_current_waiting_incompatible_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> MDL_lock::m_current_waiting_incompatible_idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of one of the MDL_lock_strategy::m_waiting_incompatible arrays which represents the current priority matrice. </p>

</div>
</div>
<a id="ae02937012711c410ef3a00f941e7f26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02937012711c410ef3a00f941e7f26b">&#9670;&nbsp;</a></span>m_fast_path_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="classMDL__lock.html#afc52a5a78b9a3b911e91c2fcb932981a">fast_path_state_t</a>&gt; MDL_lock::m_fast_path_state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combination of IS_DESTROYED/HAS_OBTRUSIVE/HAS_SLOW_PATH flags and packed counters of specific types of "unobtrusive" locks which were granted using "fast path". </p>
<dl class="section see"><dt>See also</dt><dd>MDL_scoped_lock::m_unobtrusive_lock_increment and </dd>
<dd>
MDL_object_lock::m_unobtrusive_lock_increment for details about how counts of different types of locks are packed into this field.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't include "unobtrusive" locks granted using "slow path".</dd>
<dd>
We use combination of atomic operations and protection by MDL_lock::m_rwlock lock to work with this member:</dd></dl>
<p>Write and Read-Modify-Write operations are always carried out atomically. This is necessary to avoid lost updates on 32-bit platforms among other things. In some cases Reads can be done non-atomically because we don't really care about value which they will return (for example, if further down the line there will be an atomic compare-and-swap operation, which will validate this value and provide the correct value if the validation will fail). In other cases Reads can be done non-atomically since they happen under protection of MDL_lock::m_rwlock and there is some invariant which ensures that concurrent updates of the m_fast_path_state member can't happen while MDL_lock::m_rwlock is held (</p><dl class="section see"><dt>See also</dt><dd>IS_DESTROYED, HAS_OBTRUSIVE, HAS_SLOW_PATH).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>IMPORTANT!!! In order to enforce the above rules and other invariants, MDL_lock::m_fast_path_state should not be updated directly. Use fast_path_state_cas()/add()/reset() wrapper methods instead. </dd></dl>

</div>
</div>
<a id="a188dd53561f6cf6148277512b706ea74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188dd53561f6cf6148277512b706ea74">&#9670;&nbsp;</a></span>m_granted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::m_granted</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of granted tickets for this lock. </p>

</div>
</div>
<a id="ab173b2eb68fdd6de02d9e4e8a0c94405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab173b2eb68fdd6de02d9e4e8a0c94405">&#9670;&nbsp;</a></span>m_hog_lock_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> MDL_lock::m_hog_lock_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of times high priority, "hog" lock requests (X, SNRW, SNW) have been granted while lower priority lock requests (all other types) were waiting. </p>
<p>Currently used only for object locks. Protected by m_rwlock lock. </p>

</div>
</div>
<a id="a6ed94b58baea6bf2e22b76566aa513b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed94b58baea6bf2e22b76566aa513b3">&#9670;&nbsp;</a></span>m_object_lock_strategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock::MDL_lock_strategy</a> MDL_lock::m_object_lock_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strategy instance for per-object locks. </p>
<p>Supports all locked modes except INTENTION EXCLUSIVE locks. </p>

</div>
</div>
<a id="a7ef26eb4cf46309c494135291a82e20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef26eb4cf46309c494135291a82e20c">&#9670;&nbsp;</a></span>m_obtrusive_locks_granted_waiting_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> MDL_lock::m_obtrusive_locks_granted_waiting_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of granted or waiting lock requests of "obtrusive" type. </p>
<p>Also includes "obtrusive" lock requests for which we about to check if they can be granted.</p>
<dl class="section see"><dt>See also</dt><dd>MDL_lock::get_unobtrusive_lock_increment() description.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This number doesn't include "unobtrusive" locks which were acquired using "slow path". </dd></dl>

</div>
</div>
<a id="af4f177eeae90b5de66b37eab32fd563a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f177eeae90b5de66b37eab32fd563a">&#9670;&nbsp;</a></span>m_piglet_lock_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> MDL_lock::m_piglet_lock_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of times high priority, "piglet" lock requests (SW) have been granted while locks requests with lower priority (SRO) were waiting. </p>
<p>Currently used only for object locks. Protected by m_rwlock lock. </p>

</div>
</div>
<a id="a1308b4506d8cb6d754b4f173e3aa4962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1308b4506d8cb6d754b4f173e3aa4962">&#9670;&nbsp;</a></span>m_rwlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__prlock__t.html">mysql_prlock_t</a> MDL_lock::m_rwlock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-write lock protecting this lock context. </p>
<dl class="section note"><dt>Note</dt><dd>The fact that we use read-write lock prefers readers here is important as deadlock detector won't work correctly otherwise.</dd></dl>
<p>For example, imagine that we have following waiters graph: </p><pre class="fragment">         ctxA -&gt; obj1 -&gt; ctxB -&gt; obj1 -|
          ^                            |
          |----------------------------|
</pre><p>and both ctxA and ctxB start deadlock detection process:</p>
<p>ctxA read-locks obj1 ctxB read-locks obj2 ctxA goes deeper ctxB goes deeper</p>
<p>Now ctxC comes in who wants to start waiting on obj1, also ctxD comes in who wants to start waiting on obj2.</p>
<p>ctxC tries to write-lock obj1 ctxD tries to write-lock obj2 ctxC is blocked ctxD is blocked</p>
<p>Now ctxA and ctxB resume their search:</p>
<p>ctxA tries to read-lock obj2 ctxB tries to read-lock obj1</p>
<p>If m_rwlock prefers writes (or fair) both ctxA and ctxB would be blocked because of pending write locks from ctxD and ctxC correspondingly. Thus we will get a deadlock in deadlock detector. If m_wrlock prefers readers (actually ignoring pending writers is enough) ctxA and ctxB will continue and no deadlock will occur. </p>

</div>
</div>
<a id="aed7a092b4b9aa426597f599feb6bb19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7a092b4b9aa426597f599feb6bb19b">&#9670;&nbsp;</a></span>m_scoped_lock_strategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock::MDL_lock_strategy</a> MDL_lock::m_scoped_lock_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    </div><div class="line">    {<a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbac314c015883c75ddcbdad3ceccd0bb73">MDL_EXCLUSIVE</a>) | <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccba0d978e40251b54054c3385529888387e">MDL_SHARED</a>),</div><div class="line">     <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbac314c015883c75ddcbdad3ceccd0bb73">MDL_EXCLUSIVE</a>) | <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbae221f959e09d9dce2ac169f2d8bf33c6">MDL_INTENTION_EXCLUSIVE</a>), 0, 0, 0, 0, 0,</div><div class="line">     0, 0, 0,</div><div class="line">     <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbac314c015883c75ddcbdad3ceccd0bb73">MDL_EXCLUSIVE</a>) | <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccba0d978e40251b54054c3385529888387e">MDL_SHARED</a>) |</div><div class="line">         <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbae221f959e09d9dce2ac169f2d8bf33c6">MDL_INTENTION_EXCLUSIVE</a>)},</div><div class="line">    </div><div class="line">    {{<a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbac314c015883c75ddcbdad3ceccd0bb73">MDL_EXCLUSIVE</a>) | <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccba0d978e40251b54054c3385529888387e">MDL_SHARED</a>), <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbac314c015883c75ddcbdad3ceccd0bb73">MDL_EXCLUSIVE</a>), 0,</div><div class="line">      0, 0, 0, 0, 0, 0, 0, 0},</div><div class="line">     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</div><div class="line">     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</div><div class="line">     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},</div><div class="line">    </div><div class="line">    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</div><div class="line">    </div><div class="line">    <span class="keyword">false</span>,</div><div class="line"></div><div class="line">    </div><div class="line">    {<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>},</div><div class="line"></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">nullptr</span>,</div><div class="line">    </div><div class="line">    <span class="keyword">nullptr</span>,</div><div class="line">    &amp;<a class="code" href="classMDL__lock.html#a8d5ce95948e006dbe957792a4be80928">MDL_lock::scoped_lock_fast_path_granted_bitmap</a>,</div><div class="line">    </div><div class="line">    <span class="keyword">nullptr</span>}</div></div><!-- fragment -->
<p>Strategy instances to be used with scoped metadata locks (i.e. </p>
<p>locks from GLOBAL, COMMIT, TABLESPACE, BACKUP_LOCK and SCHEMA namespaces). The only locking modes which are supported at the moment are SHARED and INTENTION EXCLUSIVE and EXCLUSIVE. </p>

</div>
</div>
<a id="a67a214605da83d57ac8d69c1f1c4854d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a214605da83d57ac8d69c1f1c4854d">&#9670;&nbsp;</a></span>m_strategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a>* MDL_lock::m_strategy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to strategy object which defines how different types of lock requests should be handled for the namespace to which this lock belongs. </p>
<dl class="section see"><dt>See also</dt><dd>MDL_lock::m_scoped_lock_strategy and MDL_lock:m_object_lock_strategy. </dd></dl>

</div>
</div>
<a id="a4443cad6b484e2af5c816949ddb209dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4443cad6b484e2af5c816949ddb209dc">&#9670;&nbsp;</a></span>m_waiting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::m_waiting</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tickets for contexts waiting to acquire a lock. </p>

</div>
</div>
<a id="abaeb101565637f92f74d4a84bdc53fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaeb101565637f92f74d4a84bdc53fa5">&#9670;&nbsp;</a></span>MDL_OBJECT_HOG_LOCK_TYPES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMDL__lock.html#af49d3a2db62c2c6dda844e0d4531ab12">bitmap_t</a> MDL_lock::MDL_OBJECT_HOG_LOCK_TYPES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      (<a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccba625286b5c7930c17c05fea3ffef0c1da">MDL_SHARED_NO_WRITE</a>) | <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccba7f4c8af6f7028729d507769697e1d74b">MDL_SHARED_NO_READ_WRITE</a>) |</div><div class="line">       <a class="code" href="mdl_8cc.html#ad7dd3960d0c13534400fc2e61cc01ea1">MDL_BIT</a>(<a class="code" href="mdl_8h.html#a7b8d423b69ef9a2842803673e2f0dccbac314c015883c75ddcbdad3ceccd0bb73">MDL_EXCLUSIVE</a>))</div></div><!-- fragment -->
<p>Bitmap with "hog" lock types for object locks. </p>
<p>Locks of these types can easily starve out lower priority locks. To prevent this we only grant them max_write_lock_count times in a row while other lock types are waiting. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sql/<a class="el" href="mdl_8cc.html">mdl.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMDL__lock.html">MDL_lock</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
