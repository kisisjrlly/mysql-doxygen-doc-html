<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/btr/btr0cur.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('btr0cur_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0cur.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The index tree cursor.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &lt;zlib.h&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="current__thd_8h_source.html">current_thd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="debug__sync_8h_source.html">debug_sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lob0lob_8h_source.html">lob0lob.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0log_8h_source.html">mtr0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0rec_8h_source.html">rem0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0log_8h_source.html">row0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0purge_8h_source.html">row0purge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0rec_8h_source.html">trx0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0roll_8h_source.html">trx0roll.h</a>&quot;</code><br />
<code>#include &lt;array&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a34f85036ad9ae5f3170690e670a37b52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a34f85036ad9ae5f3170690e670a37b52">BTR_CUR_FINE_HISTORY_LENGTH</a>&#160;&#160;&#160;100000</td></tr>
<tr class="memdesc:a34f85036ad9ae5f3170690e670a37b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the index-&gt;lock scalability improvement, only possibility of clear performance regression observed was caused by grown huge history list length.  <a href="#a34f85036ad9ae5f3170690e670a37b52">More...</a><br /></td></tr>
<tr class="separator:a34f85036ad9ae5f3170690e670a37b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4676319e3e8cde7d9790089fe965df40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a4676319e3e8cde7d9790089fe965df40">BTR_CUR_PAGE_REORGANIZE_LIMIT</a>&#160;&#160;&#160;(UNIV_PAGE_SIZE / 32)</td></tr>
<tr class="memdesc:a4676319e3e8cde7d9790089fe965df40"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the optimistic insert, if the insert does not fit, but this much space can be released by page reorganize, then it is reorganized.  <a href="#a4676319e3e8cde7d9790089fe965df40">More...</a><br /></td></tr>
<tr class="separator:a4676319e3e8cde7d9790089fe965df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76518092843bb988e2222a5712cc0a9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a76518092843bb988e2222a5712cc0a9f">BTR_TABLE_STATS_FROM_SAMPLE</a>(<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>,  <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>,  sample,  ext_size,  not_empty)</td></tr>
<tr class="memdesc:a76518092843bb988e2222a5712cc0a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimated table level stats from sampled value.  <a href="#a76518092843bb988e2222a5712cc0a9f">More...</a><br /></td></tr>
<tr class="separator:a76518092843bb988e2222a5712cc0a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e31d2f2c964ed620e7379a4196fbd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a9e4e31d2f2c964ed620e7379a4196fbd">N_PAGES_READ_LIMIT</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a9e4e31d2f2c964ed620e7379a4196fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac8e1e7dcb5ea919124b9d6e8e868bbc8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8">btr_op_t</a> { <br />
&#160;&#160;<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8a84f603208288c0b21ebee05430ca4229">BTR_NO_OP</a> = 0, 
<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8af727af06be5922ef5e53314387951e52">BTR_INSERT_OP</a>, 
<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8a791b52e53c17e5174c4a38d4b93d5fdb">BTR_INSERT_IGNORE_UNIQUE_OP</a>, 
<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8a4d7f260f169e344aa04a3df1a3100c63">BTR_DELETE_OP</a>, 
<br />
&#160;&#160;<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8ac67a876f7a3a5ebc554eb5170a6604e4">BTR_DELMARK_OP</a>
<br />
 }<tr class="memdesc:ac8e1e7dcb5ea919124b9d6e8e868bbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffered B-tree operation types, introduced as part of delete buffering.  <a href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac8e1e7dcb5ea919124b9d6e8e868bbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1d9731b3089d61f713f3aba4b632c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a> { <a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1ae687d414d3d4f4e93b8a08e912e261b8">BTR_INTENTION_DELETE</a>, 
<a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1adc11887c56406bbdec889ab81c8fecd4">BTR_INTENTION_BOTH</a>, 
<a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1a0285d0eaa29fe5dd2c6345483103b9cc">BTR_INTENTION_INSERT</a>
 }<tr class="memdesc:aad1d9731b3089d61f713f3aba4b632c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modification types for the B-tree operation.  <a href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aad1d9731b3089d61f713f3aba4b632c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d25b1d3defc3c7b44c623f71c32dfce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a8d25b1d3defc3c7b44c623f71c32dfce">btr_cur_add_path_info</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint height, ulint root_height)</td></tr>
<tr class="memdesc:a8d25b1d3defc3c7b44c623f71c32dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds path information to the cursor for the current page, for which the binary search has been performed.  <a href="#a8d25b1d3defc3c7b44c623f71c32dfce">More...</a><br /></td></tr>
<tr class="separator:a8d25b1d3defc3c7b44c623f71c32dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6270343de26ab24466bb5980d91848e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbtr__latch__leaves__t.html">btr_latch_leaves_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a6270343de26ab24466bb5980d91848e9">btr_cur_latch_leaves</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a6270343de26ab24466bb5980d91848e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latches the leaf page or pages requested.  <a href="#a6270343de26ab24466bb5980d91848e9">More...</a><br /></td></tr>
<tr class="separator:a6270343de26ab24466bb5980d91848e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367d84590d5ae4ceb873a30c7d2a7b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a367d84590d5ae4ceb873a30c7d2a7b4d">btr_cur_optimistic_latch_leaves</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ib_uint64_t modify_clock, ulint *latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a367d84590d5ae4ceb873a30c7d2a7b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimistically latches the leaf page or pages requested.  <a href="#a367d84590d5ae4ceb873a30c7d2a7b4d">More...</a><br /></td></tr>
<tr class="separator:a367d84590d5ae4ceb873a30c7d2a7b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909bf67a15790602fbf94b34844bd2ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a909bf67a15790602fbf94b34844bd2ea">btr_cur_get_and_clear_intention</a> (ulint *latch_mode)</td></tr>
<tr class="memdesc:a909bf67a15790602fbf94b34844bd2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets intention in btr_intention_t from latch_mode, and cleares the intention at the latch_mode.  <a href="#a909bf67a15790602fbf94b34844bd2ea">More...</a><br /></td></tr>
<tr class="separator:a909bf67a15790602fbf94b34844bd2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80dc41de91dd6745f80193fc78af64e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ad80dc41de91dd6745f80193fc78af64e">btr_cur_latch_for_root_leaf</a> (ulint latch_mode)</td></tr>
<tr class="memdesc:ad80dc41de91dd6745f80193fc78af64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the desired latch type for the root leaf (root page is root leaf) at the latch mode.  <a href="#ad80dc41de91dd6745f80193fc78af64e">More...</a><br /></td></tr>
<tr class="separator:ad80dc41de91dd6745f80193fc78af64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67c9549d39c7424a689f4382480f1a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ad67c9549d39c7424a689f4382480f1a0">btr_cur_will_modify_tree</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a> lock_intention, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint rec_size, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ad67c9549d39c7424a689f4382480f1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the modifying record might need a modifying tree structure.  <a href="#ad67c9549d39c7424a689f4382480f1a0">More...</a><br /></td></tr>
<tr class="separator:ad67c9549d39c7424a689f4382480f1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5075b2630cbd6c470fac6b1c9261041b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a5075b2630cbd6c470fac6b1c9261041b">btr_cur_need_opposite_intention</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a> lock_intention, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a5075b2630cbd6c470fac6b1c9261041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the modifying record might need a opposite modification to the intention.  <a href="#a5075b2630cbd6c470fac6b1c9261041b">More...</a><br /></td></tr>
<tr class="separator:a5075b2630cbd6c470fac6b1c9261041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542936a2ff210fb6502b04fd367a1ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a542936a2ff210fb6502b04fd367a1ae0">btr_cur_search_to_nth_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint has_search_latch, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a542936a2ff210fb6502b04fd367a1ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches an index tree and positions a tree cursor on a given level.  <a href="#a542936a2ff210fb6502b04fd367a1ae0">More...</a><br /></td></tr>
<tr class="separator:a542936a2ff210fb6502b04fd367a1ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabcd3b0d78376d6d3b819d738aaae07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#afabcd3b0d78376d6d3b819d738aaae07">btr_cur_search_to_nth_level_with_no_latch</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> mark_dirty)</td></tr>
<tr class="memdesc:afabcd3b0d78376d6d3b819d738aaae07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches an index tree and positions a tree cursor on a given level.  <a href="#afabcd3b0d78376d6d3b819d738aaae07">More...</a><br /></td></tr>
<tr class="separator:afabcd3b0d78376d6d3b819d738aaae07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2ef1b901ec66346efc1096bb1aeece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a5e2ef1b901ec66346efc1096bb1aeece">btr_cur_open_at_index_side_func</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> from_left, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint level, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a5e2ef1b901ec66346efc1096bb1aeece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a cursor at either end of an index.  <a href="#a5e2ef1b901ec66346efc1096bb1aeece">More...</a><br /></td></tr>
<tr class="separator:a5e2ef1b901ec66346efc1096bb1aeece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c362a21cd664ca4fe74169890e1db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ae37c362a21cd664ca4fe74169890e1db">btr_cur_open_at_index_side_with_no_latch_func</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> from_left, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint level, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae37c362a21cd664ca4fe74169890e1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a cursor at either end of an index.  <a href="#ae37c362a21cd664ca4fe74169890e1db">More...</a><br /></td></tr>
<tr class="separator:ae37c362a21cd664ca4fe74169890e1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97879c31eba0c93fdb888685580771a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ae97879c31eba0c93fdb888685580771a">btr_cur_open_at_rnd_pos_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae97879c31eba0c93fdb888685580771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions a cursor at a randomly chosen position within a B-tree.  <a href="#ae97879c31eba0c93fdb888685580771a">More...</a><br /></td></tr>
<tr class="separator:ae97879c31eba0c93fdb888685580771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c725a67926c24150795756b7d924d23"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a9c725a67926c24150795756b7d924d23">btr_cur_insert_if_possible</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a9c725a67926c24150795756b7d924d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a record if there is enough space, or if enough space can be freed by reorganizing.  <a href="#a9c725a67926c24150795756b7d924d23">More...</a><br /></td></tr>
<tr class="separator:a9c725a67926c24150795756b7d924d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc22fea68de608924c4c8fef2fe9efd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a8bc22fea68de608924c4c8fef2fe9efd">btr_cur_ins_lock_and_undo</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, ibool *inherit)</td></tr>
<tr class="memdesc:a8bc22fea68de608924c4c8fef2fe9efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an insert, checks the locks and does the undo logging if desired.  <a href="#a8bc22fea68de608924c4c8fef2fe9efd">More...</a><br /></td></tr>
<tr class="separator:a8bc22fea68de608924c4c8fef2fe9efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e611f6cfd79cf807d5ef14e3b842f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a09e611f6cfd79cf807d5ef14e3b842f7">btr_cur_prefetch_siblings</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a09e611f6cfd79cf807d5ef14e3b842f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch siblings of the leaf for the pessimistic operation.  <a href="#a09e611f6cfd79cf807d5ef14e3b842f7">More...</a><br /></td></tr>
<tr class="separator:a09e611f6cfd79cf807d5ef14e3b842f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a5ffe53e178cb8e15738a9a57944c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a755a5ffe53e178cb8e15738a9a57944c">btr_cur_optimistic_insert</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **rec, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **big_rec, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a755a5ffe53e178cb8e15738a9a57944c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to perform an insert to a page in an index tree, next to cursor.  <a href="#a755a5ffe53e178cb8e15738a9a57944c">More...</a><br /></td></tr>
<tr class="separator:a755a5ffe53e178cb8e15738a9a57944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2f4cf3c619c6630d174de684f44f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aca2f4cf3c619c6630d174de684f44f80">btr_cur_pessimistic_insert</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **rec, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **big_rec, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aca2f4cf3c619c6630d174de684f44f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an insert on a page of an index tree.  <a href="#aca2f4cf3c619c6630d174de684f44f80">More...</a><br /></td></tr>
<tr class="separator:aca2f4cf3c619c6630d174de684f44f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1fed8ce2d391e0cc53d0d59ff3d07"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ac1f1fed8ce2d391e0cc53d0d59ff3d07">btr_cur_upd_lock_and_undo</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint cmpl_info, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *roll_ptr)</td></tr>
<tr class="memdesc:ac1f1fed8ce2d391e0cc53d0d59ff3d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an update, checks the locks and does the undo logging.  <a href="#ac1f1fed8ce2d391e0cc53d0d59ff3d07">More...</a><br /></td></tr>
<tr class="separator:ac1f1fed8ce2d391e0cc53d0d59ff3d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe0bb94cee5310f935edc06c06ece60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#afbe0bb94cee5310f935edc06c06ece60">btr_cur_update_in_place_log</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:afbe0bb94cee5310f935edc06c06ece60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a redo log record of updating a record in-place.  <a href="#afbe0bb94cee5310f935edc06c06ece60">More...</a><br /></td></tr>
<tr class="separator:afbe0bb94cee5310f935edc06c06ece60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2779e13e725b69e10b92eba034a1a143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a2779e13e725b69e10b92eba034a1a143">btr_cur_parse_update_in_place</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a2779e13e725b69e10b92eba034a1a143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a redo log record of updating a record in-place.  <a href="#a2779e13e725b69e10b92eba034a1a143">More...</a><br /></td></tr>
<tr class="separator:a2779e13e725b69e10b92eba034a1a143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdc46d486a27aa882f0c8f80cbf09c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#abfdc46d486a27aa882f0c8f80cbf09c4">btr_cur_update_alloc_zip_func</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint *offsets, ulint length, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> create, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:abfdc46d486a27aa882f0c8f80cbf09c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if there is enough place in the page modification log to log an update-in-place.  <a href="#abfdc46d486a27aa882f0c8f80cbf09c4">More...</a><br /></td></tr>
<tr class="separator:abfdc46d486a27aa882f0c8f80cbf09c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f42051e928b6c3f72b7fc3bb59293a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a8f42051e928b6c3f72b7fc3bb59293a0">btr_cur_update_in_place</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint cmpl_info, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a8f42051e928b6c3f72b7fc3bb59293a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a record when the update causes no size changes in its fields.  <a href="#a8f42051e928b6c3f72b7fc3bb59293a0">More...</a><br /></td></tr>
<tr class="separator:a8f42051e928b6c3f72b7fc3bb59293a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daa7a19fdc8383127085073ea67bea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a4daa7a19fdc8383127085073ea67bea9">btr_cur_optimistic_update</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint cmpl_info, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a4daa7a19fdc8383127085073ea67bea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to update a record on a page in an index tree.  <a href="#a4daa7a19fdc8383127085073ea67bea9">More...</a><br /></td></tr>
<tr class="separator:a4daa7a19fdc8383127085073ea67bea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a8df6cc43f61d2a90dceb886983ef9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#af8a8df6cc43f61d2a90dceb886983ef9">btr_cur_pess_upd_restore_supremum</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af8a8df6cc43f61d2a90dceb886983ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If, in a split, a new supremum record was created as the predecessor of the updated record, the supremum record must inherit exactly the locks on the updated record.  <a href="#af8a8df6cc43f61d2a90dceb886983ef9">More...</a><br /></td></tr>
<tr class="separator:af8a8df6cc43f61d2a90dceb886983ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88683e53b86efea31be52cf349bdca78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a88683e53b86efea31be52cf349bdca78">btr_cur_pessimistic_update</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offsets_heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *entry_heap, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **big_rec, <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint cmpl_info, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#a4661d2883c1cd5d8f1cfbd63b553f1bc">undo_no_t</a> undo_no, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur)</td></tr>
<tr class="memdesc:a88683e53b86efea31be52cf349bdca78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an update of a record on a page of a tree.  <a href="#a88683e53b86efea31be52cf349bdca78">More...</a><br /></td></tr>
<tr class="separator:a88683e53b86efea31be52cf349bdca78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770e0a5b2cd615f9d598bb931b0474be"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a770e0a5b2cd615f9d598bb931b0474be">btr_cur_del_mark_set_clust_rec_log</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a770e0a5b2cd615f9d598bb931b0474be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the redo log record for delete marking or unmarking of an index record.  <a href="#a770e0a5b2cd615f9d598bb931b0474be">More...</a><br /></td></tr>
<tr class="separator:a770e0a5b2cd615f9d598bb931b0474be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c486e1078df1872ee87c377006674a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a63c486e1078df1872ee87c377006674a">btr_cur_parse_del_mark_set_clust_rec</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a63c486e1078df1872ee87c377006674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the redo log record for delete marking or unmarking of a clustered index record.  <a href="#a63c486e1078df1872ee87c377006674a">More...</a><br /></td></tr>
<tr class="separator:a63c486e1078df1872ee87c377006674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769cec83638735de3b95862c5d3ee139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a769cec83638735de3b95862c5d3ee139">btr_cur_del_mark_set_clust_rec</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a769cec83638735de3b95862c5d3ee139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a clustered index record deleted.  <a href="#a769cec83638735de3b95862c5d3ee139">More...</a><br /></td></tr>
<tr class="separator:a769cec83638735de3b95862c5d3ee139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b5e425b158cb805c7a59d8d52ffc10"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a78b5e425b158cb805c7a59d8d52ffc10">btr_cur_del_mark_set_sec_rec_log</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ibool val, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a78b5e425b158cb805c7a59d8d52ffc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the redo log record for a delete mark setting of a secondary index record.  <a href="#a78b5e425b158cb805c7a59d8d52ffc10">More...</a><br /></td></tr>
<tr class="separator:a78b5e425b158cb805c7a59d8d52ffc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0c1be287e095e69d5f46809e583700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a9c0c1be287e095e69d5f46809e583700">btr_cur_parse_del_mark_set_sec_rec</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="memdesc:a9c0c1be287e095e69d5f46809e583700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the redo log record for delete marking or unmarking of a secondary index record.  <a href="#a9c0c1be287e095e69d5f46809e583700">More...</a><br /></td></tr>
<tr class="separator:a9c0c1be287e095e69d5f46809e583700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427aa7747fe4f0f2f0f75b14fb303906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a427aa7747fe4f0f2f0f75b14fb303906">btr_cur_del_mark_set_sec_rec</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ibool val, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a427aa7747fe4f0f2f0f75b14fb303906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a secondary index record delete mark to TRUE or FALSE.  <a href="#a427aa7747fe4f0f2f0f75b14fb303906">More...</a><br /></td></tr>
<tr class="separator:a427aa7747fe4f0f2f0f75b14fb303906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af010a9efa9efe7a02c590a268e7d810d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#af010a9efa9efe7a02c590a268e7d810d">btr_cur_set_deleted_flag_for_ibuf</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ibool val, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af010a9efa9efe7a02c590a268e7d810d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a secondary index record's delete mark to the given value.  <a href="#af010a9efa9efe7a02c590a268e7d810d">More...</a><br /></td></tr>
<tr class="separator:af010a9efa9efe7a02c590a268e7d810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fd277719862187604bf48005ec191c"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a64fd277719862187604bf48005ec191c">btr_cur_compress_if_useful</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ibool adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a64fd277719862187604bf48005ec191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to compress a page of the tree if it seems useful.  <a href="#a64fd277719862187604bf48005ec191c">More...</a><br /></td></tr>
<tr class="separator:a64fd277719862187604bf48005ec191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d02deb9d204909dbee067cb7e84c2a7"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a8d02deb9d204909dbee067cb7e84c2a7">btr_cur_optimistic_delete_func</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a8d02deb9d204909dbee067cb7e84c2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the record on which the tree cursor is positioned on a leaf page.  <a href="#a8d02deb9d204909dbee067cb7e84c2a7">More...</a><br /></td></tr>
<tr class="separator:a8d02deb9d204909dbee067cb7e84c2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52504db19be214f5fa7d0fa804657cc"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ac52504db19be214f5fa7d0fa804657cc">btr_cur_pessimistic_delete</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *err, ibool has_reserved_extents, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="sql__cmd__srs_8cc.html#ae1f3a7aed6d381dcd98b265913716fd4">rollback</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#a4661d2883c1cd5d8f1cfbd63b553f1bc">undo_no_t</a> undo_no, ulint rec_type, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur)</td></tr>
<tr class="memdesc:ac52504db19be214f5fa7d0fa804657cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the record on which the tree cursor is positioned.  <a href="#ac52504db19be214f5fa7d0fa804657cc">More...</a><br /></td></tr>
<tr class="separator:ac52504db19be214f5fa7d0fa804657cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500234d32d851da1930f5d459b88f2dd"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a500234d32d851da1930f5d459b88f2dd">btr_estimate_n_rows_in_range_on_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbtr__path__t.html">btr_path_t</a> *slot1, <a class="el" href="structbtr__path__t.html">btr_path_t</a> *slot2, int64_t n_rows_on_prev_level, ibool *is_n_rows_exact)</td></tr>
<tr class="memdesc:a500234d32d851da1930f5d459b88f2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the number of rows between slot1 and slot2 for any level on a B-tree.  <a href="#a500234d32d851da1930f5d459b88f2dd">More...</a><br /></td></tr>
<tr class="separator:a500234d32d851da1930f5d459b88f2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6808d869e61ef7da5d5393341dbefd61"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a6808d869e61ef7da5d5393341dbefd61">btr_estimate_n_rows_in_range_low</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple1, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode1, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple2, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode2, unsigned nth_attempt)</td></tr>
<tr class="memdesc:a6808d869e61ef7da5d5393341dbefd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of rows in a given index range.  <a href="#a6808d869e61ef7da5d5393341dbefd61">More...</a><br /></td></tr>
<tr class="separator:a6808d869e61ef7da5d5393341dbefd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2103e405e81402bc71b951afb1e583c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab2103e405e81402bc71b951afb1e583c">btr_estimate_n_rows_in_range</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple1, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode1, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple2, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode2)</td></tr>
<tr class="memdesc:ab2103e405e81402bc71b951afb1e583c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of rows in a given index range.  <a href="#ab2103e405e81402bc71b951afb1e583c">More...</a><br /></td></tr>
<tr class="separator:ab2103e405e81402bc71b951afb1e583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3504db9f888c4d4994bf1b8a894b8b90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a3504db9f888c4d4994bf1b8a894b8b90">btr_record_not_null_field_in_rec</a> (ulint n_unique, const ulint *offsets, ib_uint64_t *n_not_null)</td></tr>
<tr class="memdesc:a3504db9f888c4d4994bf1b8a894b8b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the number of non_null key values in a given index for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index).  <a href="#a3504db9f888c4d4994bf1b8a894b8b90">More...</a><br /></td></tr>
<tr class="separator:a3504db9f888c4d4994bf1b8a894b8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4bd3b42e8c550c943089ebef00fe54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a0f4bd3b42e8c550c943089ebef00fe54">btr_estimate_number_of_different_key_vals</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a0f4bd3b42e8c550c943089ebef00fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of different key values in a given index, for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index).  <a href="#a0f4bd3b42e8c550c943089ebef00fe54">More...</a><br /></td></tr>
<tr class="separator:a0f4bd3b42e8c550c943089ebef00fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7b7a92b1123d6493729904f846f05a03"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a7b7a92b1123d6493729904f846f05a03">btr_cur_n_non_sea</a> = 0</td></tr>
<tr class="memdesc:a7b7a92b1123d6493729904f846f05a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of searches down the B-tree in btr_cur_search_to_nth_level().  <a href="#a7b7a92b1123d6493729904f846f05a03">More...</a><br /></td></tr>
<tr class="separator:a7b7a92b1123d6493729904f846f05a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b3d4f868488aa0addf8d9fa32df663"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ae0b3d4f868488aa0addf8d9fa32df663">btr_cur_n_sea</a> = 0</td></tr>
<tr class="memdesc:ae0b3d4f868488aa0addf8d9fa32df663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of successful adaptive hash index lookups in btr_cur_search_to_nth_level().  <a href="#ae0b3d4f868488aa0addf8d9fa32df663">More...</a><br /></td></tr>
<tr class="separator:ae0b3d4f868488aa0addf8d9fa32df663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefef1d2e4bf03540d18ff799bf9c0a74"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aefef1d2e4bf03540d18ff799bf9c0a74">btr_cur_n_non_sea_old</a> = 0</td></tr>
<tr class="memdesc:aefef1d2e4bf03540d18ff799bf9c0a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Old value of btr_cur_n_non_sea.  <a href="#aefef1d2e4bf03540d18ff799bf9c0a74">More...</a><br /></td></tr>
<tr class="separator:aefef1d2e4bf03540d18ff799bf9c0a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df6a65d39b12848a998a57d2cc328d0"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a8df6a65d39b12848a998a57d2cc328d0">btr_cur_n_sea_old</a> = 0</td></tr>
<tr class="memdesc:a8df6a65d39b12848a998a57d2cc328d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Old value of btr_cur_n_sea.  <a href="#a8df6a65d39b12848a998a57d2cc328d0">More...</a><br /></td></tr>
<tr class="separator:a8df6a65d39b12848a998a57d2cc328d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6f6e317169b84969361e99eb711b3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a2f6f6e317169b84969361e99eb711b3b">btr_cur_limit_optimistic_insert_debug</a> = 0</td></tr>
<tr class="separator:a2f6f6e317169b84969361e99eb711b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab400468c95b15bab3a9171ddd005f6aa"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab400468c95b15bab3a9171ddd005f6aa">rows_in_range_max_retries</a> = 4</td></tr>
<tr class="memdesc:ab400468c95b15bab3a9171ddd005f6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the tree gets changed too much between the two dives for the left and right boundary then btr_estimate_n_rows_in_range_low() will retry that many times before giving up and returning the value stored in rows_in_range_arbitrary_ret_val.  <a href="#ab400468c95b15bab3a9171ddd005f6aa">More...</a><br /></td></tr>
<tr class="separator:ab400468c95b15bab3a9171ddd005f6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac122e9c1be72af8a9ce9a2f2f30fb14"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aac122e9c1be72af8a9ce9a2f2f30fb14">rows_in_range_arbitrary_ret_val</a> = 10</td></tr>
<tr class="memdesc:aac122e9c1be72af8a9ce9a2f2f30fb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">We pretend that a range has that many records if the tree keeps changing for rows_in_range_max_retries retries while we try to estimate the records in a given range.  <a href="#aac122e9c1be72af8a9ce9a2f2f30fb14">More...</a><br /></td></tr>
<tr class="separator:aac122e9c1be72af8a9ce9a2f2f30fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The index tree cursor. </p>
<p>All changes that row operations make to a B-tree or the records there must go through this module! Undo log records are written here of every modify or insert of a clustered index record. </p><pre class="fragment">                    NOTE!!!
</pre><p> To make sure we do not run out of disk space during a pessimistic insert or update, we have to reserve 2 x the height of the index tree many pages in the tablespace before we start the operation, because if leaf splitting has been started, it is difficult to undo, except by crashing the database and doing a roll-forward.</p>
<p>Created 10/16/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a34f85036ad9ae5f3170690e670a37b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f85036ad9ae5f3170690e670a37b52">&#9670;&nbsp;</a></span>BTR_CUR_FINE_HISTORY_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_FINE_HISTORY_LENGTH&#160;&#160;&#160;100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the index-&gt;lock scalability improvement, only possibility of clear performance regression observed was caused by grown huge history list length. </p>
<p>That is because the exclusive use of index-&gt;lock also worked as reserving free blocks and read IO bandwidth with priority. To avoid huge glowing history list as same level with previous implementation, prioritizes pessimistic tree operations by purge as the previous, when it seems to be growing huge.</p>
<p>Experimentally, the history list length starts to affect to performance throughput clearly from about 100000. </p>

</div>
</div>
<a id="a4676319e3e8cde7d9790089fe965df40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4676319e3e8cde7d9790089fe965df40">&#9670;&nbsp;</a></span>BTR_CUR_PAGE_REORGANIZE_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_PAGE_REORGANIZE_LIMIT&#160;&#160;&#160;(UNIV_PAGE_SIZE / 32)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the optimistic insert, if the insert does not fit, but this much space can be released by page reorganize, then it is reorganized. </p>

</div>
</div>
<a id="a76518092843bb988e2222a5712cc0a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76518092843bb988e2222a5712cc0a9f">&#9670;&nbsp;</a></span>BTR_TABLE_STATS_FROM_SAMPLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_TABLE_STATS_FROM_SAMPLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sample, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ext_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">not_empty&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<a class="code" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>) * static_cast&lt;int64_t&gt;(<a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>-&gt;stat_n_leaf_pages) + (sample)-1 +    \</div><div class="line">    (ext_size) + (not_empty)) /                                                \</div><div class="line">   ((sample) + (ext_size)))</div><div class="ttc" id="mysql_8cc_html_adfa69ae672499b1037123a1f17c5552b"><div class="ttname"><a href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></div><div class="ttdeci">char * index(const char *, int c)</div><div class="ttdef"><b>Definition:</b> mysql.cc:2928</div></div>
<div class="ttc" id="persisted__variable_8cc_html_a211d620ef86d6a09b1d29b51b6e44f06"><div class="ttname"><a href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a></div><div class="ttdeci">const string value(&quot;\alue\)</div></div>
</div><!-- fragment -->
<p>Estimated table level stats from sampled value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>sampled stats </td></tr>
    <tr><td class="paramname">index</td><td>index being sampled </td></tr>
    <tr><td class="paramname">sample</td><td>number of sampled rows </td></tr>
    <tr><td class="paramname">ext_size</td><td>external stored data size </td></tr>
    <tr><td class="paramname">not_empty</td><td>table not empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated table wide stats from sampled value </dd></dl>

</div>
</div>
<a id="a9e4e31d2f2c964ed620e7379a4196fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e31d2f2c964ed620e7379a4196fbd">&#9670;&nbsp;</a></span>N_PAGES_READ_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define N_PAGES_READ_LIMIT&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aad1d9731b3089d61f713f3aba4b632c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1d9731b3089d61f713f3aba4b632c1">&#9670;&nbsp;</a></span>btr_intention_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modification types for the B-tree operation. </p>
<p>Note that the order of the enum values is important. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aad1d9731b3089d61f713f3aba4b632c1ae687d414d3d4f4e93b8a08e912e261b8"></a>BTR_INTENTION_DELETE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aad1d9731b3089d61f713f3aba4b632c1adc11887c56406bbdec889ab81c8fecd4"></a>BTR_INTENTION_BOTH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aad1d9731b3089d61f713f3aba4b632c1a0285d0eaa29fe5dd2c6345483103b9cc"></a>BTR_INTENTION_INSERT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e1e7dcb5ea919124b9d6e8e868bbc8">&#9670;&nbsp;</a></span>btr_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8">btr_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffered B-tree operation types, introduced as part of delete buffering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8a84f603208288c0b21ebee05430ca4229"></a>BTR_NO_OP&#160;</td><td class="fielddoc"><p>Not buffered. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8af727af06be5922ef5e53314387951e52"></a>BTR_INSERT_OP&#160;</td><td class="fielddoc"><p>Insert, do not ignore UNIQUE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8a791b52e53c17e5174c4a38d4b93d5fdb"></a>BTR_INSERT_IGNORE_UNIQUE_OP&#160;</td><td class="fielddoc"><p>Insert, ignoring UNIQUE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8a4d7f260f169e344aa04a3df1a3100c63"></a>BTR_DELETE_OP&#160;</td><td class="fielddoc"><p>Purge a delete-marked record. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8ac67a876f7a3a5ebc554eb5170a6604e4"></a>BTR_DELMARK_OP&#160;</td><td class="fielddoc"><p>Mark a record for deletion. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8d25b1d3defc3c7b44c623f71c32dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d25b1d3defc3c7b44c623f71c32dfce">&#9670;&nbsp;</a></span>btr_cur_add_path_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_add_path_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>root_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds path information to the cursor for the current page, for which the binary search has been performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Cursor positioned on a page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the page in the tree; 0 means leaf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_height</td><td>Root node height in true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64fd277719862187604bf48005ec191c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fd277719862187604bf48005ec191c">&#9670;&nbsp;</a></span>btr_cur_compress_if_useful()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_cur_compress_if_useful </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to compress a page of the tree if it seems useful. </p>
<p>It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. NOTE: it is assumed that the caller has reserved enough free extents so that the compression will always succeed if done! </p><dl class="section return"><dt>Returns</dt><dd>true if compression occurred </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to compress; cursor does not stay valid if !adjust and compression occurs </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a769cec83638735de3b95862c5d3ee139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769cec83638735de3b95862c5d3ee139">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks a clustered index record deleted. </p>
<p>Writes an undo log record to undo log on this delete marking. Writes in the trx id field the id of the deleting transaction, and in the roll ptr field pointer to the undo log record created. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of the record </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index of the record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">entry</td><td>in: dtuple for the deleting record, also contains the virtual cols if there are any </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a770e0a5b2cd615f9d598bb931b0474be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770e0a5b2cd615f9d598bb931b0474be">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_clust_rec_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_del_mark_set_clust_rec_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the redo log record for delete marking or unmarking of an index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr to the undo log record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a427aa7747fe4f0f2f0f75b14fb303906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427aa7747fe4f0f2f0f75b14fb303906">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_sec_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a secondary index record delete mark to TRUE or FALSE. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: locking flag </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78b5e425b158cb805c7a59d8d52ffc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b5e425b158cb805c7a59d8d52ffc10">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_sec_rec_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_del_mark_set_sec_rec_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the redo log record for a delete mark setting of a secondary index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a909bf67a15790602fbf94b34844bd2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909bf67a15790602fbf94b34844bd2ea">&#9670;&nbsp;</a></span>btr_cur_get_and_clear_intention()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a> btr_cur_get_and_clear_intention </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>latch_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets intention in btr_intention_t from latch_mode, and cleares the intention at the latch_mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch_mode</td><td>in/out: pointer to latch_mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>intention for latching tree </dd></dl>

</div>
</div>
<a id="a8bc22fea68de608924c4c8fef2fe9efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc22fea68de608924c4c8fef2fe9efd">&#9670;&nbsp;</a></span>btr_cur_ins_lock_and_undo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_ins_lock_and_undo </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For an insert, checks the locks and does the undo logging if desired. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameters index and thr should be specified </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on page after which to insert </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">inherit</td><td>out: TRUE if the inserted new record maybe should inherit LOCK_GAP type locks from the successor record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c725a67926c24150795756b7d924d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c725a67926c24150795756b7d924d23">&#9670;&nbsp;</a></span>btr_cur_insert_if_possible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* btr_cur_insert_if_possible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a record if there is enough space, or if enough space can be freed by reorganizing. </p>
<p>Differs from btr_cur_optimistic_insert because no heuristics is applied to whether it pays to use CPU time for reorganizing the page or not.</p>
<p>IMPORTANT: The caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking ibuf_reset_free_bits() before mtr_commit().</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to inserted record if succeed, else NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on page after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert; the size info need not have been stored to tuple </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad80dc41de91dd6745f80193fc78af64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80dc41de91dd6745f80193fc78af64e">&#9670;&nbsp;</a></span>btr_cur_latch_for_root_leaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a> btr_cur_latch_for_root_leaf </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the desired latch type for the root leaf (root page is root leaf) at the latch mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>latch type </dd></dl>

</div>
</div>
<a id="a6270343de26ab24466bb5980d91848e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6270343de26ab24466bb5980d91848e9">&#9670;&nbsp;</a></span>btr_cur_latch_leaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__latch__leaves__t.html">btr_latch_leaves_t</a> btr_cur_latch_leaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Latches the leaf page or pages requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Leaf page where the search converged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id of the leaf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">latch_mode</td><td>BTR_SEARCH_LEAF, ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cursor</td><td>Cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>blocks and savepoints which actually latched. </dd></dl>

</div>
</div>
<a id="a5075b2630cbd6c470fac6b1c9261041b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5075b2630cbd6c470fac6b1c9261041b">&#9670;&nbsp;</a></span>btr_cur_need_opposite_intention()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_cur_need_opposite_intention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a>&#160;</td>
          <td class="paramname"><em>lock_intention</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the modifying record might need a opposite modification to the intention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_intention</td><td>lock intention for the tree operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record (current node_ptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if tree modification is needed </dd></dl>

</div>
</div>
<a id="a5e2ef1b901ec66346efc1096bb1aeece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2ef1b901ec66346efc1096bb1aeece">&#9670;&nbsp;</a></span>btr_cur_open_at_index_side_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_cur_open_at_index_side_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a cursor at either end of an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_left</td><td>True if open to the low end, false if to the high end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">latch_mode</td><td>Latch mode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level to search for (0=leaf) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae37c362a21cd664ca4fe74169890e1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37c362a21cd664ca4fe74169890e1db">&#9670;&nbsp;</a></span>btr_cur_open_at_index_side_with_no_latch_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_cur_open_at_index_side_with_no_latch_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a cursor at either end of an index. </p>
<p>Avoid taking latches on buffer, just pin (by incrementing fix_count) to keep them in buffer pool. This mode is used by intrinsic table as they are not shared and so there is no need of latching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_left</td><td>true if open to low end, false if open to high end. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level to search for (0=leaf) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae97879c31eba0c93fdb888685580771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97879c31eba0c93fdb888685580771a">&#9670;&nbsp;</a></span>btr_cur_open_at_rnd_pos_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_cur_open_at_rnd_pos_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Positions a cursor at a randomly chosen position within a B-tree. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the index is available and we have put the cursor, false if the index is unavailable </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ... </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree cursor </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d02deb9d204909dbee067cb7e84c2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d02deb9d204909dbee067cb7e84c2a7">&#9670;&nbsp;</a></span>btr_cur_optimistic_delete_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_cur_optimistic_delete_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the record on which the tree cursor is positioned on a leaf page. </p>
<p>Removes the record on which the tree cursor is positioned.</p>
<p>It is assumed that the mtr has an x-latch on the page where the cursor is positioned, but no latch on the whole tree. </p><dl class="section return"><dt>Returns</dt><dd>true if success, i.e., the page did not become too empty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on leaf page, on the record to delete; cursor stays valid: if deletion succeeds, on function exit it points to the successor of the deleted record </td></tr>
    <tr><td class="paramname">flags</td><td>in: BTR_CREATE_FLAG or 0 </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; if this function returns TRUE on a leaf page of a secondary index, the mtr must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a755a5ffe53e178cb8e15738a9a57944c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755a5ffe53e178cb8e15738a9a57944c">&#9670;&nbsp;</a></span>btr_cur_optimistic_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to perform an insert to a page in an index tree, next to cursor. </p>
<p>It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page. If there is just one record on the page, the insert will always succeed; this is to prevent trying to split a page with just one record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameters index and thr should be specified </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on page after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this function returns DB_SUCCESS on a leaf page of a secondary index in a compressed tablespace, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a367d84590d5ae4ceb873a30c7d2a7b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367d84590d5ae4ceb873a30c7d2a7b4d">&#9670;&nbsp;</a></span>btr_cur_optimistic_latch_leaves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_cur_optimistic_latch_leaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>modify_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimistically latches the leaf page or pages requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Guessed buffer block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify_clock</td><td>Modify clock value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">latch_mode</td><td>BTR_SEARCH_LEAF, ... </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>

</div>
</div>
<a id="a4daa7a19fdc8383127085073ea67bea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4daa7a19fdc8383127085073ea67bea9">&#9670;&nbsp;</a></span>btr_cur_optimistic_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to update a record on a page in an index tree. </p>
<p>It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page or if the update would result in too empty a page, so that tree compression is recommended. We assume here that the ordering fields of the record do not change. </p><dl class="section return"><dt>Returns</dt><dd>error code, including </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_OVERFLOW</td><td>if the updated record does not fit </td></tr>
    <tr><td class="paramname">DB_UNDERFLOW</td><td>if the page would become too empty </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page (IBUF_BITMAP_FREE was reset outside mtr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to NULL or memory heap </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector; this must also contain trx id and roll ptr fields </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread, or NULL if flags &amp; (BTR_NO_UNDO_LOG_FLAG | BTR_NO_LOCKING_FLAG | BTR_CREATE_FLAG | BTR_KEEP_SYS_FLAG) </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63c486e1078df1872ee87c377006674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c486e1078df1872ee87c377006674a">&#9670;&nbsp;</a></span>btr_cur_parse_del_mark_set_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* btr_cur_parse_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the redo log record for delete marking or unmarking of a clustered index record. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index corresponding to page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c0c1be287e095e69d5f46809e583700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0c1be287e095e69d5f46809e583700">&#9670;&nbsp;</a></span>btr_cur_parse_del_mark_set_sec_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* btr_cur_parse_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the redo log record for delete marking or unmarking of a secondary index record. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2779e13e725b69e10b92eba034a1a143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2779e13e725b69e10b92eba034a1a143">&#9670;&nbsp;</a></span>btr_cur_parse_update_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* btr_cur_parse_update_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a redo log record of updating a record in-place. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index corresponding to page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a8df6cc43f61d2a90dceb886983ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a8df6cc43f61d2a90dceb886983ef9">&#9670;&nbsp;</a></span>btr_cur_pess_upd_restore_supremum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_pess_upd_restore_supremum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If, in a split, a new supremum record was created as the predecessor of the updated record, the supremum record must inherit exactly the locks on the updated record. </p>
<p>In the split it may have inherited locks from the successor of the updated record, which is not correct. This function restores the right locks for the new supremum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: updated record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52504db19be214f5fa7d0fa804657cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52504db19be214f5fa7d0fa804657cc">&#9670;&nbsp;</a></span>btr_cur_pessimistic_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_cur_pessimistic_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>has_reserved_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>rollback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a4661d2883c1cd5d8f1cfbd63b553f1bc">undo_no_t</a>&#160;</td>
          <td class="paramname"><em>undo_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rec_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the record on which the tree cursor is positioned. </p>
<p>Tries to compress the page if its fillfactor drops below a threshold or if it is the only page on the level. It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>DB_SUCCESS or DB_OUT_OF_FILE_SPACE; the latter may occur because we may have to update node pointers on upper levels, and in the case of variable length keys these may actually grow in size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">has_reserved_extents</td><td>TRUE if the caller has already reserved enough free extents so that he knows that the operation will succeed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cursor</td><td>Cursor on the record to delete; if compression does not occur, the cursor stays valid: it points to successor of deleted record on function exit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>BTR_CREATE_FLAG or 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rollback</td><td>True if performing rollback, false otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>The current transaction id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">undo_no</td><td>Undo number of the transaction. This is needed for rollback to savepoint of partially updated LOB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_type</td><td>Undo record type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcur</td><td>Persistent cursor on the record to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if compression occurred </dd></dl>

</div>
</div>
<a id="aca2f4cf3c619c6630d174de684f44f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2f4cf3c619c6630d174de684f44f80">&#9670;&nbsp;</a></span>btr_cur_pessimistic_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an insert on a page of an index tree. </p>
<p>It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the insert is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameter thr should be specified; if no undo logging is specified, then the caller must have reserved enough free extents in the file space so that the insertion will certainly succeed </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88683e53b86efea31be52cf349bdca78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88683e53b86efea31be52cf349bdca78">&#9670;&nbsp;</a></span>btr_cur_pessimistic_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>entry_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a4661d2883c1cd5d8f1cfbd63b553f1bc">undo_no_t</a>&#160;</td>
          <td class="paramname"><em>undo_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an update of a record on a page of a tree. </p>
<p>It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the update is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Undo logging, locking, and rollback flags </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>cursor on the record to update; cursor may become invalid if *big_rec == NULL || !(flags &amp; BTR_KEEP_POS_FLAG) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offsets</td><td>Offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets_heap</td><td>Pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry_heap</td><td>Memory heap for allocating big_rec and the index tuple. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">big_rec</td><td>Big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">update</td><td>Update vector; this is allowed to also contain trx id and roll ptr fields. Non-updated columns that are moved offpage will be appended to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmpl_info</td><td>Compiler info on secondary index updates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>Query thread, or NULL if flags &amp; (BTR_NO_UNDO_LOG_FLAG | BTR_NO_LOCKING_FLAG | BTR_CREATE_FLAG | BTR_KEEP_SYS_FLAG) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Transaction id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">undo_no</td><td>Undo number of the transaction. This is needed for rollback to savepoint of partially updated LOB. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction; must be committed before latching any further pages </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcur</td><td>The persistent cursor on the record to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="a09e611f6cfd79cf807d5ef14e3b842f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e611f6cfd79cf807d5ef14e3b842f7">&#9670;&nbsp;</a></span>btr_cur_prefetch_siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_prefetch_siblings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefetch siblings of the leaf for the pessimistic operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>leaf page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a542936a2ff210fb6502b04fd367a1ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542936a2ff210fb6502b04fd367a1ae0">&#9670;&nbsp;</a></span>btr_cur_search_to_nth_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_cur_search_to_nth_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>has_search_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches an index tree and positions a tree cursor on a given level. </p>
<p>NOTE: n_fields_cmp in tuple must be set so that it cannot be compared to node pointer page number fields on the upper levels of the tree! Note that if mode is PAGE_CUR_LE, which is used in inserts, then cursor-&gt;up_match and cursor-&gt;low_match both will have sensible values. If mode is PAGE_CUR_GE, then up_match will a have a sensible value.</p>
<p>If mode is PAGE_CUR_LE , cursor is left at the place where an insert of the search tuple should be performed in the B-tree. InnoDB does an insert immediately after the cursor. Thus, the cursor may end up on a user record, or on a page infimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: the tree level of search </td></tr>
    <tr><td class="paramname">tuple</td><td>in: data tuple; NOTE: n_fields_cmp in tuple must be set so that it cannot get compared to the node ptr page number field! </td></tr>
    <tr><td class="paramname">mode</td><td>in: PAGE_CUR_L, ...; Inserts should always be made using PAGE_CUR_LE to search the position! </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ..., ORed with at most one of BTR_INSERT, BTR_DELETE_MARK, BTR_DELETE, or BTR_ESTIMATE; cursor-&gt;left_block is used to store a pointer to the left neighbor page, in the cases BTR_SEARCH_PREV and BTR_MODIFY_PREV; NOTE that if has_search_latch is != 0, we maybe do not have a latch set on the cursor page, we assume the caller uses his search latch to protect the record! </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: tree cursor; the cursor page is s- or x-latched, but see also above! </td></tr>
    <tr><td class="paramname">has_search_latch</td><td>in: info on the latch mode the caller currently has on search system: RW_S_LATCH, or 0 </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afabcd3b0d78376d6d3b819d738aaae07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabcd3b0d78376d6d3b819d738aaae07">&#9670;&nbsp;</a></span>btr_cur_search_to_nth_level_with_no_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_cur_search_to_nth_level_with_no_latch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>mark_dirty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches an index tree and positions a tree cursor on a given level. </p>
<p>This function will avoid placing latches while traversing the path and so should be used only for cases where-in latching is not needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The tree level of search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>Data tuple; Note: n_fields_cmp in compared to the node ptr page node field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>PAGE_CUR_L, .... Insert should always be made using PAGE_CUR_LE to search the position. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Tree cursor; points to record of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mark_dirty</td><td>if true then mark the block as dirty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af010a9efa9efe7a02c590a268e7d810d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af010a9efa9efe7a02c590a268e7d810d">&#9670;&nbsp;</a></span>btr_cur_set_deleted_flag_for_ibuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_cur_set_deleted_flag_for_ibuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a secondary index record's delete mark to the given value. </p>
<p>This function is only used by the insert buffer merge mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page corresponding to rec, or NULL when the tablespace is uncompressed </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1f1fed8ce2d391e0cc53d0d59ff3d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f1fed8ce2d391e0cc53d0d59ff3d07">&#9670;&nbsp;</a></span>btr_cur_upd_lock_and_undo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_upd_lock_and_undo </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For an update, checks the locks and does the undo logging. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on record to update </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets() on cursor </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread (can be NULL if BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>out: roll pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfdc46d486a27aa882f0c8f80cbf09c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdc46d486a27aa882f0c8f80cbf09c4">&#9670;&nbsp;</a></span>btr_cur_update_alloc_zip_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_cur_update_alloc_zip_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if there is enough place in the page modification log to log an update-in-place. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if out of space; IBUF_BITMAP_FREE will be reset outside mtr if the page was recompressed </td></tr>
    <tr><td class="paramname">true</td><td>if enough place;</td></tr>
  </table>
  </dd>
</dl>
<p>IMPORTANT: The caller will have to update IBUF_BITMAP_FREE if this is a secondary index leaf page. This has to be done either within the same mini-transaction, or by invoking ibuf_reset_free_bits() before mtr_commit(mtr). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index corresponding to cursor </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets of the cursor record </td></tr>
    <tr><td class="paramname">length</td><td>in: size needed </td></tr>
    <tr><td class="paramname">create</td><td>in: true=delete-and-insert, false=update-in-place </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f42051e928b6c3f72b7fc3bb59293a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f42051e928b6c3f72b7fc3bb59293a0">&#9670;&nbsp;</a></span>btr_cur_update_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_update_in_place </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a record when the update causes no size changes in its fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Undo logging and locking flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cursor</td><td>Cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>Offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>Update vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmpl_info</td><td>Compiler info on secondary index updates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>Query thread, or null if flags &amp; (btr_no_locking_flag | btr_no_undo_log_flag | btr_create_flag | btr_keep_sys_flag) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Transaction id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>locking or undo log related error code, or </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page (IBUF_BITMAP_FREE was reset outside mtr) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbe0bb94cee5310f935edc06c06ece60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe0bb94cee5310f935edc06c06ece60">&#9670;&nbsp;</a></span>btr_cur_update_in_place_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_cur_update_in_place_log </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a redo log record of updating a record in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Undo logging and locking flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>Update vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Transaction id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll_ptr</td><td>Roll ptr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad67c9549d39c7424a689f4382480f1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67c9549d39c7424a689f4382480f1a0">&#9670;&nbsp;</a></span>btr_cur_will_modify_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_cur_will_modify_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btr0cur_8cc.html#aad1d9731b3089d61f713f3aba4b632c1">btr_intention_t</a>&#160;</td>
          <td class="paramname"><em>lock_intention</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rec_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the modifying record might need a modifying tree structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_intention</td><td>lock intention for the tree operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record (current node_ptr) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_size</td><td>size of the record or max size of node_ptr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if tree modification is needed </dd></dl>

</div>
</div>
<a id="ab2103e405e81402bc71b951afb1e583c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2103e405e81402bc71b951afb1e583c">&#9670;&nbsp;</a></span>btr_estimate_n_rows_in_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t btr_estimate_n_rows_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the number of rows in a given index range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple1</td><td>range start, may also be empty tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode1</td><td>search mode for range start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple2</td><td>range end, may also be empty tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode2</td><td>search mode for range end </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated number of rows </dd></dl>

</div>
</div>
<a id="a6808d869e61ef7da5d5393341dbefd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6808d869e61ef7da5d5393341dbefd61">&#9670;&nbsp;</a></span>btr_estimate_n_rows_in_range_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t btr_estimate_n_rows_in_range_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nth_attempt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates the number of rows in a given index range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple1</td><td>range start, may also be empty tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode1</td><td>search mode for range start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple2</td><td>range end, may also be empty tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode2</td><td>search mode for range end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nth_attempt</td><td>if the tree gets modified too much while we are trying to analyze it, then we will retry (this function will call itself, incrementing this parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated number of rows; if after rows_in_range_max_retries retries the tree keeps changing, then we will just return rows_in_range_arbitrary_ret_val as a result (if nth_attempt &gt;= rows_in_range_max_retries and the tree is modified between the two dives). </dd></dl>

</div>
</div>
<a id="a500234d32d851da1930f5d459b88f2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500234d32d851da1930f5d459b88f2dd">&#9670;&nbsp;</a></span>btr_estimate_n_rows_in_range_on_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t btr_estimate_n_rows_in_range_on_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__path__t.html">btr_path_t</a> *&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__path__t.html">btr_path_t</a> *&#160;</td>
          <td class="paramname"><em>slot2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n_rows_on_prev_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>is_n_rows_exact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the number of rows between slot1 and slot2 for any level on a B-tree. </p>
<p>This function starts from slot1-&gt;page and reads a few pages to the right, counting their records. If we reach slot2-&gt;page quickly then we know exactly how many records there are between slot1 and slot2 and we set is_n_rows_exact to TRUE. If we cannot reach slot2-&gt;page quickly then we calculate the average number of records in the pages scanned so far and assume that all pages that we did not scan up to slot2-&gt;page contain the same number of records, then we multiply that average to the number of pages between slot1-&gt;page and slot2-&gt;page (which is n_rows_on_prev_level). In this case we set is_n_rows_exact to FALSE. </p><dl class="section return"><dt>Returns</dt><dd>number of rows, not including the borders (exact or estimated) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">slot1</td><td>in: left border </td></tr>
    <tr><td class="paramname">slot2</td><td>in: right border </td></tr>
    <tr><td class="paramname">n_rows_on_prev_level</td><td>in: number of rows on the previous level for the same descend paths; used to determine the number of pages on this level </td></tr>
    <tr><td class="paramname">is_n_rows_exact</td><td>out: TRUE if the returned value is exact i.e. not an estimation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f4bd3b42e8c550c943089ebef00fe54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4bd3b42e8c550c943089ebef00fe54">&#9670;&nbsp;</a></span>btr_estimate_number_of_different_key_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_estimate_number_of_different_key_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the number of different key values in a given index, for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index). </p>
<p>The estimates are stored in the array index-&gt;stat_n_diff_key_vals[] (indexed 0..n_uniq-1) and the number of pages that were sampled is saved in index-&gt;stat_n_sample_sizes[]. If innodb_stats_method is nulls_ignored, we also record the number of non-null values for each prefix and stored the estimates in array index-&gt;stat_n_non_null_key_vals. </p><dl class="section return"><dt>Returns</dt><dd>true if the index is available and we get the estimated numbers, false if the index is unavailable. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3504db9f888c4d4994bf1b8a894b8b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3504db9f888c4d4994bf1b8a894b8b90">&#9670;&nbsp;</a></span>btr_record_not_null_field_in_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_record_not_null_field_in_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t *&#160;</td>
          <td class="paramname"><em>n_not_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the number of non_null key values in a given index for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index). </p>
<p>The estimates are eventually stored in the array: index-&gt;stat_n_non_null_key_vals[], which is indexed from 0 to n-1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_unique</td><td>in: dict_index_get_n_unique(index), number of columns uniquely determine an index entry </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index), its size could be for all fields or that of "n_unique" </td></tr>
    <tr><td class="paramname">n_not_null</td><td>in/out: array to record number of not null rows for n-column prefix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2f6f6e317169b84969361e99eb711b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6f6e317169b84969361e99eb711b3b">&#9670;&nbsp;</a></span>btr_cur_limit_optimistic_insert_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> btr_cur_limit_optimistic_insert_debug = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b7a92b1123d6493729904f846f05a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7a92b1123d6493729904f846f05a03">&#9670;&nbsp;</a></span>btr_cur_n_non_sea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_non_sea = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of searches down the B-tree in btr_cur_search_to_nth_level(). </p>

</div>
</div>
<a id="aefef1d2e4bf03540d18ff799bf9c0a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefef1d2e4bf03540d18ff799bf9c0a74">&#9670;&nbsp;</a></span>btr_cur_n_non_sea_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_non_sea_old = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Old value of btr_cur_n_non_sea. </p>
<p>Copied by srv_refresh_innodb_monitor_stats(). Referenced by srv_printf_innodb_monitor(). </p>

</div>
</div>
<a id="ae0b3d4f868488aa0addf8d9fa32df663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b3d4f868488aa0addf8d9fa32df663">&#9670;&nbsp;</a></span>btr_cur_n_sea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_sea = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of successful adaptive hash index lookups in btr_cur_search_to_nth_level(). </p>

</div>
</div>
<a id="a8df6a65d39b12848a998a57d2cc328d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df6a65d39b12848a998a57d2cc328d0">&#9670;&nbsp;</a></span>btr_cur_n_sea_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_sea_old = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Old value of btr_cur_n_sea. </p>
<p>Copied by srv_refresh_innodb_monitor_stats(). Referenced by srv_printf_innodb_monitor(). </p>

</div>
</div>
<a id="aac122e9c1be72af8a9ce9a2f2f30fb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac122e9c1be72af8a9ce9a2f2f30fb14">&#9670;&nbsp;</a></span>rows_in_range_arbitrary_ret_val</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t rows_in_range_arbitrary_ret_val = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We pretend that a range has that many records if the tree keeps changing for rows_in_range_max_retries retries while we try to estimate the records in a given range. </p>

</div>
</div>
<a id="ab400468c95b15bab3a9171ddd005f6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab400468c95b15bab3a9171ddd005f6aa">&#9670;&nbsp;</a></span>rows_in_range_max_retries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned rows_in_range_max_retries = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the tree gets changed too much between the two dives for the left and right boundary then btr_estimate_n_rows_in_range_low() will retry that many times before giving up and returning the value stored in rows_in_range_arbitrary_ret_val. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_f48f5f24c3af6e5b48618127168756b9.html">btr</a></li><li class="navelem"><a class="el" href="btr0cur_8cc.html">btr0cur.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
