<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: sql/sql_tmp_table.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sql__tmp__table_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sql_tmp_table.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Temporary table handling functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="my__base_8h_source.html">my_base.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__inttypes_8h_source.html">my_inttypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="item_8h_source.html">sql/item.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="temp__table__param_8h_source.html">sql/temp_table_param.h</a>&quot;</code><br />
</div>
<p><a href="sql__tmp__table_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classList.html">List&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a31abbe04a5efec8e7bd7d802716ec289"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a31abbe04a5efec8e7bd7d802716ec289">enum_internal_tmp_mem_storage_engine</a> { <a class="el" href="sql__tmp__table_8h.html#a31abbe04a5efec8e7bd7d802716ec289aad8733ff09ba11677618af18cdab4c38">TMP_TABLE_MEMORY</a>, 
<a class="el" href="sql__tmp__table_8h.html#a31abbe04a5efec8e7bd7d802716ec289a70e383ad49cd0ae7a6678b3d7b505765">TMP_TABLE_TEMPTABLE</a>
 }</td></tr>
<tr class="separator:a31abbe04a5efec8e7bd7d802716ec289"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9583199306abbe9c382cd7cee73bc1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a9583199306abbe9c382cd7cee73bc1d5">create_tmp_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, <a class="el" href="structORDER.html">ORDER</a> *group, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> distinct, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> save_sum_fields, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> select_options, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> rows_limit, const char *table_alias)</td></tr>
<tr class="separator:a9583199306abbe9c382cd7cee73bc1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b731f0ef0953b3406adc1383bfed7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#ab6b731f0ef0953b3406adc1383bfed7d">open_tmp_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ab6b731f0ef0953b3406adc1383bfed7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ad810de493a138a0c5979a8d9d3794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a87ad810de493a138a0c5979a8d9d3794">create_tmp_table_from_fields</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; &amp;field_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_virtual=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> select_options=0, const char *alias=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:a87ad810de493a138a0c5979a8d9d3794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an, optionally reduced, TABLE object with properly set up Field list from a list of field definitions.  <a href="#a87ad810de493a138a0c5979a8d9d3794">More...</a><br /></td></tr>
<tr class="separator:a87ad810de493a138a0c5979a8d9d3794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231fffba10cb15bd9de8dc6ceb5aaf94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a231fffba10cb15bd9de8dc6ceb5aaf94">create_ondisk_from_heap</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, int error, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ignore_last_dup, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *<a class="el" href="pfs__example__employee__name_8cc.html#a74fccabad4135c2a5a2e7eb8f939bac4">is_duplicate</a>)</td></tr>
<tr class="memdesc:a231fffba10cb15bd9de8dc6ceb5aaf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a MEMORY table gets full, create a disk-based table and copy all rows to this.  <a href="#a231fffba10cb15bd9de8dc6ceb5aaf94">More...</a><br /></td></tr>
<tr class="separator:a231fffba10cb15bd9de8dc6ceb5aaf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58804ac1c656953403c8c84b643294ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a58804ac1c656953403c8c84b643294ec">close_tmp_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>)</td></tr>
<tr class="memdesc:a58804ac1c656953403c8c84b643294ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a temporary table at end of preparation or execution.  <a href="#a58804ac1c656953403c8c84b643294ec">More...</a><br /></td></tr>
<tr class="separator:a58804ac1c656953403c8c84b643294ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d90d0f88f88efb319ad1531079720e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a9d90d0f88f88efb319ad1531079720e4">free_tmp_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>)</td></tr>
<tr class="memdesc:a9d90d0f88f88efb319ad1531079720e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free temporary table.  <a href="#a9d90d0f88f88efb319ad1531079720e4">More...</a><br /></td></tr>
<tr class="separator:a9d90d0f88f88efb319ad1531079720e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9e476ed3103722f6797275569bcef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a05f9e476ed3103722f6797275569bcef">create_duplicate_weedout_tmp_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> uniq_tuple_length_arg, <a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *sjtbl)</td></tr>
<tr class="memdesc:a05f9e476ed3103722f6797275569bcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a temporary table to weed out duplicate rowid combinations.  <a href="#a05f9e476ed3103722f6797275569bcef">More...</a><br /></td></tr>
<tr class="separator:a05f9e476ed3103722f6797275569bcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06373a361b79e80f99e07dd5936723e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a06373a361b79e80f99e07dd5936723e0">setup_tmp_table_handler</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> select_options, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> force_disk_table=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> schema_table=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a06373a361b79e80f99e07dd5936723e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create_tmp_table_* family for setting up table's SE.  <a href="#a06373a361b79e80f99e07dd5936723e0">More...</a><br /></td></tr>
<tr class="separator:a06373a361b79e80f99e07dd5936723e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd008c63435583d145d2d0e4827708c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#afd008c63435583d145d2d0e4827708c4">instantiate_tmp_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:afd008c63435583d145d2d0e4827708c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates temporary table.  <a href="#afd008c63435583d145d2d0e4827708c4">More...</a><br /></td></tr>
<tr class="separator:afd008c63435583d145d2d0e4827708c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd6cecda8880004fc82ea29e256a01d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a1bd6cecda8880004fc82ea29e256a01d">create_tmp_field</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classItem.html#a6b718f9918eb7a5b2d4572cc1a231005">Item::Type</a> type, <a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *copy_func, <a class="el" href="classField.html">Field</a> **from_field, <a class="el" href="classField.html">Field</a> **default_field, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> group, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> modify_item, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> table_cant_handle_bit_fields, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> make_copy_field, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> copy_result_field=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a1bd6cecda8880004fc82ea29e256a01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create field for temporary table.  <a href="#a1bd6cecda8880004fc82ea29e256a01d">More...</a><br /></td></tr>
<tr class="separator:a1bd6cecda8880004fc82ea29e256a01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628b73c62c97f1fb526e97339bfbec06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#a628b73c62c97f1fb526e97339bfbec06">create_tmp_field_from_field</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="classField.html">Field</a> *org_field, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classItem__field.html">Item_field</a> *item)</td></tr>
<tr class="memdesc:a628b73c62c97f1fb526e97339bfbec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifecycle management of internal temporary tables.  <a href="#a628b73c62c97f1fb526e97339bfbec06">More...</a><br /></td></tr>
<tr class="separator:a628b73c62c97f1fb526e97339bfbec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb717d5f7cb6edac609bef3981598c3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#abb717d5f7cb6edac609bef3981598c3e">get_max_key_and_part_length</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *max_key_length, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *max_key_part_length, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *max_key_parts)</td></tr>
<tr class="memdesc:abb717d5f7cb6edac609bef3981598c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum of max_key_length and max_key_part_length between HEAP engine and internal_tmp_disk_storage_engine.  <a href="#abb717d5f7cb6edac609bef3981598c3e">More...</a><br /></td></tr>
<tr class="separator:abb717d5f7cb6edac609bef3981598c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b030319fe92a064c1c0a930289225b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#ad6b030319fe92a064c1c0a930289225b">init_cache_tmp_engine_properties</a> ()</td></tr>
<tr class="memdesc:ad6b030319fe92a064c1c0a930289225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the storage engine properties for the alternative temporary table storage engines.  <a href="#ad6b030319fe92a064c1c0a930289225b">More...</a><br /></td></tr>
<tr class="separator:ad6b030319fe92a064c1c0a930289225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee806b2c5151b4c7c50b89d67e2b04a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#aaee806b2c5151b4c7c50b89d67e2b04a">encode_innodb_position</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *rowid_bytes, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> length, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> row_num)</td></tr>
<tr class="memdesc:aaee806b2c5151b4c7c50b89d67e2b04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an InnoDB PK in 6 bytes, high-byte first; like InnoDB's dict_sys_write_row_id() does.  <a href="#aaee806b2c5151b4c7c50b89d67e2b04a">More...</a><br /></td></tr>
<tr class="separator:aaee806b2c5151b4c7c50b89d67e2b04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33bfb8c4596076edd46ffaa0a9f5fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#aa33bfb8c4596076edd46ffaa0a9f5fd4">reposition_innodb_cursor</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> row_num)</td></tr>
<tr class="memdesc:aa33bfb8c4596076edd46ffaa0a9f5fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for create_ondisk_from_heap().  <a href="#aa33bfb8c4596076edd46ffaa0a9f5fd4">More...</a><br /></td></tr>
<tr class="separator:aa33bfb8c4596076edd46ffaa0a9f5fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Temporary table handling functions. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a31abbe04a5efec8e7bd7d802716ec289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31abbe04a5efec8e7bd7d802716ec289">&#9670;&nbsp;</a></span>enum_internal_tmp_mem_storage_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sql__tmp__table_8h.html#a31abbe04a5efec8e7bd7d802716ec289">enum_internal_tmp_mem_storage_engine</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a31abbe04a5efec8e7bd7d802716ec289aad8733ff09ba11677618af18cdab4c38"></a>TMP_TABLE_MEMORY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31abbe04a5efec8e7bd7d802716ec289a70e383ad49cd0ae7a6678b3d7b505765"></a>TMP_TABLE_TEMPTABLE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a58804ac1c656953403c8c84b643294ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58804ac1c656953403c8c84b643294ec">&#9670;&nbsp;</a></span>close_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a temporary table at end of preparation or execution. </p>
<p>Any buffers associated with the table will be released. When tmp_handler_count reaches zero, the following will happen:</p><ul>
<li>If table contents has been created, it will be deleted.</li>
<li>If a storage handler has been allocated, it will be deleted and the plugin will be released.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">entry</td><td>Table reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f9e476ed3103722f6797275569bcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f9e476ed3103722f6797275569bcef">&#9670;&nbsp;</a></span>create_duplicate_weedout_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* create_duplicate_weedout_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>uniq_tuple_length_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>sjtbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a temporary table to weed out duplicate rowid combinations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">uniq_tuple_length_arg</td><td>Length of the table's column </td></tr>
    <tr><td class="paramname">sjtbl</td><td>Update sjtbl-&gt;[start_]recinfo values which will be needed if we'll need to convert the created temptable from HEAP to MyISAM/Maria.</td></tr>
  </table>
  </dd>
</dl>
<p>create_duplicate_weedout_tmp_table()</p>
<p>Create a temporary table to weed out duplicate rowid combinations. The table has a single column that is a concatenation of all rowids in the combination.</p>
<p>Depending on the needed length, there are two cases:</p>
<ol type="1">
<li><p class="startli">When the length of the column &lt; max_key_length:</p>
<p class="startli">CREATE TABLE tmp (col VARBINARY(n) NOT NULL, UNIQUE KEY(col));</p>
</li>
<li><p class="startli">Otherwise (not a valid SQL syntax but internally supported):</p>
<p class="startli">CREATE TABLE tmp (col VARBINARY NOT NULL, UNIQUE CONSTRAINT(col));</p>
</li>
</ol>
<p>The code in this function was produced by extraction of relevant parts from create_tmp_table().</p>
<dl class="section return"><dt>Returns</dt><dd>created table NULL on error </dd></dl>

</div>
</div>
<a id="a231fffba10cb15bd9de8dc6ceb5aaf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231fffba10cb15bd9de8dc6ceb5aaf94">&#9670;&nbsp;</a></span>create_ondisk_from_heap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> create_ondisk_from_heap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>wtable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_last_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>is_duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a MEMORY table gets full, create a disk-based table and copy all rows to this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>THD reference </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">wtable</td><td>Table reference being written to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error</td><td>Reason why inserting into MEMORY table failed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ignore_last_dup</td><td>If true, ignore duplicate key error for last inserted key (see detailed description below). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_duplicate</td><td>if non-NULL and ignore_last_dup is true, return true if last key was a duplicate, and false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p>Function can be called with any error code, but only HA_ERR_RECORD_FILE_FULL will be handled, all other errors cause a fatal error to be thrown. The function creates a disk-based temporary table, copies all records from the MEMORY table into this new table, deletes the old table and switches to use the new table within the table handle. The function uses table-&gt;record[1] as a temporary buffer while copying.</p>
<p>The function assumes that table-&gt;record[0] contains the row that caused the error when inserting into the MEMORY table (the "last row"). After all existing rows have been copied to the new table, the last row is attempted to be inserted as well. If ignore_last_dup is true, this row can be a duplicate of an existing row without throwing an error. If is_duplicate is non-NULL, an indication of whether the last row was a duplicate is returned.</p>
<dl class="section note"><dt>Note</dt><dd>that any index/scan access initialized on the MEMORY 'wtable' is not replicated to the on-disk table - it's the caller's responsibility. However, access initialized on other TABLEs, is replicated.</dd></dl>
<p>If 'wtable' has other TABLE clones (example: a multi-referenced or a recursive CTE), we convert all clones; if an error happens during conversion of clone B after successfully converting clone A, clone A and B will exit from the function with a TABLE_SHARE corresponding to the pre-conversion table ("old" TABLE_SHARE). So A will be inconsistent (for example s-&gt;db_type() will say "MEMORY" while A-&gt;file will be a disk-based engine). However, as all callers bail out, it is reasonable to think that they won't be using the TABLE_SHARE except in free_tmp_table(); and free_tmp_table() only uses properties of TABLE_SHARE which are common to the old and new object (reference counts, MEM_ROOT), so that should work. Solutions to fix this cleanly:</p><ul>
<li>allocate new TABLE_SHARE on heap instead of on stack, to be able to exit with two TABLE_SHAREs (drawback: more heap memory consumption, and need to verify all exit paths are safe),</li>
<li>close all TABLEs if error (but then callers and cleanup code may be surprised to find already-closed tables so they would need fixing). To lower the risk of error between A and B: we expect most errors will happen when copying rows (e.g. read or write errors); so we convert 'wtable' (which does the row copying) first; if it fails, the A-B situation is avoided and we can properly exit with the old TABLE_SHARE.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if error. </dd></dl>

</div>
</div>
<a id="a1bd6cecda8880004fc82ea29e256a01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd6cecda8880004fc82ea29e256a01d">&#9670;&nbsp;</a></span>create_tmp_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* create_tmp_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html#a6b718f9918eb7a5b2d4572cc1a231005">Item::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *&#160;</td>
          <td class="paramname"><em>copy_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>from_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>default_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>modify_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>table_cant_handle_bit_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>make_copy_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>copy_result_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create field for temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>Temporary table </td></tr>
    <tr><td class="paramname">item</td><td>Item to create a field for </td></tr>
    <tr><td class="paramname">type</td><td>Type of item (normally item-&gt;type) </td></tr>
    <tr><td class="paramname">copy_func</td><td>If set and item is a function, store copy of item in this array </td></tr>
    <tr><td class="paramname">from_field</td><td>if field will be created using other field as example, pointer example field will be written here </td></tr>
    <tr><td class="paramname">default_field</td><td>If field has a default value field, store it here </td></tr>
    <tr><td class="paramname">group</td><td>1 if we are going to do a relative group by on result </td></tr>
    <tr><td class="paramname">modify_item</td><td>1 if item-&gt;result_field should point to new item. This is relevent for how fill_record() is going to work: If modify_item is 1 then fill_record() will update the record in the original table. If modify_item is 0 then fill_record() will update the temporary table </td></tr>
    <tr><td class="paramname">table_cant_handle_bit_fields</td><td>if table can't handle bit-fields and bit-fields shall be converted to long </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Temp_table_param::bit_fields_as_long </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">make_copy_field</td><td>if true, a pointer of the result field should be stored in from_field, otherwise the item should be wrapped in Func_ptr and stored in copy_func </td></tr>
    <tr><td class="paramname">copy_result_field</td><td>true &lt;=&gt; save item's result_field in the from_field arg, before changing it. This is used for a window's OUT table when window uses frame buffer to copy a function's result field from OUT table to frame buffer (and back). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>that the goals of 'from_field' when this argument is true and when it is false, are different.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>On error.</td></tr>
    <tr><td class="paramname">new_created</td><td>field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a628b73c62c97f1fb526e97339bfbec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628b73c62c97f1fb526e97339bfbec06">&#9670;&nbsp;</a></span>create_tmp_field_from_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* create_tmp_field_from_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>org_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lifecycle management of internal temporary tables. </p>
<p>An internal temporary table is represented by a TABLE_SHARE object.</p>
<p>The interface to an internal temporary table is through one or more TABLE objects, of which at most one TABLE object is a writer object, the remaining TABLE objects are reader objects. Each TABLE object points to the TABLE_SHARE. TABLE_SHARE::ref_count counts the number of TABLE objects that points to it.</p>
<p>The TABLE, TABLE_SHARE and associated objects (e.g Field objects) are created in a dedicated mem_root. This mem_root is deleted when the TABLE_SHARE object is deleted.</p>
<p>Initially, an internal temporary table is created with one TABLE_SHARE object and one TABLE object. The table is created with no file handler (storage engine) and in the "deleted" state. Later, more TABLE objects may be created against the table, and TABLE_SHARE::ref_count is increased.</p>
<p>An internal temporary table may be instantiated and used multiple times, typically once per execution of a statement.</p>
<p>To instantiate a table, call instantiate_tmp_table(). This function will first assign and lock a storage engine using setup_tmp_table_handler(). The locked engine is assigned to TABLE_SHARE::db_plugin and the file handler is assigned to TABLE::file. After this, calling TABLE::has_storage_handler() reports true.</p>
<p>After this, the table contents is created by calling TABLE::file-&gt;create() and the table is opened by calling open_tmp_table(), which itself calls TABLE::file-&gt;ha_open(), increments TABLE_SHARE::tmp_handler_count to indicate the number of active TABLE handles to this table, and sets the TABLE::created flag.</p>
<p>To open an already instantiated table, assign a storage handler by calling setup_tmp_table_handler(), then call open_tmp_table() which will again increment TABLE_SHARE::tmp_handler_count and set TABLE::created.</p>
<p>Insert, update, delete and read rows using the active TABLE handlers.</p>
<p>After use, close all active TABLE handlers by calling close_tmp_table(). For simplicity, we may also call close_tmp_table() on a non-active TABLE, as it will check whether a storage handler has been assigned.</p>
<p>If the table is created, TABLE_SHARE::tmp_handler_count is decremented. If there are no remaining active TABLE objects, delete the table contents by calling TABLE::file-&gt;ha_drop_table(), otherwise close it by calling TABLE::file-&gt;ha_close(). Set status of the TABLE to deleted and delete the storage handler. If there are no remaining active tables and the storage engine is still locked, unlock the plugin and disassociate it from the TABLE_SHARE object.</p>
<p>After the final instantiation of an internal temporary table, call free_tmp_table() for all associated TABLE objects.</p>
<p>free_tmp_table() can only be called on a non-instantiated temporary table. It will decrement TABLE_SHARE::ref_count and the final call will also remove the temporary table's mem_root object. Create field for temporary table from given field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">org_field</td><td>Field from which new field will be created </td></tr>
    <tr><td class="paramname">name</td><td>New field name </td></tr>
    <tr><td class="paramname">table</td><td>Temporary table </td></tr>
    <tr><td class="paramname">item</td><td>If item != NULL then fill_record() will update the record in the original table. If item == NULL then fill_record() will update the temporary table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error </td></tr>
    <tr><td class="paramname">new_created</td><td>field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9583199306abbe9c382cd7cee73bc1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9583199306abbe9c382cd7cee73bc1d5">&#9670;&nbsp;</a></span>create_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* create_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>distinct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>save_sum_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>select_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>rows_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When true, enforces unique constraint (by adding a hidden hash_field and creating a key over this field) when: (1) unique key is too long, or (2) number of key parts in distinct key is too big, or (3) the caller has requested it.</p>

</div>
</div>
<a id="a87ad810de493a138a0c5979a8d9d3794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ad810de493a138a0c5979a8d9d3794">&#9670;&nbsp;</a></span>create_tmp_table_from_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* create_tmp_table_from_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_virtual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>select_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an, optionally reduced, TABLE object with properly set up Field list from a list of field definitions. </p>
<p>When is_virtual arg is true: The created table doesn't have a table handler associated with it, has no keys, no group/distinct, no copy_funcs array. The sole purpose of this TABLE object is to use the power of Field class to read/write data to/from table-&gt;record[0]. Then one can store the record in any container (RB tree, hash, etc). The table is created in THD mem_root, so are the table's fields. Consequently, if you don't BLOB fields, you don't need to free it. When is_virtual is false: This function creates a normal tmp table out of fields' definitions, rather than from lst of items. This is the main difference with create_tmp_table. Also the table created here doesn't do grouping, doesn't have indexes and copy_funcs/fields. The purpose is to be able to create result table for table functions out of fields' definitions without need in intermediate list of items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>connection handle </td></tr>
    <tr><td class="paramname">field_list</td><td>list of column definitions </td></tr>
    <tr><td class="paramname">is_virtual</td><td>if true, then it's effectively only a record buffer with wrapper, used e.g to store vars in SP if false, then a normal table, which can hold records, is created </td></tr>
    <tr><td class="paramname">select_options</td><td>options for non-virtual tmp table </td></tr>
    <tr><td class="paramname">alias</td><td>table's alias</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if out of memory, TABLE object in case of success </dd></dl>

</div>
</div>
<a id="aaee806b2c5151b4c7c50b89d67e2b04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee806b2c5151b4c7c50b89d67e2b04a">&#9670;&nbsp;</a></span>encode_innodb_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_innodb_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>rowid_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>row_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode an InnoDB PK in 6 bytes, high-byte first; like InnoDB's dict_sys_write_row_id() does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowid_bytes</td><td>where to store the result </td></tr>
    <tr><td class="paramname">length</td><td>how many available bytes in rowid_bytes </td></tr>
    <tr><td class="paramname">row_num</td><td>PK to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d90d0f88f88efb319ad1531079720e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d90d0f88f88efb319ad1531079720e4">&#9670;&nbsp;</a></span>free_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free temporary table. </p>
<p>When ref_count reaches zero, the table's mem_root allocator is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Table reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb717d5f7cb6edac609bef3981598c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb717d5f7cb6edac609bef3981598c3e">&#9670;&nbsp;</a></span>get_max_key_and_part_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_max_key_and_part_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>max_key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>max_key_part_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>max_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum of max_key_length and max_key_part_length between HEAP engine and internal_tmp_disk_storage_engine. </p>
<p>Get the minimum of max_key_length and max_key_part_length between HEAP engine and internal_tmp_disk_storage_engine.</p>
<p>The minimum is between HEAP engine and internal_tmp_disk_storage_engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max_key_length</td><td>Minimum of max_key_length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_key_part_length</td><td>Minimum of max_key_part_length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_key_parts</td><td>Minimum of max_key_parts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6b030319fe92a064c1c0a930289225b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b030319fe92a064c1c0a930289225b">&#9670;&nbsp;</a></span>init_cache_tmp_engine_properties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_cache_tmp_engine_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the storage engine properties for the alternative temporary table storage engines. </p>

</div>
</div>
<a id="afd008c63435583d145d2d0e4827708c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd008c63435583d145d2d0e4827708c4">&#9670;&nbsp;</a></span>instantiate_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> instantiate_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>Table object that describes the table to be instantiated</td></tr>
  </table>
  </dd>
</dl>
<p>Creates tmp table and opens it.</p>
<dl class="section return"><dt>Returns</dt><dd>false - OK true - Error </dd></dl>

</div>
</div>
<a id="ab6b731f0ef0953b3406adc1383bfed7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b731f0ef0953b3406adc1383bfed7d">&#9670;&nbsp;</a></span>open_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa33bfb8c4596076edd46ffaa0a9f5fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33bfb8c4596076edd46ffaa0a9f5fd4">&#9670;&nbsp;</a></span>reposition_innodb_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reposition_innodb_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>row_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for create_ondisk_from_heap(). </p>
<p>Our InnoDB on-disk intrinsic table uses an autogenerated auto-incrementing primary key:</p><ul>
<li>first inserted row has pk=1 (see dict_table_get_next_table_sess_row_id()), second has pk=2, etc</li>
<li>ha_rnd_next uses a PK index scan so returns rows in PK order</li>
<li>position() returns the PK</li>
<li>ha_rnd_pos() takes the PK in input.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>table read by cursor </td></tr>
    <tr><td class="paramname">row_num</td><td>function should position on the row_num'th row in insertion order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06373a361b79e80f99e07dd5936723e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06373a361b79e80f99e07dd5936723e0">&#9670;&nbsp;</a></span>setup_tmp_table_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_tmp_table_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>select_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>force_disk_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>schema_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create_tmp_table_* family for setting up table's SE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>table to allocate SE for </td></tr>
    <tr><td class="paramname">select_options</td><td>Options that may control storage engine selection </td></tr>
    <tr><td class="paramname">force_disk_table</td><td>true &lt;=&gt; Use InnoDB </td></tr>
    <tr><td class="paramname">schema_table</td><td>whether the table is a schema table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In a prepared statement, both preparation and execution may use this function, for a same TABLE. Execution always uses force_disk_table=schema_table=false; this may be inconsistent with what was used at preparation, but it's ok in fact:<ul>
<li>force_disk_table=true is for semijoin duplicate elimination table, which is execution-only</li>
<li>schema_table=true is for schema tables, and they're re-created at each execution. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5bd71961b401a432086d0fb290a87f3f.html">sql</a></li><li class="navelem"><a class="el" href="sql__tmp__table_8h.html">sql_tmp_table.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
