<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: ha_innobase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classha__innobase.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classha__innobase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ha_innobase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class defining a handle to an InnoDB table.  
 <a href="classha__innobase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ha__innodb_8h_source.html">ha_innodb.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ha_innobase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classha__innobase.png" usemap="#ha_5Finnobase_map" alt=""/>
  <map id="ha_5Finnobase_map" name="ha_5Finnobase_map">
<area href="classhandler.html" title="The handler class is the interface for dynamically loadable storage engines. " alt="handler" shape="rect" coords="0,0,84,24"/>
<area href="classha__innopart.html" title="The class defining a partitioning aware handle to an InnoDB table. " alt="ha_innopart" shape="rect" coords="0,112,84,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a62ac24c4cc72e377007948043566f849"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a62ac24c4cc72e377007948043566f849">Reader</a> = <a class="el" href="classParallel__reader__adapter.html">Parallel_reader_adapter</a></td></tr>
<tr class="separator:a62ac24c4cc72e377007948043566f849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">enum_range_scan_direction</a> { <a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2da9b3cccc513b9642d3f98dc18781feae5">RANGE_SCAN_ASC</a>, 
<a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2daa9e3a542611729d0b0825b523c603b8a">RANGE_SCAN_DESC</a>
 }</td></tr>
<tr class="separator:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf7978057d7f5cf7b58f37727a1ce6c inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6ca448bbe9d4d955739e67450e94458076d">NONE</a> = 0, 
<a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6ca992cf6748d817c1cf1d7961455ed4be4">INDEX</a>, 
<a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6cab713692ea5c27311b0a69f8617599c45">RND</a>, 
<a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6ca0ebae1da94d3f9a811c564316d5c67f2">SAMPLING</a>
 }</td></tr>
<tr class="separator:aedf7978057d7f5cf7b58f37727a1ce6c inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a></td></tr>
<tr class="separator:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa6c4d02e61680defa11a4081f1e24b inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">Load_init_cbk</a> = std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(void *cookie, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> ncols, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> row_len, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *col_offsets, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *null_byte_offsets, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *null_bitmasks)&gt;</td></tr>
<tr class="memdesc:a6aa6c4d02e61680defa11a4081f1e24b inherit pub_types_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called by each parallel load thread at the beginning of the parallel load for the adapter scan.  <a href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">More...</a><br /></td></tr>
<tr class="separator:a6aa6c4d02e61680defa11a4081f1e24b inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d8794466270fec22f8a676eaa0c90a inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">Load_cbk</a> = std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(void *cookie, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> nrows, void *rowdata, uint64_t partition_id)&gt;</td></tr>
<tr class="memdesc:af9d8794466270fec22f8a676eaa0c90a inherit pub_types_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called by each parallel load thread when processing of rows is required for the adapter scan.  <a href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">More...</a><br /></td></tr>
<tr class="separator:af9d8794466270fec22f8a676eaa0c90a inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e65d325f0e08107186740bcb248756 inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a24e65d325f0e08107186740bcb248756">Load_end_cbk</a> = std::function&lt; void(void *cookie)&gt;</td></tr>
<tr class="memdesc:a24e65d325f0e08107186740bcb248756 inherit pub_types_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called by each parallel load thread when processing of rows has ended for the adapter scan.  <a href="classhandler.html#a24e65d325f0e08107186740bcb248756">More...</a><br /></td></tr>
<tr class="separator:a24e65d325f0e08107186740bcb248756 inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c241e50948859d98ceae6e39066838 inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a>) (const <a class="el" href="structTABLE.html">TABLE</a> *, void *)</td></tr>
<tr class="memdesc:ad4c241e50948859d98ceae6e39066838 inherit pub_types_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function that will be called by my_prepare_gcolumn_template once the table has been opened.  <a href="classhandler.html#ad4c241e50948859d98ceae6e39066838">More...</a><br /></td></tr>
<tr class="separator:ad4c241e50948859d98ceae6e39066838 inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68036418df66335546ea69f063f353ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a68036418df66335546ea69f063f353ae">ha_innobase</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table_arg)</td></tr>
<tr class="memdesc:a68036418df66335546ea69f063f353ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct ha_innobase handler.  <a href="#a68036418df66335546ea69f063f353ae">More...</a><br /></td></tr>
<tr class="separator:a68036418df66335546ea69f063f353ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c964866b4536e1c1e708c6fb6299e7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a1c964866b4536e1c1e708c6fb6299e7b">~ha_innobase</a> () override</td></tr>
<tr class="memdesc:a1c964866b4536e1c1e708c6fb6299e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct ha_innobase handler.  <a href="#a1c964866b4536e1c1e708c6fb6299e7b">More...</a><br /></td></tr>
<tr class="separator:a1c964866b4536e1c1e708c6fb6299e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfac6b212f587b7d8c4fbd059907ded0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql_2handler_8h.html#aae164ec549f5dd7e890b40de79fd76c8">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#acfac6b212f587b7d8c4fbd059907ded0">get_real_row_type</a> (const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info) const override</td></tr>
<tr class="memdesc:acfac6b212f587b7d8c4fbd059907ded0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get real row type for the table created based on one specified by user, CREATE TABLE options and SE capabilities.  <a href="#acfac6b212f587b7d8c4fbd059907ded0">More...</a><br /></td></tr>
<tr class="separator:acfac6b212f587b7d8c4fbd059907ded0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59155263e0c49220461c9d80ae7a72c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af59155263e0c49220461c9d80ae7a72c">table_type</a> () const override</td></tr>
<tr class="memdesc:af59155263e0c49220461c9d80ae7a72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the table type (storage engine name).  <a href="#af59155263e0c49220461c9d80ae7a72c">More...</a><br /></td></tr>
<tr class="separator:af59155263e0c49220461c9d80ae7a72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a5dd9df94dce8ab69fbf79e4d9dd64"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae9a5dd9df94dce8ab69fbf79e4d9dd64">get_default_index_algorithm</a> () const override</td></tr>
<tr class="memdesc:ae9a5dd9df94dce8ab69fbf79e4d9dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default key algorithm for SE.  <a href="#ae9a5dd9df94dce8ab69fbf79e4d9dd64">More...</a><br /></td></tr>
<tr class="separator:ae9a5dd9df94dce8ab69fbf79e4d9dd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c73e564960485a3450ed5d6990a52a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8c73e564960485a3450ed5d6990a52a6">is_index_algorithm_supported</a> (enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a> key_alg) const override</td></tr>
<tr class="memdesc:a8c73e564960485a3450ed5d6990a52a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if SE supports specific key algorithm.  <a href="#a8c73e564960485a3450ed5d6990a52a6">More...</a><br /></td></tr>
<tr class="separator:a8c73e564960485a3450ed5d6990a52a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca84fffd74ffd0394230883dffa75dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a0ca84fffd74ffd0394230883dffa75dc">table_flags</a> () const override</td></tr>
<tr class="memdesc:a0ca84fffd74ffd0394230883dffa75dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the table flags to use for the statement.  <a href="#a0ca84fffd74ffd0394230883dffa75dc">More...</a><br /></td></tr>
<tr class="separator:a0ca84fffd74ffd0394230883dffa75dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e16bca7a00ede3aa7bfd6386ca0ea56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a4e16bca7a00ede3aa7bfd6386ca0ea56">index_flags</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> all_parts) const override</td></tr>
<tr class="memdesc:a4e16bca7a00ede3aa7bfd6386ca0ea56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operations supported for indexes.  <a href="#a4e16bca7a00ede3aa7bfd6386ca0ea56">More...</a><br /></td></tr>
<tr class="separator:a4e16bca7a00ede3aa7bfd6386ca0ea56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b40d6aceeb7c9927d8765861e22bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa9b40d6aceeb7c9927d8765861e22bd7">max_supported_keys</a> () const override</td></tr>
<tr class="memdesc:aa9b40d6aceeb7c9927d8765861e22bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of keys.  <a href="#aa9b40d6aceeb7c9927d8765861e22bd7">More...</a><br /></td></tr>
<tr class="separator:aa9b40d6aceeb7c9927d8765861e22bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dfcee2676166f64d87d561aebbe813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a92dfcee2676166f64d87d561aebbe813">max_supported_key_length</a> () const override</td></tr>
<tr class="memdesc:a92dfcee2676166f64d87d561aebbe813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum key length.  <a href="#a92dfcee2676166f64d87d561aebbe813">More...</a><br /></td></tr>
<tr class="separator:a92dfcee2676166f64d87d561aebbe813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d98d1b9c8e9874003e01132a1ac5641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5d98d1b9c8e9874003e01132a1ac5641">max_supported_key_part_length</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info) const override</td></tr>
<tr class="separator:a5d98d1b9c8e9874003e01132a1ac5641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d9a737a350ec3bdc246bce46c469a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a928d9a737a350ec3bdc246bce46c469a">open</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, int, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> open_flags, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>) override</td></tr>
<tr class="memdesc:a928d9a737a350ec3bdc246bce46c469a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an InnoDB table.  <a href="#a928d9a737a350ec3bdc246bce46c469a">More...</a><br /></td></tr>
<tr class="separator:a928d9a737a350ec3bdc246bce46c469a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1929d99568428c342c15ff9a081e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3a1929d99568428c342c15ff9a081e92">clone</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *<a class="el" href="client__plugin_8cc.html#a7d0fe2f135db987da18cea87b4778737">mem_root</a>) override</td></tr>
<tr class="separator:a3a1929d99568428c342c15ff9a081e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644a1842b94dae86679d3166d85c2a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8644a1842b94dae86679d3166d85c2a6">close</a> (void) override</td></tr>
<tr class="memdesc:a8644a1842b94dae86679d3166d85c2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a handle to an InnoDB table.  <a href="#a8644a1842b94dae86679d3166d85c2a6">More...</a><br /></td></tr>
<tr class="separator:a8644a1842b94dae86679d3166d85c2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3505b4fcd544e155238c18326eaac51a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3505b4fcd544e155238c18326eaac51a">scan_time</a> () override</td></tr>
<tr class="memdesc:a3505b4fcd544e155238c18326eaac51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many seeks it will take to read through the table.  <a href="#a3505b4fcd544e155238c18326eaac51a">More...</a><br /></td></tr>
<tr class="separator:a3505b4fcd544e155238c18326eaac51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d4680d4c79132b72063091b54c8d34"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af5d4680d4c79132b72063091b54c8d34">read_time</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ranges, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> rows) override</td></tr>
<tr class="memdesc:af5d4680d4c79132b72063091b54c8d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the time it takes to read a set of ranges through an index This enables us to optimise reads for clustered indexes.  <a href="#af5d4680d4c79132b72063091b54c8d34">More...</a><br /></td></tr>
<tr class="separator:af5d4680d4c79132b72063091b54c8d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365e00b6cdae0dde50563fa9c40a162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a9c0acdcb1b083d30069a62cee1ece644">longlong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9365e00b6cdae0dde50563fa9c40a162">get_memory_buffer_size</a> () const override</td></tr>
<tr class="memdesc:a9365e00b6cdae0dde50563fa9c40a162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the InnoDB memory buffer.  <a href="#a9365e00b6cdae0dde50563fa9c40a162">More...</a><br /></td></tr>
<tr class="separator:a9365e00b6cdae0dde50563fa9c40a162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89861bd4a0fd74b4a8b0d495472a363"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae89861bd4a0fd74b4a8b0d495472a363">write_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:ae89861bd4a0fd74b4a8b0d495472a363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a row in an InnoDB database, to the table specified in this handle.  <a href="#ae89861bd4a0fd74b4a8b0d495472a363">More...</a><br /></td></tr>
<tr class="separator:ae89861bd4a0fd74b4a8b0d495472a363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517b1ecde7d65b3da61b8d2bba00389c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a517b1ecde7d65b3da61b8d2bba00389c">update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>) override</td></tr>
<tr class="memdesc:a517b1ecde7d65b3da61b8d2bba00389c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a row given as a parameter to a new value.  <a href="#a517b1ecde7d65b3da61b8d2bba00389c">More...</a><br /></td></tr>
<tr class="separator:a517b1ecde7d65b3da61b8d2bba00389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca34d7d3d9efcb40f6143fc11f9d5af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#afca34d7d3d9efcb40f6143fc11f9d5af">delete_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:afca34d7d3d9efcb40f6143fc11f9d5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a row given as the parameter.  <a href="#afca34d7d3d9efcb40f6143fc11f9d5af">More...</a><br /></td></tr>
<tr class="separator:afca34d7d3d9efcb40f6143fc11f9d5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af174cbf38ed3d1363f32d2772537ceee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af174cbf38ed3d1363f32d2772537ceee">delete_all_rows</a> () override</td></tr>
<tr class="memdesc:af174cbf38ed3d1363f32d2772537ceee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all rows from the table.  <a href="#af174cbf38ed3d1363f32d2772537ceee">More...</a><br /></td></tr>
<tr class="separator:af174cbf38ed3d1363f32d2772537ceee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ed82289ef82d7553b4dde7536bab3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a82ed82289ef82d7553b4dde7536bab3e">was_semi_consistent_read</a> () override</td></tr>
<tr class="memdesc:a82ed82289ef82d7553b4dde7536bab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally, when running UPDATE or DELETE queries, we need to wait for other transactions to release their locks on a given row before we can read it and potentially update it.  <a href="#a82ed82289ef82d7553b4dde7536bab3e">More...</a><br /></td></tr>
<tr class="separator:a82ed82289ef82d7553b4dde7536bab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9584f11c212c4ad6e1e270055122435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ac9584f11c212c4ad6e1e270055122435">try_semi_consistent_read</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> yes) override</td></tr>
<tr class="memdesc:ac9584f11c212c4ad6e1e270055122435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the engine whether it should avoid unnecessary lock waits.  <a href="#ac9584f11c212c4ad6e1e270055122435">More...</a><br /></td></tr>
<tr class="separator:ac9584f11c212c4ad6e1e270055122435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f39bfde37d1a055be72730da08c0d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a79f39bfde37d1a055be72730da08c0d4">unlock_row</a> () override</td></tr>
<tr class="memdesc:a79f39bfde37d1a055be72730da08c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a new lock set on a row, if it was not read optimistically.  <a href="#a79f39bfde37d1a055be72730da08c0d4">More...</a><br /></td></tr>
<tr class="separator:a79f39bfde37d1a055be72730da08c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba62194dbbc6666c763284c900781cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aba62194dbbc6666c763284c900781cde">index_init</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted) override</td></tr>
<tr class="memdesc:aba62194dbbc6666c763284c900781cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a handle to use an index.  <a href="#aba62194dbbc6666c763284c900781cde">More...</a><br /></td></tr>
<tr class="separator:aba62194dbbc6666c763284c900781cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539589601452095deb50f43eed9153e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a539589601452095deb50f43eed9153e0">index_end</a> () override</td></tr>
<tr class="memdesc:a539589601452095deb50f43eed9153e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently does nothing.  <a href="#a539589601452095deb50f43eed9153e0">More...</a><br /></td></tr>
<tr class="separator:a539589601452095deb50f43eed9153e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57ed745e3cbbc2d7f68904e222baa9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ad57ed745e3cbbc2d7f68904e222baa9e">index_read</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_len, <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag) override</td></tr>
<tr class="memdesc:ad57ed745e3cbbc2d7f68904e222baa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle.  <a href="#ad57ed745e3cbbc2d7f68904e222baa9e">More...</a><br /></td></tr>
<tr class="separator:ad57ed745e3cbbc2d7f68904e222baa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65348e1f6565d897704540a4c9743be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ac65348e1f6565d897704540a4c9743be">index_read_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_len) override</td></tr>
<tr class="memdesc:ac65348e1f6565d897704540a4c9743be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="#ac65348e1f6565d897704540a4c9743be">More...</a><br /></td></tr>
<tr class="separator:ac65348e1f6565d897704540a4c9743be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6e17b5c471ee9a0c83a3b1cc392236"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6b6e17b5c471ee9a0c83a3b1cc392236">index_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:a6b6e17b5c471ee9a0c83a3b1cc392236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next row from a cursor, which must have previously been positioned using index_read.  <a href="#a6b6e17b5c471ee9a0c83a3b1cc392236">More...</a><br /></td></tr>
<tr class="separator:a6b6e17b5c471ee9a0c83a3b1cc392236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e2b8ad7471f6b41dde23898aae216f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a63e2b8ad7471f6b41dde23898aae216f">index_next_same</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keylen) override</td></tr>
<tr class="memdesc:a63e2b8ad7471f6b41dde23898aae216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next row matching to the key value given as the parameter.  <a href="#a63e2b8ad7471f6b41dde23898aae216f">More...</a><br /></td></tr>
<tr class="separator:a63e2b8ad7471f6b41dde23898aae216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae598ae464f20eb0e7dde35d100da1899"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae598ae464f20eb0e7dde35d100da1899">index_prev</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:ae598ae464f20eb0e7dde35d100da1899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the previous row from a cursor, which must have previously been positioned using index_read.  <a href="#ae598ae464f20eb0e7dde35d100da1899">More...</a><br /></td></tr>
<tr class="separator:ae598ae464f20eb0e7dde35d100da1899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad308cb08362d1241caecb2e585061d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aad308cb08362d1241caecb2e585061d2">index_first</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:aad308cb08362d1241caecb2e585061d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions a cursor on the first record in an index and reads the corresponding row to buf.  <a href="#aad308cb08362d1241caecb2e585061d2">More...</a><br /></td></tr>
<tr class="separator:aad308cb08362d1241caecb2e585061d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0256fd00023ef5d65a6aca868aa07fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ab0256fd00023ef5d65a6aca868aa07fc">index_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:ab0256fd00023ef5d65a6aca868aa07fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions a cursor on the last record in an index and reads the corresponding row to buf.  <a href="#ab0256fd00023ef5d65a6aca868aa07fc">More...</a><br /></td></tr>
<tr class="separator:ab0256fd00023ef5d65a6aca868aa07fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe5d93d70b0a29facf31a419025db83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aefe5d93d70b0a29facf31a419025db83">read_range_first</a> (const <a class="el" href="structkey__range.html">key_range</a> *start_key, const <a class="el" href="structkey__range.html">key_range</a> *end_key, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> eq_range_arg, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted) override</td></tr>
<tr class="memdesc:aefe5d93d70b0a29facf31a419025db83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges.  <a href="#aefe5d93d70b0a29facf31a419025db83">More...</a><br /></td></tr>
<tr class="separator:aefe5d93d70b0a29facf31a419025db83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf847dd084d581e207005c608d0c3a32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#abf847dd084d581e207005c608d0c3a32">read_range_next</a> () override</td></tr>
<tr class="memdesc:abf847dd084d581e207005c608d0c3a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#abf847dd084d581e207005c608d0c3a32">More...</a><br /></td></tr>
<tr class="separator:abf847dd084d581e207005c608d0c3a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8e8805da5c40b0ab44d83815865aa6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6a8e8805da5c40b0ab44d83815865aa6">rnd_init</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan) override</td></tr>
<tr class="memdesc:a6a8e8805da5c40b0ab44d83815865aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a table scan.  <a href="#a6a8e8805da5c40b0ab44d83815865aa6">More...</a><br /></td></tr>
<tr class="separator:a6a8e8805da5c40b0ab44d83815865aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3100a96ea13005f90e2b65e391f9eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a4f3100a96ea13005f90e2b65e391f9eb">rnd_end</a> () override</td></tr>
<tr class="memdesc:a4f3100a96ea13005f90e2b65e391f9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a table scan.  <a href="#a4f3100a96ea13005f90e2b65e391f9eb">More...</a><br /></td></tr>
<tr class="separator:a4f3100a96ea13005f90e2b65e391f9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b2dc1d51146907892ccb345aff9c94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a65b2dc1d51146907892ccb345aff9c94">rnd_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:a65b2dc1d51146907892ccb345aff9c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next row in a table scan (also used to read the FIRST row in a table scan).  <a href="#a65b2dc1d51146907892ccb345aff9c94">More...</a><br /></td></tr>
<tr class="separator:a65b2dc1d51146907892ccb345aff9c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272db42b6b4a31203c0fa201e4b5f80f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a272db42b6b4a31203c0fa201e4b5f80f">rnd_pos</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>) override</td></tr>
<tr class="memdesc:a272db42b6b4a31203c0fa201e4b5f80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches a row from the table based on a row reference.  <a href="#a272db42b6b4a31203c0fa201e4b5f80f">More...</a><br /></td></tr>
<tr class="separator:a272db42b6b4a31203c0fa201e4b5f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072d6c2f3e9989b4d787f0eaf760144c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a072d6c2f3e9989b4d787f0eaf760144c">ft_init</a> () override</td></tr>
<tr class="memdesc:a072d6c2f3e9989b4d787f0eaf760144c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize FT index scan.  <a href="#a072d6c2f3e9989b4d787f0eaf760144c">More...</a><br /></td></tr>
<tr class="separator:a072d6c2f3e9989b4d787f0eaf760144c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90782f6c7b37725ff0845f761460dedf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a90782f6c7b37725ff0845f761460dedf">ft_end</a> ()</td></tr>
<tr class="separator:a90782f6c7b37725ff0845f761460dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a89032a14685b3aa83f8f33ef52a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFT__INFO.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa9a89032a14685b3aa83f8f33ef52a55">ft_init_ext</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> inx, <a class="el" href="classString.html">String</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>) override</td></tr>
<tr class="memdesc:aa9a89032a14685b3aa83f8f33ef52a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize FT index scan.  <a href="#aa9a89032a14685b3aa83f8f33ef52a55">More...</a><br /></td></tr>
<tr class="separator:aa9a89032a14685b3aa83f8f33ef52a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd00e39b5172edbd35a7b3e062787e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFT__INFO.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#acfd00e39b5172edbd35a7b3e062787e0">ft_init_ext_with_hints</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> inx, <a class="el" href="classString.html">String</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="classFt__hints.html">Ft_hints</a> *hints) override</td></tr>
<tr class="memdesc:acfd00e39b5172edbd35a7b3e062787e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize FT index scan.  <a href="#acfd00e39b5172edbd35a7b3e062787e0">More...</a><br /></td></tr>
<tr class="separator:acfd00e39b5172edbd35a7b3e062787e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf4ab2a217ef0a9ee3be49f4b054346"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aadf4ab2a217ef0a9ee3be49f4b054346">ft_read</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:aadf4ab2a217ef0a9ee3be49f4b054346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch next result from the FT result set.  <a href="#aadf4ab2a217ef0a9ee3be49f4b054346">More...</a><br /></td></tr>
<tr class="separator:aadf4ab2a217ef0a9ee3be49f4b054346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74733f5cbd26a05bab60b709071a1053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a74733f5cbd26a05bab60b709071a1053">position</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>) override</td></tr>
<tr class="memdesc:a74733f5cbd26a05bab60b709071a1053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a reference to the current row to 'ref' field of the handle.  <a href="#a74733f5cbd26a05bab60b709071a1053">More...</a><br /></td></tr>
<tr class="separator:a74733f5cbd26a05bab60b709071a1053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c12cb2f26e5ea83d7a007ae1b1691"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa73c12cb2f26e5ea83d7a007ae1b1691">info</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>) override</td></tr>
<tr class="memdesc:aa73c12cb2f26e5ea83d7a007ae1b1691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns statistics information of the table to the MySQL interpreter, in various fields of the handle object.  <a href="#aa73c12cb2f26e5ea83d7a007ae1b1691">More...</a><br /></td></tr>
<tr class="separator:aa73c12cb2f26e5ea83d7a007ae1b1691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b6e1d81bc96709e0aff70761bf9166"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a66b6e1d81bc96709e0aff70761bf9166">enable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode) override</td></tr>
<tr class="memdesc:a66b6e1d81bc96709e0aff70761bf9166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable indexes.  <a href="#a66b6e1d81bc96709e0aff70761bf9166">More...</a><br /></td></tr>
<tr class="separator:a66b6e1d81bc96709e0aff70761bf9166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1546e4057641f48c81fc60c1ea1a46b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a1546e4057641f48c81fc60c1ea1a46b9">disable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode) override</td></tr>
<tr class="memdesc:a1546e4057641f48c81fc60c1ea1a46b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable indexes.  <a href="#a1546e4057641f48c81fc60c1ea1a46b9">More...</a><br /></td></tr>
<tr class="separator:a1546e4057641f48c81fc60c1ea1a46b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbeedc88b2cc26817feffcf5c8febca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aabbeedc88b2cc26817feffcf5c8febca">analyze</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt) override</td></tr>
<tr class="memdesc:aabbeedc88b2cc26817feffcf5c8febca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates index cardinalities of the table, based on random dives into each index tree.  <a href="#aabbeedc88b2cc26817feffcf5c8febca">More...</a><br /></td></tr>
<tr class="separator:aabbeedc88b2cc26817feffcf5c8febca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2b8a0b92d0997d0fa57ccc83968f80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#afa2b8a0b92d0997d0fa57ccc83968f80">optimize</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt) override</td></tr>
<tr class="memdesc:afa2b8a0b92d0997d0fa57ccc83968f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is mapped to "ALTER TABLE tablename ENGINE=InnoDB", which rebuilds the table in MySQL.  <a href="#afa2b8a0b92d0997d0fa57ccc83968f80">More...</a><br /></td></tr>
<tr class="separator:afa2b8a0b92d0997d0fa57ccc83968f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390184a3611fa9b62312bc2654ea511f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a390184a3611fa9b62312bc2654ea511f">discard_or_import_tablespace</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> discard, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>) override</td></tr>
<tr class="memdesc:a390184a3611fa9b62312bc2654ea511f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards or imports an InnoDB tablespace.  <a href="#a390184a3611fa9b62312bc2654ea511f">More...</a><br /></td></tr>
<tr class="separator:a390184a3611fa9b62312bc2654ea511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2859bf5d18cdf1b9fcf43ab2194b2631"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a2859bf5d18cdf1b9fcf43ab2194b2631">extra</a> (<a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a> operation) override</td></tr>
<tr class="memdesc:a2859bf5d18cdf1b9fcf43ab2194b2631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells something additional to the handler about how to do things.  <a href="#a2859bf5d18cdf1b9fcf43ab2194b2631">More...</a><br /></td></tr>
<tr class="separator:a2859bf5d18cdf1b9fcf43ab2194b2631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b13565fedbaf700d52c15d3145b0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a056b13565fedbaf700d52c15d3145b0d">reset</a> () override</td></tr>
<tr class="memdesc:a056b13565fedbaf700d52c15d3145b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL calls this method at the end of each statement.  <a href="#a056b13565fedbaf700d52c15d3145b0d">More...</a><br /></td></tr>
<tr class="separator:a056b13565fedbaf700d52c15d3145b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ee606c8a0bcb787cd57b3f0f808adc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa9ee606c8a0bcb787cd57b3f0f808adc">external_lock</a> (<a class="el" href="classTHD.html">THD</a> *thd, int lock_type) override</td></tr>
<tr class="memdesc:aa9ee606c8a0bcb787cd57b3f0f808adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">As MySQL will execute an external lock for every new table it uses when it starts to process an SQL statement (an exception is when MySQL calls start_stmt for the handle) we can use this function to store the pointer to the THD in the handle.  <a href="#aa9ee606c8a0bcb787cd57b3f0f808adc">More...</a><br /></td></tr>
<tr class="separator:aa9ee606c8a0bcb787cd57b3f0f808adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a70836644799aa8f325cfaa7707e451"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a0a70836644799aa8f325cfaa7707e451">sample_init</a> (void *&amp;scan_ctx, double sampling_percentage, int sampling_seed, <a class="el" href="sql_2handler_8h.html#ae954cfd46ba0b8300368dccf2bebc842">enum_sampling_method</a> sampling_method) override</td></tr>
<tr class="memdesc:a0a70836644799aa8f325cfaa7707e451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sampling.  <a href="#a0a70836644799aa8f325cfaa7707e451">More...</a><br /></td></tr>
<tr class="separator:a0a70836644799aa8f325cfaa7707e451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55969372fcf3cb364249daba74da2e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af55969372fcf3cb364249daba74da2e9">sample_next</a> (void *scan_ctx, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) override</td></tr>
<tr class="memdesc:af55969372fcf3cb364249daba74da2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next record for sampling.  <a href="#af55969372fcf3cb364249daba74da2e9">More...</a><br /></td></tr>
<tr class="separator:af55969372fcf3cb364249daba74da2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab394b0c7fdded101aef186c683ce76c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ab394b0c7fdded101aef186c683ce76c7">sample_end</a> (void *scan_ctx) override</td></tr>
<tr class="memdesc:ab394b0c7fdded101aef186c683ce76c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">End sampling.  <a href="#ab394b0c7fdded101aef186c683ce76c7">More...</a><br /></td></tr>
<tr class="separator:ab394b0c7fdded101aef186c683ce76c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b1b3e128043290847d250756b66f53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a48b1b3e128043290847d250756b66f53">start_stmt</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a> lock_type) override</td></tr>
<tr class="memdesc:a48b1b3e128043290847d250756b66f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL calls this function at the start of each SQL statement inside LOCK TABLES.  <a href="#a48b1b3e128043290847d250756b66f53">More...</a><br /></td></tr>
<tr class="separator:a48b1b3e128043290847d250756b66f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a90e2d5ec1ea15c83b4f79dfdb028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a810a90e2d5ec1ea15c83b4f79dfdb028">position</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:a810a90e2d5ec1ea15c83b4f79dfdb028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95463460839f5ffce360cf02024da29b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a95463460839f5ffce360cf02024da29b">records</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows) override</td></tr>
<tr class="memdesc:a95463460839f5ffce360cf02024da29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of records that this client can see using this handler object.  <a href="#a95463460839f5ffce360cf02024da29b">More...</a><br /></td></tr>
<tr class="separator:a95463460839f5ffce360cf02024da29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20799b459cb132c6ec4aa643e3d4d946"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a20799b459cb132c6ec4aa643e3d4d946">records_from_index</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>) override</td></tr>
<tr class="memdesc:a20799b459cb132c6ec4aa643e3d4d946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in table counted using the secondary index chosen by optimizer.  <a href="#a20799b459cb132c6ec4aa643e3d4d946">More...</a><br /></td></tr>
<tr class="separator:a20799b459cb132c6ec4aa643e3d4d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583aa37f0683cb54012bc9804e268737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a583aa37f0683cb54012bc9804e268737">records_in_range</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> inx, <a class="el" href="structkey__range.html">key_range</a> *min_key, <a class="el" href="structkey__range.html">key_range</a> *max_key) override</td></tr>
<tr class="memdesc:a583aa37f0683cb54012bc9804e268737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the number of index records in a range.  <a href="#a583aa37f0683cb54012bc9804e268737">More...</a><br /></td></tr>
<tr class="separator:a583aa37f0683cb54012bc9804e268737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d47bcd9368043b44b59c1f24f690201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8d47bcd9368043b44b59c1f24f690201">estimate_rows_upper_bound</a> () override</td></tr>
<tr class="memdesc:a8d47bcd9368043b44b59c1f24f690201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an UPPER BOUND to the number of rows in a table.  <a href="#a8d47bcd9368043b44b59c1f24f690201">More...</a><br /></td></tr>
<tr class="separator:a8d47bcd9368043b44b59c1f24f690201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d9ce11b0e2884e151e005bd74f3a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ad7d9ce11b0e2884e151e005bd74f3a1f">update_create_info</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info) override</td></tr>
<tr class="memdesc:ad7d9ce11b0e2884e151e005bd74f3a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update create_info.  <a href="#ad7d9ce11b0e2884e151e005bd74f3a1f">More...</a><br /></td></tr>
<tr class="separator:ad7d9ce11b0e2884e151e005bd74f3a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6abd57a949186466989472944c0f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8b6abd57a949186466989472944c0f94">get_se_private_data</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classha__innobase.html#a056b13565fedbaf700d52c15d3145b0d">reset</a>) override</td></tr>
<tr class="memdesc:a8b6abd57a949186466989472944c0f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get storage-engine private data for a data dictionary table.  <a href="#a8b6abd57a949186466989472944c0f94">More...</a><br /></td></tr>
<tr class="separator:a8b6abd57a949186466989472944c0f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db15d03fe482536527801f0df446543"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5db15d03fe482536527801f0df446543">get_extra_columns_and_keys</a> (const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *, const <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; *, const <a class="el" href="classKEY.html">KEY</a> *, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table) override</td></tr>
<tr class="memdesc:a5db15d03fe482536527801f0df446543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add hidden columns and indexes to an InnoDB table definition.  <a href="#a5db15d03fe482536527801f0df446543">More...</a><br /></td></tr>
<tr class="separator:a5db15d03fe482536527801f0df446543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7f6f94a9e464716bb3b99b7a9b85ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aae7f6f94a9e464716bb3b99b7a9b85ba">upgrade_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db_name, const char *table_name, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table) override</td></tr>
<tr class="memdesc:aae7f6f94a9e464716bb3b99b7a9b85ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Engine specific data to dd::Table object for upgrade.  <a href="#aae7f6f94a9e464716bb3b99b7a9b85ba">More...</a><br /></td></tr>
<tr class="separator:aae7f6f94a9e464716bb3b99b7a9b85ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34323a614547239877b26d408708fda8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a34323a614547239877b26d408708fda8">create</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>) override</td></tr>
<tr class="memdesc:a34323a614547239877b26d408708fda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an InnoDB table.  <a href="#a34323a614547239877b26d408708fda8">More...</a><br /></td></tr>
<tr class="separator:a34323a614547239877b26d408708fda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d95a18bb01bd7aab0e995da4535549"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa8d95a18bb01bd7aab0e995da4535549">delete_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>) override</td></tr>
<tr class="memdesc:aa8d95a18bb01bd7aab0e995da4535549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a table.  <a href="#aa8d95a18bb01bd7aab0e995da4535549">More...</a><br /></td></tr>
<tr class="separator:aa8d95a18bb01bd7aab0e995da4535549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da78c60f55e2141137af9a0846b2e9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a7da78c60f55e2141137af9a0846b2e9e">rename_table</a> (const char *from, const char *to, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *from_table, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *to_table) override</td></tr>
<tr class="memdesc:a7da78c60f55e2141137af9a0846b2e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames an InnoDB table.  <a href="#a7da78c60f55e2141137af9a0846b2e9e">More...</a><br /></td></tr>
<tr class="separator:a7da78c60f55e2141137af9a0846b2e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb381d782e3dd2cefe882fb3fb686870"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aeb381d782e3dd2cefe882fb3fb686870">check</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt) override</td></tr>
<tr class="memdesc:aeb381d782e3dd2cefe882fb3fb686870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to check that an InnoDB table is not corrupted.  <a href="#aeb381d782e3dd2cefe882fb3fb686870">More...</a><br /></td></tr>
<tr class="separator:aeb381d782e3dd2cefe882fb3fb686870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6b5e69a443ec396cfec6f324a0e4f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9d6b5e69a443ec396cfec6f324a0e4f9">lock_count</a> (void) const override</td></tr>
<tr class="memdesc:a9d6b5e69a443ec396cfec6f324a0e4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of THR_LOCK locks used for one instance of InnoDB table.  <a href="#a9d6b5e69a443ec396cfec6f324a0e4f9">More...</a><br /></td></tr>
<tr class="separator:a9d6b5e69a443ec396cfec6f324a0e4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d647e97f555625b358f8916af249c0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9d647e97f555625b358f8916af249c0d">store_lock</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a> **to, <a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a> lock_type) override</td></tr>
<tr class="memdesc:a9d647e97f555625b358f8916af249c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supposed to convert a MySQL table lock stored in the 'lock' field of the handle to a proper type before storing pointer to the lock into an array of pointers.  <a href="#a9d647e97f555625b358f8916af249c0d">More...</a><br /></td></tr>
<tr class="separator:a9d647e97f555625b358f8916af249c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd8b745fdac5b31abd0bd105ee50a08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aafd8b745fdac5b31abd0bd105ee50a08">init_table_handle_for_HANDLER</a> () override</td></tr>
<tr class="memdesc:aafd8b745fdac5b31abd0bd105ee50a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this when you have opened a new table handle in HANDLER, before you call index_read_map() etc.  <a href="#aafd8b745fdac5b31abd0bd105ee50a08">More...</a><br /></td></tr>
<tr class="separator:aafd8b745fdac5b31abd0bd105ee50a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ce8ab38b9a25fa3bffda31659d112b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa3ce8ab38b9a25fa3bffda31659d112b">get_auto_increment</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> offset, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> increment, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> nb_desired_values, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *first_value, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *nb_reserved_values) override</td></tr>
<tr class="memdesc:aa3ce8ab38b9a25fa3bffda31659d112b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the auto-inc counter in *first_value and ~0 on failure.  <a href="#aa3ce8ab38b9a25fa3bffda31659d112b">More...</a><br /></td></tr>
<tr class="separator:aa3ce8ab38b9a25fa3bffda31659d112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5ed7bbf91a0eddc4ce709a378215dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ada5ed7bbf91a0eddc4ce709a378215dd">release_auto_increment</a> () override</td></tr>
<tr class="memdesc:ada5ed7bbf91a0eddc4ce709a378215dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do cleanup for auto increment calculation.  <a href="#ada5ed7bbf91a0eddc4ce709a378215dd">More...</a><br /></td></tr>
<tr class="separator:ada5ed7bbf91a0eddc4ce709a378215dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf8de2efb608179fa4462fdc990949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a90bf8de2efb608179fa4462fdc990949">get_error_message</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>, <a class="el" href="classString.html">String</a> *buf) override</td></tr>
<tr class="memdesc:a90bf8de2efb608179fa4462fdc990949"><td class="mdescLeft">&#160;</td><td class="mdescRight">See comment in handler.cc.  <a href="#a90bf8de2efb608179fa4462fdc990949">More...</a><br /></td></tr>
<tr class="separator:a90bf8de2efb608179fa4462fdc990949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa619024bc4a2075068278c575a39982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#afa619024bc4a2075068278c575a39982">get_foreign_dup_key</a> (char *, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, char *, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>) override</td></tr>
<tr class="memdesc:afa619024bc4a2075068278c575a39982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY.  <a href="#afa619024bc4a2075068278c575a39982">More...</a><br /></td></tr>
<tr class="separator:afa619024bc4a2075068278c575a39982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436003354606af48dbce6de74e4e8b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a436003354606af48dbce6de74e4e8b86">primary_key_is_clustered</a> () const override</td></tr>
<tr class="memdesc:a436003354606af48dbce6de74e4e8b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the primary key is clustered index.  <a href="#a436003354606af48dbce6de74e4e8b86">More...</a><br /></td></tr>
<tr class="separator:a436003354606af48dbce6de74e4e8b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa25ab9f3a03803bea3f710bc0b269e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aaa25ab9f3a03803bea3f710bc0b269e1">cmp_ref</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ref1, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ref2) const override</td></tr>
<tr class="memdesc:aaa25ab9f3a03803bea3f710bc0b269e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two 'refs'.  <a href="#aaa25ab9f3a03803bea3f710bc0b269e1">More...</a><br /></td></tr>
<tr class="separator:aaa25ab9f3a03803bea3f710bc0b269e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b55cba48f15017a7d8acd28872dbcb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql_2handler_8h.html#a66da1d8166f880283aefe422280ce631">enum_alter_inplace_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ALTER__TABLE__INTERFACE.html#ga9b55cba48f15017a7d8acd28872dbcb7">check_if_supported_inplace_alter</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info) override</td></tr>
<tr class="memdesc:ga9b55cba48f15017a7d8acd28872dbcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if InnoDB supports a particular alter table in-place.  <a href="group__ALTER__TABLE__INTERFACE.html#ga9b55cba48f15017a7d8acd28872dbcb7">More...</a><br /></td></tr>
<tr class="separator:ga9b55cba48f15017a7d8acd28872dbcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf0978ed576288f07bcda60b1212b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ALTER__TABLE__INTERFACE.html#gabcf0978ed576288f07bcda60b1212b53">prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_dd_tab, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_dd_tab) override</td></tr>
<tr class="memdesc:gabcf0978ed576288f07bcda60b1212b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows InnoDB to update internal structures with concurrent writes blocked (provided that check_if_supported_inplace_alter() did not return HA_ALTER_INPLACE_NO_LOCK).  <a href="group__ALTER__TABLE__INTERFACE.html#gabcf0978ed576288f07bcda60b1212b53">More...</a><br /></td></tr>
<tr class="separator:gabcf0978ed576288f07bcda60b1212b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade6f8038f7afc0bed72e91299ab0243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ALTER__TABLE__INTERFACE.html#gaade6f8038f7afc0bed72e91299ab0243">inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_dd_tab, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_dd_tab) override</td></tr>
<tr class="memdesc:gaade6f8038f7afc0bed72e91299ab0243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and Alter_inplace_information.  <a href="group__ALTER__TABLE__INTERFACE.html#gaade6f8038f7afc0bed72e91299ab0243">More...</a><br /></td></tr>
<tr class="separator:gaade6f8038f7afc0bed72e91299ab0243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9266f596cd73ca385c7c1ed55a217d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ALTER__TABLE__INTERFACE.html#ga6c9266f596cd73ca385c7c1ed55a217d">commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="sql__cmd__srs_8cc.html#af8756202cf6ab572edb0e832014f1a5f">commit</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_dd_tab, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_dd_tab) override</td></tr>
<tr class="memdesc:ga6c9266f596cd73ca385c7c1ed55a217d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit or rollback the changes made during prepare_inplace_alter_table() and inplace_alter_table() inside the storage engine.  <a href="group__ALTER__TABLE__INTERFACE.html#ga6c9266f596cd73ca385c7c1ed55a217d">More...</a><br /></td></tr>
<tr class="separator:ga6c9266f596cd73ca385c7c1ed55a217d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a01c18a2f2badc827709aef7151482"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ad5a01c18a2f2badc827709aef7151482">parallel_scan_init</a> (void *&amp;scan_ctx, size_t *num_threads, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_reserved_threads) override</td></tr>
<tr class="memdesc:ad5a01c18a2f2badc827709aef7151482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a parallel scan.  <a href="#ad5a01c18a2f2badc827709aef7151482">More...</a><br /></td></tr>
<tr class="separator:ad5a01c18a2f2badc827709aef7151482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf884273500d55cfae842aa7bd0159b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6bf884273500d55cfae842aa7bd0159b">parallel_scan</a> (void *scan_ctx, void **thread_ctxs, <a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Reader::Init_fn</a> init_fn, <a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Reader::Load_fn</a> load_fn, <a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">Reader::End_fn</a> end_fn) override</td></tr>
<tr class="memdesc:a6bf884273500d55cfae842aa7bd0159b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start parallel read of InnoDB records.  <a href="#a6bf884273500d55cfae842aa7bd0159b">More...</a><br /></td></tr>
<tr class="separator:a6bf884273500d55cfae842aa7bd0159b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68072931c05a5c76b2a9d251f130672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ad68072931c05a5c76b2a9d251f130672">parallel_scan_end</a> (void *scan_ctx) override</td></tr>
<tr class="memdesc:ad68072931c05a5c76b2a9d251f130672"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of the parallel scan.  <a href="#ad68072931c05a5c76b2a9d251f130672">More...</a><br /></td></tr>
<tr class="separator:ad68072931c05a5c76b2a9d251f130672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8aba3a3633ed6dc7324d9725b0526f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9d8aba3a3633ed6dc7324d9725b0526f">check_if_incompatible_data</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *<a class="el" href="classha__innobase.html#aa73c12cb2f26e5ea83d7a007ae1b1691">info</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> table_changes) override</td></tr>
<tr class="memdesc:a9d8aba3a3633ed6dc7324d9725b0526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of old, deprecated in-place ALTER API.  <a href="#a9d8aba3a3633ed6dc7324d9725b0526f">More...</a><br /></td></tr>
<tr class="separator:a9d8aba3a3633ed6dc7324d9725b0526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a72cfeaceefd05a2f700c138c194770fc">unbind_psi</a> ()</td></tr>
<tr class="separator:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1e335a403d8203854bc5b94111992b79">rebind_psi</a> ()</td></tr>
<tr class="separator:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cadefb8724982848541e06a394917e8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6cadefb8724982848541e06a394917e8">start_psi_batch_mode</a> ()</td></tr>
<tr class="memdesc:a6cadefb8724982848541e06a394917e8 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the handler in 'batch' mode when collecting table io instrumented events.  <a href="classhandler.html#a6cadefb8724982848541e06a394917e8">More...</a><br /></td></tr>
<tr class="separator:a6cadefb8724982848541e06a394917e8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a860cb6d6cb731416080acc8f179e0 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab6a860cb6d6cb731416080acc8f179e0">end_psi_batch_mode</a> ()</td></tr>
<tr class="memdesc:ab6a860cb6d6cb731416080acc8f179e0 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">End a batch started with <code>start_psi_batch_mode</code>.  <a href="classhandler.html#ab6a860cb6d6cb731416080acc8f179e0">More...</a><br /></td></tr>
<tr class="separator:ab6a860cb6d6cb731416080acc8f179e0 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75494b6dc9eb0d9fbbcd91cf0ab1d365 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a75494b6dc9eb0d9fbbcd91cf0ab1d365">end_psi_batch_mode_if_started</a> ()</td></tr>
<tr class="memdesc:a75494b6dc9eb0d9fbbcd91cf0ab1d365 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a PSI batch was started, turn if off.  <a href="classhandler.html#a75494b6dc9eb0d9fbbcd91cf0ab1d365">More...</a><br /></td></tr>
<tr class="separator:a75494b6dc9eb0d9fbbcd91cf0ab1d365 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ae8f7f7b4f67773b73906143238dc9f">handler</a> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr class="separator:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09926fc18e0dad27e77f0834ee4075cf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a09926fc18e0dad27e77f0834ee4075cf">~handler</a> (void)</td></tr>
<tr class="separator:a09926fc18e0dad27e77f0834ee4075cf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab256be9b37a44ba83d26732e5197823a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab256be9b37a44ba83d26732e5197823a">explain_extra</a> () const</td></tr>
<tr class="memdesc:ab256be9b37a44ba83d26732e5197823a inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return extra handler specific text for EXPLAIN.  <a href="classhandler.html#ab256be9b37a44ba83d26732e5197823a">More...</a><br /></td></tr>
<tr class="separator:ab256be9b37a44ba83d26732e5197823a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr class="memdesc:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called after create to allow us to set up cached variables.  <a href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">More...</a><br /></td></tr>
<tr class="separator:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace90f37b16640dc3c5f313c415e5fee6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ace90f37b16640dc3c5f313c415e5fee6">ha_set_record_buffer</a> (<a class="el" href="classRecord__buffer.html">Record_buffer</a> *<a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>)</td></tr>
<tr class="memdesc:ace90f37b16640dc3c5f313c415e5fee6 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a record buffer that the storage engine can use for multi-row reads.  <a href="classhandler.html#ace90f37b16640dc3c5f313c415e5fee6">More...</a><br /></td></tr>
<tr class="separator:ace90f37b16640dc3c5f313c415e5fee6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6fecd2d8d525592027049e61db9471 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRecord__buffer.html">Record_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2f6fecd2d8d525592027049e61db9471">ha_get_record_buffer</a> () const</td></tr>
<tr class="memdesc:a2f6fecd2d8d525592027049e61db9471 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the record buffer that was set with ha_set_record_buffer().  <a href="classhandler.html#a2f6fecd2d8d525592027049e61db9471">More...</a><br /></td></tr>
<tr class="separator:a2f6fecd2d8d525592027049e61db9471 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e9c0e51efed08a7ba13f4d1c30b1ee inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af3e9c0e51efed08a7ba13f4d1c30b1ee">ha_is_record_buffer_wanted</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *const max_rows) const</td></tr>
<tr class="memdesc:af3e9c0e51efed08a7ba13f4d1c30b1ee inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this handler want to get a Record_buffer for multi-row reads via the ha_set_record_buffer() function? And if so, what is the maximum number of records to allocate space for in the buffer?  <a href="classhandler.html#af3e9c0e51efed08a7ba13f4d1c30b1ee">More...</a><br /></td></tr>
<tr class="separator:af3e9c0e51efed08a7ba13f4d1c30b1ee inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a3a986805a5cf0312f3f1575d2343c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa4a3a986805a5cf0312f3f1575d2343c">ha_open</a> (<a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, int mode, int test_if_locked, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="separator:aa4a3a986805a5cf0312f3f1575d2343c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr class="memdesc:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler.  <a href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">More...</a><br /></td></tr>
<tr class="separator:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="memdesc:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize use of index.  <a href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">More...</a><br /></td></tr>
<tr class="separator:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr class="memdesc:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">End use of index.  <a href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">More...</a><br /></td></tr>
<tr class="separator:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan)</td></tr>
<tr class="memdesc:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize table for random read or scan.  <a href="classhandler.html#afb5c99736cb400350e007578889b8375">More...</a><br /></td></tr>
<tr class="separator:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr class="memdesc:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">End use of random access.  <a href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">More...</a><br /></td></tr>
<tr class="separator:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row via random scan.  <a href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">More...</a><br /></td></tr>
<tr class="separator:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)</td></tr>
<tr class="memdesc:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read row via random scan from position.  <a href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">More...</a><br /></td></tr>
<tr class="separator:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read [part of] row via [part of] index.  <a href="classhandler.html#a729d9c9c011527b81287574294887bf3">More...</a><br /></td></tr>
<tr class="separator:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3fa9be09b8d0b1c03c96eb95f79dd7c9">ha_index_read_last_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)</td></tr>
<tr class="separator:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an index and read it.  <a href="classhandler.html#ac831321e8d33958db4fd4968de932acf">More...</a><br /></td></tr>
<tr class="separator:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next row via index.  <a href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">More...</a><br /></td></tr>
<tr class="separator:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the previous row via index.  <a href="classhandler.html#abb977dac0435158be227e45e04c8b798">More...</a><br /></td></tr>
<tr class="separator:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first row via index.  <a href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">More...</a><br /></td></tr>
<tr class="separator:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the last row via index.  <a href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">More...</a><br /></td></tr>
<tr class="separator:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keylen)</td></tr>
<tr class="memdesc:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next same row via index.  <a href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">More...</a><br /></td></tr>
<tr class="separator:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr class="memdesc:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check handler usage and reset state of file to after 'open'.  <a href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">More...</a><br /></td></tr>
<tr class="separator:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6e1ef9b6ab27156116f91bf50b1ac19f">ha_index_or_rnd_end</a> ()</td></tr>
<tr class="separator:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b3015577f49008561db1d34ae750e70">ha_table_flags</a> () const</td></tr>
<tr class="memdesc:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cached_table_flags is set at ha_open and ha_external_lock.  <a href="classhandler.html#a6b3015577f49008561db1d34ae750e70">More...</a><br /></td></tr>
<tr class="separator:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (<a class="el" href="classTHD.html">THD</a> *thd, int lock_type)</td></tr>
<tr class="memdesc:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions represent the public interface to <em>users</em> of the handler class, hence they are <em>not</em> virtual.  <a href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">More...</a><br /></td></tr>
<tr class="separator:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad8e651543ba0dbb2257a50dc1cdb5ea9">ha_write_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f6bb19636dda0f1537fe780b6aca17a">ha_update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>)</td></tr>
<tr class="memdesc:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the current row.  <a href="classhandler.html#a1f6bb19636dda0f1537fe780b6aca17a">More...</a><br /></td></tr>
<tr class="separator:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f0e3b24f5bb5b2a8fa0c45732db8cdd">ha_delete_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abfbcbef5b9b8ed0f76d700a29091ad3f">ha_release_auto_increment</a> ()</td></tr>
<tr class="separator:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a79a8030a4a3928d216599e1c03e9b28c">ha_check_for_upgrade</a> (<a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">to be actually called to get 'check()' functionality  <a href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">More...</a><br /></td></tr>
<tr class="separator:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repair table: public interface.  <a href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">More...</a><br /></td></tr>
<tr class="separator:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> rows)</td></tr>
<tr class="memdesc:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start bulk insert.  <a href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">More...</a><br /></td></tr>
<tr class="separator:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr class="memdesc:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">End bulk insert.  <a href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">More...</a><br /></td></tr>
<tr class="separator:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *dup_key_found)</td></tr>
<tr class="memdesc:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk update row: public interface.  <a href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">More...</a><br /></td></tr>
<tr class="separator:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr class="memdesc:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all rows: public interface.  <a href="classhandler.html#a1fef228137a11565f7d52a60ad802004">More...</a><br /></td></tr>
<tr class="separator:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa3573d855956938bdc5171e7bada5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6faa3573d855956938bdc5171e7bada5">ha_truncate</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:a6faa3573d855956938bdc5171e7bada5 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate table: public interface.  <a href="classhandler.html#a6faa3573d855956938bdc5171e7bada5">More...</a><br /></td></tr>
<tr class="separator:a6faa3573d855956938bdc5171e7bada5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize table: public interface.  <a href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">More...</a><br /></td></tr>
<tr class="separator:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze table: public interface.  <a href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">More...</a><br /></td></tr>
<tr class="separator:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and repair table: public interface.  <a href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">More...</a><br /></td></tr>
<tr class="separator:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode)</td></tr>
<tr class="memdesc:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable indexes: public interface.  <a href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">More...</a><br /></td></tr>
<tr class="separator:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode)</td></tr>
<tr class="memdesc:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable indexes: public interface.  <a href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">More...</a><br /></td></tr>
<tr class="separator:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d065a0acbb43dda3bec8d2d17c64362 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4d065a0acbb43dda3bec8d2d17c64362">ha_discard_or_import_tablespace</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> discard, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:a4d065a0acbb43dda3bec8d2d17c64362 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard or import tablespace: public interface.  <a href="classhandler.html#a4d065a0acbb43dda3bec8d2d17c64362">More...</a><br /></td></tr>
<tr class="separator:a4d065a0acbb43dda3bec8d2d17c64362 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fdba3807d26163cf0bcebcf9fb2664 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af6fdba3807d26163cf0bcebcf9fb2664">ha_rename_table</a> (const char *from, const char *to, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *from_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *to_table_def)</td></tr>
<tr class="memdesc:af6fdba3807d26163cf0bcebcf9fb2664 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename table: public interface.  <a href="classhandler.html#af6fdba3807d26163cf0bcebcf9fb2664">More...</a><br /></td></tr>
<tr class="separator:af6fdba3807d26163cf0bcebcf9fb2664 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf699c767f76315ce2500f18cb20eb71 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaf699c767f76315ce2500f18cb20eb71">ha_delete_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:aaf699c767f76315ce2500f18cb20eb71 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete table: public interface.  <a href="classhandler.html#aaf699c767f76315ce2500f18cb20eb71">More...</a><br /></td></tr>
<tr class="separator:aaf699c767f76315ce2500f18cb20eb71 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="memdesc:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop table in the engine: public interface.  <a href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">More...</a><br /></td></tr>
<tr class="separator:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdeebefcfc1390a0e89ac7ef04586a1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3cdeebefcfc1390a0e89ac7ef04586a1">ha_create</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *<a class="el" href="classhandler.html#a3de6f276d98eba4327f1a9a860d65f3c">info</a>, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:a3cdeebefcfc1390a0e89ac7ef04586a1 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table in the engine: public interface.  <a href="classhandler.html#a3cdeebefcfc1390a0e89ac7ef04586a1">More...</a><br /></td></tr>
<tr class="separator:a3cdeebefcfc1390a0e89ac7ef04586a1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac530d2a77ce857389f6d32dcfeb10002 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac530d2a77ce857389f6d32dcfeb10002">ha_load_table</a> (const <a class="el" href="structTABLE.html">TABLE</a> &amp;<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>)</td></tr>
<tr class="memdesc:ac530d2a77ce857389f6d32dcfeb10002 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a table into its defined secondary storage engine: public interface.  <a href="classhandler.html#ac530d2a77ce857389f6d32dcfeb10002">More...</a><br /></td></tr>
<tr class="separator:ac530d2a77ce857389f6d32dcfeb10002 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2066c996d7f772dc0483494de4e3bd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb2066c996d7f772dc0483494de4e3bd">ha_unload_table</a> (const char *db_name, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> error_if_not_loaded)</td></tr>
<tr class="memdesc:afb2066c996d7f772dc0483494de4e3bd inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads a table from its defined secondary storage engine: public interface.  <a href="classhandler.html#afb2066c996d7f772dc0483494de4e3bd">More...</a><br /></td></tr>
<tr class="separator:afb2066c996d7f772dc0483494de4e3bd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e49e88aeec6d85f9f7b94f6ed2ee487 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7e49e88aeec6d85f9f7b94f6ed2ee487">ha_get_se_private_data</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">reset</a>)</td></tr>
<tr class="memdesc:a7e49e88aeec6d85f9f7b94f6ed2ee487 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a dd::Table object representing a core DD table having hardcoded data to be filled in by the DDSE.  <a href="classhandler.html#a7e49e88aeec6d85f9f7b94f6ed2ee487">More...</a><br /></td></tr>
<tr class="separator:a7e49e88aeec6d85f9f7b94f6ed2ee487 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4c090210fefb7e95d885688f5717028">adjust_next_insert_id_after_explicit_value</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> nr)</td></tr>
<tr class="separator:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8a7d2f9da11425e388640206b4d22241">update_auto_increment</a> ()</td></tr>
<tr class="separator:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4f1390385a4dc0bfd2981fee23e6c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">print_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>, <a class="el" href="my__inttypes_8h.html#a0db1f888c3bc329e7b0b340dbd41eb2b">myf</a> errflag)</td></tr>
<tr class="memdesc:afda4f1390385a4dc0bfd2981fee23e6c inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error that we got from handler function.  <a href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">More...</a><br /></td></tr>
<tr class="separator:afda4f1390385a4dc0bfd2981fee23e6c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="separator:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b117a976fc9423d2337da59f35d128c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2b117a976fc9423d2337da59f35d128c">change_table_ptr</a> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="memdesc:a2b117a976fc9423d2337da59f35d128c inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the internal TABLE_SHARE pointer.  <a href="classhandler.html#a2b117a976fc9423d2337da59f35d128c">More...</a><br /></td></tr>
<tr class="separator:a2b117a976fc9423d2337da59f35d128c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e5d856e729be3f3ebee87e6857c45d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac0e5d856e729be3f3ebee87e6857c45d">get_table_share</a> () const</td></tr>
<tr class="separator:ac0e5d856e729be3f3ebee87e6857c45d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keynr, double <a class="el" href="classhandler.html#a9d2371385a8f73f1258965f5f7cfdf93">records</a>)</td></tr>
<tr class="memdesc:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate cost of 'index only' scan for given index and number of records.  <a href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">More...</a><br /></td></tr>
<tr class="separator:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9380355a7eea5386ef061f36479258 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e9380355a7eea5386ef061f36479258">table_scan_cost</a> ()</td></tr>
<tr class="memdesc:a5e9380355a7eea5386ef061f36479258 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate for doing a complete table scan.  <a href="classhandler.html#a5e9380355a7eea5386ef061f36479258">More...</a><br /></td></tr>
<tr class="separator:a5e9380355a7eea5386ef061f36479258 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5575d58c0acbb1924f7f3d3eb756612a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5575d58c0acbb1924f7f3d3eb756612a">index_scan_cost</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, double ranges, double rows)</td></tr>
<tr class="memdesc:a5575d58c0acbb1924f7f3d3eb756612a inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate for reading a number of ranges from an index.  <a href="classhandler.html#a5575d58c0acbb1924f7f3d3eb756612a">More...</a><br /></td></tr>
<tr class="separator:a5575d58c0acbb1924f7f3d3eb756612a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d85fe55a71cc09c642592e771b662 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a196d85fe55a71cc09c642592e771b662">read_cost</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, double ranges, double rows)</td></tr>
<tr class="memdesc:a196d85fe55a71cc09c642592e771b662 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate for reading a set of ranges from the table using an index to access it.  <a href="classhandler.html#a196d85fe55a71cc09c642592e771b662">More...</a><br /></td></tr>
<tr class="separator:a196d85fe55a71cc09c642592e771b662 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171927b3afde9e800755b834bd8d31bd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a171927b3afde9e800755b834bd8d31bd">table_in_memory_estimate</a> () const</td></tr>
<tr class="memdesc:a171927b3afde9e800755b834bd8d31bd inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimate of how much of the table that is currently stored in main memory.  <a href="classhandler.html#a171927b3afde9e800755b834bd8d31bd">More...</a><br /></td></tr>
<tr class="separator:a171927b3afde9e800755b834bd8d31bd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375fdfc86f021f336777324dd5a98a02 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a375fdfc86f021f336777324dd5a98a02">index_in_memory_estimate</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno) const</td></tr>
<tr class="memdesc:a375fdfc86f021f336777324dd5a98a02 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimate of how much of the index that is currently stored in main memory.  <a href="classhandler.html#a375fdfc86f021f336777324dd5a98a02">More...</a><br /></td></tr>
<tr class="separator:a375fdfc86f021f336777324dd5a98a02 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0014e351a991fe9c77b4657e4f75dbab inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0014e351a991fe9c77b4657e4f75dbab">ha_sample_init</a> (void *&amp;scan_ctx, double sampling_percentage, int sampling_seed, <a class="el" href="sql_2handler_8h.html#ae954cfd46ba0b8300368dccf2bebc842">enum_sampling_method</a> sampling_method)</td></tr>
<tr class="memdesc:a0014e351a991fe9c77b4657e4f75dbab inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sampling.  <a href="classhandler.html#a0014e351a991fe9c77b4657e4f75dbab">More...</a><br /></td></tr>
<tr class="separator:a0014e351a991fe9c77b4657e4f75dbab inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a7ed7143700cada199b11f231876c3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a72a7ed7143700cada199b11f231876c3">ha_sample_next</a> (void *scan_ctx, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a72a7ed7143700cada199b11f231876c3 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next record for sampling.  <a href="classhandler.html#a72a7ed7143700cada199b11f231876c3">More...</a><br /></td></tr>
<tr class="separator:a72a7ed7143700cada199b11f231876c3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3147b1facb5846b2ecdf2a0d77775d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e3147b1facb5846b2ecdf2a0d77775d">ha_sample_end</a> (void *scan_ctx)</td></tr>
<tr class="memdesc:a3e3147b1facb5846b2ecdf2a0d77775d inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">End sampling.  <a href="classhandler.html#a3e3147b1facb5846b2ecdf2a0d77775d">More...</a><br /></td></tr>
<tr class="separator:a3e3147b1facb5846b2ecdf2a0d77775d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7462a72e9f19ae676d9eb6735a8204 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2e7462a72e9f19ae676d9eb6735a8204">ha_multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="separator:a2e7462a72e9f19ae676d9eb6735a8204 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57496d1b472f836f21ef273b661949ee inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a57496d1b472f836f21ef273b661949ee">ha_read_range_first</a> (const <a class="el" href="structkey__range.html">key_range</a> *start_key, const <a class="el" href="structkey__range.html">key_range</a> *end_key, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classhandler.html#a272c3d9b40a9e7c5de20ed390d23a636">eq_range</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="separator:a57496d1b472f836f21ef273b661949ee inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c81a68cc8e83e75f5b87a8fb1922271 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3c81a68cc8e83e75f5b87a8fb1922271">ha_read_range_next</a> ()</td></tr>
<tr class="separator:a3c81a68cc8e83e75f5b87a8fb1922271 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d4ecfa5cfe85d8179aa52488016d0 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae73d4ecfa5cfe85d8179aa52488016d0">has_transactions</a> ()</td></tr>
<tr class="separator:ae73d4ecfa5cfe85d8179aa52488016d0 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd434bc44b88f4e47f44f02c877c91 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a27fd434bc44b88f4e47f44f02c877c91">extra_rec_buf_length</a> () const</td></tr>
<tr class="separator:a27fd434bc44b88f4e47f44f02c877c91 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5919d6a3f3098353f4517e2c81037 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a39c5919d6a3f3098353f4517e2c81037">is_ignorable_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="memdesc:a39c5919d6a3f3098353f4517e2c81037 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error can be ignored or not.  <a href="classhandler.html#a39c5919d6a3f3098353f4517e2c81037">More...</a><br /></td></tr>
<tr class="separator:a39c5919d6a3f3098353f4517e2c81037 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37413b5d60b340ffe26a6713b65bab75 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37413b5d60b340ffe26a6713b65bab75">is_fatal_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="memdesc:a37413b5d60b340ffe26a6713b65bab75 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error is fatal or not.  <a href="classhandler.html#a37413b5d60b340ffe26a6713b65bab75">More...</a><br /></td></tr>
<tr class="separator:a37413b5d60b340ffe26a6713b65bab75 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe4a9e78c818aa2823c302f0fe65522 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9fe4a9e78c818aa2823c302f0fe65522">ha_records</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows)</td></tr>
<tr class="memdesc:a9fe4a9e78c818aa2823c302f0fe65522 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to call records() in storage engine.  <a href="classhandler.html#a9fe4a9e78c818aa2823c302f0fe65522">More...</a><br /></td></tr>
<tr class="separator:a9fe4a9e78c818aa2823c302f0fe65522 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545cfccfcb87c61521d140c55c328c9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5545cfccfcb87c61521d140c55c328c9">ha_records</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a5545cfccfcb87c61521d140c55c328c9 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to call records_from_index() in storage engine.  <a href="classhandler.html#a5545cfccfcb87c61521d140c55c328c9">More...</a><br /></td></tr>
<tr class="separator:a5545cfccfcb87c61521d140c55c328c9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr class="memdesc:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that the table-&gt;read_set and table-&gt;write_set table maps changed The handler is allowed to set additional bits in the above map in this call.  <a href="classhandler.html#a4de97045e5381007565fd2b0da235c07">More...</a><br /></td></tr>
<tr class="separator:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aacdf0aed6539181d465676ebc661f2b5">get_index</a> (void) const</td></tr>
<tr class="separator:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488245f51aa4676c872bb0564dbe71f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a> ()</td></tr>
<tr class="separator:a7488245f51aa4676c872bb0564dbe71f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf7319a6498f655f8f07b1b34b12fc inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a> ()</td></tr>
<tr class="separator:acdaf7319a6498f655f8f07b1b34b12fc inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf2fbf16de7e200e3ebc0765fb6e4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *dup_key_found)</td></tr>
<tr class="memdesc:a886bf2fbf16de7e200e3ebc0765fb6e4 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">After this call all outstanding updates must be performed.  <a href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">More...</a><br /></td></tr>
<tr class="separator:a886bf2fbf16de7e200e3ebc0765fb6e4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6c46d66ca282a4cbd6118e4c99e03 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a> ()</td></tr>
<tr class="memdesc:a2bf6c46d66ca282a4cbd6118e4c99e03 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any needed clean-up, no outstanding updates are there at the moment.  <a href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">More...</a><br /></td></tr>
<tr class="separator:a2bf6c46d66ca282a4cbd6118e4c99e03 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9f1ca2b5efc0b41e96c6b793d9bb1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a> ()</td></tr>
<tr class="memdesc:af5f9f1ca2b5efc0b41e96c6b793d9bb1 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute all outstanding deletes and close down the bulk delete.  <a href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">More...</a><br /></td></tr>
<tr class="separator:af5f9f1ca2b5efc0b41e96c6b793d9bb1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const <a class="el" href="structkey__range.html">key_range</a> *<a class="el" href="structrange.html">range</a>, <a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">enum_range_scan_direction</a> direction)</td></tr>
<tr class="memdesc:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the end position for a range scan.  <a href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">More...</a><br /></td></tr>
<tr class="separator:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (<a class="el" href="structkey__range.html">key_range</a> *<a class="el" href="structrange.html">range</a>)</td></tr>
<tr class="memdesc:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if found key (in row) is over max-value.  <a href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">More...</a><br /></td></tr>
<tr class="separator:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab767345668267e3c8881fab6e351e6c8">compare_key_icp</a> (const <a class="el" href="structkey__range.html">key_range</a> *<a class="el" href="structrange.html">range</a>) const</td></tr>
<tr class="separator:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac3d9b9796d3bfb18b96a1989d6f516 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeac3d9b9796d3bfb18b96a1989d6f516">compare_key_in_buffer</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) const</td></tr>
<tr class="memdesc:aeac3d9b9796d3bfb18b96a1989d6f516 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the key in the given buffer (which is not necessarily TABLE::record[0]) is within range.  <a href="classhandler.html#aeac3d9b9796d3bfb18b96a1989d6f516">More...</a><br /></td></tr>
<tr class="separator:aeac3d9b9796d3bfb18b96a1989d6f516 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a72693b6e25765a4290f531f578bcf2eb">ft_end</a> ()</td></tr>
<tr class="separator:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ed6e67d0d9891569f90f4122d3855 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adb6ed6e67d0d9891569f90f4122d3855">ha_ft_read</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:adb6ed6e67d0d9891569f90f4122d3855 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bc3e86490651704ce5b928169dd725 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4bc3e86490651704ce5b928169dd725">ha_read_first_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> primary_key)</td></tr>
<tr class="memdesc:ae4bc3e86490651704ce5b928169dd725 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row (only) from a table.  <a href="classhandler.html#ae4bc3e86490651704ce5b928169dd725">More...</a><br /></td></tr>
<tr class="separator:ae4bc3e86490651704ce5b928169dd725 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be2fa5d347252f8a28dce931654b76 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="memdesc:ac2be2fa5d347252f8a28dce931654b76 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set.  <a href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">More...</a><br /></td></tr>
<tr class="separator:ac2be2fa5d347252f8a28dce931654b76 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e746c224b70d3b03b2886ecf4563394 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7e746c224b70d3b03b2886ecf4563394">calculate_key_hash_value</a> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr class="separator:a7e746c224b70d3b03b2886ecf4563394 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a7e1c60d82baca1890cf9805d1694b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62a7e1c60d82baca1890cf9805d1694b">ha_extra</a> (enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a> operation)</td></tr>
<tr class="memdesc:a62a7e1c60d82baca1890cf9805d1694b inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request storage engine to do an extra operation: enable,disable or run some functionality.  <a href="classhandler.html#a62a7e1c60d82baca1890cf9805d1694b">More...</a><br /></td></tr>
<tr class="separator:a62a7e1c60d82baca1890cf9805d1694b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e72da94a7f5577f00ab5c89204ec1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b7e72da94a7f5577f00ab5c89204ec1">extra_opt</a> (enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a> operation, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> <a class="el" href="xcom__cache_8cc.html#a27d1b984097f6bd1dcfa1b428c6a8549">cache_size</a>)</td></tr>
<tr class="separator:a6b7e72da94a7f5577f00ab5c89204ec1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb375aeab783a6c520296c7621fb559 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#accb375aeab783a6c520296c7621fb559">engine_push</a> (<a class="el" href="classAQP_1_1Table__access.html">AQP::Table_access</a> *<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>)</td></tr>
<tr class="memdesc:accb375aeab783a6c520296c7621fb559 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let storage engine inspect the optimized 'plan' and pick whatever it like for being pushed down to the engine.  <a href="classhandler.html#accb375aeab783a6c520296c7621fb559">More...</a><br /></td></tr>
<tr class="separator:accb375aeab783a6c520296c7621fb559 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2428788c2437e4e33c4b390cc697f7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a> (void)</td></tr>
<tr class="memdesc:a3e2428788c2437e4e33c4b390cc697f7 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start read (before write) removal on the current table.  <a href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">More...</a><br /></td></tr>
<tr class="separator:a3e2428788c2437e4e33c4b390cc697f7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d99c283e85e8d97460f07a781dabf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a> (void)</td></tr>
<tr class="memdesc:a517d99c283e85e8d97460f07a781dabf inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">End read (before write) removal and return the number of rows really written.  <a href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">More...</a><br /></td></tr>
<tr class="separator:a517d99c283e85e8d97460f07a781dabf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab6f9bf8ee63f3b8312fdc31be3819ede">set_next_insert_id</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>)</td></tr>
<tr class="separator:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a15b51670b2497f01f19f587a4a969386">restore_auto_increment</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> <a class="el" href="sql_2handler_8cc.html#a6c4bbd335242a13cd781210b929c6d4b">prev_insert_id</a>)</td></tr>
<tr class="separator:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f356517f0bbed3e92061117e003f20 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a73f356517f0bbed3e92061117e003f20">assign_to_keycache</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="separator:a73f356517f0bbed3e92061117e003f20 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49396e778b671ffd7eade208e0e32054 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49396e778b671ffd7eade208e0e32054">preload_keys</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="separator:a49396e778b671ffd7eade208e0e32054 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc45e93a1b669fa750f73a617c46bac inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8bc45e93a1b669fa750f73a617c46bac">indexes_are_disabled</a> (void)</td></tr>
<tr class="memdesc:a8bc45e93a1b669fa750f73a617c46bac inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indexes are disabled.  <a href="classhandler.html#a8bc45e93a1b669fa750f73a617c46bac">More...</a><br /></td></tr>
<tr class="separator:a8bc45e93a1b669fa750f73a617c46bac inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a441afeebcb5b56e598fb7f860c9247d1">append_create_info</a> (<a class="el" href="classString.html">String</a> *packet)</td></tr>
<tr class="separator:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7ee9c5a03956913d75de1fca3af7833a">max_record_length</a> () const</td></tr>
<tr class="separator:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a493c1ac62569e6cc89cbfde66fea47f3">max_keys</a> () const</td></tr>
<tr class="separator:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1adabba96b635533f31d5e38e6d2a74c">max_key_parts</a> () const</td></tr>
<tr class="separator:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9e1b1d6fe7e717fe234c18915cb26e87">max_key_length</a> () const</td></tr>
<tr class="separator:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3699689407f76a90ea62a3f5f593e15 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae3699689407f76a90ea62a3f5f593e15">max_key_part_length</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info) const</td></tr>
<tr class="separator:ae3699689407f76a90ea62a3f5f593e15 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a498859c2d47448100e5e703622bb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a672a498859c2d47448100e5e703622bb">max_supported_record_length</a> () const</td></tr>
<tr class="separator:a672a498859c2d47448100e5e703622bb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d5b6de2843435371dc9045403e3d07 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25d5b6de2843435371dc9045403e3d07">max_supported_key_parts</a> () const</td></tr>
<tr class="separator:a25d5b6de2843435371dc9045403e3d07 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082d2a49764e8548b8104dc514877b3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab082d2a49764e8548b8104dc514877b3">min_record_length</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="sql__show__processlist_8cc.html#a625d75986eec56d5b1eae931c2492497">options</a>) const</td></tr>
<tr class="separator:ab082d2a49764e8548b8104dc514877b3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a20da13aaa177f1a256e5fb63e7c78 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64a20da13aaa177f1a256e5fb63e7c78">low_byte_first</a> () const</td></tr>
<tr class="separator:a64a20da13aaa177f1a256e5fb63e7c78 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00ca688822b5d3c9db5ce5d6a982b44 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MYSYS.html#ga31ef2f6273d26427fe4a13ed5049b050">ha_checksum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad00ca688822b5d3c9db5ce5d6a982b44">checksum</a> () const</td></tr>
<tr class="separator:ad00ca688822b5d3c9db5ce5d6a982b44 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea4b726707284210cc365ad454add03 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ea4b726707284210cc365ad454add03">is_crashed</a> () const</td></tr>
<tr class="memdesc:a6ea4b726707284210cc365ad454add03 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table is crashed.  <a href="classhandler.html#a6ea4b726707284210cc365ad454add03">More...</a><br /></td></tr>
<tr class="separator:a6ea4b726707284210cc365ad454add03 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08387779d587f8d3ea84b965ddc391 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aca08387779d587f8d3ea84b965ddc391">auto_repair</a> () const</td></tr>
<tr class="memdesc:aca08387779d587f8d3ea84b965ddc391 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table can be automatically repaired.  <a href="classhandler.html#aca08387779d587f8d3ea84b965ddc391">More...</a><br /></td></tr>
<tr class="separator:aca08387779d587f8d3ea84b965ddc391 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818d1203804da43f05fa666d4a0c83a9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a818d1203804da43f05fa666d4a0c83a9">cond_push</a> (const <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> other_tbls_ok)</td></tr>
<tr class="memdesc:a818d1203804da43f05fa666d4a0c83a9 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push condition down to the table handler.  <a href="classhandler.html#a818d1203804da43f05fa666d4a0c83a9">More...</a><br /></td></tr>
<tr class="separator:a818d1203804da43f05fa666d4a0c83a9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr class="memdesc:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset information about pushed index conditions.  <a href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">More...</a><br /></td></tr>
<tr class="separator:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86930bf10b20ad19b3df07e07d28116e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">number_of_pushed_joins</a> () const</td></tr>
<tr class="memdesc:a86930bf10b20ad19b3df07e07d28116e inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports number of tables included in pushed join which this handler instance is part of.  <a href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">More...</a><br /></td></tr>
<tr class="separator:a86930bf10b20ad19b3df07e07d28116e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777443226094990f74c6008c8a67168b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a777443226094990f74c6008c8a67168b">member_of_pushed_join</a> () const</td></tr>
<tr class="memdesc:a777443226094990f74c6008c8a67168b inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this handler instance is part of a pushed join sequence returned TABLE instance being root of the pushed query?  <a href="classhandler.html#a777443226094990f74c6008c8a67168b">More...</a><br /></td></tr>
<tr class="separator:a777443226094990f74c6008c8a67168b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef865015edc575d0a50d1a6f5b13e4a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">parent_of_pushed_join</a> () const</td></tr>
<tr class="memdesc:aaef865015edc575d0a50d1a6f5b13e4a inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this handler instance is a child in a pushed join sequence returned TABLE instance being my parent?  <a href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">More...</a><br /></td></tr>
<tr class="separator:aaef865015edc575d0a50d1a6f5b13e4a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17a6fa82ef1a46a8772118ce98c6867 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac17a6fa82ef1a46a8772118ce98c6867">tables_in_pushed_join</a> () const</td></tr>
<tr class="separator:ac17a6fa82ef1a46a8772118ce98c6867 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972eaf8824b8e5fbbafc0f76d8ab0d8a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a972eaf8824b8e5fbbafc0f76d8ab0d8a">ha_index_read_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)</td></tr>
<tr class="separator:a972eaf8824b8e5fbbafc0f76d8ab0d8a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9b89354e9938d79b1f72e11c8e7626 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1d9b89354e9938d79b1f72e11c8e7626">ha_index_next_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:a1d9b89354e9938d79b1f72e11c8e7626 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9ef0d5918463a152ffa763dd8d794a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6c9ef0d5918463a152ffa763dd8d794a">ha_prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:a6c9ef0d5918463a152ffa763dd8d794a inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public functions wrapping the actual handler call.  <a href="classhandler.html#a6c9ef0d5918463a152ffa763dd8d794a">More...</a><br /></td></tr>
<tr class="separator:a6c9ef0d5918463a152ffa763dd8d794a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d24ed82fba01ba93d3ed5059789e7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abf2d24ed82fba01ba93d3ed5059789e7">ha_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:abf2d24ed82fba01ba93d3ed5059789e7 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public function wrapping the actual handler call.  <a href="classhandler.html#abf2d24ed82fba01ba93d3ed5059789e7">More...</a><br /></td></tr>
<tr class="separator:abf2d24ed82fba01ba93d3ed5059789e7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6902ffe7fd0afa8a32969f606e4302e7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6902ffe7fd0afa8a32969f606e4302e7">ha_commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="sql__cmd__srs_8cc.html#af8756202cf6ab572edb0e832014f1a5f">commit</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:a6902ffe7fd0afa8a32969f606e4302e7 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public function wrapping the actual handler call.  <a href="classhandler.html#a6902ffe7fd0afa8a32969f606e4302e7">More...</a><br /></td></tr>
<tr class="separator:a6902ffe7fd0afa8a32969f606e4302e7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8d36387a3cb7301ee63d842198d328 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb8d36387a3cb7301ee63d842198d328">ha_notify_table_changed</a> (<a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="memdesc:abb8d36387a3cb7301ee63d842198d328 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public function wrapping the actual handler call.  <a href="classhandler.html#abb8d36387a3cb7301ee63d842198d328">More...</a><br /></td></tr>
<tr class="separator:abb8d36387a3cb7301ee63d842198d328 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr class="memdesc:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key  <a href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">More...</a><br /></td></tr>
<tr class="separator:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd7e44bc71120ace1e467ccb02ad06 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *dup_key_found)</td></tr>
<tr class="memdesc:ac8dd7e44bc71120ace1e467ccb02ad06 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time.  <a href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">More...</a><br /></td></tr>
<tr class="separator:ac8dd7e44bc71120ace1e467ccb02ad06 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbfc4312adf397f421dba81d65186ab inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abfbfc4312adf397f421dba81d65186ab">truncate</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:abfbfc4312adf397f421dba81d65186ab inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly remove all rows from a table.  <a href="classhandler.html#abfbfc4312adf397f421dba81d65186ab">More...</a><br /></td></tr>
<tr class="separator:abfbfc4312adf397f421dba81d65186ab inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1378edb4813d141f666ce2b9382a4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac9c1378edb4813d141f666ce2b9382a4">check_and_repair</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ac9c1378edb4813d141f666ce2b9382a4 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and repair the table if necessary.  <a href="classhandler.html#ac9c1378edb4813d141f666ce2b9382a4">More...</a><br /></td></tr>
<tr class="separator:ac9c1378edb4813d141f666ce2b9382a4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac61d474cf912188a562e9f419872031e">drop_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="separator:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370a0f787c1b936e475a5762b91350c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae370a0f787c1b936e475a5762b91350c">set_ha_share_ref</a> (<a class="el" href="classHandler__share.html">Handler_share</a> **arg_ha_share)</td></tr>
<tr class="separator:ae370a0f787c1b936e475a5762b91350c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcbbed1055c74444efa8e21dc3b84af inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0fcbbed1055c74444efa8e21dc3b84af">set_ha_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg)</td></tr>
<tr class="separator:a0fcbbed1055c74444efa8e21dc3b84af inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6a271a4a135d110cf6f22ae8ce664664">get_lock_type</a> () const</td></tr>
<tr class="separator:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dad27a5b6b7320e6270138f7d5a0a30 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPartition__handler.html">Partition_handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6dad27a5b6b7320e6270138f7d5a0a30">get_partition_handler</a> ()</td></tr>
<tr class="separator:a6dad27a5b6b7320e6270138f7d5a0a30 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44adf6e8563f65c68edcb47e8e442f7e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a44adf6e8563f65c68edcb47e8e442f7e">ha_upgrade_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *dbname, const char *table_name, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table, <a class="el" href="structTABLE.html">TABLE</a> *table_arg)</td></tr>
<tr class="memdesc:a44adf6e8563f65c68edcb47e8e442f7e inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set se_private_id and se_private_data during upgrade.  <a href="classhandler.html#a44adf6e8563f65c68edcb47e8e442f7e">More...</a><br /></td></tr>
<tr class="separator:a44adf6e8563f65c68edcb47e8e442f7e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d5a87a9d7efac748885280b87cfd04 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64d5a87a9d7efac748885280b87cfd04">ha_set_primary_handler</a> (<a class="el" href="classhandler.html">handler</a> *primary_handler)</td></tr>
<tr class="memdesc:a64d5a87a9d7efac748885280b87cfd04 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the handler of the primary table that corresponds to the secondary table in this handler.  <a href="classhandler.html#a64d5a87a9d7efac748885280b87cfd04">More...</a><br /></td></tr>
<tr class="separator:a64d5a87a9d7efac748885280b87cfd04 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1766c3ce158b96a006cf148b31f18 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4b1766c3ce158b96a006cf148b31f18">ha_get_primary_handler</a> () const</td></tr>
<tr class="memdesc:ae4b1766c3ce158b96a006cf148b31f18 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a handler for the table in the primary storage engine, if this handler is for a table in a secondary storage engine.  <a href="classhandler.html#ae4b1766c3ce158b96a006cf148b31f18">More...</a><br /></td></tr>
<tr class="separator:ae4b1766c3ce158b96a006cf148b31f18 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5386c0ecf6cc739bdaf7b61e5b027 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac6a5386c0ecf6cc739bdaf7b61e5b027">ha_mv_key_capacity</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *num_keys, size_t *keys_length) const</td></tr>
<tr class="memdesc:ac6a5386c0ecf6cc739bdaf7b61e5b027 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return max limits for a single set of multi-valued keys.  <a href="classhandler.html#ac6a5386c0ecf6cc739bdaf7b61e5b027">More...</a><br /></td></tr>
<tr class="separator:ac6a5386c0ecf6cc739bdaf7b61e5b027 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a199305091c0b0e32198a8bfc5541f277"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a199305091c0b0e32198a8bfc5541f277">delete_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>, enum <a class="el" href="my__sqlcommand_8h.html#a46bba265a20f1784df6b9802aec4122a">enum_sql_command</a> sqlcom)</td></tr>
<tr class="memdesc:a199305091c0b0e32198a8bfc5541f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a table.  <a href="#a199305091c0b0e32198a8bfc5541f277">More...</a><br /></td></tr>
<tr class="separator:a199305091c0b0e32198a8bfc5541f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88304b5868b42aa9f64afdf617b17c5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a88304b5868b42aa9f64afdf617b17c5e">srv_concurrency_enter</a> ()</td></tr>
<tr class="memdesc:a88304b5868b42aa9f64afdf617b17c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter InnoDB engine after checking max allowed threads.  <a href="#a88304b5868b42aa9f64afdf617b17c5e">More...</a><br /></td></tr>
<tr class="separator:a88304b5868b42aa9f64afdf617b17c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a972bc49516aea7ff451a71bc94db6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3a972bc49516aea7ff451a71bc94db6c">srv_concurrency_exit</a> ()</td></tr>
<tr class="memdesc:a3a972bc49516aea7ff451a71bc94db6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave Innodb, if no more tickets are left.  <a href="#a3a972bc49516aea7ff451a71bc94db6c">More...</a><br /></td></tr>
<tr class="separator:a3a972bc49516aea7ff451a71bc94db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544385a9ff719a58727aef2f8bf8cf1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a544385a9ff719a58727aef2f8bf8cf1b">update_thd</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a544385a9ff719a58727aef2f8bf8cf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the user_thd field in a handle and also allocates a new InnoDB transaction handle if needed, and updates the transaction fields in the m_prebuilt struct.  <a href="#a544385a9ff719a58727aef2f8bf8cf1b">More...</a><br /></td></tr>
<tr class="separator:a544385a9ff719a58727aef2f8bf8cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7643086f7386ad81e3f1393cf8fbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a1f7643086f7386ad81e3f1393cf8fbcb">general_fetch</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> direction, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> match_mode)</td></tr>
<tr class="memdesc:a1f7643086f7386ad81e3f1393cf8fbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next or previous row from a cursor, which must have previously been positioned using index_read.  <a href="#a1f7643086f7386ad81e3f1393cf8fbcb">More...</a><br /></td></tr>
<tr class="separator:a1f7643086f7386ad81e3f1393cf8fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a48a3f83277536b4a13c51a3b210793"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5a48a3f83277536b4a13c51a3b210793">innobase_get_index</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keynr)</td></tr>
<tr class="memdesc:a5a48a3f83277536b4a13c51a3b210793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index for a handle.  <a href="#a5a48a3f83277536b4a13c51a3b210793">More...</a><br /></td></tr>
<tr class="separator:a5a48a3f83277536b4a13c51a3b210793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31824ee43bb96fab66831871f53581ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a31824ee43bb96fab66831871f53581ba">build_template</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> whole_row)</td></tr>
<tr class="memdesc:a31824ee43bb96fab66831871f53581ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a 'template' to the m_prebuilt struct.  <a href="#a31824ee43bb96fab66831871f53581ba">More...</a><br /></td></tr>
<tr class="separator:a31824ee43bb96fab66831871f53581ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51ab4f43bfc4cd142195f620a43a61f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af51ab4f43bfc4cd142195f620a43a61f">info_low</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_analyze)</td></tr>
<tr class="memdesc:af51ab4f43bfc4cd142195f620a43a61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns statistics information of the table to the MySQL interpreter, in various fields of the handle object.  <a href="#af51ab4f43bfc4cd142195f620a43a61f">More...</a><br /></td></tr>
<tr class="separator:af51ab4f43bfc4cd142195f620a43a61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a82a21bb13d0f355cde55cf15574ff8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8a82a21bb13d0f355cde55cf15574ff8">end_stmt</a> ()</td></tr>
<tr class="memdesc:a8a82a21bb13d0f355cde55cf15574ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL calls this method at the end of each statement.  <a href="#a8a82a21bb13d0f355cde55cf15574ff8">More...</a><br /></td></tr>
<tr class="separator:a8a82a21bb13d0f355cde55cf15574ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c844476f28ce4eee84f8b51bb94e75"><td class="memTemplParams" colspan="2">template&lt;typename Table &gt; </td></tr>
<tr class="memitem:a65c844476f28ce4eee84f8b51bb94e75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a65c844476f28ce4eee84f8b51bb94e75">prepare_inplace_alter_table_impl</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classTable.html">Table</a> *old_dd_tab, <a class="el" href="classTable.html">Table</a> *new_dd_tab)</td></tr>
<tr class="memdesc:a65c844476f28ce4eee84f8b51bb94e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of prepare_inplace_alter_table()  <a href="#a65c844476f28ce4eee84f8b51bb94e75">More...</a><br /></td></tr>
<tr class="separator:a65c844476f28ce4eee84f8b51bb94e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e8864d0b37e4093ad3c357d0f7c86d"><td class="memTemplParams" colspan="2">template&lt;typename Table &gt; </td></tr>
<tr class="memitem:a77e8864d0b37e4093ad3c357d0f7c86d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a77e8864d0b37e4093ad3c357d0f7c86d">inplace_alter_table_impl</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classTable.html">Table</a> *old_dd_tab, <a class="el" href="classTable.html">Table</a> *new_dd_tab)</td></tr>
<tr class="memdesc:a77e8864d0b37e4093ad3c357d0f7c86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of inplace_alter_table()  <a href="#a77e8864d0b37e4093ad3c357d0f7c86d">More...</a><br /></td></tr>
<tr class="separator:a77e8864d0b37e4093ad3c357d0f7c86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f95d1675ae28286a640d502b8c9c38"><td class="memTemplParams" colspan="2">template&lt;typename Table &gt; </td></tr>
<tr class="memitem:aa5f95d1675ae28286a640d502b8c9c38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa5f95d1675ae28286a640d502b8c9c38">commit_inplace_alter_table_impl</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="sql__cmd__srs_8cc.html#af8756202cf6ab572edb0e832014f1a5f">commit</a>, const <a class="el" href="classTable.html">Table</a> *old_dd_tab, <a class="el" href="classTable.html">Table</a> *new_dd_tab)</td></tr>
<tr class="memdesc:aa5f95d1675ae28286a640d502b8c9c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of commit_inplace_alter_table()  <a href="#aa5f95d1675ae28286a640d502b8c9c38">More...</a><br /></td></tr>
<tr class="separator:aa5f95d1675ae28286a640d502b8c9c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aa41314a91727810c195bde3843bdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a00aa41314a91727810c195bde3843bdb">mv_key_capacity</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *num_keys, size_t *keys_length) const override</td></tr>
<tr class="memdesc:a00aa41314a91727810c195bde3843bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return max limits for a single set of multi-valued keys.  <a href="#a00aa41314a91727810c195bde3843bdb">More...</a><br /></td></tr>
<tr class="separator:a00aa41314a91727810c195bde3843bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">index_read_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index').  <a href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">More...</a><br /></td></tr>
<tr class="separator:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">index_read_idx_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument.  <a href="classhandler.html#acba0c549a00023dd44682cd9452cf830">More...</a><br /></td></tr>
<tr class="separator:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">index_read_last_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)</td></tr>
<tr class="memdesc:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">More...</a><br /></td></tr>
<tr class="separator:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f216ddcf2eed269254ed5f6c764342 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a34f216ddcf2eed269254ed5f6c764342">index_read_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>)</td></tr>
<tr class="separator:a34f216ddcf2eed269254ed5f6c764342 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b953412855f4339ce3ed022fc043dd inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a91b953412855f4339ce3ed022fc043dd">index_next_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:a91b953412855f4339ce3ed022fc043dd inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac6921759060b252db86f800e46fc99 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ac6921759060b252db86f800e46fc99">notify_table_changed</a> (<a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="memdesc:a9ac6921759060b252db86f800e46fc99 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the storage engine that the table definition has been updated.  <a href="classhandler.html#a9ac6921759060b252db86f800e46fc99">More...</a><br /></td></tr>
<tr class="separator:a9ac6921759060b252db86f800e46fc99 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4999b9c5fba920ee4e45da810dc32cda inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4999b9c5fba920ee4e45da810dc32cda">ha_statistic_increment</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> System_status_var::*offset) const</td></tr>
<tr class="separator:a4999b9c5fba920ee4e45da810dc32cda inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9df65ee64bcedb5a4b34bf752b2fab08">ha_thd</a> (void) const</td></tr>
<tr class="separator:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__table.html#gada4ffe8c7b58d5fd0b8bd8c793819184">PSI_table_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a69803cd29d92bfecd97212354212c516">ha_table_share_psi</a> (const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="memdesc:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the instrumented table information from a table share.  <a href="classhandler.html#a69803cd29d92bfecd97212354212c516">More...</a><br /></td></tr>
<tr class="separator:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr class="memdesc:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an initialized ha_share.  <a href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">More...</a><br /></td></tr>
<tr class="separator:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="classHandler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr class="memdesc:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ha_share to be used by all instances of the same table/partition.  <a href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">More...</a><br /></td></tr>
<tr class="separator:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr class="memdesc:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a lock for protecting shared handler data.  <a href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">More...</a><br /></td></tr>
<tr class="separator:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr class="memdesc:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release lock for protecting ha_share.  <a href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">More...</a><br /></td></tr>
<tr class="separator:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a119bf770d1236ded83e472953ffc56ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDsMrr__impl.html">DsMrr_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a119bf770d1236ded83e472953ffc56ac">m_ds_mrr</a></td></tr>
<tr class="memdesc:a119bf770d1236ded83e472953ffc56ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multi range read session object.  <a href="#a119bf770d1236ded83e472953ffc56ac">More...</a><br /></td></tr>
<tr class="separator:a119bf770d1236ded83e472953ffc56ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7ac63b3f490bc8e9fc37688c4c5fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5f7ac63b3f490bc8e9fc37688c4c5fbf">m_prebuilt</a></td></tr>
<tr class="memdesc:a5f7ac63b3f490bc8e9fc37688c4c5fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save CPU time with prebuilt/cached data structures.  <a href="#a5f7ac63b3f490bc8e9fc37688c4c5fbf">More...</a><br /></td></tr>
<tr class="separator:a5f7ac63b3f490bc8e9fc37688c4c5fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00043185de77b7b62cb1ff4d731c7892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a00043185de77b7b62cb1ff4d731c7892">m_user_thd</a></td></tr>
<tr class="memdesc:a00043185de77b7b62cb1ff4d731c7892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread handle of the user currently using the handler; this is set in external_lock function.  <a href="#a00043185de77b7b62cb1ff4d731c7892">More...</a><br /></td></tr>
<tr class="separator:a00043185de77b7b62cb1ff4d731c7892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf7cfc62bf068b9f0a36b670d5e4f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structINNOBASE__SHARE.html">INNOBASE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6bf7cfc62bf068b9f0a36b670d5e4f1f">m_share</a></td></tr>
<tr class="memdesc:a6bf7cfc62bf068b9f0a36b670d5e4f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">information for MySQL table locking  <a href="#a6bf7cfc62bf068b9f0a36b670d5e4f1f">More...</a><br /></td></tr>
<tr class="separator:a6bf7cfc62bf068b9f0a36b670d5e4f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a660c7aefb96de3d325531d254c6155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a1a660c7aefb96de3d325531d254c6155">m_upd_buf</a></td></tr>
<tr class="memdesc:a1a660c7aefb96de3d325531d254c6155"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer used in updates  <a href="#a1a660c7aefb96de3d325531d254c6155">More...</a><br /></td></tr>
<tr class="separator:a1a660c7aefb96de3d325531d254c6155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39d884bfcc68b38b1175c14c46d14c9"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa39d884bfcc68b38b1175c14c46d14c9">m_upd_buf_size</a></td></tr>
<tr class="memdesc:aa39d884bfcc68b38b1175c14c46d14c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of upd_buf in bytes  <a href="#aa39d884bfcc68b38b1175c14c46d14c9">More...</a><br /></td></tr>
<tr class="separator:aa39d884bfcc68b38b1175c14c46d14c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac241ca27bc9eee2c949a552e81b202c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ac241ca27bc9eee2c949a552e81b202c0">m_int_table_flags</a></td></tr>
<tr class="memdesc:ac241ca27bc9eee2c949a552e81b202c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags that specificy the handler instance (table) capability.  <a href="#ac241ca27bc9eee2c949a552e81b202c0">More...</a><br /></td></tr>
<tr class="separator:ac241ca27bc9eee2c949a552e81b202c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d141e41ac99ae6927fe7c2518810e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a7d141e41ac99ae6927fe7c2518810e1a">m_start_of_scan</a></td></tr>
<tr class="memdesc:a7d141e41ac99ae6927fe7c2518810e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is set to 1 when we are starting a table scan but have not yet fetched any row, else false  <a href="#a7d141e41ac99ae6927fe7c2518810e1a">More...</a><br /></td></tr>
<tr class="separator:a7d141e41ac99ae6927fe7c2518810e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2691576aee2886e00364dd1b0c2b9568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a2691576aee2886e00364dd1b0c2b9568">m_last_match_mode</a> {0}</td></tr>
<tr class="separator:a2691576aee2886e00364dd1b0c2b9568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8cc56d04d8bff2c06736db1beecf54"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6e8cc56d04d8bff2c06736db1beecf54">m_stored_select_lock_type</a></td></tr>
<tr class="memdesc:a6e8cc56d04d8bff2c06736db1beecf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">this field is used to remember the original select_lock_type that was decided in ha_innodb.cc,":: store_lock()", "::external_lock()", etc.  <a href="#a6e8cc56d04d8bff2c06736db1beecf54">More...</a><br /></td></tr>
<tr class="separator:a6e8cc56d04d8bff2c06736db1beecf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b767b944c208922ac6c192bc565309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a63b767b944c208922ac6c192bc565309">m_mysql_has_locked</a></td></tr>
<tr class="memdesc:a63b767b944c208922ac6c192bc565309"><td class="mdescLeft">&#160;</td><td class="mdescRight">If mysql has locked with external_lock()  <a href="#a63b767b944c208922ac6c192bc565309">More...</a><br /></td></tr>
<tr class="separator:a63b767b944c208922ac6c192bc565309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3b094cfe680aa06a7d8b70194415aa3b">table_share</a></td></tr>
<tr class="separator:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a></td></tr>
<tr class="separator:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a98743b18a24c8baef7e22a11df74d6c9">cached_table_flags</a></td></tr>
<tr class="separator:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adf44b6a4c101f982cd13a344dce5a870">estimation_rows_to_insert</a></td></tr>
<tr class="separator:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a011df14ecc738037499572c304d8ee90">range_key_part</a></td></tr>
<tr class="separator:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a272c3d9b40a9e7c5de20ed390d23a636">eq_range</a></td></tr>
<tr class="separator:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1a159ca294d8dafe32405e6ad546e6a4">in_range_check_pushed_down</a></td></tr>
<tr class="separator:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a69a39a509591249bd1baf5010c69286a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a69a39a509591249bd1baf5010c69286a">update_thd</a> ()</td></tr>
<tr class="memdesc:a69a39a509591249bd1baf5010c69286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the user_thd field in a handle and also allocates a new InnoDB transaction handle if needed, and updates the transaction fields in the m_prebuilt struct.  <a href="#a69a39a509591249bd1baf5010c69286a">More...</a><br /></td></tr>
<tr class="separator:a69a39a509591249bd1baf5010c69286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c2656c55aed7c6f81d03bc00c7fc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a942c2656c55aed7c6f81d03bc00c7fc4">change_active_index</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keynr)</td></tr>
<tr class="memdesc:a942c2656c55aed7c6f81d03bc00c7fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the active index of a handle.  <a href="#a942c2656c55aed7c6f81d03bc00c7fc4">More...</a><br /></td></tr>
<tr class="separator:a942c2656c55aed7c6f81d03bc00c7fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcdac25ce135fedf0ba5c741c7832ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#acbcdac25ce135fedf0ba5c741c7832ff">innobase_lock_autoinc</a> ()</td></tr>
<tr class="memdesc:acbcdac25ce135fedf0ba5c741c7832ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This special handling is really to overcome the limitations of MySQL's binlogging.  <a href="#acbcdac25ce135fedf0ba5c741c7832ff">More...</a><br /></td></tr>
<tr class="separator:acbcdac25ce135fedf0ba5c741c7832ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7137f4054ebb3f178545f985f14fe3dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a7137f4054ebb3f178545f985f14fe3dc">innobase_set_max_autoinc</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> auto_inc)</td></tr>
<tr class="memdesc:a7137f4054ebb3f178545f985f14fe3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the autoinc value in the table.  <a href="#a7137f4054ebb3f178545f985f14fe3dc">More...</a><br /></td></tr>
<tr class="separator:a7137f4054ebb3f178545f985f14fe3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01cb111b995307de63904caa846b9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa01cb111b995307de63904caa846b9fb">innobase_get_autoinc</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:aa01cb111b995307de63904caa846b9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next autoinc value.  <a href="#aa01cb111b995307de63904caa846b9fb">More...</a><br /></td></tr>
<tr class="separator:aa01cb111b995307de63904caa846b9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35920b0122df98efb5af2e651edbb332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a35920b0122df98efb5af2e651edbb332">innobase_initialize_autoinc</a> ()</td></tr>
<tr class="memdesc:a35920b0122df98efb5af2e651edbb332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the autoinc column max value.  <a href="#a35920b0122df98efb5af2e651edbb332">More...</a><br /></td></tr>
<tr class="separator:a35920b0122df98efb5af2e651edbb332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa288074a103562d391f66ddb87e9329b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa288074a103562d391f66ddb87e9329b">reset_template</a> ()</td></tr>
<tr class="memdesc:aa288074a103562d391f66ddb87e9329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a query execution 'template'.  <a href="#aa288074a103562d391f66ddb87e9329b">More...</a><br /></td></tr>
<tr class="separator:aa288074a103562d391f66ddb87e9329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b6d168ce1f0a03dcea03e7cf81771e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a47b6d168ce1f0a03dcea03e7cf81771e">intrinsic_table_write_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="memdesc:a47b6d168ce1f0a03dcea03e7cf81771e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Row Interface optimized for Intrinsic table.  <a href="#a47b6d168ce1f0a03dcea03e7cf81771e">More...</a><br /></td></tr>
<tr class="separator:a47b6d168ce1f0a03dcea03e7cf81771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e2ca85a1df3d0873915209aabb2a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a34e2ca85a1df3d0873915209aabb2a21">is_record_buffer_wanted</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *const max_rows) const override</td></tr>
<tr class="memdesc:a34e2ca85a1df3d0873915209aabb2a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if a Record_buffer is wanted by this handler, and what is the maximum buffer size the handler wants.  <a href="#a34e2ca85a1df3d0873915209aabb2a21">More...</a><br /></td></tr>
<tr class="separator:a34e2ca85a1df3d0873915209aabb2a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21f574e10b4de8b9720995f9acd2a48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ab21f574e10b4de8b9720995f9acd2a48">truncate_impl</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:ab21f574e10b4de8b9720995f9acd2a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUNCATE an InnoDB table.  <a href="#ab21f574e10b4de8b9720995f9acd2a48">More...</a><br /></td></tr>
<tr class="separator:ab21f574e10b4de8b9720995f9acd2a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multi Range Read interface</div></td></tr>
<tr class="memitem:a78a2d449b902956fe2c9fd93dde38115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a78a2d449b902956fe2c9fd93dde38115">multi_range_read_init</a> (<a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode, <a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a> *buf) override</td></tr>
<tr class="memdesc:a78a2d449b902956fe2c9fd93dde38115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize multi range read.  <a href="#a78a2d449b902956fe2c9fd93dde38115">More...</a><br /></td></tr>
<tr class="separator:a78a2d449b902956fe2c9fd93dde38115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f55001fcfd247fc65e444392e36659d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5f55001fcfd247fc65e444392e36659d">multi_range_read_next</a> (char **range_info) override</td></tr>
<tr class="memdesc:a5f55001fcfd247fc65e444392e36659d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process next multi range read.  <a href="#a5f55001fcfd247fc65e444392e36659d">More...</a><br /></td></tr>
<tr class="separator:a5f55001fcfd247fc65e444392e36659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f9cc89de8eea56d8a6bd661ab1c440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae7f9cc89de8eea56d8a6bd661ab1c440">multi_range_read_info_const</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *bufsz, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost) override</td></tr>
<tr class="memdesc:ae7f9cc89de8eea56d8a6bd661ab1c440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize multi range read and get information.  <a href="#ae7f9cc89de8eea56d8a6bd661ab1c440">More...</a><br /></td></tr>
<tr class="separator:ae7f9cc89de8eea56d8a6bd661ab1c440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf8d905383ec74b3283d40cd9c3aa51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3bf8d905383ec74b3283d40cd9c3aa51">multi_range_read_info</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test2_8cc.html#a417cc326920c9222b40e57c326ae83c9">keys</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *bufsz, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost) override</td></tr>
<tr class="memdesc:a3bf8d905383ec74b3283d40cd9c3aa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize multi range read and get information.  <a href="#a3bf8d905383ec74b3283d40cd9c3aa51">More...</a><br /></td></tr>
<tr class="separator:a3bf8d905383ec74b3283d40cd9c3aa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09e4715e6cbecad9c68bc6d1b7b679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a1d09e4715e6cbecad9c68bc6d1b7b679">idx_cond_push</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="classItem.html">Item</a> *idx_cond) override</td></tr>
<tr class="memdesc:a1d09e4715e6cbecad9c68bc6d1b7b679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to push down an index condition.  <a href="#a1d09e4715e6cbecad9c68bc6d1b7b679">More...</a><br /></td></tr>
<tr class="separator:a1d09e4715e6cbecad9c68bc6d1b7b679"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:aa6c449e2194c590eb53b6a6b5dbb362c inherit pub_static_methods_classhandler"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa6c449e2194c590eb53b6a6b5dbb362c">my_prepare_gcolumn_template</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db_name, const char *table_name, <a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a> myc, void *ib_table)</td></tr>
<tr class="memdesc:aa6c449e2194c590eb53b6a6b5dbb362c inherit pub_static_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to allow InnoDB to prepare a template for generated column processing.  <a href="classhandler.html#aa6c449e2194c590eb53b6a6b5dbb362c">More...</a><br /></td></tr>
<tr class="separator:aa6c449e2194c590eb53b6a6b5dbb362c inherit pub_static_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bedac06ed1345e080b5eb35075ac17 inherit pub_static_methods_classhandler"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad1bedac06ed1345e080b5eb35075ac17">my_eval_gcolumn_expr_with_open</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db_name, const char *table_name, const <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *const fields, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>, const char **mv_data_ptr, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *mv_length)</td></tr>
<tr class="memdesc:ad1bedac06ed1345e080b5eb35075ac17 inherit pub_static_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for generated columns processing.  <a href="classhandler.html#ad1bedac06ed1345e080b5eb35075ac17">More...</a><br /></td></tr>
<tr class="separator:ad1bedac06ed1345e080b5eb35075ac17 inherit pub_static_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff12cbff0ca6dad2c5565b8930ff698b inherit pub_static_methods_classhandler"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff12cbff0ca6dad2c5565b8930ff698b">my_eval_gcolumn_expr</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>, const <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *const fields, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>, const char **mv_data_ptr, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *mv_length)</td></tr>
<tr class="memdesc:aff12cbff0ca6dad2c5565b8930ff698b inherit pub_static_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for computing generated column values.  <a href="classhandler.html#aff12cbff0ca6dad2c5565b8930ff698b">More...</a><br /></td></tr>
<tr class="separator:aff12cbff0ca6dad2c5565b8930ff698b inherit pub_static_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a395bae75af9e51a116097a788b2cf57f">ht</a></td></tr>
<tr class="separator:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53c7037216007ba6140e6cff5162024d">ref</a></td></tr>
<tr class="memdesc:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to current row.  <a href="classhandler.html#a53c7037216007ba6140e6cff5162024d">More...</a><br /></td></tr>
<tr class="separator:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7501dc41ecb010069e8bc9d035aae6aa">dup_ref</a></td></tr>
<tr class="memdesc:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to duplicate row.  <a href="classhandler.html#a7501dc41ecb010069e8bc9d035aae6aa">More...</a><br /></td></tr>
<tr class="separator:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1df561df4b2b6552a7b42189feb0400a">stats</a></td></tr>
<tr class="separator:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ec520eba79eb9f182c534e82c60ebc6">mrr_iter</a></td></tr>
<tr class="separator:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a51e423645829d3e540c109556931fa">mrr_funcs</a></td></tr>
<tr class="separator:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a52372127bd238a7f622190316ba8124f">multi_range_buffer</a></td></tr>
<tr class="separator:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1a476dfe8526807dfc820c4b09f7a6d1">ranges_in_seq</a></td></tr>
<tr class="separator:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adff4dfb21c4583b55afc4fe5aba50389">mrr_is_output_sorted</a></td></tr>
<tr class="separator:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af2632d137c3a17fa583f08db5681e80a">mrr_have_range</a></td></tr>
<tr class="separator:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af2347edc229832e533d1fb73b236e32b">mrr_cur_range</a></td></tr>
<tr class="separator:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkey__range.html">key_range</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28d698fe9901f0f487c9618ddbb0f1be">end_range</a></td></tr>
<tr class="memdesc:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">End value for a range scan.  <a href="classhandler.html#a28d698fe9901f0f487c9618ddbb0f1be">More...</a><br /></td></tr>
<tr class="separator:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0f0786eed8e5cca4422f700bc1f5bb inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1d0f0786eed8e5cca4422f700bc1f5bb">m_virt_gcol_in_end_range</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:a1d0f0786eed8e5cca4422f700bc1f5bb inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag which tells if end_range contains a virtual generated column.  <a href="classhandler.html#a1d0f0786eed8e5cca4422f700bc1f5bb">More...</a><br /></td></tr>
<tr class="separator:a1d0f0786eed8e5cca4422f700bc1f5bb inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3186b7c7a70634a8e9758ed51708359c">errkey</a></td></tr>
<tr class="separator:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5ad5efc62f32ef66b55667fd8370ef33">key_used_on_scan</a></td></tr>
<tr class="separator:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a29f2838eebffef46663c19f85d2ad2cc">active_index</a></td></tr>
<tr class="separator:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr class="memdesc:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of ref (1-8 or the clustered key length)  <a href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">More...</a><br /></td></tr>
<tr class="separator:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFT__INFO.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a943005f89e7a6d5cee246e1c5b46e9ab">ft_handler</a></td></tr>
<tr class="separator:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4562b84f0a9dd9a138e2329d8e0c2175 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4562b84f0a9dd9a138e2329d8e0c2175">inited</a></td></tr>
<tr class="separator:a4562b84f0a9dd9a138e2329d8e0c2175 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afd47d68a7b406d8777396a657095d5e8">implicit_emptied</a></td></tr>
<tr class="separator:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0ed2f8d7155cb44162bb4181cb09f2f3">pushed_cond</a></td></tr>
<tr class="separator:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae9b3d956f73649657bad389acfad5f0b">pushed_idx_cond</a></td></tr>
<tr class="separator:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4dc8d81143d1c9c10b976711fe44cf37">pushed_idx_cond_keyno</a></td></tr>
<tr class="separator:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr class="memdesc:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_insert_id is the next value which should be inserted into the auto_increment column: in a inserting-multi-row statement (like INSERT SELECT), for the first row where the autoinc value is not specified by the statement, get_auto_increment() called and asked to generate a value, next_insert_id is set to the next value, then for all other rows next_insert_id is used (and increased each time) without calling get_auto_increment().  <a href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">More...</a><br /></td></tr>
<tr class="separator:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr class="memdesc:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert id for the current row (<em>autogenerated</em>; if not autogenerated, it's 0).  <a href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">More...</a><br /></td></tr>
<tr class="separator:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr class="memdesc:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval returned by get_auto_increment() and being consumed by the inserter.  <a href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">More...</a><br /></td></tr>
<tr class="separator:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr class="memdesc:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of reserved auto-increment intervals.  <a href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">More...</a><br /></td></tr>
<tr class="separator:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__table.html#gadcd09ac8bc8a8fcecb5e7cf78033a18b">PSI_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr class="memdesc:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instrumented table associated with this handler.  <a href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">More...</a><br /></td></tr>
<tr class="separator:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110bb2ddff9878db7a7dd92ce768243a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a110bb2ddff9878db7a7dd92ce768243a">m_random_number_engine</a></td></tr>
<tr class="separator:a110bb2ddff9878db7a7dd92ce768243a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b25b6f921e217b471ef2d372f15aeb7 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b25b6f921e217b471ef2d372f15aeb7">m_sampling_percentage</a></td></tr>
<tr class="separator:a4b25b6f921e217b471ef2d372f15aeb7 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class defining a handle to an InnoDB table. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a62ac24c4cc72e377007948043566f849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ac24c4cc72e377007948043566f849">&#9670;&nbsp;</a></span>Reader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classha__innobase.html#a62ac24c4cc72e377007948043566f849">ha_innobase::Reader</a> =  <a class="el" href="classParallel__reader__adapter.html">Parallel_reader_adapter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a68036418df66335546ea69f063f353ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68036418df66335546ea69f063f353ae">&#9670;&nbsp;</a></span>ha_innobase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_innobase::ha_innobase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct ha_innobase handler. </p>

</div>
</div>
<a id="a1c964866b4536e1c1e708c6fb6299e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c964866b4536e1c1e708c6fb6299e7b">&#9670;&nbsp;</a></span>~ha_innobase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_innobase::~ha_innobase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct ha_innobase handler. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aabbeedc88b2cc26817feffcf5c8febca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbeedc88b2cc26817feffcf5c8febca">&#9670;&nbsp;</a></span>analyze()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::analyze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates index cardinalities of the table, based on random dives into each index tree. </p>
<p>This does NOT calculate exact statistics on the table. </p><dl class="section return"><dt>Returns</dt><dd>HA_ADMIN_* error code or HA_ADMIN_OK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: connection thread handle </td></tr>
    <tr><td class="paramname">check_opt</td><td>in: currently ignored </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a992137f9f725825c7046029667aeab8a">handler</a>.</p>

</div>
</div>
<a id="a31824ee43bb96fab66831871f53581ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31824ee43bb96fab66831871f53581ba">&#9670;&nbsp;</a></span>build_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::build_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>whole_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a 'template' to the m_prebuilt struct. </p>
<p>The template is used in fast retrieval of just those column values MySQL needs in its processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">whole_row</td><td>true if access is needed to a whole row, false if accessing individual fields is enough </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a942c2656c55aed7c6f81d03bc00c7fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942c2656c55aed7c6f81d03bc00c7fc4">&#9670;&nbsp;</a></span>change_active_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::change_active_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the active index of a handle. </p>
<dl class="section return"><dt>Returns</dt><dd>0 or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: use this index; MAX_KEY means always clustered index, even if it was internally generated by InnoDB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb381d782e3dd2cefe882fb3fb686870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb381d782e3dd2cefe882fb3fb686870">&#9670;&nbsp;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to check that an InnoDB table is not corrupted. </p>
<p>If corruption is noticed, prints to stderr information about it. In case of corruption may also assert a failure and crash the server. </p><dl class="section return"><dt>Returns</dt><dd>HA_ADMIN_CORRUPT or HA_ADMIN_OK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: user thread handle </td></tr>
    <tr><td class="paramname">check_opt</td><td>in: check options </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a45abab7763a52f715ba32e3dcbf7d92c">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a1f2779ce526bd725c7882d9802ff4f2b">ha_innopart</a>.</p>

</div>
</div>
<a id="a9d8aba3a3633ed6dc7324d9725b0526f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8aba3a3633ed6dc7324d9725b0526f">&#9670;&nbsp;</a></span>check_if_incompatible_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::check_if_incompatible_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Part of old, deprecated in-place ALTER API. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a88df16f68605b9e2c3c275e9cd442c13">ha_innopart</a>.</p>

</div>
</div>
<a id="a3a1929d99568428c342c15ff9a081e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1929d99568428c342c15ff9a081e92">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html">handler</a> * ha_innobase::clone </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>mem_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
    <tr><td class="paramname">mem_root</td><td>in: memory context </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a97fc340039f5cf37a26e7c3b53685794">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a56359f1cbc9093c071799a915cefefce">ha_innopart</a>.</p>

</div>
</div>
<a id="a8644a1842b94dae86679d3166d85c2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8644a1842b94dae86679d3166d85c2a6">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes a handle to an InnoDB table. </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a71d762c5bae301ed92e1f393ed39d347">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga1693c8027c0450cf42f9fe78a32593cc">ha_innopart</a>.</p>

</div>
</div>
<a id="aaa25ab9f3a03803bea3f710bc0b269e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa25ab9f3a03803bea3f710bc0b269e1">&#9670;&nbsp;</a></span>cmp_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::cmp_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ref1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ref2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two 'refs'. </p>
<p>A 'ref' is the (internal) primary key value of the row. If there is no explicitly declared non-null unique key or a primary key, then InnoDB internally uses the row id as the primary key. </p><dl class="section return"><dt>Returns</dt><dd>&lt; 0 if ref1 &lt; ref2, 0 if equal, else &gt; 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref1</td><td>in: an (internal) primary key value in the MySQL key value format </td></tr>
    <tr><td class="paramname">ref2</td><td>in: an (internal) primary key value in the MySQL key value format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af3caf4144919df570d9f0554fc718f74">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ab85ee7e3833038f4e26fe91e00d997e2">ha_innopart</a>.</p>

</div>
</div>
<a id="aa5f95d1675ae28286a640d502b8c9c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f95d1675ae28286a640d502b8c9c38">&#9670;&nbsp;</a></span>commit_inplace_alter_table_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Table &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::commit_inplace_alter_table_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a> *&#160;</td>
          <td class="paramname"><em>old_dd_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTable.html">Table</a> *&#160;</td>
          <td class="paramname"><em>new_dd_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of commit_inplace_alter_table() </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Table</td><td>dd::Table or dd::Partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">altered_table</td><td>TABLE object for new version of table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER TABLE and holding data used during in-place alter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commit</td><td>True to commit or false to rollback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_dd_tab</td><td>Table object describing old version of the table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_dd_tab</td><td>Table object for the new version of the table. Can be adjusted by this call. Changes to the table definition will be persisted in the data-dictionary at statement version of it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34323a614547239877b26d408708fda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34323a614547239877b26d408708fda8">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an InnoDB table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>table name in filename-safe encoding </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>table structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">create_info</td><td>more information on the table </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_def</td><td>dd::Table describing table to be created. Can be adjusted by SE, the changes will be saved into data-dictionary at statement commit time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#af642f26e84f63386742df472343be117">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ae5c540fba9c540797278ea33b37dabcf">ha_innopart</a>.</p>

</div>
</div>
<a id="af174cbf38ed3d1363f32d2772537ceee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af174cbf38ed3d1363f32d2772537ceee">&#9670;&nbsp;</a></span>delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::delete_all_rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all rows from the table. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_WRONG_COMMAND</td><td>if the table is transactional </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ae570f80412285f65eef8eb8608c2a49c">ha_innopart</a>.</p>

</div>
</div>
<a id="afca34d7d3d9efcb40f6143fc11f9d5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca34d7d3d9efcb40f6143fc11f9d5af">&#9670;&nbsp;</a></span>delete_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::delete_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes a row given as the parameter. </p>
<dl class="section return"><dt>Returns</dt><dd>error number or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>in: a row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae8f4e049d9c85be8efb799be07c41db8">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#gae30201abe4fb1340b988ce3a277bdfe6">ha_innopart</a>.</p>

</div>
</div>
<a id="aa8d95a18bb01bd7aab0e995da4535549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d95a18bb01bd7aab0e995da4535549">&#9670;&nbsp;</a></span>delete_table() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_def</td><td>dd::Table describing table to be dropped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ad91031fadbe7d634ab58bfeb984c3e0b">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a5a5c17abd4fa849a011e5754ad81d951">ha_innopart</a>.</p>

</div>
</div>
<a id="a199305091c0b0e32198a8bfc5541f277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199305091c0b0e32198a8bfc5541f277">&#9670;&nbsp;</a></span>delete_table() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__sqlcommand_8h.html#a46bba265a20f1784df6b9802aec4122a">enum_sql_command</a>&#160;</td>
          <td class="paramname"><em>sqlcom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_def</td><td>dd::Table describing table to be dropped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sqlcom</td><td>type of operation that the DROP is part of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1546e4057641f48c81fc60c1ea1a46b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1546e4057641f48c81fc60c1ea1a46b9">&#9670;&nbsp;</a></span>disable_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::disable_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>disable index mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HA_ERR_* error code or 0 </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a272e3a0622ad461a5a86c74ddb9289c6">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a814e1803181506f9d3e6d042a0456986">ha_innopart</a>.</p>

</div>
</div>
<a id="a390184a3611fa9b62312bc2654ea511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390184a3611fa9b62312bc2654ea511f">&#9670;&nbsp;</a></span>discard_or_import_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::discard_or_import_tablespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>discard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards or imports an InnoDB tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">discard</td><td>TRUE if discard, else import </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_def</td><td>dd::Table describing table which tablespace is to be imported or discarded. Can be adjusted by SE, the changes will be saved into the data-dictionary at statement commit time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 == success, -1 == error </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a88684b7fb4f91836331a71d43f233fc8">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a1f7882d6bc40d58f050e2f5f657a33af">ha_innopart</a>.</p>

</div>
</div>
<a id="a66b6e1d81bc96709e0aff70761bf9166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b6e1d81bc96709e0aff70761bf9166">&#9670;&nbsp;</a></span>enable_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::enable_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>enable index mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HA_ERR_* error code or 0 </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a22328b49eac2417561360bd00bbe8299">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a2d990f2f9cf5190ded2e2b8a7bee2598">ha_innopart</a>.</p>

</div>
</div>
<a id="a8a82a21bb13d0f355cde55cf15574ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a82a21bb13d0f355cde55cf15574ff8">&#9670;&nbsp;</a></span>end_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::end_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MySQL calls this method at the end of each statement. </p>
<p>This method exists for readability only, called from reset(). The name reset() doesn't give any clue that it is called at the end of a statement.</p>
<p>This method exists for readability only. ha_innobase::reset() doesn't give any clue about the method. </p>

</div>
</div>
<a id="a8d47bcd9368043b44b59c1f24f690201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d47bcd9368043b44b59c1f24f690201">&#9670;&nbsp;</a></span>estimate_rows_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> ha_innobase::estimate_rows_upper_bound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an UPPER BOUND to the number of rows in a table. </p>
<p>This is used in filesort.cc. </p><dl class="section return"><dt>Returns</dt><dd>upper bound of rows </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a5d73bb43e401237d9037b4de05db670d">ha_innopart</a>.</p>

</div>
</div>
<a id="aa9ee606c8a0bcb787cd57b3f0f808adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ee606c8a0bcb787cd57b3f0f808adc">&#9670;&nbsp;</a></span>external_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::external_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As MySQL will execute an external lock for every new table it uses when it starts to process an SQL statement (an exception is when MySQL calls start_stmt for the handle) we can use this function to store the pointer to the THD in the handle. </p>
<p>We will also use this function to communicate to InnoDB that a new SQL statement has started and that we must store a savepoint to our transaction handle, so that we are able to roll back the SQL statement in case of an error. </p><dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>
<p>To limit range of circumstances under which transaction's isolation level can be compromised, we allow disabling readlocks only for DD and ACL tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: handle to the user thread </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a61e9f55268d9cf941080231994e0710c">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#gac8b49ac0f42b6e6c6a79eb326f5522e4">ha_innopart</a>.</p>

</div>
</div>
<a id="a2859bf5d18cdf1b9fcf43ab2194b2631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2859bf5d18cdf1b9fcf43ab2194b2631">&#9670;&nbsp;</a></span>extra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::extra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells something additional to the handler about how to do things. </p>
<dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>in: HA_EXTRA_FLUSH or some other flag </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a2b7687330aaf0d97540db07ab436e349">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ae3001ea8866f1b521dcb38b994641424">ha_innopart</a>.</p>

</div>
</div>
<a id="a90782f6c7b37725ff0845f761460dedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90782f6c7b37725ff0845f761460dedf">&#9670;&nbsp;</a></span>ft_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::ft_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a072d6c2f3e9989b4d787f0eaf760144c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072d6c2f3e9989b4d787f0eaf760144c">&#9670;&nbsp;</a></span>ft_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::ft_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize FT index scan. </p>
<dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab734678f90b9e7cc6b000047f7c89bb1">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ad8083230f3406f28570a3c3e70d17a59">ha_innopart</a>.</p>

</div>
</div>
<a id="aa9a89032a14685b3aa83f8f33ef52a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a89032a14685b3aa83f8f33ef52a55">&#9670;&nbsp;</a></span>ft_init_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFT__INFO.html">FT_INFO</a> * ha_innobase::ft_init_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize FT index scan. </p>
<dl class="section return"><dt>Returns</dt><dd>FT_INFO structure if successful or NULL </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a109448e09ee2c456b1471b74bb9eb8e6">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a27e140f9a2fe931115ac3e8ccee65746">ha_innopart</a>.</p>

</div>
</div>
<a id="acfd00e39b5172edbd35a7b3e062787e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd00e39b5172edbd35a7b3e062787e0">&#9670;&nbsp;</a></span>ft_init_ext_with_hints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFT__INFO.html">FT_INFO</a> * ha_innobase::ft_init_ext_with_hints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFt__hints.html">Ft_hints</a> *&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize FT index scan. </p>
<dl class="section return"><dt>Returns</dt><dd>FT_INFO structure if successful or NULL </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a9ceb6075e1b3ad667596b30eea85feb6">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a20044380efb596ab0c70c9eaebd2eec7">ha_innopart</a>.</p>

</div>
</div>
<a id="aadf4ab2a217ef0a9ee3be49f4b054346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf4ab2a217ef0a9ee3be49f4b054346">&#9670;&nbsp;</a></span>ft_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::ft_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch next result from the FT result set. </p>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buf contain result row </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a015fbf835ec7f952aa4b4698023af196">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#adcca541201935703314356690fc85843">ha_innopart</a>.</p>

</div>
</div>
<a id="a1f7643086f7386ad81e3f1393cf8fbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7643086f7386ad81e3f1393cf8fbcb">&#9670;&nbsp;</a></span>general_fetch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::general_fetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>match_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next or previous row from a cursor, which must have previously been positioned using index_read. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for next row in MySQL format </td></tr>
    <tr><td class="paramname">direction</td><td>in: ROW_SEL_NEXT or ROW_SEL_PREV </td></tr>
    <tr><td class="paramname">match_mode</td><td>in: 0, ROW_SEL_EXACT, or ROW_SEL_EXACT_PREFIX </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3ce8ab38b9a25fa3bffda31659d112b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ce8ab38b9a25fa3bffda31659d112b">&#9670;&nbsp;</a></span>get_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::get_auto_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the auto-inc counter in *first_value and ~0 on failure. </p>
<p>The following logic is needed to avoid duplicate key error for autoincrement column.</p>
<p>(1) InnoDB gives the current autoincrement value with respect to increment and offset value.</p>
<p>(2) Basically it does compute_next_insert_id() logic inside InnoDB to avoid the current auto increment value changed by handler layer.</p>
<p>(3) It is restricted only for insert operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>in: table autoinc offset </td></tr>
    <tr><td class="paramname">increment</td><td>in: table autoinc increment </td></tr>
    <tr><td class="paramname">nb_desired_values</td><td>in: number of values reqd </td></tr>
    <tr><td class="paramname">first_value</td><td>out: the autoinc value </td></tr>
    <tr><td class="paramname">nb_reserved_values</td><td>out: count of reserved values </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#af358184d36d80575d994e527521740a2">ha_innopart</a>.</p>

</div>
</div>
<a id="ae9a5dd9df94dce8ab69fbf79e4d9dd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a5dd9df94dce8ab69fbf79e4d9dd64">&#9670;&nbsp;</a></span>get_default_index_algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a> ha_innobase::get_default_index_algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get default key algorithm for SE. </p>
<p>It is used when user has not provided algorithm explicitly or when algorithm specified is not supported by SE. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a170e714527e670014e9fb4395f0b187f">handler</a>.</p>

</div>
</div>
<a id="a90bf8de2efb608179fa4462fdc990949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf8de2efb608179fa4462fdc990949">&#9670;&nbsp;</a></span>get_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::get_error_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See comment in handler.cc. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">handler</a>.</p>

</div>
</div>
<a id="a5db15d03fe482536527801f0df446543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db15d03fe482536527801f0df446543">&#9670;&nbsp;</a></span>get_extra_columns_and_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::get_extra_columns_and_keys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>dd_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add hidden columns and indexes to an InnoDB table definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dd_table</td><td>data dictionary cache object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ad9ab2b12bb621c43438531c67e4278e0">handler</a>.</p>

</div>
</div>
<a id="afa619024bc4a2075068278c575a39982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa619024bc4a2075068278c575a39982">&#9670;&nbsp;</a></span>get_foreign_dup_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::get_foreign_dup_key </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>child_table_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_key_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>child_key_name_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY. </p>
<p>If any of the names is not available, then this method will return false and will not change any of child_table_name or child_key_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">child_table_name</td><td>Table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_table_name_len</td><td>Table name buffer size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">child_key_name</td><td>Key name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_key_name_len</td><td>Key name buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>table and key names were available and were written into the corresponding out parameters. </td></tr>
    <tr><td class="paramname">false</td><td>table and key names were not available, the out parameters were not touched. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a018ba4b85de71ff265bdb1157bf95894">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a7466f8dd3a7b6899dd980443d4dd7ef5">ha_innopart</a>.</p>

</div>
</div>
<a id="a9365e00b6cdae0dde50563fa9c40a162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9365e00b6cdae0dde50563fa9c40a162">&#9670;&nbsp;</a></span>get_memory_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a9c0acdcb1b083d30069a62cee1ece644">longlong</a> ha_innobase::get_memory_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the InnoDB memory buffer. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a475f7fbe39f6ff0e9da2ac6c3d6c629e">handler</a>.</p>

</div>
</div>
<a id="acfac6b212f587b7d8c4fbd059907ded0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfac6b212f587b7d8c4fbd059907ded0">&#9670;&nbsp;</a></span>get_real_row_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sql_2handler_8h.html#aae164ec549f5dd7e890b40de79fd76c8">row_type</a> ha_innobase::get_real_row_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get real row type for the table created based on one specified by user, CREATE TABLE options and SE capabilities. </p>
<dl class="section note"><dt>Note</dt><dd>The current code in this method is redundant with/copy of code from create_table_info_t::innobase_table_flags(). This is temporary workaround. In future this method will always return ROW_TYPE_DYNAMIC (which is suitable for intrisinc temporary tables) and rely on adjusting row format in table definition at ha_innobase::create() or ha_innobase::prepare_inplace_alter_table() time. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af8877c5cafa237927cc9917e3a422a2d">handler</a>.</p>

</div>
</div>
<a id="a8b6abd57a949186466989472944c0f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6abd57a949186466989472944c0f94">&#9670;&nbsp;</a></span>get_se_private_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::get_se_private_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>dd_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get storage-engine private data for a data dictionary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dd_table</td><td>data dictionary table definition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">reset</td><td>reset counters </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>an error occurred </td></tr>
    <tr><td class="paramname">false</td><td>success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ad252f8049754e2ac8a2064ae90ee5055">handler</a>.</p>

</div>
</div>
<a id="a1d09e4715e6cbecad9c68bc6d1b7b679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d09e4715e6cbecad9c68bc6d1b7b679">&#9670;&nbsp;</a></span>idx_cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classItem.html">Item</a> * ha_innobase::idx_cond_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>idx_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to push down an index condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyno</td><td>MySQL key number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_cond</td><td>Index condition to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idx_cond if pushed; NULL if not pushed </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">handler</a>.</p>

</div>
</div>
<a id="a539589601452095deb50f43eed9153e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539589601452095deb50f43eed9153e0">&#9670;&nbsp;</a></span>index_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Currently does nothing. </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#abfec3aae2f0c2981d6c17d6a46107e67">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga410bd45d099e12e2d372ad7229566d25">ha_innopart</a>.</p>

</div>
</div>
<a id="aad308cb08362d1241caecb2e585061d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad308cb08362d1241caecb2e585061d2">&#9670;&nbsp;</a></span>index_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions a cursor on the first record in an index and reads the corresponding row to buf. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1386e0dc6f31536470b7b6d89243b7bb">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#aff4e6f0f69a9a16c5c7d2de96698b113">ha_innopart</a>.</p>

</div>
</div>
<a id="a4e16bca7a00ede3aa7bfd6386ca0ea56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e16bca7a00ede3aa7bfd6386ca0ea56">&#9670;&nbsp;</a></span>index_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> ha_innobase::index_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>all_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operations supported for indexes. </p>
<dl class="section return"><dt>Returns</dt><dd>flags of supported operations </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a612375d87a4cbb6e7c190ea7d05cf945">handler</a>.</p>

</div>
</div>
<a id="aba62194dbbc6666c763284c900781cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba62194dbbc6666c763284c900781cde">&#9670;&nbsp;</a></span>index_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a handle to use an index. </p>
<dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: key (index) number </td></tr>
    <tr><td class="paramname">sorted</td><td>in: 1 if result MUST be sorted according to index </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1fefa98fca726c4807e5a763603ff22d">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga83c8a1c634d734625f5b02356b558593">ha_innopart</a>.</p>

</div>
</div>
<a id="ab0256fd00023ef5d65a6aca868aa07fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0256fd00023ef5d65a6aca868aa07fc">&#9670;&nbsp;</a></span>index_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions a cursor on the last record in an index and reads the corresponding row to buf. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aeec72a3f0dba086e9e9279cee1a78efd">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a3e65cf4574cbf00341843a4b85b6b389">ha_innopart</a>.</p>

</div>
</div>
<a id="a6b6e17b5c471ee9a0c83a3b1cc392236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6e17b5c471ee9a0c83a3b1cc392236">&#9670;&nbsp;</a></span>index_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next row from a cursor, which must have previously been positioned using index_read. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for next row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a57310b473c83de0515ded4481925fa43">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a7388d5e245839db619773c47a4665688">ha_innopart</a>.</p>

</div>
</div>
<a id="a63e2b8ad7471f6b41dde23898aae216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e2b8ad7471f6b41dde23898aae216f">&#9670;&nbsp;</a></span>index_next_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_next_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next row matching to the key value given as the parameter. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
    <tr><td class="paramname">key</td><td>in: key value </td></tr>
    <tr><td class="paramname">keylen</td><td>in: key value length </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a2a0002980ac07a15c0e11d807b73b0d3">ha_innopart</a>.</p>

</div>
</div>
<a id="ae598ae464f20eb0e7dde35d100da1899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae598ae464f20eb0e7dde35d100da1899">&#9670;&nbsp;</a></span>index_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the previous row from a cursor, which must have previously been positioned using index_read. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for previous row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0b8373c14364e6b45df26b5b77cc7e9c">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a9f91f1c63629957f2d6f588e0524de37">ha_innopart</a>.</p>

</div>
</div>
<a id="ad57ed745e3cbbc2d7f68904e222baa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57ed745e3cbbc2d7f68904e222baa9e">&#9670;&nbsp;</a></span>index_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in the handle. </p>
<p>Fetches the row if any. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_KEY_NOT_FOUND, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the returned row </td></tr>
    <tr><td class="paramname">key_ptr</td><td>in: key value; if this is NULL we position the cursor at the start or end of index; this can also contain an InnoDB row id, in which case key_len is the InnoDB row id length; the key value can also be a prefix of a full key value, and the last column can be a prefix of a full column </td></tr>
    <tr><td class="paramname">key_len</td><td>in: key value length </td></tr>
    <tr><td class="paramname">find_flag</td><td>in: search flags from my_base.h </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a4ccf806316a9d88a7130d70e7637e8e5">handler</a>.</p>

</div>
</div>
<a id="ac65348e1f6565d897704540a4c9743be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65348e1f6565d897704540a4c9743be">&#9670;&nbsp;</a></span>index_read_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::index_read_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_KEY_NOT_FOUND, or an error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: fetched row </td></tr>
    <tr><td class="paramname">key_ptr</td><td>in: key value, or a prefix of a full key value </td></tr>
    <tr><td class="paramname">key_len</td><td>in: length of the key val or prefix in bytes </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a90af353b21f935dc95212e1cfef50452">handler</a>.</p>

</div>
</div>
<a id="aa73c12cb2f26e5ea83d7a007ae1b1691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73c12cb2f26e5ea83d7a007ae1b1691">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns statistics information of the table to the MySQL interpreter, in various fields of the handle object. </p>
<dl class="section return"><dt>Returns</dt><dd>HA_ERR_* error code or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>in: what information is requested </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#a3de6f276d98eba4327f1a9a860d65f3c">handler</a>.</p>

</div>
</div>
<a id="af51ab4f43bfc4cd142195f620a43a61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51ab4f43bfc4cd142195f620a43a61f">&#9670;&nbsp;</a></span>info_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::info_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_analyze</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns statistics information of the table to the MySQL interpreter, in various fields of the handle object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>what information is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_analyze</td><td>True if called from "::analyze()". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HA_ERR_* error code or 0 </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a8f2b1d664eca113c8db2b80c2fab8bb5">ha_innopart</a>.</p>

</div>
</div>
<a id="aafd8b745fdac5b31abd0bd105ee50a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd8b745fdac5b31abd0bd105ee50a08">&#9670;&nbsp;</a></span>init_table_handle_for_HANDLER()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::init_table_handle_for_HANDLER </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this when you have opened a new table handle in HANDLER, before you call index_read_map() etc. </p>
<p>Actually, we can let the cursor stay open even over a transaction commit! Then you should call this before every operation, fetch next etc. This function inits the necessary things even after a transaction commit. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a28dfb73f9401996a25b9cf925db74149">handler</a>.</p>

</div>
</div>
<a id="aa01cb111b995307de63904caa846b9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01cb111b995307de63904caa846b9fb">&#9670;&nbsp;</a></span>innobase_get_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ha_innobase::innobase_get_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next autoinc value. </p>
<p>Acquire the relevant locks before reading the AUTOINC value. If SUCCESS then the table AUTOINC mutex will be locked on return and all relevant locks acquired. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>out: autoinc value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a48a3f83277536b4a13c51a3b210793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a48a3f83277536b4a13c51a3b210793">&#9670;&nbsp;</a></span>innobase_get_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a> * ha_innobase::innobase_get_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index for a handle. </p>
<p>Does not change active index. </p><dl class="section return"><dt>Returns</dt><dd>NULL or index instance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: use this index; MAX_KEY means always clustered index, even if it was internally generated by InnoDB </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ad1cdbc8c1b9893d7de4b118c0d6f9576">ha_innopart</a>.</p>

</div>
</div>
<a id="a35920b0122df98efb5af2e651edbb332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35920b0122df98efb5af2e651edbb332">&#9670;&nbsp;</a></span>innobase_initialize_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::innobase_initialize_autoinc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the autoinc column max value. </p>
<p>This should only be called from ha_innobase::open, therefore there's no need for a covering lock. </p>

</div>
</div>
<a id="acbcdac25ce135fedf0ba5c741c7832ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcdac25ce135fedf0ba5c741c7832ff">&#9670;&nbsp;</a></span>innobase_lock_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ha_innobase::innobase_lock_autoinc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This special handling is really to overcome the limitations of MySQL's binlogging. </p>
<p>We need to eliminate the non-determinism that will arise in INSERT ... SELECT type of statements, since MySQL binlog only stores the min value of the autoinc interval. Once that is fixed we can get rid of the special lock handling. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK else error code </dd></dl>

</div>
</div>
<a id="a7137f4054ebb3f178545f985f14fe3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7137f4054ebb3f178545f985f14fe3dc">&#9670;&nbsp;</a></span>innobase_set_max_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ha_innobase::innobase_set_max_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>auto_inc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the autoinc value in the table. </p>
<p>The autoinc value is only set if it's greater than the existing autoinc value in the table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all went well else error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auto_inc</td><td>in: value to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77e8864d0b37e4093ad3c357d0f7c86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e8864d0b37e4093ad3c357d0f7c86d">&#9670;&nbsp;</a></span>inplace_alter_table_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Table &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::inplace_alter_table_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a> *&#160;</td>
          <td class="paramname"><em>old_dd_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTable.html">Table</a> *&#160;</td>
          <td class="paramname"><em>new_dd_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of inplace_alter_table() </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Table</td><td>dd::Table or dd::Partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">altered_table</td><td>TABLE object for new version of table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER TABLE and holding data used during in-place alter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_dd_tab</td><td>dd::Table object describing old version of the table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_dd_tab</td><td>dd::Table object for the new version of the table. Can be adjusted by this call. Changes to the table definition will be persisted in the data-dictionary at statement commit time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47b6d168ce1f0a03dcea03e7cf81771e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b6d168ce1f0a03dcea03e7cf81771e">&#9670;&nbsp;</a></span>intrinsic_table_write_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::intrinsic_table_write_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write Row Interface optimized for Intrinsic table. </p>
<p>Write Row interface optimized for intrinisc table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">record</td><td>a row in MySQL format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or error code </dd></dl>

</div>
</div>
<a id="a8c73e564960485a3450ed5d6990a52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c73e564960485a3450ed5d6990a52a6">&#9670;&nbsp;</a></span>is_index_algorithm_supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::is_index_algorithm_supported </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a>&#160;</td>
          <td class="paramname"><em>key_alg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if SE supports specific key algorithm. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a05f77c614e5852c3058d6b7a1f5d701b">handler</a>.</p>

</div>
</div>
<a id="a34e2ca85a1df3d0873915209aabb2a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e2ca85a1df3d0873915209aabb2a21">&#9670;&nbsp;</a></span>is_record_buffer_wanted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::is_record_buffer_wanted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *const&#160;</td>
          <td class="paramname"><em>max_rows</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out if a Record_buffer is wanted by this handler, and what is the maximum buffer size the handler wants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max_rows</td><td>gets set to the maximum number of records to allocate space for in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the handler wants a buffer </td></tr>
    <tr><td class="paramname">false</td><td>if the handler does not want a buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a9771a747571d6440b274a23d0aa6c43b">handler</a>.</p>

</div>
</div>
<a id="a9d6b5e69a443ec396cfec6f324a0e4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6b5e69a443ec396cfec6f324a0e4f9">&#9670;&nbsp;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ha_innobase::lock_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of THR_LOCK locks used for one instance of InnoDB table. </p>
<p>InnoDB no longer relies on THR_LOCK locks so 0 value is returned. Instead of THR_LOCK locks InnoDB relies on combination of metadata locks (e.g. for LOCK TABLES and DDL) and its own locking subsystem. Note that even though this method returns 0, SQL-layer still calls "::store_lock()", "::start_stmt()" and "::external_lock()" methods for InnoDB tables. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">handler</a>.</p>

</div>
</div>
<a id="a92dfcee2676166f64d87d561aebbe813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dfcee2676166f64d87d561aebbe813">&#9670;&nbsp;</a></span>max_supported_key_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ha_innobase::max_supported_key_length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum key length. </p>
<dl class="section return"><dt>Returns</dt><dd>maximum supported key length, in bytes </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0c2216dba316fe13117f00e8d21cbdab">handler</a>.</p>

</div>
</div>
<a id="a5d98d1b9c8e9874003e01132a1ac5641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d98d1b9c8e9874003e01132a1ac5641">&#9670;&nbsp;</a></span>max_supported_key_part_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ha_innobase::max_supported_key_part_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classhandler.html#a44a45b6e069b4c13b85bdaf4992f7828">handler</a>.</p>

</div>
</div>
<a id="aa9b40d6aceeb7c9927d8765861e22bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b40d6aceeb7c9927d8765861e22bd7">&#9670;&nbsp;</a></span>max_supported_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ha_innobase::max_supported_keys </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of keys. </p>
<dl class="section return"><dt>Returns</dt><dd>MAX_KEY </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a9c7b335988ea24ea8b685c4278442cf8">handler</a>.</p>

</div>
</div>
<a id="a3bf8d905383ec74b3283d40cd9c3aa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf8d905383ec74b3283d40cd9c3aa51">&#9670;&nbsp;</a></span>multi_range_read_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> ha_innobase::multi_range_read_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize multi range read and get information. </p>
<dl class="section see"><dt>See also</dt><dd>DsMrr_impl::dsmrr_info </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">handler</a>.</p>

</div>
</div>
<a id="ae7f9cc89de8eea56d8a6bd661ab1c440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f9cc89de8eea56d8a6bd661ab1c440">&#9670;&nbsp;</a></span>multi_range_read_info_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> ha_innobase::multi_range_read_info_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize multi range read and get information. </p>
<dl class="section see"><dt>See also</dt><dd>ha_myisam::multi_range_read_info_const </dd>
<dd>
DsMrr_impl::dsmrr_info_const </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">handler</a>.</p>

</div>
</div>
<a id="a78a2d449b902956fe2c9fd93dde38115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a2d449b902956fe2c9fd93dde38115">&#9670;&nbsp;</a></span>multi_range_read_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::multi_range_read_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize multi range read. </p>
<p>Multi Range Read interface, DS-MRR calls.</p>
<dl class="section see"><dt>See also</dt><dd>DsMrr_impl::dsmrr_init </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">handler</a>.</p>

</div>
</div>
<a id="a5f55001fcfd247fc65e444392e36659d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f55001fcfd247fc65e444392e36659d">&#9670;&nbsp;</a></span>multi_range_read_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::multi_range_read_next </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process next multi range read. </p>
<dl class="section see"><dt>See also</dt><dd>DsMrr_impl::dsmrr_next </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">handler</a>.</p>

</div>
</div>
<a id="a00aa41314a91727810c195bde3843bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00aa41314a91727810c195bde3843bdb">&#9670;&nbsp;</a></span>mv_key_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::mv_key_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>keys_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return max limits for a single set of multi-valued keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_keys</td><td>number of keys to store </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keys_length</td><td>total length of keys, bytes </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ad010849c65ff0fb7630ab7af27887741">handler</a>.</p>

</div>
</div>
<a id="a928d9a737a350ec3bdc246bce46c469a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928d9a737a350ec3bdc246bce46c469a">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>open_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open an InnoDB table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">open_flags</td><td>flags for opening table from SQL-layer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_def</td><td>dd::Table object describing table to be opened </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if error </td></tr>
    <tr><td class="paramname">0</td><td>if success </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#a12158d5ad8caae47ffe4ac111adb65fe">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga66a08d8985fdef61524c17bb9b704096">ha_innopart</a>.</p>

</div>
</div>
<a id="afa2b8a0b92d0997d0fa57ccc83968f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2b8a0b92d0997d0fa57ccc83968f80">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is mapped to "ALTER TABLE tablename ENGINE=InnoDB", which rebuilds the table in MySQL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: connection thread handle </td></tr>
    <tr><td class="paramname">check_opt</td><td>in: currently ignored </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ac8025ebb1cabba85cdf0df9c8a1b7c6f">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ac5f876f83625935a5f402272f694df23">ha_innopart</a>.</p>

</div>
</div>
<a id="a6bf884273500d55cfae842aa7bd0159b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf884273500d55cfae842aa7bd0159b">&#9670;&nbsp;</a></span>parallel_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::parallel_scan </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>thread_ctxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Reader::Init_fn</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Reader::Load_fn</a>&#160;</td>
          <td class="paramname"><em>load_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">Reader::End_fn</a>&#160;</td>
          <td class="paramname"><em>end_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start parallel read of InnoDB records. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>A scan context created by parallel_scan_init </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_ctxs</td><td>Context for each of the spawned threads </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback called by each parallel load thread at the beginning of the parallel load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_fn</td><td>Callback called by each parallel load thread when processing of rows is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_fn</td><td>Callback called by each parallel load thread when processing of rows has ended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aebd6632fba224ccdaf229a9886cbe0b4">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ac77cf6540726d6766e92597dbca4bb58">ha_innopart</a>.</p>

</div>
</div>
<a id="ad68072931c05a5c76b2a9d251f130672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68072931c05a5c76b2a9d251f130672">&#9670;&nbsp;</a></span>parallel_scan_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::parallel_scan_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of the parallel scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>A scan context created by parallel_scan_init. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a680f73512eef288b1ddca958933c2016">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a197dfbb668e3e7f046d434b404bc90e3">ha_innopart</a>.</p>

</div>
</div>
<a id="ad5a01c18a2f2badc827709aef7151482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a01c18a2f2badc827709aef7151482">&#9670;&nbsp;</a></span>parallel_scan_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::parallel_scan_init </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_reserved_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a parallel scan. </p>
<p>It creates a scan_ctx that has to be used across all parallel_scan methods. Also, gets the number of threads that would be spawned for parallel scan. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">scan_ctx</td><td>A scan context created by this method that has to be used in parallel_scan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_threads</td><td>Number of threads to be spawned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_reserved_threads</td><td>true if reserved threads are to be used if we exhaust the max cap of number of parallel read threads that can be spawned at a time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a826010c8deb55ee4435b1b3fc18fe7a0">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#acfc3fdafebbca7392369159b706842b6">ha_innopart</a>.</p>

</div>
</div>
<a id="a74733f5cbd26a05bab60b709071a1053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74733f5cbd26a05bab60b709071a1053">&#9670;&nbsp;</a></span>position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a reference to the current row to 'ref' field of the handle. </p>
<p>Note that in the case where we have generated the clustered index for the table, the function parameter is illogical: we MUST ASSUME that 'record' is the current 'position' of the handle, because if row ref is actually the row id internally generated in InnoDB, then 'record' does not contain it. We just guess that the row id must be for the record where the handle was positioned the last time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">record</td><td>row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#ad3c1515e7a936fa9cbc19f93d43495b6">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ac36839a8e456e5ea2f6322c9a9746f1f">ha_innopart</a>.</p>

</div>
</div>
<a id="a810a90e2d5ec1ea15c83b4f79dfdb028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810a90e2d5ec1ea15c83b4f79dfdb028">&#9670;&nbsp;</a></span>position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65c844476f28ce4eee84f8b51bb94e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c844476f28ce4eee84f8b51bb94e75">&#9670;&nbsp;</a></span>prepare_inplace_alter_table_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Table &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::prepare_inplace_alter_table_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a> *&#160;</td>
          <td class="paramname"><em>old_dd_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTable.html">Table</a> *&#160;</td>
          <td class="paramname"><em>new_dd_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of prepare_inplace_alter_table() </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Table</td><td>dd::Table or dd::Partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">altered_table</td><td>TABLE object for new version of table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER TABLE and holding data used during in-place alter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_dd_tab</td><td>dd::Table object representing old version of the table </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_dd_tab</td><td>dd::Table object representing new version of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>
<p>&lt; Index to be dropped</p>
<p>&lt; Number of indexes to drop</p>
<p>&lt; Indexes to be dropped</p>
<p>&lt; Number of indexes to rename</p>
<p>&lt; Foreign key constraints to drop</p>
<p>&lt; Number of foreign keys to drop</p>
<p>&lt; Foreign key constraints to drop</p>
<p>&lt; Number of foreign keys to drop</p>
<p>&lt; Table where indexes are created </p>

</div>
</div>
<a id="a436003354606af48dbce6de74e4e8b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436003354606af48dbce6de74e4e8b86">&#9670;&nbsp;</a></span>primary_key_is_clustered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::primary_key_is_clustered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the primary key is clustered index. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1c885f4b3b5bf6d2878225a188b5599f">handler</a>.</p>

</div>
</div>
<a id="aefe5d93d70b0a29facf31a419025db83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe5d93d70b0a29facf31a419025db83">&#9670;&nbsp;</a></span>read_range_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::read_range_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read first row between two ranges. </p>
<p>Store ranges for future calls to read_range_next.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ab158d52ba2f106fa837b8ec424618d10">ha_innopart</a>.</p>

</div>
</div>
<a id="abf847dd084d581e207005c608d0c3a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf847dd084d581e207005c608d0c3a32">&#9670;&nbsp;</a></span>read_range_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a7804617e6e16bb1585ddeeab21e28039">ha_innopart</a>.</p>

</div>
</div>
<a id="af5d4680d4c79132b72063091b54c8d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d4680d4c79132b72063091b54c8d34">&#9670;&nbsp;</a></span>read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ha_innobase::read_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the time it takes to read a set of ranges through an index This enables us to optimise reads for clustered indexes. </p>
<dl class="section return"><dt>Returns</dt><dd>estimated time measured in disk seeks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: key number </td></tr>
    <tr><td class="paramname">ranges</td><td>in: how many ranges </td></tr>
    <tr><td class="paramname">rows</td><td>in: estimated number of rows in the ranges </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler</a>.</p>

</div>
</div>
<a id="a95463460839f5ffce360cf02024da29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95463460839f5ffce360cf02024da29b">&#9670;&nbsp;</a></span>records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::records </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>num_rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exact number of records that this client can see using this handler object. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code in case something goes wrong. These errors will abort the current query: case HA_ERR_LOCK_DEADLOCK: case HA_ERR_LOCK_TABLE_FULL: case HA_ERR_LOCK_WAIT_TIMEOUT: case HA_ERR_QUERY_INTERRUPTED: For other error codes, the server will fall back to counting records. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>out: number of rows </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a9d2371385a8f73f1258965f5f7cfdf93">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a240eacfa94d0cb64105cfbed5a383ed8">ha_innopart</a>.</p>

</div>
</div>
<a id="a20799b459cb132c6ec4aa643e3d4d946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20799b459cb132c6ec4aa643e3d4d946">&#9670;&nbsp;</a></span>records_from_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::records_from_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows in table counted using the secondary index chosen by optimizer. </p>
<p>See comments in optimize_aggregated_query() .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>[out] Number of rows in table. </td></tr>
    <tr><td class="paramname">index</td><td>Index chosen by optimizer for counting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a11a4096cff6dd66d0fa5cbb5992f3169">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a84ab468112746def6ef39168d0f28225">ha_innopart</a>.</p>

</div>
</div>
<a id="a583aa37f0683cb54012bc9804e268737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583aa37f0683cb54012bc9804e268737">&#9670;&nbsp;</a></span>records_in_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> ha_innobase::records_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>min_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>max_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates the number of index records in a range. </p>
<dl class="section return"><dt>Returns</dt><dd>estimated number of rows </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: index number </td></tr>
    <tr><td class="paramname">min_key</td><td>in: start key value of the range, may also be 0 </td></tr>
    <tr><td class="paramname">max_key</td><td>in: range end key val, may also be 0 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a33ac874ad6fd5a2e6b97376befacb165">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a48dc6d640d137eb38317cf19e621e3fa">ha_innopart</a>.</p>

</div>
</div>
<a id="ada5ed7bbf91a0eddc4ce709a378215dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5ed7bbf91a0eddc4ce709a378215dd">&#9670;&nbsp;</a></span>release_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::release_auto_increment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do cleanup for auto increment calculation. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ae3c86ff21b8c2db61977f93746bb6727">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a8c0d26f8aa4a03b7fce16e595d19b7ee">ha_innopart</a>.</p>

</div>
</div>
<a id="a7da78c60f55e2141137af9a0846b2e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da78c60f55e2141137af9a0846b2e9e">&#9670;&nbsp;</a></span>rename_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>from_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>to_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames an InnoDB table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Old name of the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>New name of the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_table_def</td><td>dd::Table object describing old version of table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">to_table_def</td><td>dd::Table object describing version of table with new name. Can be updated by SE. Changes are persisted to the dictionary at statement commit time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or error code </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a9fde9c902c411ed3ccd8e6ca8e99b2e9">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a3e6de240a7efecddd94ca0c2b27b6add">ha_innopart</a>.</p>

</div>
</div>
<a id="a056b13565fedbaf700d52c15d3145b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056b13565fedbaf700d52c15d3145b0d">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MySQL calls this method at the end of each statement. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#adaa0c9dde8956878db8ca937138f3462">ha_innopart</a>.</p>

</div>
</div>
<a id="aa288074a103562d391f66ddb87e9329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa288074a103562d391f66ddb87e9329b">&#9670;&nbsp;</a></span>reset_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::reset_template </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a query execution 'template'. </p>
<p>Resets some fields of a m_prebuilt struct.</p>
<dl class="section see"><dt>See also</dt><dd>build_template()</dd></dl>
<p>The template is used in fast retrieval of just those column values MySQL needs in its processing. </p>

</div>
</div>
<a id="a4f3100a96ea13005f90e2b65e391f9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3100a96ea13005f90e2b65e391f9eb">&#9670;&nbsp;</a></span>rnd_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::rnd_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a table scan. </p>
<dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a590d32e2e1c26e4e9dcfc8228750b0ab">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#gac16c679b99fbcf88b1651e50726b8b6b">ha_innopart</a>.</p>

</div>
</div>
<a id="a6a8e8805da5c40b0ab44d83815865aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8e8805da5c40b0ab44d83815865aa6">&#9670;&nbsp;</a></span>rnd_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::rnd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a table scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan</td><td>whether this is a second call to rnd_init() without rnd_end() in between </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga251b5008a845bb57a23b38a8c339c90f">ha_innopart</a>.</p>

</div>
</div>
<a id="a65b2dc1d51146907892ccb345aff9c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b2dc1d51146907892ccb345aff9c94">&#9670;&nbsp;</a></span>rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::rnd_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the next row in a table scan (also used to read the FIRST row in a table scan). </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: returns the row in this buffer, in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a06e882ae034f6be670c486332d281ec0">ha_innopart</a>.</p>

</div>
</div>
<a id="a272db42b6b4a31203c0fa201e4b5f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272db42b6b4a31203c0fa201e4b5f80f">&#9670;&nbsp;</a></span>rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::rnd_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches a row from the table based on a row reference. </p>
<dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_KEY_NOT_FOUND, or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
    <tr><td class="paramname">pos</td><td>in: primary key value of the row in the MySQL format, or the row id if the clustered index was internally generated by InnoDB; the length of data in pos has to be ref_length </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#af6e836398b1cc1e50876eef3cf7fd918">ha_innopart</a>.</p>

</div>
</div>
<a id="ab394b0c7fdded101aef186c683ce76c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab394b0c7fdded101aef186c683ce76c7">&#9670;&nbsp;</a></span>sample_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::sample_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>Scan context of the sampling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else one of the HA_xxx values in case of error. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0014408fc37a178d96063b809c0eab90">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga902d0aacd5e6da14739d93a6e2a4423f">ha_innopart</a>.</p>

</div>
</div>
<a id="a0a70836644799aa8f325cfaa7707e451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a70836644799aa8f325cfaa7707e451">&#9670;&nbsp;</a></span>sample_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::sample_init </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_percentage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampling_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql_2handler_8h.html#ae954cfd46ba0b8300368dccf2bebc842">enum_sampling_method</a>&#160;</td>
          <td class="paramname"><em>sampling_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">scan_ctx</td><td>A scan context created by this method that has to be used in sample_next </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_percentage</td><td>percentage of records that need to be sampled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_seed</td><td>random seed that the random generator will use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_method</td><td>sampling method to be used; currently only SYSTEM sampling is supported </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else one of the HA_xxx values in case of error. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aa41795e1f1fba64e38a606b4b844d731">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga799e71a922942685475d8043c603b005">ha_innopart</a>.</p>

</div>
</div>
<a id="af55969372fcf3cb364249daba74da2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55969372fcf3cb364249daba74da2e9">&#9670;&nbsp;</a></span>sample_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::sample_next </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next record for sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>Scan context of the sampling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>buffer to place the read record </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else one of the HA_xxx values in case of error. </dd></dl>
<p>Buffer rows one by one </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a3757d00cf8932b2ab370164723f830c0">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga60b26b3819afb7b708e2f661f79a1d39">ha_innopart</a>.</p>

</div>
</div>
<a id="a3505b4fcd544e155238c18326eaac51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3505b4fcd544e155238c18326eaac51a">&#9670;&nbsp;</a></span>scan_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ha_innobase::scan_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many seeks it will take to read through the table. </p>
<p>This is to be comparable to the number returned by records_in_range so that we can decide if we should scan the table or use keys. </p><dl class="section return"><dt>Returns</dt><dd>estimated time measured in disk seeks </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a65f8e5188e2bd9636a564bbc0c3fef86">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga25bb5886aa04e2b4488ee3a82e5cbc02">ha_innopart</a>.</p>

</div>
</div>
<a id="a88304b5868b42aa9f64afdf617b17c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88304b5868b42aa9f64afdf617b17c5e">&#9670;&nbsp;</a></span>srv_concurrency_enter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::srv_concurrency_enter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enter InnoDB engine after checking max allowed threads. </p>
<dl class="section return"><dt>Returns</dt><dd>mysql error code. </dd></dl>

</div>
</div>
<a id="a3a972bc49516aea7ff451a71bc94db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a972bc49516aea7ff451a71bc94db6c">&#9670;&nbsp;</a></span>srv_concurrency_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::srv_concurrency_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leave Innodb, if no more tickets are left. </p>

</div>
</div>
<a id="a48b1b3e128043290847d250756b66f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b1b3e128043290847d250756b66f53">&#9670;&nbsp;</a></span>start_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::start_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a>&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MySQL calls this function at the start of each SQL statement inside LOCK TABLES. </p>
<p>Inside LOCK TABLES the "::external_lock" method does not work to mark SQL statement borders. Note also a special case: if a temporary table is created inside LOCK TABLES, MySQL has not called external_lock() at all on that table. MySQL-5.0 also calls this before each statement in an execution of a stored procedure. To make the execution more deterministic for binlogging, MySQL-5.0 locks all tables involved in a stored procedure with full explicit table locks (thd_in_lock_tables(thd) holds in store_lock()) before executing the procedure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>handle to the user thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_type</td><td>lock type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or error code </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a90c625117fcff640b7af11e7018519cd">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#aaaa9bd51ec41066cc54c7e39f76a7c58">ha_innopart</a>.</p>

</div>
</div>
<a id="a9d647e97f555625b358f8916af249c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d647e97f555625b358f8916af249c0d">&#9670;&nbsp;</a></span>store_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a> ** ha_innobase::store_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a> **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a>&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Supposed to convert a MySQL table lock stored in the 'lock' field of the handle to a proper type before storing pointer to the lock into an array of pointers. </p>
<p>In practice, since InnoDB no longer relies on THR_LOCK locks and its lock_count() method returns 0 it just informs storage engine about type of THR_LOCK which SQL-layer would have acquired for this specific statement on this specific table. MySQL also calls this if it wants to reset some table locks to a not-locked state during the processing of an SQL query. An example is that during a SELECT the read lock is released early on the 'const' tables where we only fetch one row. MySQL does not call this when it releases all locks at the end of an SQL statement. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the current element in the 'to' array. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: user thread handle </td></tr>
    <tr><td class="paramname">to</td><td>in: pointer to the current element in an array of pointers to lock structs; only used as return value </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type to store in 'lock'; this may also be TL_IGNORE </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga9774a407435944f61025ab5c3d8a2347">ha_innopart</a>.</p>

</div>
</div>
<a id="a0ca84fffd74ffd0394230883dffa75dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca84fffd74ffd0394230883dffa75dc">&#9670;&nbsp;</a></span>table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">handler::Table_flags</a> ha_innobase::table_flags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the table flags to use for the statement. </p>
<dl class="section return"><dt>Returns</dt><dd>table flags </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a8dfa0934ac54d557e2dc9bd2bb634645">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a9d19fbf38d1854e3d4b69875b1a7f7ce">ha_innopart</a>.</p>

</div>
</div>
<a id="af59155263e0c49220461c9d80ae7a72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59155263e0c49220461c9d80ae7a72c">&#9670;&nbsp;</a></span>table_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ha_innobase::table_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the table type (storage engine name). </p>
<dl class="section return"><dt>Returns</dt><dd>table type </dd></dl>

<p>Implements <a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">handler</a>.</p>

</div>
</div>
<a id="ab21f574e10b4de8b9720995f9acd2a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21f574e10b4de8b9720995f9acd2a48">&#9670;&nbsp;</a></span>truncate_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::truncate_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TRUNCATE an InnoDB table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>table definition </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_def</td><td>dd::Table describing table to be truncated. Can be adjusted by SE, the changes will be saved into the data-dictionary at statement commit time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9584f11c212c4ad6e1e270055122435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9584f11c212c4ad6e1e270055122435">&#9670;&nbsp;</a></span>try_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::try_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the engine whether it should avoid unnecessary lock waits. </p>
<p>If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga92a0f60851cef91f64a913af312ed240">ha_innopart</a>.</p>

</div>
</div>
<a id="a79f39bfde37d1a055be72730da08c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f39bfde37d1a055be72730da08c0d4">&#9670;&nbsp;</a></span>unlock_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::unlock_row </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a new lock set on a row, if it was not read optimistically. </p>
<p>This can be called after a row has been read in the processing of an UPDATE or a DELETE query, when trx_t::allow_semi_consistent() is true. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a48e6fd090f73a8e7e5e94769c9a10733">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga7ac38c8df0ffeb09b7de13f3a6cd10d3">ha_innopart</a>.</p>

</div>
</div>
<a id="ad7d9ce11b0e2884e151e005bd74f3a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d9ce11b0e2884e151e005bd74f3a1f">&#9670;&nbsp;</a></span>update_create_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::update_create_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update create_info. </p>
<p>Used in SHOW CREATE TABLE et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_info</td><td>in/out: create info </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a58141e7b51aaf97bdf63ea68c411f401">handler</a>.</p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#afda3c6c261bb3b6bbd428eebb97551eb">ha_innopart</a>.</p>

</div>
</div>
<a id="a517b1ecde7d65b3da61b8d2bba00389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517b1ecde7d65b3da61b8d2bba00389c">&#9670;&nbsp;</a></span>update_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::update_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>old_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>new_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a row given as a parameter to a new value. </p>
<p>Note that we are given whole rows, not just the fields which are updated: this incurs some overhead for CPU when we check which fields are actually updated. TODO: currently InnoDB does not prevent the 'Halloween problem': in a searched update a single row can get updated several times if its index columns are updated! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">old_row</td><td>Old row contents in MySQL format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_row</td><td>Updated row contents in MySQL format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error number or 0 </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3483fb841777f6e50a8b890ce95527e8">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga94fc3f3ee0e1c409a055d8447a783f26">ha_innopart</a>.</p>

</div>
</div>
<a id="a69a39a509591249bd1baf5010c69286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a39a509591249bd1baf5010c69286a">&#9670;&nbsp;</a></span>update_thd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::update_thd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the user_thd field in a handle and also allocates a new InnoDB transaction handle if needed, and updates the transaction fields in the m_prebuilt struct. </p>

</div>
</div>
<a id="a544385a9ff719a58727aef2f8bf8cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544385a9ff719a58727aef2f8bf8cf1b">&#9670;&nbsp;</a></span>update_thd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::update_thd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the user_thd field in a handle and also allocates a new InnoDB transaction handle if needed, and updates the transaction fields in the m_prebuilt struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: thd to use the handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae7f6f94a9e464716bb3b99b7a9b85ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7f6f94a9e464716bb3b99b7a9b85ba">&#9670;&nbsp;</a></span>upgrade_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::upgrade_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>dd_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set Engine specific data to dd::Table object for upgrade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">db_name</td><td>database name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_name</td><td>table name </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dd_table</td><td>data dictionary cache object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ad8691b98cbb43c5a930149f25d1e55ac">handler</a>.</p>

</div>
</div>
<a id="a82ed82289ef82d7553b4dde7536bab3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ed82289ef82d7553b4dde7536bab3e">&#9670;&nbsp;</a></span>was_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::was_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normally, when running UPDATE or DELETE queries, we need to wait for other transactions to release their locks on a given row before we can read it and potentially update it. </p>
<p>However, in READ UNCOMMITTED and READ COMMITTED, we can ignore these locks if we don't intend to modify the row (e.g., because it failed a WHERE). This is signaled through enabling semi-consistent read, by calling try_semi_consistent_read(true) (and then setting it back to false after finishing the query).</p>
<p>If semi-consistent read is enabled, and we are in READ UNCOMMITTED or READ COMMITTED, the storage engine is permitted to return rows that are locked and thus un-updatable. If the optimizer doesn't want the row, e.g., because it got filtered out, it can call unlock_row() as usual. However, if it intends to update the row, it needs to call was_semi_consistent_read() before doing so. If was_semi_consistent_read() returns false, the row was never locked to begin with and can be updated as usual. However, if it returns 1, it was read optimistically, must be discarded (ie., do not try to update the row) and must be re-read with locking enabled. The next read call after was_semi_consistent_read() will automatically re-read the same row, this time with locking enabled.</p>
<p>Thus, typical use in an UPDATE scenario would look like this: </p><pre class="fragment">file-&gt;try_semi_consistent_read(true);
file-&gt;ha_rnd_init(true);
while (file-&gt;ha_rnd_next(table-&gt;record[0]) == 0) {
  if (row is filtered...) {
    file-&gt;unlock_row();
    continue;
  }
  if (file-&gt;was_semi_consistent_read()) {
</pre><p> Discard the row; next ha_rnd_next() will read it again with locking. continue; } Process row here. } file-&gt;ha_rnd_end(); file-&gt;try_semi_consistent_read(false);</p>
<p>If the transaction isolation level is REPEATABLE READ or SERIALIZABLE, enabling this flag has no effect. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga4144012d1f7d568dfcb896d1131af698">ha_innopart</a>.</p>

</div>
</div>
<a id="ae89861bd4a0fd74b4a8b0d495472a363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89861bd4a0fd74b4a8b0d495472a363">&#9670;&nbsp;</a></span>write_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::write_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a row in an InnoDB database, to the table specified in this handle. </p>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>in: a row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3b26a1dd124ff748aa02f9dd34a378a">handler</a>.</p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga450ee9e6861663b2a9e814d3ee5bbf01">ha_innopart</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a119bf770d1236ded83e472953ffc56ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119bf770d1236ded83e472953ffc56ac">&#9670;&nbsp;</a></span>m_ds_mrr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDsMrr__impl.html">DsMrr_impl</a> ha_innobase::m_ds_mrr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The multi range read session object. </p>

</div>
</div>
<a id="ac241ca27bc9eee2c949a552e81b202c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac241ca27bc9eee2c949a552e81b202c0">&#9670;&nbsp;</a></span>m_int_table_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a> ha_innobase::m_int_table_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags that specificy the handler instance (table) capability. </p>

</div>
</div>
<a id="a2691576aee2886e00364dd1b0c2b9568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2691576aee2886e00364dd1b0c2b9568">&#9670;&nbsp;</a></span>m_last_match_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ha_innobase::m_last_match_mode {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b767b944c208922ac6c192bc565309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b767b944c208922ac6c192bc565309">&#9670;&nbsp;</a></span>m_mysql_has_locked</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::m_mysql_has_locked</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If mysql has locked with external_lock() </p>

</div>
</div>
<a id="a5f7ac63b3f490bc8e9fc37688c4c5fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7ac63b3f490bc8e9fc37688c4c5fbf">&#9670;&nbsp;</a></span>m_prebuilt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a>* ha_innobase::m_prebuilt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save CPU time with prebuilt/cached data structures. </p>

</div>
</div>
<a id="a6bf7cfc62bf068b9f0a36b670d5e4f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf7cfc62bf068b9f0a36b670d5e4f1f">&#9670;&nbsp;</a></span>m_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structINNOBASE__SHARE.html">INNOBASE_SHARE</a>* ha_innobase::m_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>information for MySQL table locking </p>

</div>
</div>
<a id="a7d141e41ac99ae6927fe7c2518810e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d141e41ac99ae6927fe7c2518810e1a">&#9670;&nbsp;</a></span>m_start_of_scan</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ha_innobase::m_start_of_scan</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this is set to 1 when we are starting a table scan but have not yet fetched any row, else false </p>
<p>match mode of the latest search: ROW_SEL_EXACT, ROW_SEL_EXACT_PREFIX, or undefined </p>

</div>
</div>
<a id="a6e8cc56d04d8bff2c06736db1beecf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8cc56d04d8bff2c06736db1beecf54">&#9670;&nbsp;</a></span>m_stored_select_lock_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint ha_innobase::m_stored_select_lock_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this field is used to remember the original select_lock_type that was decided in ha_innodb.cc,":: store_lock()", "::external_lock()", etc. </p>

</div>
</div>
<a id="a1a660c7aefb96de3d325531d254c6155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a660c7aefb96de3d325531d254c6155">&#9670;&nbsp;</a></span>m_upd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* ha_innobase::m_upd_buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>buffer used in updates </p>

</div>
</div>
<a id="aa39d884bfcc68b38b1175c14c46d14c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39d884bfcc68b38b1175c14c46d14c9">&#9670;&nbsp;</a></span>m_upd_buf_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint ha_innobase::m_upd_buf_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the size of upd_buf in bytes </p>

</div>
</div>
<a id="a00043185de77b7b62cb1ff4d731c7892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00043185de77b7b62cb1ff4d731c7892">&#9670;&nbsp;</a></span>m_user_thd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTHD.html">THD</a>* ha_innobase::m_user_thd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread handle of the user currently using the handler; this is set in external_lock function. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>storage/innobase/handler/<a class="el" href="ha__innodb_8h_source.html">ha_innodb.h</a></li>
<li>storage/innobase/handler/<a class="el" href="ha__innodb_8cc.html">ha_innodb.cc</a></li>
<li>storage/innobase/handler/<a class="el" href="handler0alter_8cc.html">handler0alter.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classha__innobase.html">ha_innobase</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
