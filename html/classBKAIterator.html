<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: BKAIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classBKAIterator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBKAIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BKAIterator Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The BKA join iterator, with an arbitrary iterator tree on the outer side and a MultiRangeRowIterator on the inner side (possibly with a filter or similar in-between).  
 <a href="classBKAIterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bka__iterator_8h_source.html">bka_iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BKAIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBKAIterator.png" usemap="#BKAIterator_map" alt=""/>
  <map id="BKAIterator_map" name="BKAIterator_map">
<area href="classRowIterator.html" title="A context for reading through a single table using a chosen access method: index read, scan, etc, use of cache, etc. " alt="RowIterator" shape="rect" coords="0,0,77,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a535f5f39aee2e186e0095c0bc366b41d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a535f5f39aee2e186e0095c0bc366b41d">BKAIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; outer_input, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> outer_input_tables, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; inner_input, size_t max_memory_available, size_t mrr_bytes_needed_for_single_inner_row, float expected_inner_rows_per_outer_row, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> store_rowids, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tables_to_get_rowid_for, <a class="el" href="classMultiRangeRowIterator.html">MultiRangeRowIterator</a> *mrr_iterator, <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>)</td></tr>
<tr class="separator:a535f5f39aee2e186e0095c0bc366b41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53bde3f57efec86729af104870fc50b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ae53bde3f57efec86729af104870fc50b">Init</a> () override</td></tr>
<tr class="memdesc:ae53bde3f57efec86729af104870fc50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#ae53bde3f57efec86729af104870fc50b">More...</a><br /></td></tr>
<tr class="separator:ae53bde3f57efec86729af104870fc50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c0109f0a572765452415d102758b2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ab9c0109f0a572765452415d102758b2c">Read</a> () override</td></tr>
<tr class="memdesc:ab9c0109f0a572765452415d102758b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single row.  <a href="#ab9c0109f0a572765452415d102758b2c">More...</a><br /></td></tr>
<tr class="separator:ab9c0109f0a572765452415d102758b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ae212bcbc26a5af0149e783b80a5a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ae2ae212bcbc26a5af0149e783b80a5a1">SetNullRowFlag</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_null_row) override</td></tr>
<tr class="memdesc:ae2ae212bcbc26a5af0149e783b80a5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row).  <a href="#ae2ae212bcbc26a5af0149e783b80a5a1">More...</a><br /></td></tr>
<tr class="separator:ae2ae212bcbc26a5af0149e783b80a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cb029dd7e15858d1971a99323315d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ae2cb029dd7e15858d1971a99323315d8">UnlockRow</a> () override</td></tr>
<tr class="separator:ae2cb029dd7e15858d1971a99323315d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653eac2cbf6d5999aeb84a9e4a975767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a653eac2cbf6d5999aeb84a9e4a975767">EndPSIBatchModeIfStarted</a> () override</td></tr>
<tr class="memdesc:a653eac2cbf6d5999aeb84a9e4a975767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends performance schema batch mode, if started.  <a href="#a653eac2cbf6d5999aeb84a9e4a975767">More...</a><br /></td></tr>
<tr class="separator:a653eac2cbf6d5999aeb84a9e4a975767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a9e730a0c6722be2f9841fd6b7a3f6a52">RowIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>)</td></tr>
<tr class="separator:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a8778b8e93d01e1e47f0e98804882ea8e">~RowIterator</a> ()</td></tr>
<tr class="separator:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#acb75cd99708ea3f1d62b41c8072f1d96">TimingString</a> () const</td></tr>
<tr class="separator:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c60f99cb3a1bc36776d718636aab5a0 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a3c60f99cb3a1bc36776d718636aab5a0">StartPSIBatchMode</a> ()</td></tr>
<tr class="memdesc:a3c60f99cb3a1bc36776d718636aab5a0 inherit pub_methods_classRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start performance schema batch mode, if supported (otherwise ignored).  <a href="classRowIterator.html#a3c60f99cb3a1bc36776d718636aab5a0">More...</a><br /></td></tr>
<tr class="separator:a3c60f99cb3a1bc36776d718636aab5a0 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">real_iterator</a> ()</td></tr>
<tr class="memdesc:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this iterator is wrapping a different iterator (e.g.  <a href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">More...</a><br /></td></tr>
<tr class="separator:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#ad0baf633d8ed8803dc77c86a2c9faeda">real_iterator</a> () const</td></tr>
<tr class="separator:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a8f02df57e8c1ee3f284b1ae7cbb1672c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672c">State</a> { <a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672ca7bebc54bee6036791e8c1be1369770b6">State::NEED_OUTER_ROWS</a>, 
<a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672ca5666d6660a12e48e7172bcda9fbfd522">State::RETURNING_JOINED_ROWS</a>, 
<a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672cabf876a288997414bc766654638c2c7a8">State::RETURNING_NULL_COMPLEMENTED_ROWS</a>, 
<a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672cac51fdf14ade8bb36f7dc3e02aed6c1d7">State::END_OF_ROWS</a>
 }</td></tr>
<tr class="separator:a8f02df57e8c1ee3f284b1ae7cbb1672c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad9d5ea6e997f65c7703d3c46c809289b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ad9d5ea6e997f65c7703d3c46c809289b">BeginNewBatch</a> ()</td></tr>
<tr class="memdesc:ad9d5ea6e997f65c7703d3c46c809289b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear out the MEM_ROOT and prepare for reading rows anew.  <a href="#ad9d5ea6e997f65c7703d3c46c809289b">More...</a><br /></td></tr>
<tr class="separator:ad9d5ea6e997f65c7703d3c46c809289b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa5116f15b9404d5dd53ce94999dcbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a4fa5116f15b9404d5dd53ce94999dcbb">BatchFinished</a> ()</td></tr>
<tr class="memdesc:a4fa5116f15b9404d5dd53ce94999dcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are more outer rows, begin the next batch.  <a href="#a4fa5116f15b9404d5dd53ce94999dcbb">More...</a><br /></td></tr>
<tr class="separator:a4fa5116f15b9404d5dd53ce94999dcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c394c633f2e2562fb55706d251e807"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a02c394c633f2e2562fb55706d251e807">MakeNullComplementedRow</a> ()</td></tr>
<tr class="memdesc:a02c394c633f2e2562fb55706d251e807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next unmatched row, and load it for output as a NULL-complemented row.  <a href="#a02c394c633f2e2562fb55706d251e807">More...</a><br /></td></tr>
<tr class="separator:a02c394c633f2e2562fb55706d251e807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d968d9a4d5f120dc74d832da041e9b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a3d968d9a4d5f120dc74d832da041e9b3">ReadOuterRows</a> ()</td></tr>
<tr class="memdesc:a3d968d9a4d5f120dc74d832da041e9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a batch of outer rows (BeginNewBatch() must have been called earlier).  <a href="#a3d968d9a4d5f120dc74d832da041e9b3">More...</a><br /></td></tr>
<tr class="separator:a3d968d9a4d5f120dc74d832da041e9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad9c2ae1d8b1f8dbed672d158aef00eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672c">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ad9c2ae1d8b1f8dbed672d158aef00eec">m_state</a></td></tr>
<tr class="separator:ad9c2ae1d8b1f8dbed672d158aef00eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85a22cf917093a19a0c9bc094016bae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#af85a22cf917093a19a0c9bc094016bae">m_outer_input</a></td></tr>
<tr class="separator:af85a22cf917093a19a0c9bc094016bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ef03b0c08a4c059df5b56894fc5c9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a64ef03b0c08a4c059df5b56894fc5c9f">m_inner_input</a></td></tr>
<tr class="separator:a64ef03b0c08a4c059df5b56894fc5c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182be8780960c885a6630951aa607a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a182be8780960c885a6630951aa607a74">m_mem_root</a></td></tr>
<tr class="memdesc:a182be8780960c885a6630951aa607a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MEM_ROOT we are storing the outer rows on, and also allocating MRR buffer from.  <a href="#a182be8780960c885a6630951aa607a74">More...</a><br /></td></tr>
<tr class="separator:a182be8780960c885a6630951aa607a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86a9bcc7522487090cdd4af2b335030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ac86a9bcc7522487090cdd4af2b335030">m_rows</a></td></tr>
<tr class="memdesc:ac86a9bcc7522487090cdd4af2b335030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffered outer rows.  <a href="#ac86a9bcc7522487090cdd4af2b335030">More...</a><br /></td></tr>
<tr class="separator:ac86a9bcc7522487090cdd4af2b335030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0699619d7f7246f5fc63ceb5ed894cb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhash__join__buffer_1_1TableCollection.html">hash_join_buffer::TableCollection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a0699619d7f7246f5fc63ceb5ed894cb0">m_outer_input_tables</a></td></tr>
<tr class="memdesc:a0699619d7f7246f5fc63ceb5ed894cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tables and columns needed for each outer row.  <a href="#a0699619d7f7246f5fc63ceb5ed894cb0">More...</a><br /></td></tr>
<tr class="separator:a0699619d7f7246f5fc63ceb5ed894cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984ac2bfe32548395ebe94a90d92f383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classString.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a984ac2bfe32548395ebe94a90d92f383">m_outer_row_buffer</a></td></tr>
<tr class="memdesc:a984ac2bfe32548395ebe94a90d92f383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for serializing the row we read from the outer table(s), before it stored into the MEM_ROOT and put into m_rows.  <a href="#a984ac2bfe32548395ebe94a90d92f383">More...</a><br /></td></tr>
<tr class="separator:a984ac2bfe32548395ebe94a90d92f383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d3390b2ad3c519f65ee29e204dd4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a15d3390b2ad3c519f65ee29e204dd4c6">m_has_row_from_previous_batch</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:a15d3390b2ad3c519f65ee29e204dd4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we have a row in m_outer_row_buffer from the previous batch of rows that we haven't stored in m_rows yet.  <a href="#a15d3390b2ad3c519f65ee29e204dd4c6">More...</a><br /></td></tr>
<tr class="separator:a15d3390b2ad3c519f65ee29e204dd4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df24842f5048742c30c042a37d108a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a9df24842f5048742c30c042a37d108a6">m_mrr_bytes_needed_per_row</a></td></tr>
<tr class="memdesc:a9df24842f5048742c30c042a37d108a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each outer row, how many bytes we need in the MRR buffer (ie., the number of bytes we expect to use on rows from the inner table).  <a href="#a9df24842f5048742c30c042a37d108a6">More...</a><br /></td></tr>
<tr class="separator:a9df24842f5048742c30c042a37d108a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab513e64d82b458fca495bfeacf59f575"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ab513e64d82b458fca495bfeacf59f575">m_bytes_used</a> = 0</td></tr>
<tr class="memdesc:ab513e64d82b458fca495bfeacf59f575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimated number of bytes used on m_mem_root so far.  <a href="#ab513e64d82b458fca495bfeacf59f575">More...</a><br /></td></tr>
<tr class="separator:ab513e64d82b458fca495bfeacf59f575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc868263c9c53b4584ff5a138907597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#abfc868263c9c53b4584ff5a138907597">m_end_of_outer_rows</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:abfc868263c9c53b4584ff5a138907597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we've seen EOF from the outer iterator.  <a href="#abfc868263c9c53b4584ff5a138907597">More...</a><br /></td></tr>
<tr class="separator:abfc868263c9c53b4584ff5a138907597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa05704ee6086bdc4495ece7eca7844"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a7fa05704ee6086bdc4495ece7eca7844">m_max_memory_available</a></td></tr>
<tr class="memdesc:a7fa05704ee6086bdc4495ece7eca7844"><td class="mdescLeft">&#160;</td><td class="mdescRight">See max_memory_available in the constructor.  <a href="#a7fa05704ee6086bdc4495ece7eca7844">More...</a><br /></td></tr>
<tr class="separator:a7fa05704ee6086bdc4495ece7eca7844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019114481026c0e0784fe5a786beea96"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a019114481026c0e0784fe5a786beea96">m_mrr_bytes_needed_for_single_inner_row</a></td></tr>
<tr class="memdesc:a019114481026c0e0784fe5a786beea96"><td class="mdescLeft">&#160;</td><td class="mdescRight">See max_memory_available in the constructor.  <a href="#a019114481026c0e0784fe5a786beea96">More...</a><br /></td></tr>
<tr class="separator:a019114481026c0e0784fe5a786beea96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d5b2ed19fb2cab3af0c13b50834c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMultiRangeRowIterator.html">MultiRangeRowIterator</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#a81d5b2ed19fb2cab3af0c13b50834c44">m_mrr_iterator</a></td></tr>
<tr class="memdesc:a81d5b2ed19fb2cab3af0c13b50834c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">See mrr_iterator in the constructor.  <a href="#a81d5b2ed19fb2cab3af0c13b50834c44">More...</a><br /></td></tr>
<tr class="separator:a81d5b2ed19fb2cab3af0c13b50834c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab79d1e659487c84b978525979b4ad1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#aab79d1e659487c84b978525979b4ad1c">m_join_type</a></td></tr>
<tr class="memdesc:aab79d1e659487c84b978525979b4ad1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The join type of the BKA join.  <a href="#aab79d1e659487c84b978525979b4ad1c">More...</a><br /></td></tr>
<tr class="separator:aab79d1e659487c84b978525979b4ad1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83c2f9599921025fbbbb0c96749e7e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBKAIterator.html#ab83c2f9599921025fbbbb0c96749e7e7">m_current_pos</a></td></tr>
<tr class="memdesc:ab83c2f9599921025fbbbb0c96749e7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we are synthesizing NULL-complemented rows (for an outer join or antijoin), points to the next row within "m_rows" that we haven't considered yet.  <a href="#ab83c2f9599921025fbbbb0c96749e7e7">More...</a><br /></td></tr>
<tr class="separator:ab83c2f9599921025fbbbb0c96749e7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a> () const</td></tr>
<tr class="separator:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The BKA join iterator, with an arbitrary iterator tree on the outer side and a MultiRangeRowIterator on the inner side (possibly with a filter or similar in-between). </p>
<p>See file comment for more details. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8f02df57e8c1ee3f284b1ae7cbb1672c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f02df57e8c1ee3f284b1ae7cbb1672c">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672c">BKAIterator::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8f02df57e8c1ee3f284b1ae7cbb1672ca7bebc54bee6036791e8c1be1369770b6"></a>NEED_OUTER_ROWS&#160;</td><td class="fielddoc"><p>We are about to start reading outer rows into our buffer. </p>
<p>A single Read() call will fill it up, so there is no in-between “currently reading” state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f02df57e8c1ee3f284b1ae7cbb1672ca5666d6660a12e48e7172bcda9fbfd522"></a>RETURNING_JOINED_ROWS&#160;</td><td class="fielddoc"><p>We are returning rows from the MultiRangeRowIterator. </p>
<p>(For antijoins, we are looking up the rows, but don't actually return them.) </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f02df57e8c1ee3f284b1ae7cbb1672cabf876a288997414bc766654638c2c7a8"></a>RETURNING_NULL_COMPLEMENTED_ROWS&#160;</td><td class="fielddoc"><p>We are an outer join or antijoin, and we're returning NULL-complemented rows for those outer rows that never had a matching inner row. </p>
<p>Note that this is done in the BKAIterator and not the MRR iterator for two reasons: First, it gives more sensible EXPLAIN ANALYZE numbers. Second, the NULL-complemented rows could be filtered inadvertently by a FilterIterator before they reach the BKAIterator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f02df57e8c1ee3f284b1ae7cbb1672cac51fdf14ade8bb36f7dc3e02aed6c1d7"></a>END_OF_ROWS&#160;</td><td class="fielddoc"><p>Both the outer and inner side are out of rows. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a535f5f39aee2e186e0095c0bc366b41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535f5f39aee2e186e0095c0bc366b41d">&#9670;&nbsp;</a></span>BKAIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BKAIterator::BKAIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>outer_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>outer_input_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>inner_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_memory_available</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mrr_bytes_needed_for_single_inner_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>expected_inner_rows_per_outer_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>store_rowids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>tables_to_get_rowid_for</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMultiRangeRowIterator.html">MultiRangeRowIterator</a> *&#160;</td>
          <td class="paramname"><em>mrr_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td>
          <td class="paramname"><em>join_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle. </td></tr>
    <tr><td class="paramname">join</td><td>The JOIN we are part of. </td></tr>
    <tr><td class="paramname">outer_input</td><td>The iterator to read the outer rows from. </td></tr>
    <tr><td class="paramname">outer_input_tables</td><td>QEP_TAB for each outer table involved. Used to know which fields we are to read into our buffer. </td></tr>
    <tr><td class="paramname">inner_input</td><td>The iterator to read the inner rows from. Must end up in a MultiRangeRowIterator. </td></tr>
    <tr><td class="paramname">max_memory_available</td><td>Number of bytes available for row buffers, both outer rows and MRR buffers. Note that allocation is incremental, so we can allocate less than this. </td></tr>
    <tr><td class="paramname">mrr_bytes_needed_for_single_inner_row</td><td>Number of bytes MRR needs space for in its buffer for holding a single row from the inner table. </td></tr>
    <tr><td class="paramname">expected_inner_rows_per_outer_row</td><td>Number of inner rows we statistically expect for each outer row. Used for dividing the buffer space between inner rows and MRR row buffer (if we expect many inner rows, we can't load as many outer rows). </td></tr>
    <tr><td class="paramname">store_rowids</td><td>Whether we need to make sure all tables below us have row IDs available, after Read() has been called. Used only if we are below a weedout operation. </td></tr>
    <tr><td class="paramname">tables_to_get_rowid_for</td><td>A map of which tables BKAIterator needs to call position() for itself. tables that are in outer_input_tables but not in this map, are expected to be handled by some other iterator. tables that are in this map but not in outer_input_tables will be ignored. </td></tr>
    <tr><td class="paramname">mrr_iterator</td><td>Pointer to the MRR iterator at the bottom of inner_input. Used to send row ranges and buffers. </td></tr>
    <tr><td class="paramname">join_type</td><td>What kind of join we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4fa5116f15b9404d5dd53ce94999dcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa5116f15b9404d5dd53ce94999dcbb">&#9670;&nbsp;</a></span>BatchFinished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BKAIterator::BatchFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If there are more outer rows, begin the next batch. </p>
<p>If not, move to the EOF state. </p>

</div>
</div>
<a id="ad9d5ea6e997f65c7703d3c46c809289b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d5ea6e997f65c7703d3c46c809289b">&#9670;&nbsp;</a></span>BeginNewBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BKAIterator::BeginNewBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear out the MEM_ROOT and prepare for reading rows anew. </p>

</div>
</div>
<a id="a653eac2cbf6d5999aeb84a9e4a975767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653eac2cbf6d5999aeb84a9e4a975767">&#9670;&nbsp;</a></span>EndPSIBatchModeIfStarted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BKAIterator::EndPSIBatchModeIfStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends performance schema batch mode, if started. </p>
<p>It's always safe to call this.</p>
<p>Iterators that have children (composite iterators) must forward the EndPSIBatchModeIfStarted() call to every iterator they could conceivably have called StartPSIBatchMode() on. This ensures that after such a call to on the root iterator, all handlers are out of batch mode. </p>

<p>Reimplemented from <a class="el" href="classRowIterator.html#a9d2300ee51cfa38a5d6bfe0793d12540">RowIterator</a>.</p>

</div>
</div>
<a id="ae53bde3f57efec86729af104870fc50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53bde3f57efec86729af104870fc50b">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> BKAIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="a02c394c633f2e2562fb55706d251e807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c394c633f2e2562fb55706d251e807">&#9670;&nbsp;</a></span>MakeNullComplementedRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BKAIterator::MakeNullComplementedRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the next unmatched row, and load it for output as a NULL-complemented row. </p>
<p>(Assumes the NULL row flag has already been set on the inner table iterator.) Returns 0 if a row was found, -1 if no row was found. (Errors cannot happen.) </p>

</div>
</div>
<a id="ab9c0109f0a572765452415d102758b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c0109f0a572765452415d102758b2c">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BKAIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single row. </p>
<p>The row data is not actually returned from the function; it is put in the table's (or tables', in case of a join) record buffer, ie., table-&gt;records[0].</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="a3d968d9a4d5f120dc74d832da041e9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d968d9a4d5f120dc74d832da041e9b3">&#9670;&nbsp;</a></span>ReadOuterRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BKAIterator::ReadOuterRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a batch of outer rows (BeginNewBatch() must have been called earlier). </p>
<p>Returns -1 for no outer rows found (sets state to END_OF_ROWS), 0 for OK (sets state to RETURNING_JOINED_ROWS) or 1 for error. </p>

</div>
</div>
<a id="ae2ae212bcbc26a5af0149e783b80a5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ae212bcbc26a5af0149e783b80a5a1">&#9670;&nbsp;</a></span>SetNullRowFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BKAIterator::SetNullRowFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_null_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row). </p>
<p>This is used for outer joins, when an iterator hasn't produced any rows and we need to produce a NULL-complemented row. Init() or Read() won't necessarily reset this flag, so if you ever set is to true, make sure to also set it to false when needed.</p>
<p>Note that this can be called without Init() having been called first. For example, NestedLoopIterator can hit EOF immediately on the outer iterator, which means the inner iterator doesn't get an Init() call, but will still forward SetNullRowFlag to both inner and outer iterators.</p>
<p>TODO: We shouldn't need this. See the comments on AggregateIterator for a bit more discussion on abstracting out a row interface. </p>

<p>Implements <a class="el" href="classRowIterator.html#a2fb51c6b0d8b763265d8b20710a31cb1">RowIterator</a>.</p>

</div>
</div>
<a id="ae2cb029dd7e15858d1971a99323315d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cb029dd7e15858d1971a99323315d8">&#9670;&nbsp;</a></span>UnlockRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BKAIterator::UnlockRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRowIterator.html#a7590a98b54a85d3624cd9667c2da0764">RowIterator</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab513e64d82b458fca495bfeacf59f575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab513e64d82b458fca495bfeacf59f575">&#9670;&nbsp;</a></span>m_bytes_used</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BKAIterator::m_bytes_used = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimated number of bytes used on m_mem_root so far. </p>

</div>
</div>
<a id="ab83c2f9599921025fbbbb0c96749e7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83c2f9599921025fbbbb0c96749e7e7">&#9670;&nbsp;</a></span>m_current_pos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a>* BKAIterator::m_current_pos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we are synthesizing NULL-complemented rows (for an outer join or antijoin), points to the next row within "m_rows" that we haven't considered yet. </p>

</div>
</div>
<a id="abfc868263c9c53b4584ff5a138907597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc868263c9c53b4584ff5a138907597">&#9670;&nbsp;</a></span>m_end_of_outer_rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> BKAIterator::m_end_of_outer_rows = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we've seen EOF from the outer iterator. </p>

</div>
</div>
<a id="a15d3390b2ad3c519f65ee29e204dd4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d3390b2ad3c519f65ee29e204dd4c6">&#9670;&nbsp;</a></span>m_has_row_from_previous_batch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> BKAIterator::m_has_row_from_previous_batch = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we have a row in m_outer_row_buffer from the previous batch of rows that we haven't stored in m_rows yet. </p>

</div>
</div>
<a id="a64ef03b0c08a4c059df5b56894fc5c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ef03b0c08a4c059df5b56894fc5c9f">&#9670;&nbsp;</a></span>m_inner_input</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt;<a class="el" href="classRowIterator.html">RowIterator</a>&gt; BKAIterator::m_inner_input</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab79d1e659487c84b978525979b4ad1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab79d1e659487c84b978525979b4ad1c">&#9670;&nbsp;</a></span>m_join_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> BKAIterator::m_join_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The join type of the BKA join. </p>

</div>
</div>
<a id="a7fa05704ee6086bdc4495ece7eca7844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa05704ee6086bdc4495ece7eca7844">&#9670;&nbsp;</a></span>m_max_memory_available</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t BKAIterator::m_max_memory_available</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See max_memory_available in the constructor. </p>

</div>
</div>
<a id="a182be8780960c885a6630951aa607a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182be8780960c885a6630951aa607a74">&#9670;&nbsp;</a></span>m_mem_root</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> BKAIterator::m_mem_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The MEM_ROOT we are storing the outer rows on, and also allocating MRR buffer from. </p>
<p>In total, this should not go significantly over m_max_memory_available bytes. </p>

</div>
</div>
<a id="a019114481026c0e0784fe5a786beea96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019114481026c0e0784fe5a786beea96">&#9670;&nbsp;</a></span>m_mrr_bytes_needed_for_single_inner_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t BKAIterator::m_mrr_bytes_needed_for_single_inner_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See max_memory_available in the constructor. </p>

</div>
</div>
<a id="a9df24842f5048742c30c042a37d108a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df24842f5048742c30c042a37d108a6">&#9670;&nbsp;</a></span>m_mrr_bytes_needed_per_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BKAIterator::m_mrr_bytes_needed_per_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each outer row, how many bytes we need in the MRR buffer (ie., the number of bytes we expect to use on rows from the inner table). </p>
<p>This is the expected number of inner rows per key, multiplied by the (fixed) size of each inner row. We use this information to stop scanning before we've used up the entire RAM allowance on outer rows, so that we have space remaining for the inner rows (in the MRR buffer), too. </p>

</div>
</div>
<a id="a81d5b2ed19fb2cab3af0c13b50834c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d5b2ed19fb2cab3af0c13b50834c44">&#9670;&nbsp;</a></span>m_mrr_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMultiRangeRowIterator.html">MultiRangeRowIterator</a>* const BKAIterator::m_mrr_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See mrr_iterator in the constructor. </p>

</div>
</div>
<a id="af85a22cf917093a19a0c9bc094016bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85a22cf917093a19a0c9bc094016bae">&#9670;&nbsp;</a></span>m_outer_input</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt;<a class="el" href="classRowIterator.html">RowIterator</a>&gt; BKAIterator::m_outer_input</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0699619d7f7246f5fc63ceb5ed894cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0699619d7f7246f5fc63ceb5ed894cb0">&#9670;&nbsp;</a></span>m_outer_input_tables</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhash__join__buffer_1_1TableCollection.html">hash_join_buffer::TableCollection</a> BKAIterator::m_outer_input_tables</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tables and columns needed for each outer row. </p>
<p>Rows/columns that are not needed are filtered out in the constructor; the rest are read and stored in m_rows. </p>

</div>
</div>
<a id="a984ac2bfe32548395ebe94a90d92f383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984ac2bfe32548395ebe94a90d92f383">&#9670;&nbsp;</a></span>m_outer_row_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classString.html">String</a> BKAIterator::m_outer_row_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for serializing the row we read from the outer table(s), before it stored into the MEM_ROOT and put into m_rows. </p>
<p>Should there not be room in m_rows for the row, it will stay in this variable until we start reading the next batch of outer rows.</p>
<p>If there are no BLOB/TEXT column in the join, we calculate an upper bound of the row size that is used to preallocate this buffer. In the case of BLOB/TEXT columns, we cannot calculate a reasonable upper bound, and the row size is calculated per row. The allocated memory is kept for the duration of the iterator, so that we (most likely) avoid reallocations. </p>

</div>
</div>
<a id="ac86a9bcc7522487090cdd4af2b335030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86a9bcc7522487090cdd4af2b335030">&#9670;&nbsp;</a></span>m_rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt;<a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a>&gt; BKAIterator::m_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffered outer rows. </p>

</div>
</div>
<a id="ad9c2ae1d8b1f8dbed672d158aef00eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c2ae1d8b1f8dbed672d158aef00eec">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBKAIterator.html#a8f02df57e8c1ee3f284b1ae7cbb1672c">State</a> BKAIterator::m_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="bka__iterator_8h_source.html">bka_iterator.h</a></li>
<li>sql/<a class="el" href="bka__iterator_8cc.html">bka_iterator.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classBKAIterator.html">BKAIterator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
