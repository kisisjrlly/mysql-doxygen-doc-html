<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: handler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhandler.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">handler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The handler class is the interface for dynamically loadable storage engines.  
 <a href="classhandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sql_2handler_8h_source.html">handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for handler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhandler.png" usemap="#handler_map" alt=""/>
  <map id="handler_map" name="handler_map">
<area href="classha__archive.html" alt="ha_archive" shape="rect" coords="126,56,242,80"/>
<area href="classha__blackhole.html" alt="ha_blackhole" shape="rect" coords="126,112,242,136"/>
<area href="classha__example.html" title="Class definition for the storage engine. " alt="ha_example" shape="rect" coords="126,168,242,192"/>
<area href="classha__federated.html" alt="ha_federated" shape="rect" coords="126,224,242,248"/>
<area href="classha__heap.html" alt="ha_heap" shape="rect" coords="126,280,242,304"/>
<area href="classha__innobase.html" title="The class defining a handle to an InnoDB table. " alt="ha_innobase" shape="rect" coords="126,336,242,360"/>
<area href="classha__myisam.html" alt="ha_myisam" shape="rect" coords="126,392,242,416"/>
<area href="classha__myisammrg.html" alt="ha_myisammrg" shape="rect" coords="126,448,242,472"/>
<area href="classha__perfschema.html" title="A handler for a PERFORMANCE_SCHEMA table. " alt="ha_perfschema" shape="rect" coords="126,504,242,528"/>
<area href="classha__tina.html" alt="ha_tina" shape="rect" coords="126,560,242,584"/>
<area href="classmock_1_1ha__mock.html" title="The MOCK storage engine is used for testing MySQL server functionality related to secondary storage e..." alt="mock::ha_mock" shape="rect" coords="126,616,242,640"/>
<area href="classtemptable_1_1Handler.html" title="Temptable engine handler. " alt="temptable::Handler" shape="rect" coords="126,672,242,696"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab5b14b11876fb5ac53a4cc7aceea6a2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">enum_range_scan_direction</a> { <a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2da9b3cccc513b9642d3f98dc18781feae5">RANGE_SCAN_ASC</a>, 
<a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2daa9e3a542611729d0b0825b523c603b8a">RANGE_SCAN_DESC</a>
 }</td></tr>
<tr class="separator:ab5b14b11876fb5ac53a4cc7aceea6a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf7978057d7f5cf7b58f37727a1ce6c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6ca448bbe9d4d955739e67450e94458076d">NONE</a> = 0, 
<a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6ca992cf6748d817c1cf1d7961455ed4be4">INDEX</a>, 
<a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6cab713692ea5c27311b0a69f8617599c45">RND</a>, 
<a class="el" href="classhandler.html#aedf7978057d7f5cf7b58f37727a1ce6ca0ebae1da94d3f9a811c564316d5c67f2">SAMPLING</a>
 }</td></tr>
<tr class="separator:aedf7978057d7f5cf7b58f37727a1ce6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af5473a36655c922682399d4c5b6ec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a></td></tr>
<tr class="separator:a67af5473a36655c922682399d4c5b6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa6c4d02e61680defa11a4081f1e24b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">Load_init_cbk</a> = std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(void *cookie, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> ncols, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> row_len, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *col_offsets, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *null_byte_offsets, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *null_bitmasks)&gt;</td></tr>
<tr class="memdesc:a6aa6c4d02e61680defa11a4081f1e24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called by each parallel load thread at the beginning of the parallel load for the adapter scan.  <a href="#a6aa6c4d02e61680defa11a4081f1e24b">More...</a><br /></td></tr>
<tr class="separator:a6aa6c4d02e61680defa11a4081f1e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d8794466270fec22f8a676eaa0c90a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">Load_cbk</a> = std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(void *cookie, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> nrows, void *rowdata, uint64_t partition_id)&gt;</td></tr>
<tr class="memdesc:af9d8794466270fec22f8a676eaa0c90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called by each parallel load thread when processing of rows is required for the adapter scan.  <a href="#af9d8794466270fec22f8a676eaa0c90a">More...</a><br /></td></tr>
<tr class="separator:af9d8794466270fec22f8a676eaa0c90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e65d325f0e08107186740bcb248756"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a24e65d325f0e08107186740bcb248756">Load_end_cbk</a> = std::function&lt; void(void *cookie)&gt;</td></tr>
<tr class="memdesc:a24e65d325f0e08107186740bcb248756"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback is called by each parallel load thread when processing of rows has ended for the adapter scan.  <a href="#a24e65d325f0e08107186740bcb248756">More...</a><br /></td></tr>
<tr class="separator:a24e65d325f0e08107186740bcb248756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c241e50948859d98ceae6e39066838"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a>) (const <a class="el" href="structTABLE.html">TABLE</a> *, void *)</td></tr>
<tr class="memdesc:ad4c241e50948859d98ceae6e39066838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function that will be called by my_prepare_gcolumn_template once the table has been opened.  <a href="#ad4c241e50948859d98ceae6e39066838">More...</a><br /></td></tr>
<tr class="separator:ad4c241e50948859d98ceae6e39066838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72cfeaceefd05a2f700c138c194770fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a72cfeaceefd05a2f700c138c194770fc">unbind_psi</a> ()</td></tr>
<tr class="separator:a72cfeaceefd05a2f700c138c194770fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e335a403d8203854bc5b94111992b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1e335a403d8203854bc5b94111992b79">rebind_psi</a> ()</td></tr>
<tr class="separator:a1e335a403d8203854bc5b94111992b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cadefb8724982848541e06a394917e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6cadefb8724982848541e06a394917e8">start_psi_batch_mode</a> ()</td></tr>
<tr class="memdesc:a6cadefb8724982848541e06a394917e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the handler in 'batch' mode when collecting table io instrumented events.  <a href="#a6cadefb8724982848541e06a394917e8">More...</a><br /></td></tr>
<tr class="separator:a6cadefb8724982848541e06a394917e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a860cb6d6cb731416080acc8f179e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab6a860cb6d6cb731416080acc8f179e0">end_psi_batch_mode</a> ()</td></tr>
<tr class="memdesc:ab6a860cb6d6cb731416080acc8f179e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End a batch started with <code>start_psi_batch_mode</code>.  <a href="#ab6a860cb6d6cb731416080acc8f179e0">More...</a><br /></td></tr>
<tr class="separator:ab6a860cb6d6cb731416080acc8f179e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75494b6dc9eb0d9fbbcd91cf0ab1d365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a75494b6dc9eb0d9fbbcd91cf0ab1d365">end_psi_batch_mode_if_started</a> ()</td></tr>
<tr class="memdesc:a75494b6dc9eb0d9fbbcd91cf0ab1d365"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a PSI batch was started, turn if off.  <a href="#a75494b6dc9eb0d9fbbcd91cf0ab1d365">More...</a><br /></td></tr>
<tr class="separator:a75494b6dc9eb0d9fbbcd91cf0ab1d365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae8f7f7b4f67773b73906143238dc9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ae8f7f7b4f67773b73906143238dc9f">handler</a> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr class="separator:a9ae8f7f7b4f67773b73906143238dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09926fc18e0dad27e77f0834ee4075cf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a09926fc18e0dad27e77f0834ee4075cf">~handler</a> (void)</td></tr>
<tr class="separator:a09926fc18e0dad27e77f0834ee4075cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab256be9b37a44ba83d26732e5197823a"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab256be9b37a44ba83d26732e5197823a">explain_extra</a> () const</td></tr>
<tr class="memdesc:ab256be9b37a44ba83d26732e5197823a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return extra handler specific text for EXPLAIN.  <a href="#ab256be9b37a44ba83d26732e5197823a">More...</a><br /></td></tr>
<tr class="separator:ab256be9b37a44ba83d26732e5197823a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc340039f5cf37a26e7c3b53685794"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a97fc340039f5cf37a26e7c3b53685794">clone</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *<a class="el" href="client__plugin_8cc.html#a7d0fe2f135db987da18cea87b4778737">mem_root</a>)</td></tr>
<tr class="separator:a97fc340039f5cf37a26e7c3b53685794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad6edb66592b200a7c7ac0f947dc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr class="memdesc:ab1ad6edb66592b200a7c7ac0f947dc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called after create to allow us to set up cached variables.  <a href="#ab1ad6edb66592b200a7c7ac0f947dc66">More...</a><br /></td></tr>
<tr class="separator:ab1ad6edb66592b200a7c7ac0f947dc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace90f37b16640dc3c5f313c415e5fee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ace90f37b16640dc3c5f313c415e5fee6">ha_set_record_buffer</a> (<a class="el" href="classRecord__buffer.html">Record_buffer</a> *<a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>)</td></tr>
<tr class="memdesc:ace90f37b16640dc3c5f313c415e5fee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a record buffer that the storage engine can use for multi-row reads.  <a href="#ace90f37b16640dc3c5f313c415e5fee6">More...</a><br /></td></tr>
<tr class="separator:ace90f37b16640dc3c5f313c415e5fee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6fecd2d8d525592027049e61db9471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRecord__buffer.html">Record_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2f6fecd2d8d525592027049e61db9471">ha_get_record_buffer</a> () const</td></tr>
<tr class="memdesc:a2f6fecd2d8d525592027049e61db9471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the record buffer that was set with ha_set_record_buffer().  <a href="#a2f6fecd2d8d525592027049e61db9471">More...</a><br /></td></tr>
<tr class="separator:a2f6fecd2d8d525592027049e61db9471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e9c0e51efed08a7ba13f4d1c30b1ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af3e9c0e51efed08a7ba13f4d1c30b1ee">ha_is_record_buffer_wanted</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *const max_rows) const</td></tr>
<tr class="memdesc:af3e9c0e51efed08a7ba13f4d1c30b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this handler want to get a Record_buffer for multi-row reads via the ha_set_record_buffer() function? And if so, what is the maximum number of records to allocate space for in the buffer?  <a href="#af3e9c0e51efed08a7ba13f4d1c30b1ee">More...</a><br /></td></tr>
<tr class="separator:af3e9c0e51efed08a7ba13f4d1c30b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a3a986805a5cf0312f3f1575d2343c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa4a3a986805a5cf0312f3f1575d2343c">ha_open</a> (<a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, int mode, int test_if_locked, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="separator:aa4a3a986805a5cf0312f3f1575d2343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28824cdff2c1812e282463c908e84c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr class="memdesc:ae28824cdff2c1812e282463c908e84c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler.  <a href="#ae28824cdff2c1812e282463c908e84c2">More...</a><br /></td></tr>
<tr class="separator:ae28824cdff2c1812e282463c908e84c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af23462b249041a0db03c1c7139d76b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="memdesc:a0af23462b249041a0db03c1c7139d76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize use of index.  <a href="#a0af23462b249041a0db03c1c7139d76b">More...</a><br /></td></tr>
<tr class="separator:a0af23462b249041a0db03c1c7139d76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bd01057c6cdd86d2ea2ee4ea65ca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr class="memdesc:afa6bd01057c6cdd86d2ea2ee4ea65ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">End use of index.  <a href="#afa6bd01057c6cdd86d2ea2ee4ea65ca3">More...</a><br /></td></tr>
<tr class="separator:afa6bd01057c6cdd86d2ea2ee4ea65ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c99736cb400350e007578889b8375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan)</td></tr>
<tr class="memdesc:afb5c99736cb400350e007578889b8375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize table for random read or scan.  <a href="#afb5c99736cb400350e007578889b8375">More...</a><br /></td></tr>
<tr class="separator:afb5c99736cb400350e007578889b8375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9bf34ac0a004d8c5c32267f20842f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr class="memdesc:ad4d9bf34ac0a004d8c5c32267f20842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End use of random access.  <a href="#ad4d9bf34ac0a004d8c5c32267f20842f">More...</a><br /></td></tr>
<tr class="separator:ad4d9bf34ac0a004d8c5c32267f20842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3743f3a48e7be751dbb2691be4c992a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:ad3743f3a48e7be751dbb2691be4c992a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row via random scan.  <a href="#ad3743f3a48e7be751dbb2691be4c992a">More...</a><br /></td></tr>
<tr class="separator:ad3743f3a48e7be751dbb2691be4c992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8615219b3e692e7d484d2ba6cfa86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)</td></tr>
<tr class="memdesc:abcd8615219b3e692e7d484d2ba6cfa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read row via random scan from position.  <a href="#abcd8615219b3e692e7d484d2ba6cfa86">More...</a><br /></td></tr>
<tr class="separator:abcd8615219b3e692e7d484d2ba6cfa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d9c9c011527b81287574294887bf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:a729d9c9c011527b81287574294887bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read [part of] row via [part of] index.  <a href="#a729d9c9c011527b81287574294887bf3">More...</a><br /></td></tr>
<tr class="separator:a729d9c9c011527b81287574294887bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9be09b8d0b1c03c96eb95f79dd7c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3fa9be09b8d0b1c03c96eb95f79dd7c9">ha_index_read_last_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)</td></tr>
<tr class="separator:a3fa9be09b8d0b1c03c96eb95f79dd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831321e8d33958db4fd4968de932acf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:ac831321e8d33958db4fd4968de932acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an index and read it.  <a href="#ac831321e8d33958db4fd4968de932acf">More...</a><br /></td></tr>
<tr class="separator:ac831321e8d33958db4fd4968de932acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99e96a8350ff577a94529be9387a30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a4c99e96a8350ff577a94529be9387a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next row via index.  <a href="#a4c99e96a8350ff577a94529be9387a30">More...</a><br /></td></tr>
<tr class="separator:a4c99e96a8350ff577a94529be9387a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb977dac0435158be227e45e04c8b798"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:abb977dac0435158be227e45e04c8b798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the previous row via index.  <a href="#abb977dac0435158be227e45e04c8b798">More...</a><br /></td></tr>
<tr class="separator:abb977dac0435158be227e45e04c8b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd574a3025588e9b0cd49e0d6908e3b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:abd574a3025588e9b0cd49e0d6908e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the first row via index.  <a href="#abd574a3025588e9b0cd49e0d6908e3b8">More...</a><br /></td></tr>
<tr class="separator:abd574a3025588e9b0cd49e0d6908e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7415f1744039a51ef15e923ef7da1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a2a7415f1744039a51ef15e923ef7da1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the last row via index.  <a href="#a2a7415f1744039a51ef15e923ef7da1b">More...</a><br /></td></tr>
<tr class="separator:a2a7415f1744039a51ef15e923ef7da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79360a45d50c6b558feb1c308c4157"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keylen)</td></tr>
<tr class="memdesc:a3f79360a45d50c6b558feb1c308c4157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next same row via index.  <a href="#a3f79360a45d50c6b558feb1c308c4157">More...</a><br /></td></tr>
<tr class="separator:a3f79360a45d50c6b558feb1c308c4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d38f167906d8aaa9e560c71e595a42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr class="memdesc:a53d38f167906d8aaa9e560c71e595a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check handler usage and reset state of file to after 'open'.  <a href="#a53d38f167906d8aaa9e560c71e595a42">More...</a><br /></td></tr>
<tr class="separator:a53d38f167906d8aaa9e560c71e595a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ef9b6ab27156116f91bf50b1ac19f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6e1ef9b6ab27156116f91bf50b1ac19f">ha_index_or_rnd_end</a> ()</td></tr>
<tr class="separator:a6e1ef9b6ab27156116f91bf50b1ac19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3015577f49008561db1d34ae750e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b3015577f49008561db1d34ae750e70">ha_table_flags</a> () const</td></tr>
<tr class="memdesc:a6b3015577f49008561db1d34ae750e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cached_table_flags is set at ha_open and ha_external_lock.  <a href="#a6b3015577f49008561db1d34ae750e70">More...</a><br /></td></tr>
<tr class="separator:a6b3015577f49008561db1d34ae750e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b5f8ae28bc5c374919396f8dcf08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (<a class="el" href="classTHD.html">THD</a> *thd, int lock_type)</td></tr>
<tr class="memdesc:a9a99b5f8ae28bc5c374919396f8dcf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions represent the public interface to <em>users</em> of the handler class, hence they are <em>not</em> virtual.  <a href="#a9a99b5f8ae28bc5c374919396f8dcf08">More...</a><br /></td></tr>
<tr class="separator:a9a99b5f8ae28bc5c374919396f8dcf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e651543ba0dbb2257a50dc1cdb5ea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad8e651543ba0dbb2257a50dc1cdb5ea9">ha_write_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:ad8e651543ba0dbb2257a50dc1cdb5ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bb19636dda0f1537fe780b6aca17a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f6bb19636dda0f1537fe780b6aca17a">ha_update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>)</td></tr>
<tr class="memdesc:a1f6bb19636dda0f1537fe780b6aca17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the current row.  <a href="#a1f6bb19636dda0f1537fe780b6aca17a">More...</a><br /></td></tr>
<tr class="separator:a1f6bb19636dda0f1537fe780b6aca17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e3b24f5bb5b2a8fa0c45732db8cdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f0e3b24f5bb5b2a8fa0c45732db8cdd">ha_delete_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:a3f0e3b24f5bb5b2a8fa0c45732db8cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbcbef5b9b8ed0f76d700a29091ad3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abfbcbef5b9b8ed0f76d700a29091ad3f">ha_release_auto_increment</a> ()</td></tr>
<tr class="separator:abfbcbef5b9b8ed0f76d700a29091ad3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a8030a4a3928d216599e1c03e9b28c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a79a8030a4a3928d216599e1c03e9b28c">ha_check_for_upgrade</a> (<a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a79a8030a4a3928d216599e1c03e9b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56545ec9967544c80d5612f8ac9b8e6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:a56545ec9967544c80d5612f8ac9b8e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">to be actually called to get 'check()' functionality  <a href="#a56545ec9967544c80d5612f8ac9b8e6e">More...</a><br /></td></tr>
<tr class="separator:a56545ec9967544c80d5612f8ac9b8e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d70543d9566894b5a81d25eca2e8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:ad28d70543d9566894b5a81d25eca2e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repair table: public interface.  <a href="#ad28d70543d9566894b5a81d25eca2e8e">More...</a><br /></td></tr>
<tr class="separator:ad28d70543d9566894b5a81d25eca2e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f09a15d46c019a621b0a65bb1ec89d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> rows)</td></tr>
<tr class="memdesc:a3f09a15d46c019a621b0a65bb1ec89d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start bulk insert.  <a href="#a3f09a15d46c019a621b0a65bb1ec89d3">More...</a><br /></td></tr>
<tr class="separator:a3f09a15d46c019a621b0a65bb1ec89d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3cbf4a769155c994ed39f76433106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr class="memdesc:a30f3cbf4a769155c994ed39f76433106"><td class="mdescLeft">&#160;</td><td class="mdescRight">End bulk insert.  <a href="#a30f3cbf4a769155c994ed39f76433106">More...</a><br /></td></tr>
<tr class="separator:a30f3cbf4a769155c994ed39f76433106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8ce82a564b0cbf6340dc9b74a9c23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *dup_key_found)</td></tr>
<tr class="memdesc:a49c8ce82a564b0cbf6340dc9b74a9c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk update row: public interface.  <a href="#a49c8ce82a564b0cbf6340dc9b74a9c23">More...</a><br /></td></tr>
<tr class="separator:a49c8ce82a564b0cbf6340dc9b74a9c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef228137a11565f7d52a60ad802004"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr class="memdesc:a1fef228137a11565f7d52a60ad802004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all rows: public interface.  <a href="#a1fef228137a11565f7d52a60ad802004">More...</a><br /></td></tr>
<tr class="separator:a1fef228137a11565f7d52a60ad802004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa3573d855956938bdc5171e7bada5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6faa3573d855956938bdc5171e7bada5">ha_truncate</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:a6faa3573d855956938bdc5171e7bada5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate table: public interface.  <a href="#a6faa3573d855956938bdc5171e7bada5">More...</a><br /></td></tr>
<tr class="separator:a6faa3573d855956938bdc5171e7bada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8a7650a41fd9a05a32521826ccd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:a980a8a7650a41fd9a05a32521826ccd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize table: public interface.  <a href="#a980a8a7650a41fd9a05a32521826ccd5">More...</a><br /></td></tr>
<tr class="separator:a980a8a7650a41fd9a05a32521826ccd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc9e4971b8e768c102398da0656a7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="memdesc:a66cc9e4971b8e768c102398da0656a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze table: public interface.  <a href="#a66cc9e4971b8e768c102398da0656a7f">More...</a><br /></td></tr>
<tr class="separator:a66cc9e4971b8e768c102398da0656a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d5287bdf480f8cd20f758bb2d9bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a169d5287bdf480f8cd20f758bb2d9bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and repair table: public interface.  <a href="#a169d5287bdf480f8cd20f758bb2d9bd1">More...</a><br /></td></tr>
<tr class="separator:a169d5287bdf480f8cd20f758bb2d9bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb079b3dc59160ba828ef89b4463921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode)</td></tr>
<tr class="memdesc:aeeb079b3dc59160ba828ef89b4463921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable indexes: public interface.  <a href="#aeeb079b3dc59160ba828ef89b4463921">More...</a><br /></td></tr>
<tr class="separator:aeeb079b3dc59160ba828ef89b4463921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9c53758728e07eb37cbb65ea3ab50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode)</td></tr>
<tr class="memdesc:a36e9c53758728e07eb37cbb65ea3ab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable indexes: public interface.  <a href="#a36e9c53758728e07eb37cbb65ea3ab50">More...</a><br /></td></tr>
<tr class="separator:a36e9c53758728e07eb37cbb65ea3ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d065a0acbb43dda3bec8d2d17c64362"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4d065a0acbb43dda3bec8d2d17c64362">ha_discard_or_import_tablespace</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> discard, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:a4d065a0acbb43dda3bec8d2d17c64362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard or import tablespace: public interface.  <a href="#a4d065a0acbb43dda3bec8d2d17c64362">More...</a><br /></td></tr>
<tr class="separator:a4d065a0acbb43dda3bec8d2d17c64362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fdba3807d26163cf0bcebcf9fb2664"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af6fdba3807d26163cf0bcebcf9fb2664">ha_rename_table</a> (const char *from, const char *to, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *from_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *to_table_def)</td></tr>
<tr class="memdesc:af6fdba3807d26163cf0bcebcf9fb2664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename table: public interface.  <a href="#af6fdba3807d26163cf0bcebcf9fb2664">More...</a><br /></td></tr>
<tr class="separator:af6fdba3807d26163cf0bcebcf9fb2664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf699c767f76315ce2500f18cb20eb71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaf699c767f76315ce2500f18cb20eb71">ha_delete_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:aaf699c767f76315ce2500f18cb20eb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete table: public interface.  <a href="#aaf699c767f76315ce2500f18cb20eb71">More...</a><br /></td></tr>
<tr class="separator:aaf699c767f76315ce2500f18cb20eb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37ec84386f5d6cc86448781666cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="memdesc:a6bcc37ec84386f5d6cc86448781666cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop table in the engine: public interface.  <a href="#a6bcc37ec84386f5d6cc86448781666cb">More...</a><br /></td></tr>
<tr class="separator:a6bcc37ec84386f5d6cc86448781666cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdeebefcfc1390a0e89ac7ef04586a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3cdeebefcfc1390a0e89ac7ef04586a1">ha_create</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *<a class="el" href="classhandler.html#a3de6f276d98eba4327f1a9a860d65f3c">info</a>, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:a3cdeebefcfc1390a0e89ac7ef04586a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table in the engine: public interface.  <a href="#a3cdeebefcfc1390a0e89ac7ef04586a1">More...</a><br /></td></tr>
<tr class="separator:a3cdeebefcfc1390a0e89ac7ef04586a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac530d2a77ce857389f6d32dcfeb10002"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac530d2a77ce857389f6d32dcfeb10002">ha_load_table</a> (const <a class="el" href="structTABLE.html">TABLE</a> &amp;<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>)</td></tr>
<tr class="memdesc:ac530d2a77ce857389f6d32dcfeb10002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a table into its defined secondary storage engine: public interface.  <a href="#ac530d2a77ce857389f6d32dcfeb10002">More...</a><br /></td></tr>
<tr class="separator:ac530d2a77ce857389f6d32dcfeb10002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2066c996d7f772dc0483494de4e3bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb2066c996d7f772dc0483494de4e3bd">ha_unload_table</a> (const char *db_name, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> error_if_not_loaded)</td></tr>
<tr class="memdesc:afb2066c996d7f772dc0483494de4e3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads a table from its defined secondary storage engine: public interface.  <a href="#afb2066c996d7f772dc0483494de4e3bd">More...</a><br /></td></tr>
<tr class="separator:afb2066c996d7f772dc0483494de4e3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826010c8deb55ee4435b1b3fc18fe7a0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a826010c8deb55ee4435b1b3fc18fe7a0">parallel_scan_init</a> (void *&amp;scan_ctx, size_t *num_threads, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_reserved_threads)</td></tr>
<tr class="memdesc:a826010c8deb55ee4435b1b3fc18fe7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a parallel scan.  <a href="#a826010c8deb55ee4435b1b3fc18fe7a0">More...</a><br /></td></tr>
<tr class="separator:a826010c8deb55ee4435b1b3fc18fe7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd6632fba224ccdaf229a9886cbe0b4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aebd6632fba224ccdaf229a9886cbe0b4">parallel_scan</a> (void *scan_ctx, void **thread_ctxs, <a class="el" href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">Load_init_cbk</a> init_fn, <a class="el" href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">Load_cbk</a> load_fn, <a class="el" href="classhandler.html#a24e65d325f0e08107186740bcb248756">Load_end_cbk</a> end_fn)</td></tr>
<tr class="memdesc:aebd6632fba224ccdaf229a9886cbe0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the parallel read of data.  <a href="#aebd6632fba224ccdaf229a9886cbe0b4">More...</a><br /></td></tr>
<tr class="separator:aebd6632fba224ccdaf229a9886cbe0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680f73512eef288b1ddca958933c2016"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a680f73512eef288b1ddca958933c2016">parallel_scan_end</a> (void *scan_ctx)</td></tr>
<tr class="memdesc:a680f73512eef288b1ddca958933c2016"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of the parallel scan.  <a href="#a680f73512eef288b1ddca958933c2016">More...</a><br /></td></tr>
<tr class="separator:a680f73512eef288b1ddca958933c2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e49e88aeec6d85f9f7b94f6ed2ee487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7e49e88aeec6d85f9f7b94f6ed2ee487">ha_get_se_private_data</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">reset</a>)</td></tr>
<tr class="memdesc:a7e49e88aeec6d85f9f7b94f6ed2ee487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a dd::Table object representing a core DD table having hardcoded data to be filled in by the DDSE.  <a href="#a7e49e88aeec6d85f9f7b94f6ed2ee487">More...</a><br /></td></tr>
<tr class="separator:a7e49e88aeec6d85f9f7b94f6ed2ee487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c090210fefb7e95d885688f5717028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4c090210fefb7e95d885688f5717028">adjust_next_insert_id_after_explicit_value</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> nr)</td></tr>
<tr class="separator:ad4c090210fefb7e95d885688f5717028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d2f9da11425e388640206b4d22241"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8a7d2f9da11425e388640206b4d22241">update_auto_increment</a> ()</td></tr>
<tr class="separator:a8a7d2f9da11425e388640206b4d22241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4f1390385a4dc0bfd2981fee23e6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">print_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>, <a class="el" href="my__inttypes_8h.html#a0db1f888c3bc329e7b0b340dbd41eb2b">myf</a> errflag)</td></tr>
<tr class="memdesc:afda4f1390385a4dc0bfd2981fee23e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error that we got from handler function.  <a href="#afda4f1390385a4dc0bfd2981fee23e6c">More...</a><br /></td></tr>
<tr class="separator:afda4f1390385a4dc0bfd2981fee23e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8ffd064ce683481494c7503ef820c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">get_error_message</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>, <a class="el" href="classString.html">String</a> *buf)</td></tr>
<tr class="memdesc:afce8ffd064ce683481494c7503ef820c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an error message specific to this handler.  <a href="#afce8ffd064ce683481494c7503ef820c">More...</a><br /></td></tr>
<tr class="separator:afce8ffd064ce683481494c7503ef820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eede0999f8273864faa40c5e181793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="separator:ad5eede0999f8273864faa40c5e181793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018ba4b85de71ff265bdb1157bf95894"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a018ba4b85de71ff265bdb1157bf95894">get_foreign_dup_key</a> (char *child_table_name, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> child_table_name_len, char *child_key_name, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> child_key_name_len)</td></tr>
<tr class="memdesc:a018ba4b85de71ff265bdb1157bf95894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY.  <a href="#a018ba4b85de71ff265bdb1157bf95894">More...</a><br /></td></tr>
<tr class="separator:a018ba4b85de71ff265bdb1157bf95894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b117a976fc9423d2337da59f35d128c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2b117a976fc9423d2337da59f35d128c">change_table_ptr</a> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="memdesc:a2b117a976fc9423d2337da59f35d128c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the internal TABLE_SHARE pointer.  <a href="#a2b117a976fc9423d2337da59f35d128c">More...</a><br /></td></tr>
<tr class="separator:a2b117a976fc9423d2337da59f35d128c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e5d856e729be3f3ebee87e6857c45d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac0e5d856e729be3f3ebee87e6857c45d">get_table_share</a> () const</td></tr>
<tr class="separator:ac0e5d856e729be3f3ebee87e6857c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f8e5188e2bd9636a564bbc0c3fef86"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a65f8e5188e2bd9636a564bbc0c3fef86">scan_time</a> ()</td></tr>
<tr class="separator:a65f8e5188e2bd9636a564bbc0c3fef86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061b519fb16fbff126b0e21530973c2e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">read_time</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ranges, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> rows)</td></tr>
<tr class="memdesc:a061b519fb16fbff126b0e21530973c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost of reading a set of ranges from the table using an index to access it.  <a href="#a061b519fb16fbff126b0e21530973c2e">More...</a><br /></td></tr>
<tr class="separator:a061b519fb16fbff126b0e21530973c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ac6b2908a899c0ce230818bb7a993"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keynr, double <a class="el" href="classhandler.html#a9d2371385a8f73f1258965f5f7cfdf93">records</a>)</td></tr>
<tr class="memdesc:a4a2ac6b2908a899c0ce230818bb7a993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate cost of 'index only' scan for given index and number of records.  <a href="#a4a2ac6b2908a899c0ce230818bb7a993">More...</a><br /></td></tr>
<tr class="separator:a4a2ac6b2908a899c0ce230818bb7a993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9380355a7eea5386ef061f36479258"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e9380355a7eea5386ef061f36479258">table_scan_cost</a> ()</td></tr>
<tr class="memdesc:a5e9380355a7eea5386ef061f36479258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate for doing a complete table scan.  <a href="#a5e9380355a7eea5386ef061f36479258">More...</a><br /></td></tr>
<tr class="separator:a5e9380355a7eea5386ef061f36479258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5575d58c0acbb1924f7f3d3eb756612a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5575d58c0acbb1924f7f3d3eb756612a">index_scan_cost</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, double ranges, double rows)</td></tr>
<tr class="memdesc:a5575d58c0acbb1924f7f3d3eb756612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate for reading a number of ranges from an index.  <a href="#a5575d58c0acbb1924f7f3d3eb756612a">More...</a><br /></td></tr>
<tr class="separator:a5575d58c0acbb1924f7f3d3eb756612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d85fe55a71cc09c642592e771b662"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a196d85fe55a71cc09c642592e771b662">read_cost</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, double ranges, double rows)</td></tr>
<tr class="memdesc:a196d85fe55a71cc09c642592e771b662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate for reading a set of ranges from the table using an index to access it.  <a href="#a196d85fe55a71cc09c642592e771b662">More...</a><br /></td></tr>
<tr class="separator:a196d85fe55a71cc09c642592e771b662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f7fbe39f6ff0e9da2ac6c3d6c629e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__inttypes_8h.html#a9c0acdcb1b083d30069a62cee1ece644">longlong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a475f7fbe39f6ff0e9da2ac6c3d6c629e">get_memory_buffer_size</a> () const</td></tr>
<tr class="memdesc:a475f7fbe39f6ff0e9da2ac6c3d6c629e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimate on the amount of memory the storage engine will use for caching data in memory.  <a href="#a475f7fbe39f6ff0e9da2ac6c3d6c629e">More...</a><br /></td></tr>
<tr class="separator:a475f7fbe39f6ff0e9da2ac6c3d6c629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171927b3afde9e800755b834bd8d31bd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a171927b3afde9e800755b834bd8d31bd">table_in_memory_estimate</a> () const</td></tr>
<tr class="memdesc:a171927b3afde9e800755b834bd8d31bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimate of how much of the table that is currently stored in main memory.  <a href="#a171927b3afde9e800755b834bd8d31bd">More...</a><br /></td></tr>
<tr class="separator:a171927b3afde9e800755b834bd8d31bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375fdfc86f021f336777324dd5a98a02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a375fdfc86f021f336777324dd5a98a02">index_in_memory_estimate</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno) const</td></tr>
<tr class="memdesc:a375fdfc86f021f336777324dd5a98a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimate of how much of the index that is currently stored in main memory.  <a href="#a375fdfc86f021f336777324dd5a98a02">More...</a><br /></td></tr>
<tr class="separator:a375fdfc86f021f336777324dd5a98a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0014e351a991fe9c77b4657e4f75dbab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0014e351a991fe9c77b4657e4f75dbab">ha_sample_init</a> (void *&amp;scan_ctx, double sampling_percentage, int sampling_seed, <a class="el" href="sql_2handler_8h.html#ae954cfd46ba0b8300368dccf2bebc842">enum_sampling_method</a> sampling_method)</td></tr>
<tr class="memdesc:a0014e351a991fe9c77b4657e4f75dbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sampling.  <a href="#a0014e351a991fe9c77b4657e4f75dbab">More...</a><br /></td></tr>
<tr class="separator:a0014e351a991fe9c77b4657e4f75dbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a7ed7143700cada199b11f231876c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a72a7ed7143700cada199b11f231876c3">ha_sample_next</a> (void *scan_ctx, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a72a7ed7143700cada199b11f231876c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next record for sampling.  <a href="#a72a7ed7143700cada199b11f231876c3">More...</a><br /></td></tr>
<tr class="separator:a72a7ed7143700cada199b11f231876c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3147b1facb5846b2ecdf2a0d77775d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e3147b1facb5846b2ecdf2a0d77775d">ha_sample_end</a> (void *scan_ctx)</td></tr>
<tr class="memdesc:a3e3147b1facb5846b2ecdf2a0d77775d"><td class="mdescLeft">&#160;</td><td class="mdescRight">End sampling.  <a href="#a3e3147b1facb5846b2ecdf2a0d77775d">More...</a><br /></td></tr>
<tr class="separator:a3e3147b1facb5846b2ecdf2a0d77775d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee356d2340552eb121d423fc01597f8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">multi_range_read_info_const</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *bufsz, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="memdesc:a5ee356d2340552eb121d423fc01597f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cost and other information about MRR scan over a known list of ranges.  <a href="#a5ee356d2340552eb121d423fc01597f8">More...</a><br /></td></tr>
<tr class="separator:a5ee356d2340552eb121d423fc01597f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5add40a6cd7088ffef25a3816294b624"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">multi_range_read_info</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test2_8cc.html#a417cc326920c9222b40e57c326ae83c9">keys</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *bufsz, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="memdesc:a5add40a6cd7088ffef25a3816294b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cost and other information about MRR scan over some sequence of ranges.  <a href="#a5add40a6cd7088ffef25a3816294b624">More...</a><br /></td></tr>
<tr class="separator:a5add40a6cd7088ffef25a3816294b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e8899f4bae262b6b91c7284f1d946e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init</a> (<a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode, <a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a33e8899f4bae262b6b91c7284f1d946e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the MRR scan.  <a href="#a33e8899f4bae262b6b91c7284f1d946e">More...</a><br /></td></tr>
<tr class="separator:a33e8899f4bae262b6b91c7284f1d946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7462a72e9f19ae676d9eb6735a8204"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2e7462a72e9f19ae676d9eb6735a8204">ha_multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="separator:a2e7462a72e9f19ae676d9eb6735a8204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57496d1b472f836f21ef273b661949ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a57496d1b472f836f21ef273b661949ee">ha_read_range_first</a> (const <a class="el" href="structkey__range.html">key_range</a> *start_key, const <a class="el" href="structkey__range.html">key_range</a> *end_key, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classhandler.html#a272c3d9b40a9e7c5de20ed390d23a636">eq_range</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="separator:a57496d1b472f836f21ef273b661949ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c81a68cc8e83e75f5b87a8fb1922271"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3c81a68cc8e83e75f5b87a8fb1922271">ha_read_range_next</a> ()</td></tr>
<tr class="separator:a3c81a68cc8e83e75f5b87a8fb1922271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d4ecfa5cfe85d8179aa52488016d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae73d4ecfa5cfe85d8179aa52488016d0">has_transactions</a> ()</td></tr>
<tr class="separator:ae73d4ecfa5cfe85d8179aa52488016d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd434bc44b88f4e47f44f02c877c91"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a27fd434bc44b88f4e47f44f02c877c91">extra_rec_buf_length</a> () const</td></tr>
<tr class="separator:a27fd434bc44b88f4e47f44f02c877c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5919d6a3f3098353f4517e2c81037"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a39c5919d6a3f3098353f4517e2c81037">is_ignorable_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="memdesc:a39c5919d6a3f3098353f4517e2c81037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error can be ignored or not.  <a href="#a39c5919d6a3f3098353f4517e2c81037">More...</a><br /></td></tr>
<tr class="separator:a39c5919d6a3f3098353f4517e2c81037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37413b5d60b340ffe26a6713b65bab75"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37413b5d60b340ffe26a6713b65bab75">is_fatal_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="memdesc:a37413b5d60b340ffe26a6713b65bab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error is fatal or not.  <a href="#a37413b5d60b340ffe26a6713b65bab75">More...</a><br /></td></tr>
<tr class="separator:a37413b5d60b340ffe26a6713b65bab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe4a9e78c818aa2823c302f0fe65522"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9fe4a9e78c818aa2823c302f0fe65522">ha_records</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows)</td></tr>
<tr class="memdesc:a9fe4a9e78c818aa2823c302f0fe65522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to call records() in storage engine.  <a href="#a9fe4a9e78c818aa2823c302f0fe65522">More...</a><br /></td></tr>
<tr class="separator:a9fe4a9e78c818aa2823c302f0fe65522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545cfccfcb87c61521d140c55c328c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5545cfccfcb87c61521d140c55c328c9">ha_records</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a5545cfccfcb87c61521d140c55c328c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to call records_from_index() in storage engine.  <a href="#a5545cfccfcb87c61521d140c55c328c9">More...</a><br /></td></tr>
<tr class="separator:a5545cfccfcb87c61521d140c55c328c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59e9a1d36d852f4dd5dd00bff5f1ae4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">estimate_rows_upper_bound</a> ()</td></tr>
<tr class="memdesc:ae59e9a1d36d852f4dd5dd00bff5f1ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return upper bound of current number of records in the table (max.  <a href="#ae59e9a1d36d852f4dd5dd00bff5f1ae4">More...</a><br /></td></tr>
<tr class="separator:ae59e9a1d36d852f4dd5dd00bff5f1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8877c5cafa237927cc9917e3a422a2d"><td class="memItemLeft" align="right" valign="top">virtual enum <a class="el" href="sql_2handler_8h.html#aae164ec549f5dd7e890b40de79fd76c8">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8877c5cafa237927cc9917e3a422a2d">get_real_row_type</a> (const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info) const</td></tr>
<tr class="memdesc:af8877c5cafa237927cc9917e3a422a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get real row type for the table created based on one specified by user, CREATE TABLE options and SE capabilities.  <a href="#af8877c5cafa237927cc9917e3a422a2d">More...</a><br /></td></tr>
<tr class="separator:af8877c5cafa237927cc9917e3a422a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170e714527e670014e9fb4395f0b187f"><td class="memItemLeft" align="right" valign="top">virtual enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a170e714527e670014e9fb4395f0b187f">get_default_index_algorithm</a> () const</td></tr>
<tr class="memdesc:a170e714527e670014e9fb4395f0b187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default key algorithm for SE.  <a href="#a170e714527e670014e9fb4395f0b187f">More...</a><br /></td></tr>
<tr class="separator:a170e714527e670014e9fb4395f0b187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f77c614e5852c3058d6b7a1f5d701b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05f77c614e5852c3058d6b7a1f5d701b">is_index_algorithm_supported</a> (enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a> key_alg) const</td></tr>
<tr class="memdesc:a05f77c614e5852c3058d6b7a1f5d701b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if SE supports specific key algorithm.  <a href="#a05f77c614e5852c3058d6b7a1f5d701b">More...</a><br /></td></tr>
<tr class="separator:a05f77c614e5852c3058d6b7a1f5d701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de97045e5381007565fd2b0da235c07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr class="memdesc:a4de97045e5381007565fd2b0da235c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that the table-&gt;read_set and table-&gt;write_set table maps changed The handler is allowed to set additional bits in the above map in this call.  <a href="#a4de97045e5381007565fd2b0da235c07">More...</a><br /></td></tr>
<tr class="separator:a4de97045e5381007565fd2b0da235c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf0aed6539181d465676ebc661f2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aacdf0aed6539181d465676ebc661f2b5">get_index</a> (void) const</td></tr>
<tr class="separator:aacdf0aed6539181d465676ebc661f2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488245f51aa4676c872bb0564dbe71f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a> ()</td></tr>
<tr class="separator:a7488245f51aa4676c872bb0564dbe71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf7319a6498f655f8f07b1b34b12fc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a> ()</td></tr>
<tr class="separator:acdaf7319a6498f655f8f07b1b34b12fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf2fbf16de7e200e3ebc0765fb6e4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *dup_key_found)</td></tr>
<tr class="memdesc:a886bf2fbf16de7e200e3ebc0765fb6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">After this call all outstanding updates must be performed.  <a href="#a886bf2fbf16de7e200e3ebc0765fb6e4">More...</a><br /></td></tr>
<tr class="separator:a886bf2fbf16de7e200e3ebc0765fb6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6c46d66ca282a4cbd6118e4c99e03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a> ()</td></tr>
<tr class="memdesc:a2bf6c46d66ca282a4cbd6118e4c99e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any needed clean-up, no outstanding updates are there at the moment.  <a href="#a2bf6c46d66ca282a4cbd6118e4c99e03">More...</a><br /></td></tr>
<tr class="separator:a2bf6c46d66ca282a4cbd6118e4c99e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9f1ca2b5efc0b41e96c6b793d9bb1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a> ()</td></tr>
<tr class="memdesc:af5f9f1ca2b5efc0b41e96c6b793d9bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute all outstanding deletes and close down the bulk delete.  <a href="#af5f9f1ca2b5efc0b41e96c6b793d9bb1">More...</a><br /></td></tr>
<tr class="separator:af5f9f1ca2b5efc0b41e96c6b793d9bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dfb95a0da2e828ac018aa2b4abe3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const <a class="el" href="structkey__range.html">key_range</a> *<a class="el" href="structrange.html">range</a>, <a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">enum_range_scan_direction</a> direction)</td></tr>
<tr class="memdesc:a4b7dfb95a0da2e828ac018aa2b4abe3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the end position for a range scan.  <a href="#a4b7dfb95a0da2e828ac018aa2b4abe3a">More...</a><br /></td></tr>
<tr class="separator:a4b7dfb95a0da2e828ac018aa2b4abe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef38e7407e87ba5d1ccde59c3e94bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (<a class="el" href="structkey__range.html">key_range</a> *<a class="el" href="structrange.html">range</a>)</td></tr>
<tr class="memdesc:af0ef38e7407e87ba5d1ccde59c3e94bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if found key (in row) is over max-value.  <a href="#af0ef38e7407e87ba5d1ccde59c3e94bb">More...</a><br /></td></tr>
<tr class="separator:af0ef38e7407e87ba5d1ccde59c3e94bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767345668267e3c8881fab6e351e6c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab767345668267e3c8881fab6e351e6c8">compare_key_icp</a> (const <a class="el" href="structkey__range.html">key_range</a> *<a class="el" href="structrange.html">range</a>) const</td></tr>
<tr class="separator:ab767345668267e3c8881fab6e351e6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac3d9b9796d3bfb18b96a1989d6f516"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeac3d9b9796d3bfb18b96a1989d6f516">compare_key_in_buffer</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf) const</td></tr>
<tr class="memdesc:aeac3d9b9796d3bfb18b96a1989d6f516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the key in the given buffer (which is not necessarily TABLE::record[0]) is within range.  <a href="#aeac3d9b9796d3bfb18b96a1989d6f516">More...</a><br /></td></tr>
<tr class="separator:aeac3d9b9796d3bfb18b96a1989d6f516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab734678f90b9e7cc6b000047f7c89bb1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab734678f90b9e7cc6b000047f7c89bb1">ft_init</a> ()</td></tr>
<tr class="separator:ab734678f90b9e7cc6b000047f7c89bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693b6e25765a4290f531f578bcf2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a72693b6e25765a4290f531f578bcf2eb">ft_end</a> ()</td></tr>
<tr class="separator:a72693b6e25765a4290f531f578bcf2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109448e09ee2c456b1471b74bb9eb8e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structFT__INFO.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a109448e09ee2c456b1471b74bb9eb8e6">ft_init_ext</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> inx, <a class="el" href="classString.html">String</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="separator:a109448e09ee2c456b1471b74bb9eb8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceb6075e1b3ad667596b30eea85feb6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structFT__INFO.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ceb6075e1b3ad667596b30eea85feb6">ft_init_ext_with_hints</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> inx, <a class="el" href="classString.html">String</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="classFt__hints.html">Ft_hints</a> *hints)</td></tr>
<tr class="separator:a9ceb6075e1b3ad667596b30eea85feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ed6e67d0d9891569f90f4122d3855"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adb6ed6e67d0d9891569f90f4122d3855">ha_ft_read</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:adb6ed6e67d0d9891569f90f4122d3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bc3e86490651704ce5b928169dd725"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4bc3e86490651704ce5b928169dd725">ha_read_first_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> primary_key)</td></tr>
<tr class="memdesc:ae4bc3e86490651704ce5b928169dd725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row (only) from a table.  <a href="#ae4bc3e86490651704ce5b928169dd725">More...</a><br /></td></tr>
<tr class="separator:ae4bc3e86490651704ce5b928169dd725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be2fa5d347252f8a28dce931654b76"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="memdesc:ac2be2fa5d347252f8a28dce931654b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set.  <a href="#ac2be2fa5d347252f8a28dce931654b76">More...</a><br /></td></tr>
<tr class="separator:ac2be2fa5d347252f8a28dce931654b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac874ad6fd5a2e6b97376befacb165"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a33ac874ad6fd5a2e6b97376befacb165">records_in_range</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> inx, <a class="el" href="structkey__range.html">key_range</a> *min_key, <a class="el" href="structkey__range.html">key_range</a> *max_key)</td></tr>
<tr class="memdesc:a33ac874ad6fd5a2e6b97376befacb165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find number of records in a range.  <a href="#a33ac874ad6fd5a2e6b97376befacb165">More...</a><br /></td></tr>
<tr class="separator:a33ac874ad6fd5a2e6b97376befacb165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c1515e7a936fa9cbc19f93d43495b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3c1515e7a936fa9cbc19f93d43495b6">position</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)=0</td></tr>
<tr class="separator:ad3c1515e7a936fa9cbc19f93d43495b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de6f276d98eba4327f1a9a860d65f3c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3de6f276d98eba4327f1a9a860d65f3c">info</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>)=0</td></tr>
<tr class="memdesc:a3de6f276d98eba4327f1a9a860d65f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">General method to gather info from handler.  <a href="#a3de6f276d98eba4327f1a9a860d65f3c">More...</a><br /></td></tr>
<tr class="separator:a3de6f276d98eba4327f1a9a860d65f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e746c224b70d3b03b2886ecf4563394"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7e746c224b70d3b03b2886ecf4563394">calculate_key_hash_value</a> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr class="separator:a7e746c224b70d3b03b2886ecf4563394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a7e1c60d82baca1890cf9805d1694b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62a7e1c60d82baca1890cf9805d1694b">ha_extra</a> (enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a> operation)</td></tr>
<tr class="memdesc:a62a7e1c60d82baca1890cf9805d1694b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request storage engine to do an extra operation: enable,disable or run some functionality.  <a href="#a62a7e1c60d82baca1890cf9805d1694b">More...</a><br /></td></tr>
<tr class="separator:a62a7e1c60d82baca1890cf9805d1694b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e72da94a7f5577f00ab5c89204ec1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b7e72da94a7f5577f00ab5c89204ec1">extra_opt</a> (enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a> operation, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> <a class="el" href="xcom__cache_8cc.html#a27d1b984097f6bd1dcfa1b428c6a8549">cache_size</a>)</td></tr>
<tr class="separator:a6b7e72da94a7f5577f00ab5c89204ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb375aeab783a6c520296c7621fb559"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#accb375aeab783a6c520296c7621fb559">engine_push</a> (<a class="el" href="classAQP_1_1Table__access.html">AQP::Table_access</a> *<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>)</td></tr>
<tr class="memdesc:accb375aeab783a6c520296c7621fb559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let storage engine inspect the optimized 'plan' and pick whatever it like for being pushed down to the engine.  <a href="#accb375aeab783a6c520296c7621fb559">More...</a><br /></td></tr>
<tr class="separator:accb375aeab783a6c520296c7621fb559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2428788c2437e4e33c4b390cc697f7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a> (void)</td></tr>
<tr class="memdesc:a3e2428788c2437e4e33c4b390cc697f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start read (before write) removal on the current table.  <a href="#a3e2428788c2437e4e33c4b390cc697f7">More...</a><br /></td></tr>
<tr class="separator:a3e2428788c2437e4e33c4b390cc697f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d99c283e85e8d97460f07a781dabf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a> (void)</td></tr>
<tr class="memdesc:a517d99c283e85e8d97460f07a781dabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">End read (before write) removal and return the number of rows really written.  <a href="#a517d99c283e85e8d97460f07a781dabf">More...</a><br /></td></tr>
<tr class="separator:a517d99c283e85e8d97460f07a781dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d92f647a4ca5a3b7867fa5538242a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">was_semi_consistent_read</a> ()</td></tr>
<tr class="memdesc:a54d92f647a4ca5a3b7867fa5538242a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally, when running UPDATE or DELETE queries, we need to wait for other transactions to release their locks on a given row before we can read it and potentially update it.  <a href="#a54d92f647a4ca5a3b7867fa5538242a6">More...</a><br /></td></tr>
<tr class="separator:a54d92f647a4ca5a3b7867fa5538242a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e767094bff139a26743e9314df8476"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">try_semi_consistent_read</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>)</td></tr>
<tr class="memdesc:ab3e767094bff139a26743e9314df8476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the engine whether it should avoid unnecessary lock waits.  <a href="#ab3e767094bff139a26743e9314df8476">More...</a><br /></td></tr>
<tr class="separator:ab3e767094bff139a26743e9314df8476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e6fd090f73a8e7e5e94769c9a10733"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a48e6fd090f73a8e7e5e94769c9a10733">unlock_row</a> ()</td></tr>
<tr class="memdesc:a48e6fd090f73a8e7e5e94769c9a10733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock last accessed row.  <a href="#a48e6fd090f73a8e7e5e94769c9a10733">More...</a><br /></td></tr>
<tr class="separator:a48e6fd090f73a8e7e5e94769c9a10733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c625117fcff640b7af11e7018519cd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a90c625117fcff640b7af11e7018519cd">start_stmt</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a> lock_type)</td></tr>
<tr class="memdesc:a90c625117fcff640b7af11e7018519cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a statement when table is locked.  <a href="#a90c625117fcff640b7af11e7018519cd">More...</a><br /></td></tr>
<tr class="separator:a90c625117fcff640b7af11e7018519cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6af760a4ef09984a5cc1dc58db9a40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> offset, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> increment, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> nb_desired_values, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *first_value, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *nb_reserved_values)</td></tr>
<tr class="memdesc:aaf6af760a4ef09984a5cc1dc58db9a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves an interval of auto_increment values from the handler.  <a href="#aaf6af760a4ef09984a5cc1dc58db9a40">More...</a><br /></td></tr>
<tr class="separator:aaf6af760a4ef09984a5cc1dc58db9a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9bf8ee63f3b8312fdc31be3819ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab6f9bf8ee63f3b8312fdc31be3819ede">set_next_insert_id</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>)</td></tr>
<tr class="separator:ab6f9bf8ee63f3b8312fdc31be3819ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b51670b2497f01f19f587a4a969386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a15b51670b2497f01f19f587a4a969386">restore_auto_increment</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> <a class="el" href="sql_2handler_8cc.html#a6c4bbd335242a13cd781210b929c6d4b">prev_insert_id</a>)</td></tr>
<tr class="separator:a15b51670b2497f01f19f587a4a969386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58141e7b51aaf97bdf63ea68c411f401"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a58141e7b51aaf97bdf63ea68c411f401">update_create_info</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="memdesc:a58141e7b51aaf97bdf63ea68c411f401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update create info as part of ALTER TABLE.  <a href="#a58141e7b51aaf97bdf63ea68c411f401">More...</a><br /></td></tr>
<tr class="separator:a58141e7b51aaf97bdf63ea68c411f401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f356517f0bbed3e92061117e003f20"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a73f356517f0bbed3e92061117e003f20">assign_to_keycache</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="separator:a73f356517f0bbed3e92061117e003f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49396e778b671ffd7eade208e0e32054"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49396e778b671ffd7eade208e0e32054">preload_keys</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="separator:a49396e778b671ffd7eade208e0e32054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc45e93a1b669fa750f73a617c46bac"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8bc45e93a1b669fa750f73a617c46bac">indexes_are_disabled</a> (void)</td></tr>
<tr class="memdesc:a8bc45e93a1b669fa750f73a617c46bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if indexes are disabled.  <a href="#a8bc45e93a1b669fa750f73a617c46bac">More...</a><br /></td></tr>
<tr class="separator:a8bc45e93a1b669fa750f73a617c46bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441afeebcb5b56e598fb7f860c9247d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a441afeebcb5b56e598fb7f860c9247d1">append_create_info</a> (<a class="el" href="classString.html">String</a> *packet)</td></tr>
<tr class="separator:a441afeebcb5b56e598fb7f860c9247d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dfb73f9401996a25b9cf925db74149"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28dfb73f9401996a25b9cf925db74149">init_table_handle_for_HANDLER</a> ()</td></tr>
<tr class="separator:a28dfb73f9401996a25b9cf925db74149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38f5d3f1e026a0af32b5542aa5ac2f9"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">table_type</a> () const =0</td></tr>
<tr class="memdesc:ad38f5d3f1e026a0af32b5542aa5ac2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following can be called without an open handler.  <a href="#ad38f5d3f1e026a0af32b5542aa5ac2f9">More...</a><br /></td></tr>
<tr class="separator:ad38f5d3f1e026a0af32b5542aa5ac2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612375d87a4cbb6e7c190ea7d05cf945"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a612375d87a4cbb6e7c190ea7d05cf945">index_flags</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> all_parts) const =0</td></tr>
<tr class="separator:a612375d87a4cbb6e7c190ea7d05cf945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c5a03956913d75de1fca3af7833a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7ee9c5a03956913d75de1fca3af7833a">max_record_length</a> () const</td></tr>
<tr class="separator:a7ee9c5a03956913d75de1fca3af7833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c1ac62569e6cc89cbfde66fea47f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a493c1ac62569e6cc89cbfde66fea47f3">max_keys</a> () const</td></tr>
<tr class="separator:a493c1ac62569e6cc89cbfde66fea47f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adabba96b635533f31d5e38e6d2a74c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1adabba96b635533f31d5e38e6d2a74c">max_key_parts</a> () const</td></tr>
<tr class="separator:a1adabba96b635533f31d5e38e6d2a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b1d6fe7e717fe234c18915cb26e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9e1b1d6fe7e717fe234c18915cb26e87">max_key_length</a> () const</td></tr>
<tr class="separator:a9e1b1d6fe7e717fe234c18915cb26e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3699689407f76a90ea62a3f5f593e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae3699689407f76a90ea62a3f5f593e15">max_key_part_length</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info) const</td></tr>
<tr class="separator:ae3699689407f76a90ea62a3f5f593e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a498859c2d47448100e5e703622bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a672a498859c2d47448100e5e703622bb">max_supported_record_length</a> () const</td></tr>
<tr class="separator:a672a498859c2d47448100e5e703622bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b335988ea24ea8b685c4278442cf8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9c7b335988ea24ea8b685c4278442cf8">max_supported_keys</a> () const</td></tr>
<tr class="separator:a9c7b335988ea24ea8b685c4278442cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d5b6de2843435371dc9045403e3d07"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25d5b6de2843435371dc9045403e3d07">max_supported_key_parts</a> () const</td></tr>
<tr class="separator:a25d5b6de2843435371dc9045403e3d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2216dba316fe13117f00e8d21cbdab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0c2216dba316fe13117f00e8d21cbdab">max_supported_key_length</a> () const</td></tr>
<tr class="separator:a0c2216dba316fe13117f00e8d21cbdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a45b6e069b4c13b85bdaf4992f7828"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a44a45b6e069b4c13b85bdaf4992f7828">max_supported_key_part_length</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info) const</td></tr>
<tr class="separator:a44a45b6e069b4c13b85bdaf4992f7828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082d2a49764e8548b8104dc514877b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab082d2a49764e8548b8104dc514877b3">min_record_length</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="sql__show__processlist_8cc.html#a625d75986eec56d5b1eae931c2492497">options</a>) const</td></tr>
<tr class="separator:ab082d2a49764e8548b8104dc514877b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a20da13aaa177f1a256e5fb63e7c78"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64a20da13aaa177f1a256e5fb63e7c78">low_byte_first</a> () const</td></tr>
<tr class="separator:a64a20da13aaa177f1a256e5fb63e7c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00ca688822b5d3c9db5ce5d6a982b44"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MYSYS.html#ga31ef2f6273d26427fe4a13ed5049b050">ha_checksum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad00ca688822b5d3c9db5ce5d6a982b44">checksum</a> () const</td></tr>
<tr class="separator:ad00ca688822b5d3c9db5ce5d6a982b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea4b726707284210cc365ad454add03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ea4b726707284210cc365ad454add03">is_crashed</a> () const</td></tr>
<tr class="memdesc:a6ea4b726707284210cc365ad454add03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table is crashed.  <a href="#a6ea4b726707284210cc365ad454add03">More...</a><br /></td></tr>
<tr class="separator:a6ea4b726707284210cc365ad454add03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08387779d587f8d3ea84b965ddc391"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aca08387779d587f8d3ea84b965ddc391">auto_repair</a> () const</td></tr>
<tr class="memdesc:aca08387779d587f8d3ea84b965ddc391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table can be automatically repaired.  <a href="#aca08387779d587f8d3ea84b965ddc391">More...</a><br /></td></tr>
<tr class="separator:aca08387779d587f8d3ea84b965ddc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2447668275a831bcf73b5c00818254a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count</a> (void) const</td></tr>
<tr class="memdesc:a2447668275a831bcf73b5c00818254a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of lock objects returned in store_lock.  <a href="#a2447668275a831bcf73b5c00818254a6">More...</a><br /></td></tr>
<tr class="separator:a2447668275a831bcf73b5c00818254a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2502e460566f2c4b506cc1b30eb79e0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a> **to, enum <a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a> lock_type)=0</td></tr>
<tr class="memdesc:a2502e460566f2c4b506cc1b30eb79e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is not invoked for non-transactional temporary tables.  <a href="#a2502e460566f2c4b506cc1b30eb79e0a">More...</a><br /></td></tr>
<tr class="separator:a2502e460566f2c4b506cc1b30eb79e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c885f4b3b5bf6d2878225a188b5599f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1c885f4b3b5bf6d2878225a188b5599f">primary_key_is_clustered</a> () const</td></tr>
<tr class="memdesc:a1c885f4b3b5bf6d2878225a188b5599f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the primary key is clustered or not.  <a href="#a1c885f4b3b5bf6d2878225a188b5599f">More...</a><br /></td></tr>
<tr class="separator:a1c885f4b3b5bf6d2878225a188b5599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3caf4144919df570d9f0554fc718f74"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af3caf4144919df570d9f0554fc718f74">cmp_ref</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ref1, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ref2) const</td></tr>
<tr class="memdesc:af3caf4144919df570d9f0554fc718f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two positions.  <a href="#af3caf4144919df570d9f0554fc718f74">More...</a><br /></td></tr>
<tr class="separator:af3caf4144919df570d9f0554fc718f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818d1203804da43f05fa666d4a0c83a9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a818d1203804da43f05fa666d4a0c83a9">cond_push</a> (const <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> other_tbls_ok)</td></tr>
<tr class="memdesc:a818d1203804da43f05fa666d4a0c83a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push condition down to the table handler.  <a href="#a818d1203804da43f05fa666d4a0c83a9">More...</a><br /></td></tr>
<tr class="separator:a818d1203804da43f05fa666d4a0c83a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb554282443af443fc8aae4533e1407"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">idx_cond_push</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="classItem.html">Item</a> *idx_cond)</td></tr>
<tr class="memdesc:a0bb554282443af443fc8aae4533e1407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push down an index condition to the handler.  <a href="#a0bb554282443af443fc8aae4533e1407">More...</a><br /></td></tr>
<tr class="separator:a0bb554282443af443fc8aae4533e1407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc6ba204aa4d1bacc35d9d1d75ab15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr class="memdesc:a41cc6ba204aa4d1bacc35d9d1d75ab15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset information about pushed index conditions.  <a href="#a41cc6ba204aa4d1bacc35d9d1d75ab15">More...</a><br /></td></tr>
<tr class="separator:a41cc6ba204aa4d1bacc35d9d1d75ab15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86930bf10b20ad19b3df07e07d28116e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">number_of_pushed_joins</a> () const</td></tr>
<tr class="memdesc:a86930bf10b20ad19b3df07e07d28116e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports number of tables included in pushed join which this handler instance is part of.  <a href="#a86930bf10b20ad19b3df07e07d28116e">More...</a><br /></td></tr>
<tr class="separator:a86930bf10b20ad19b3df07e07d28116e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777443226094990f74c6008c8a67168b"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a777443226094990f74c6008c8a67168b">member_of_pushed_join</a> () const</td></tr>
<tr class="memdesc:a777443226094990f74c6008c8a67168b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this handler instance is part of a pushed join sequence returned TABLE instance being root of the pushed query?  <a href="#a777443226094990f74c6008c8a67168b">More...</a><br /></td></tr>
<tr class="separator:a777443226094990f74c6008c8a67168b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef865015edc575d0a50d1a6f5b13e4a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">parent_of_pushed_join</a> () const</td></tr>
<tr class="memdesc:aaef865015edc575d0a50d1a6f5b13e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this handler instance is a child in a pushed join sequence returned TABLE instance being my parent?  <a href="#aaef865015edc575d0a50d1a6f5b13e4a">More...</a><br /></td></tr>
<tr class="separator:aaef865015edc575d0a50d1a6f5b13e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17a6fa82ef1a46a8772118ce98c6867"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac17a6fa82ef1a46a8772118ce98c6867">tables_in_pushed_join</a> () const</td></tr>
<tr class="separator:ac17a6fa82ef1a46a8772118ce98c6867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972eaf8824b8e5fbbafc0f76d8ab0d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a972eaf8824b8e5fbbafc0f76d8ab0d8a">ha_index_read_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)</td></tr>
<tr class="separator:a972eaf8824b8e5fbbafc0f76d8ab0d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9b89354e9938d79b1f72e11c8e7626"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1d9b89354e9938d79b1f72e11c8e7626">ha_index_next_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:a1d9b89354e9938d79b1f72e11c8e7626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d800c8dafbc9efde9af932305529e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">check_if_incompatible_data</a> (<a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> table_changes)</td></tr>
<tr class="memdesc:a36d800c8dafbc9efde9af932305529e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of old, deprecated in-place ALTER API.  <a href="#a36d800c8dafbc9efde9af932305529e4">More...</a><br /></td></tr>
<tr class="separator:a36d800c8dafbc9efde9af932305529e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67890a9deb89b9ef0128601e7687fcba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="sql_2handler_8h.html#a66da1d8166f880283aefe422280ce631">enum_alter_inplace_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="memdesc:a67890a9deb89b9ef0128601e7687fcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a storage engine supports a particular alter table in-place.  <a href="#a67890a9deb89b9ef0128601e7687fcba">More...</a><br /></td></tr>
<tr class="separator:a67890a9deb89b9ef0128601e7687fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9ef0d5918463a152ffa763dd8d794a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6c9ef0d5918463a152ffa763dd8d794a">ha_prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:a6c9ef0d5918463a152ffa763dd8d794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public functions wrapping the actual handler call.  <a href="#a6c9ef0d5918463a152ffa763dd8d794a">More...</a><br /></td></tr>
<tr class="separator:a6c9ef0d5918463a152ffa763dd8d794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d24ed82fba01ba93d3ed5059789e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abf2d24ed82fba01ba93d3ed5059789e7">ha_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:abf2d24ed82fba01ba93d3ed5059789e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public function wrapping the actual handler call.  <a href="#abf2d24ed82fba01ba93d3ed5059789e7">More...</a><br /></td></tr>
<tr class="separator:abf2d24ed82fba01ba93d3ed5059789e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6902ffe7fd0afa8a32969f606e4302e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6902ffe7fd0afa8a32969f606e4302e7">ha_commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="sql__cmd__srs_8cc.html#af8756202cf6ab572edb0e832014f1a5f">commit</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:a6902ffe7fd0afa8a32969f606e4302e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public function wrapping the actual handler call.  <a href="#a6902ffe7fd0afa8a32969f606e4302e7">More...</a><br /></td></tr>
<tr class="separator:a6902ffe7fd0afa8a32969f606e4302e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8d36387a3cb7301ee63d842198d328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb8d36387a3cb7301ee63d842198d328">ha_notify_table_changed</a> (<a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="memdesc:abb8d36387a3cb7301ee63d842198d328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public function wrapping the actual handler call.  <a href="#abb8d36387a3cb7301ee63d842198d328">More...</a><br /></td></tr>
<tr class="separator:abb8d36387a3cb7301ee63d842198d328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac21f2d10c4463fb1d7e14882c6314f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr class="memdesc:adac21f2d10c4463fb1d7e14882c6314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key  <a href="#adac21f2d10c4463fb1d7e14882c6314f">More...</a><br /></td></tr>
<tr class="separator:adac21f2d10c4463fb1d7e14882c6314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd7e44bc71120ace1e467ccb02ad06"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *dup_key_found)</td></tr>
<tr class="memdesc:ac8dd7e44bc71120ace1e467ccb02ad06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time.  <a href="#ac8dd7e44bc71120ace1e467ccb02ad06">More...</a><br /></td></tr>
<tr class="separator:ac8dd7e44bc71120ace1e467ccb02ad06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24fcaab09a75e81702c2e2c34fa0b62"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">delete_all_rows</a> ()</td></tr>
<tr class="memdesc:ac24fcaab09a75e81702c2e2c34fa0b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all rows in a table.  <a href="#ac24fcaab09a75e81702c2e2c34fa0b62">More...</a><br /></td></tr>
<tr class="separator:ac24fcaab09a75e81702c2e2c34fa0b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbfc4312adf397f421dba81d65186ab"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abfbfc4312adf397f421dba81d65186ab">truncate</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:abfbfc4312adf397f421dba81d65186ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly remove all rows from a table.  <a href="#abfbfc4312adf397f421dba81d65186ab">More...</a><br /></td></tr>
<tr class="separator:abfbfc4312adf397f421dba81d65186ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8025ebb1cabba85cdf0df9c8a1b7c6f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8025ebb1cabba85cdf0df9c8a1b7c6f">optimize</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="separator:ac8025ebb1cabba85cdf0df9c8a1b7c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992137f9f725825c7046029667aeab8a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a992137f9f725825c7046029667aeab8a">analyze</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="separator:a992137f9f725825c7046029667aeab8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1378edb4813d141f666ce2b9382a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac9c1378edb4813d141f666ce2b9382a4">check_and_repair</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ac9c1378edb4813d141f666ce2b9382a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and repair the table if necessary.  <a href="#ac9c1378edb4813d141f666ce2b9382a4">More...</a><br /></td></tr>
<tr class="separator:ac9c1378edb4813d141f666ce2b9382a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e3a0622ad461a5a86c74ddb9289c6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a272e3a0622ad461a5a86c74ddb9289c6">disable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode)</td></tr>
<tr class="memdesc:a272e3a0622ad461a5a86c74ddb9289c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable indexes for a while.  <a href="#a272e3a0622ad461a5a86c74ddb9289c6">More...</a><br /></td></tr>
<tr class="separator:a272e3a0622ad461a5a86c74ddb9289c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22328b49eac2417561360bd00bbe8299"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a22328b49eac2417561360bd00bbe8299">enable_indexes</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mode)</td></tr>
<tr class="memdesc:a22328b49eac2417561360bd00bbe8299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable indexes again.  <a href="#a22328b49eac2417561360bd00bbe8299">More...</a><br /></td></tr>
<tr class="separator:a22328b49eac2417561360bd00bbe8299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88684b7fb4f91836331a71d43f233fc8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a88684b7fb4f91836331a71d43f233fc8">discard_or_import_tablespace</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> discard, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:a88684b7fb4f91836331a71d43f233fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard or import tablespace.  <a href="#a88684b7fb4f91836331a71d43f233fc8">More...</a><br /></td></tr>
<tr class="separator:a88684b7fb4f91836331a71d43f233fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d474cf912188a562e9f419872031e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac61d474cf912188a562e9f419872031e">drop_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="separator:ac61d474cf912188a562e9f419872031e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af642f26e84f63386742df472343be117"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af642f26e84f63386742df472343be117">create</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *<a class="el" href="classhandler.html#a3de6f276d98eba4327f1a9a860d65f3c">info</a>, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)=0</td></tr>
<tr class="memdesc:af642f26e84f63386742df472343be117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create table (implementation).  <a href="#af642f26e84f63386742df472343be117">More...</a><br /></td></tr>
<tr class="separator:af642f26e84f63386742df472343be117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad252f8049754e2ac8a2064ae90ee5055"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad252f8049754e2ac8a2064ae90ee5055">get_se_private_data</a> (<a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">reset</a>)</td></tr>
<tr class="separator:ad252f8049754e2ac8a2064ae90ee5055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ab2b12bb621c43438531c67e4278e0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad9ab2b12bb621c43438531c67e4278e0">get_extra_columns_and_keys</a> (const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *create_info, const <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; *create_list, const <a class="el" href="classKEY.html">KEY</a> *key_info, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_count, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *table_obj)</td></tr>
<tr class="memdesc:ad9ab2b12bb621c43438531c67e4278e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust definition of table to be created by adding implicit columns and indexes necessary for the storage engine.  <a href="#ad9ab2b12bb621c43438531c67e4278e0">More...</a><br /></td></tr>
<tr class="separator:ad9ab2b12bb621c43438531c67e4278e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370a0f787c1b936e475a5762b91350c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae370a0f787c1b936e475a5762b91350c">set_ha_share_ref</a> (<a class="el" href="classHandler__share.html">Handler_share</a> **arg_ha_share)</td></tr>
<tr class="separator:ae370a0f787c1b936e475a5762b91350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcbbed1055c74444efa8e21dc3b84af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0fcbbed1055c74444efa8e21dc3b84af">set_ha_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg)</td></tr>
<tr class="separator:a0fcbbed1055c74444efa8e21dc3b84af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a271a4a135d110cf6f22ae8ce664664"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6a271a4a135d110cf6f22ae8ce664664">get_lock_type</a> () const</td></tr>
<tr class="separator:a6a271a4a135d110cf6f22ae8ce664664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dad27a5b6b7320e6270138f7d5a0a30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPartition__handler.html">Partition_handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6dad27a5b6b7320e6270138f7d5a0a30">get_partition_handler</a> ()</td></tr>
<tr class="separator:a6dad27a5b6b7320e6270138f7d5a0a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44adf6e8563f65c68edcb47e8e442f7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a44adf6e8563f65c68edcb47e8e442f7e">ha_upgrade_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *dbname, const char *table_name, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table, <a class="el" href="structTABLE.html">TABLE</a> *table_arg)</td></tr>
<tr class="memdesc:a44adf6e8563f65c68edcb47e8e442f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set se_private_id and se_private_data during upgrade.  <a href="#a44adf6e8563f65c68edcb47e8e442f7e">More...</a><br /></td></tr>
<tr class="separator:a44adf6e8563f65c68edcb47e8e442f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d5a87a9d7efac748885280b87cfd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64d5a87a9d7efac748885280b87cfd04">ha_set_primary_handler</a> (<a class="el" href="classhandler.html">handler</a> *primary_handler)</td></tr>
<tr class="memdesc:a64d5a87a9d7efac748885280b87cfd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a pointer to the handler of the primary table that corresponds to the secondary table in this handler.  <a href="#a64d5a87a9d7efac748885280b87cfd04">More...</a><br /></td></tr>
<tr class="separator:a64d5a87a9d7efac748885280b87cfd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1766c3ce158b96a006cf148b31f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4b1766c3ce158b96a006cf148b31f18">ha_get_primary_handler</a> () const</td></tr>
<tr class="memdesc:ae4b1766c3ce158b96a006cf148b31f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a handler for the table in the primary storage engine, if this handler is for a table in a secondary storage engine.  <a href="#ae4b1766c3ce158b96a006cf148b31f18">More...</a><br /></td></tr>
<tr class="separator:ae4b1766c3ce158b96a006cf148b31f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5386c0ecf6cc739bdaf7b61e5b027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac6a5386c0ecf6cc739bdaf7b61e5b027">ha_mv_key_capacity</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *num_keys, size_t *keys_length) const</td></tr>
<tr class="memdesc:ac6a5386c0ecf6cc739bdaf7b61e5b027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return max limits for a single set of multi-valued keys.  <a href="#ac6a5386c0ecf6cc739bdaf7b61e5b027">More...</a><br /></td></tr>
<tr class="separator:ac6a5386c0ecf6cc739bdaf7b61e5b027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa6c449e2194c590eb53b6a6b5dbb362c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa6c449e2194c590eb53b6a6b5dbb362c">my_prepare_gcolumn_template</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db_name, const char *table_name, <a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a> myc, void *ib_table)</td></tr>
<tr class="memdesc:aa6c449e2194c590eb53b6a6b5dbb362c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to allow InnoDB to prepare a template for generated column processing.  <a href="#aa6c449e2194c590eb53b6a6b5dbb362c">More...</a><br /></td></tr>
<tr class="separator:aa6c449e2194c590eb53b6a6b5dbb362c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bedac06ed1345e080b5eb35075ac17"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad1bedac06ed1345e080b5eb35075ac17">my_eval_gcolumn_expr_with_open</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db_name, const char *table_name, const <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *const fields, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>, const char **mv_data_ptr, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *mv_length)</td></tr>
<tr class="memdesc:ad1bedac06ed1345e080b5eb35075ac17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for generated columns processing.  <a href="#ad1bedac06ed1345e080b5eb35075ac17">More...</a><br /></td></tr>
<tr class="separator:ad1bedac06ed1345e080b5eb35075ac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff12cbff0ca6dad2c5565b8930ff698b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff12cbff0ca6dad2c5565b8930ff698b">my_eval_gcolumn_expr</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>, const <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *const fields, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>, const char **mv_data_ptr, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *mv_length)</td></tr>
<tr class="memdesc:aff12cbff0ca6dad2c5565b8930ff698b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for computing generated column values.  <a href="#aff12cbff0ca6dad2c5565b8930ff698b">More...</a><br /></td></tr>
<tr class="separator:aff12cbff0ca6dad2c5565b8930ff698b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a395bae75af9e51a116097a788b2cf57f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a395bae75af9e51a116097a788b2cf57f">ht</a></td></tr>
<tr class="separator:a395bae75af9e51a116097a788b2cf57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7037216007ba6140e6cff5162024d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53c7037216007ba6140e6cff5162024d">ref</a></td></tr>
<tr class="memdesc:a53c7037216007ba6140e6cff5162024d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to current row.  <a href="#a53c7037216007ba6140e6cff5162024d">More...</a><br /></td></tr>
<tr class="separator:a53c7037216007ba6140e6cff5162024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501dc41ecb010069e8bc9d035aae6aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7501dc41ecb010069e8bc9d035aae6aa">dup_ref</a></td></tr>
<tr class="memdesc:a7501dc41ecb010069e8bc9d035aae6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to duplicate row.  <a href="#a7501dc41ecb010069e8bc9d035aae6aa">More...</a><br /></td></tr>
<tr class="separator:a7501dc41ecb010069e8bc9d035aae6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df561df4b2b6552a7b42189feb0400a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1df561df4b2b6552a7b42189feb0400a">stats</a></td></tr>
<tr class="separator:a1df561df4b2b6552a7b42189feb0400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec520eba79eb9f182c534e82c60ebc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ec520eba79eb9f182c534e82c60ebc6">mrr_iter</a></td></tr>
<tr class="separator:a9ec520eba79eb9f182c534e82c60ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51e423645829d3e540c109556931fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a51e423645829d3e540c109556931fa">mrr_funcs</a></td></tr>
<tr class="separator:a2a51e423645829d3e540c109556931fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52372127bd238a7f622190316ba8124f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a52372127bd238a7f622190316ba8124f">multi_range_buffer</a></td></tr>
<tr class="separator:a52372127bd238a7f622190316ba8124f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a476dfe8526807dfc820c4b09f7a6d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1a476dfe8526807dfc820c4b09f7a6d1">ranges_in_seq</a></td></tr>
<tr class="separator:a1a476dfe8526807dfc820c4b09f7a6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4dfb21c4583b55afc4fe5aba50389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adff4dfb21c4583b55afc4fe5aba50389">mrr_is_output_sorted</a></td></tr>
<tr class="separator:adff4dfb21c4583b55afc4fe5aba50389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2632d137c3a17fa583f08db5681e80a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af2632d137c3a17fa583f08db5681e80a">mrr_have_range</a></td></tr>
<tr class="separator:af2632d137c3a17fa583f08db5681e80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2347edc229832e533d1fb73b236e32b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af2347edc229832e533d1fb73b236e32b">mrr_cur_range</a></td></tr>
<tr class="separator:af2347edc229832e533d1fb73b236e32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d698fe9901f0f487c9618ddbb0f1be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkey__range.html">key_range</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28d698fe9901f0f487c9618ddbb0f1be">end_range</a></td></tr>
<tr class="memdesc:a28d698fe9901f0f487c9618ddbb0f1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">End value for a range scan.  <a href="#a28d698fe9901f0f487c9618ddbb0f1be">More...</a><br /></td></tr>
<tr class="separator:a28d698fe9901f0f487c9618ddbb0f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0f0786eed8e5cca4422f700bc1f5bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1d0f0786eed8e5cca4422f700bc1f5bb">m_virt_gcol_in_end_range</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:a1d0f0786eed8e5cca4422f700bc1f5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag which tells if end_range contains a virtual generated column.  <a href="#a1d0f0786eed8e5cca4422f700bc1f5bb">More...</a><br /></td></tr>
<tr class="separator:a1d0f0786eed8e5cca4422f700bc1f5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186b7c7a70634a8e9758ed51708359c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3186b7c7a70634a8e9758ed51708359c">errkey</a></td></tr>
<tr class="separator:a3186b7c7a70634a8e9758ed51708359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5efc62f32ef66b55667fd8370ef33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5ad5efc62f32ef66b55667fd8370ef33">key_used_on_scan</a></td></tr>
<tr class="separator:a5ad5efc62f32ef66b55667fd8370ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2838eebffef46663c19f85d2ad2cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a29f2838eebffef46663c19f85d2ad2cc">active_index</a></td></tr>
<tr class="separator:a29f2838eebffef46663c19f85d2ad2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64def328ff0ca7e391b217c2d3a758ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr class="memdesc:a64def328ff0ca7e391b217c2d3a758ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of ref (1-8 or the clustered key length)  <a href="#a64def328ff0ca7e391b217c2d3a758ec">More...</a><br /></td></tr>
<tr class="separator:a64def328ff0ca7e391b217c2d3a758ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943005f89e7a6d5cee246e1c5b46e9ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFT__INFO.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a943005f89e7a6d5cee246e1c5b46e9ab">ft_handler</a></td></tr>
<tr class="separator:a943005f89e7a6d5cee246e1c5b46e9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4562b84f0a9dd9a138e2329d8e0c2175"><td class="memItemLeft" align="right" valign="top">enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4562b84f0a9dd9a138e2329d8e0c2175">inited</a></td></tr>
<tr class="separator:a4562b84f0a9dd9a138e2329d8e0c2175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47d68a7b406d8777396a657095d5e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afd47d68a7b406d8777396a657095d5e8">implicit_emptied</a></td></tr>
<tr class="separator:afd47d68a7b406d8777396a657095d5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2f8d7155cb44162bb4181cb09f2f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0ed2f8d7155cb44162bb4181cb09f2f3">pushed_cond</a></td></tr>
<tr class="separator:a0ed2f8d7155cb44162bb4181cb09f2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3d956f73649657bad389acfad5f0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae9b3d956f73649657bad389acfad5f0b">pushed_idx_cond</a></td></tr>
<tr class="separator:ae9b3d956f73649657bad389acfad5f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8d81143d1c9c10b976711fe44cf37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4dc8d81143d1c9c10b976711fe44cf37">pushed_idx_cond_keyno</a></td></tr>
<tr class="separator:a4dc8d81143d1c9c10b976711fe44cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab295e407d8a5c50087fed0f4fcd18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr class="memdesc:a62ab295e407d8a5c50087fed0f4fcd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">next_insert_id is the next value which should be inserted into the auto_increment column: in a inserting-multi-row statement (like INSERT SELECT), for the first row where the autoinc value is not specified by the statement, get_auto_increment() called and asked to generate a value, next_insert_id is set to the next value, then for all other rows next_insert_id is used (and increased each time) without calling get_auto_increment().  <a href="#a62ab295e407d8a5c50087fed0f4fcd18">More...</a><br /></td></tr>
<tr class="separator:a62ab295e407d8a5c50087fed0f4fcd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd2cafd83ae60562649bf9688aebf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr class="memdesc:a05dd2cafd83ae60562649bf9688aebf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert id for the current row (<em>autogenerated</em>; if not autogenerated, it's 0).  <a href="#a05dd2cafd83ae60562649bf9688aebf1">More...</a><br /></td></tr>
<tr class="separator:a05dd2cafd83ae60562649bf9688aebf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540a47a05c03724f1102aaaa623131e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr class="memdesc:a1540a47a05c03724f1102aaaa623131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval returned by get_auto_increment() and being consumed by the inserter.  <a href="#a1540a47a05c03724f1102aaaa623131e">More...</a><br /></td></tr>
<tr class="separator:a1540a47a05c03724f1102aaaa623131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfcef0738a89138c8f41ded8da17c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr class="memdesc:acdfcef0738a89138c8f41ded8da17c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of reserved auto-increment intervals.  <a href="#acdfcef0738a89138c8f41ded8da17c0a">More...</a><br /></td></tr>
<tr class="separator:acdfcef0738a89138c8f41ded8da17c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e7cba3fe3bf9731a91be82983cc35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__table.html#gadcd09ac8bc8a8fcecb5e7cf78033a18b">PSI_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr class="memdesc:a881e7cba3fe3bf9731a91be82983cc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instrumented table associated with this handler.  <a href="#a881e7cba3fe3bf9731a91be82983cc35">More...</a><br /></td></tr>
<tr class="separator:a881e7cba3fe3bf9731a91be82983cc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110bb2ddff9878db7a7dd92ce768243a"><td class="memItemLeft" align="right" valign="top">std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a110bb2ddff9878db7a7dd92ce768243a">m_random_number_engine</a></td></tr>
<tr class="separator:a110bb2ddff9878db7a7dd92ce768243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b25b6f921e217b471ef2d372f15aeb7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b25b6f921e217b471ef2d372f15aeb7">m_sampling_percentage</a></td></tr>
<tr class="separator:a4b25b6f921e217b471ef2d372f15aeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3419071f3d4abf183dac95ef565adfff"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="memdesc:a3419071f3d4abf183dac95ef565adfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next record in MRR scan.  <a href="#a3419071f3d4abf183dac95ef565adfff">More...</a><br /></td></tr>
<tr class="separator:a3419071f3d4abf183dac95ef565adfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2371385a8f73f1258965f5f7cfdf93"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9d2371385a8f73f1258965f5f7cfdf93">records</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows)</td></tr>
<tr class="memdesc:a9d2371385a8f73f1258965f5f7cfdf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in table.  <a href="#a9d2371385a8f73f1258965f5f7cfdf93">More...</a><br /></td></tr>
<tr class="separator:a9d2371385a8f73f1258965f5f7cfdf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a4096cff6dd66d0fa5cbb5992f3169"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a11a4096cff6dd66d0fa5cbb5992f3169">records_from_index</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a11a4096cff6dd66d0fa5cbb5992f3169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in table counted using the secondary index chosen by optimizer.  <a href="#a11a4096cff6dd66d0fa5cbb5992f3169">More...</a><br /></td></tr>
<tr class="separator:a11a4096cff6dd66d0fa5cbb5992f3169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c2b258691e5baac8dd22d19c084b37"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">index_read_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:af8c2b258691e5baac8dd22d19c084b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index').  <a href="#af8c2b258691e5baac8dd22d19c084b37">More...</a><br /></td></tr>
<tr class="separator:af8c2b258691e5baac8dd22d19c084b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0c549a00023dd44682cd9452cf830"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">index_read_idx_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:acba0c549a00023dd44682cd9452cf830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument.  <a href="#acba0c549a00023dd44682cd9452cf830">More...</a><br /></td></tr>
<tr class="separator:acba0c549a00023dd44682cd9452cf830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57310b473c83de0515ded4481925fa43"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a57310b473c83de0515ded4481925fa43">index_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:a57310b473c83de0515ded4481925fa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8373c14364e6b45df26b5b77cc7e9c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0b8373c14364e6b45df26b5b77cc7e9c">index_prev</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:a0b8373c14364e6b45df26b5b77cc7e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1386e0dc6f31536470b7b6d89243b7bb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1386e0dc6f31536470b7b6d89243b7bb">index_first</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:a1386e0dc6f31536470b7b6d89243b7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec72a3f0dba086e9e9279cee1a78efd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeec72a3f0dba086e9e9279cee1a78efd">index_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:aeec72a3f0dba086e9e9279cee1a78efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5459b92420f74e6f88dec137e1941d22"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">index_next_same</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keylen)</td></tr>
<tr class="separator:a5459b92420f74e6f88dec137e1941d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae069d5991214e1fdf14cc44fd865a180"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">index_read_last_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)</td></tr>
<tr class="memdesc:ae069d5991214e1fdf14cc44fd865a180"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="#ae069d5991214e1fdf14cc44fd865a180">More...</a><br /></td></tr>
<tr class="separator:ae069d5991214e1fdf14cc44fd865a180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">read_range_first</a> (const <a class="el" href="structkey__range.html">key_range</a> *start_key, const <a class="el" href="structkey__range.html">key_range</a> *end_key, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classhandler.html#a272c3d9b40a9e7c5de20ed390d23a636">eq_range</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="memdesc:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges.  <a href="#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">More...</a><br /></td></tr>
<tr class="separator:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4632aa56c9c66a57558f849f8e01271"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">read_range_next</a> ()</td></tr>
<tr class="memdesc:ae4632aa56c9c66a57558f849f8e01271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ae4632aa56c9c66a57558f849f8e01271">More...</a><br /></td></tr>
<tr class="separator:ae4632aa56c9c66a57558f849f8e01271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cb9c94ca93dbfbb7e92822caba82a1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="separator:a48cb9c94ca93dbfbb7e92822caba82a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf659edd9d870e90c8974ae0eba7a082"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)=0</td></tr>
<tr class="separator:adf659edd9d870e90c8974ae0eba7a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015fbf835ec7f952aa4b4698023af196"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a015fbf835ec7f952aa4b4698023af196">ft_read</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:a015fbf835ec7f952aa4b4698023af196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f216ddcf2eed269254ed5f6c764342"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a34f216ddcf2eed269254ed5f6c764342">index_read_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>)</td></tr>
<tr class="separator:a34f216ddcf2eed269254ed5f6c764342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b953412855f4339ce3ed022fc043dd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a91b953412855f4339ce3ed022fc043dd">index_next_pushed</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:a91b953412855f4339ce3ed022fc043dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaacf167ca0a32694e0074b86e11e89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aafaacf167ca0a32694e0074b86e11e89">prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:aafaacf167ca0a32694e0074b86e11e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the storage engine to update internal structures with concurrent writes blocked.  <a href="#aafaacf167ca0a32694e0074b86e11e89">More...</a><br /></td></tr>
<tr class="separator:aafaacf167ca0a32694e0074b86e11e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa878645217548a566d5ea7dd6609f345"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa878645217548a566d5ea7dd6609f345">inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:aa878645217548a566d5ea7dd6609f345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and Alter_inplace_info.  <a href="#aa878645217548a566d5ea7dd6609f345">More...</a><br /></td></tr>
<tr class="separator:aa878645217548a566d5ea7dd6609f345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af510478303632967d1c14b430187b531"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af510478303632967d1c14b430187b531">commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="sql__cmd__srs_8cc.html#af8756202cf6ab572edb0e832014f1a5f">commit</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *old_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *new_table_def)</td></tr>
<tr class="memdesc:af510478303632967d1c14b430187b531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit or rollback the changes made during prepare_inplace_alter_table() and inplace_alter_table() inside the storage engine.  <a href="#af510478303632967d1c14b430187b531">More...</a><br /></td></tr>
<tr class="separator:af510478303632967d1c14b430187b531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac6921759060b252db86f800e46fc99"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ac6921759060b252db86f800e46fc99">notify_table_changed</a> (<a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="memdesc:a9ac6921759060b252db86f800e46fc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the storage engine that the table definition has been updated.  <a href="#a9ac6921759060b252db86f800e46fc99">More...</a><br /></td></tr>
<tr class="separator:a9ac6921759060b252db86f800e46fc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4999b9c5fba920ee4e45da810dc32cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4999b9c5fba920ee4e45da810dc32cda">ha_statistic_increment</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> System_status_var::*offset) const</td></tr>
<tr class="separator:a4999b9c5fba920ee4e45da810dc32cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df65ee64bcedb5a4b34bf752b2fab08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9df65ee64bcedb5a4b34bf752b2fab08">ha_thd</a> (void) const</td></tr>
<tr class="separator:a9df65ee64bcedb5a4b34bf752b2fab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69803cd29d92bfecd97212354212c516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__table.html#gada4ffe8c7b58d5fd0b8bd8c793819184">PSI_table_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a69803cd29d92bfecd97212354212c516">ha_table_share_psi</a> (const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="memdesc:a69803cd29d92bfecd97212354212c516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the instrumented table information from a table share.  <a href="#a69803cd29d92bfecd97212354212c516">More...</a><br /></td></tr>
<tr class="separator:a69803cd29d92bfecd97212354212c516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fde9c902c411ed3ccd8e6ca8e99b2e9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9fde9c902c411ed3ccd8e6ca8e99b2e9">rename_table</a> (const char *from, const char *to, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *from_table_def, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *to_table_def)</td></tr>
<tr class="memdesc:a9fde9c902c411ed3ccd8e6ca8e99b2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default rename_table() and delete_table() rename/delete files with a given name and extensions from handlerton::file_extensions.  <a href="#a9fde9c902c411ed3ccd8e6ca8e99b2e9">More...</a><br /></td></tr>
<tr class="separator:a9fde9c902c411ed3ccd8e6ca8e99b2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91031fadbe7d634ab58bfeb984c3e0b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad91031fadbe7d634ab58bfeb984c3e0b">delete_table</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:ad91031fadbe7d634ab58bfeb984c3e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a table.  <a href="#ad91031fadbe7d634ab58bfeb984c3e0b">More...</a><br /></td></tr>
<tr class="separator:ad91031fadbe7d634ab58bfeb984c3e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccf806316a9d88a7130d70e7637e8e5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4ccf806316a9d88a7130d70e7637e8e5">index_read</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_len, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="separator:a4ccf806316a9d88a7130d70e7637e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af353b21f935dc95212e1cfef50452"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a90af353b21f935dc95212e1cfef50452">index_read_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_len)</td></tr>
<tr class="separator:a90af353b21f935dc95212e1cfef50452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf21a8ad4be872bbfe94f5cb40abca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr class="memdesc:a13bf21a8ad4be872bbfe94f5cb40abca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an initialized ha_share.  <a href="#a13bf21a8ad4be872bbfe94f5cb40abca">More...</a><br /></td></tr>
<tr class="separator:a13bf21a8ad4be872bbfe94f5cb40abca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24470ac1d4ac336cedbe7c245d321c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="classHandler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr class="memdesc:ab24470ac1d4ac336cedbe7c245d321c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ha_share to be used by all instances of the same table/partition.  <a href="#ab24470ac1d4ac336cedbe7c245d321c9">More...</a><br /></td></tr>
<tr class="separator:ab24470ac1d4ac336cedbe7c245d321c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a39db9dc1cca31f4a3ec0e0e1d7300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr class="memdesc:aa3a39db9dc1cca31f4a3ec0e0e1d7300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a lock for protecting shared handler data.  <a href="#aa3a39db9dc1cca31f4a3ec0e0e1d7300">More...</a><br /></td></tr>
<tr class="separator:aa3a39db9dc1cca31f4a3ec0e0e1d7300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059bbed3de416b3bea51c69dc064e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr class="memdesc:a8059bbed3de416b3bea51c69dc064e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release lock for protecting ha_share.  <a href="#a8059bbed3de416b3bea51c69dc064e79">More...</a><br /></td></tr>
<tr class="separator:a8059bbed3de416b3bea51c69dc064e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b094cfe680aa06a7d8b70194415aa3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3b094cfe680aa06a7d8b70194415aa3b">table_share</a></td></tr>
<tr class="separator:a3b094cfe680aa06a7d8b70194415aa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d051d1ef534891b27612cc4ff56f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a></td></tr>
<tr class="separator:abb0d051d1ef534891b27612cc4ff56f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98743b18a24c8baef7e22a11df74d6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a98743b18a24c8baef7e22a11df74d6c9">cached_table_flags</a></td></tr>
<tr class="separator:a98743b18a24c8baef7e22a11df74d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44b6a4c101f982cd13a344dce5a870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adf44b6a4c101f982cd13a344dce5a870">estimation_rows_to_insert</a></td></tr>
<tr class="separator:adf44b6a4c101f982cd13a344dce5a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011df14ecc738037499572c304d8ee90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a011df14ecc738037499572c304d8ee90">range_key_part</a></td></tr>
<tr class="separator:a011df14ecc738037499572c304d8ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c3d9b40a9e7c5de20ed390d23a636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a272c3d9b40a9e7c5de20ed390d23a636">eq_range</a></td></tr>
<tr class="separator:a272c3d9b40a9e7c5de20ed390d23a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a159ca294d8dafe32405e6ad546e6a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1a159ca294d8dafe32405e6ad546e6a4">in_range_check_pushed_down</a></td></tr>
<tr class="separator:a1a159ca294d8dafe32405e6ad546e6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a14d149dcfec8790b8e58e8b10e22220a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220a">batch_mode_t</a> { <a class="el" href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220aaef015eb1bfde96f1ebd602ffed674bd6">PSI_BATCH_MODE_NONE</a>, 
<a class="el" href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220aa09617d6a8778563537351083b81917a9">PSI_BATCH_MODE_STARTING</a>, 
<a class="el" href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220aaadb8d9e383084d6e79f2a426a3eb5cd2">PSI_BATCH_MODE_STARTED</a>
 }<tr class="memdesc:a14d149dcfec8790b8e58e8b10e22220a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal state of the batch instrumentation.  <a href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a14d149dcfec8790b8e58e8b10e22220a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a234580f9765751ce185182dd1edc3bdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a> ()</td></tr>
<tr class="memdesc:a234580f9765751ce185182dd1edc3bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for incompatible collation changes.  <a href="#a234580f9765751ce185182dd1edc3bdb">More...</a><br /></td></tr>
<tr class="separator:a234580f9765751ce185182dd1edc3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec2493f2d1fc3a22a496ae694d0d458"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeec2493f2d1fc3a22a496ae694d0d458">estimate_in_memory_buffer</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> table_index_size) const</td></tr>
<tr class="memdesc:aeec2493f2d1fc3a22a496ae694d0d458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a guestimate for how much of a table or index is in a memory buffer in the case where the storage engine has not provided any estimate for this.  <a href="#aeec2493f2d1fc3a22a496ae694d0d458">More...</a><br /></td></tr>
<tr class="separator:aeec2493f2d1fc3a22a496ae694d0d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa35b7a8c85125767371878c45c8cbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9fa35b7a8c85125767371878c45c8cbe">handle_records_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *num_rows)</td></tr>
<tr class="memdesc:a9fa35b7a8c85125767371878c45c8cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function will handle the error code from call to records() and records_from_index().  <a href="#a9fa35b7a8c85125767371878c45c8cbe">More...</a><br /></td></tr>
<tr class="separator:a9fa35b7a8c85125767371878c45c8cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7687330aaf0d97540db07ab436e349"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2b7687330aaf0d97540db07ab436e349">extra</a> (enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a> operation)</td></tr>
<tr class="memdesc:a2b7687330aaf0d97540db07ab436e349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage engine specific implementation of ha_extra()  <a href="#a2b7687330aaf0d97540db07ab436e349">More...</a><br /></td></tr>
<tr class="separator:a2b7687330aaf0d97540db07ab436e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8556e08dd260c7856c7b5952e316e533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8556e08dd260c7856c7b5952e316e533">mark_trx_read_write</a> ()</td></tr>
<tr class="memdesc:a8556e08dd260c7856c7b5952e316e533"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to mark a transaction read-write, if it is started.  <a href="#a8556e08dd260c7856c7b5952e316e533">More...</a><br /></td></tr>
<tr class="separator:a8556e08dd260c7856c7b5952e316e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12158d5ad8caae47ffe4ac111adb65fe"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a12158d5ad8caae47ffe4ac111adb65fe">open</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, int mode, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> test_if_locked, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)=0</td></tr>
<tr class="separator:a12158d5ad8caae47ffe4ac111adb65fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d762c5bae301ed92e1f393ed39d347"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a71d762c5bae301ed92e1f393ed39d347">close</a> (void)=0</td></tr>
<tr class="separator:a71d762c5bae301ed92e1f393ed39d347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fefa98fca726c4807e5a763603ff22d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fefa98fca726c4807e5a763603ff22d">index_init</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="separator:a1fefa98fca726c4807e5a763603ff22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec3aae2f0c2981d6c17d6a46107e67"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abfec3aae2f0c2981d6c17d6a46107e67">index_end</a> ()</td></tr>
<tr class="separator:abfec3aae2f0c2981d6c17d6a46107e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddfc5530e45a9340e2de99626085da6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">rnd_init</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan)=0</td></tr>
<tr class="memdesc:a9ddfc5530e45a9340e2de99626085da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">rnd_init() can be called two times without rnd_end() in between (it only makes sense if scan=1).  <a href="#a9ddfc5530e45a9340e2de99626085da6">More...</a><br /></td></tr>
<tr class="separator:a9ddfc5530e45a9340e2de99626085da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590d32e2e1c26e4e9dcfc8228750b0ab"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a590d32e2e1c26e4e9dcfc8228750b0ab">rnd_end</a> ()</td></tr>
<tr class="separator:a590d32e2e1c26e4e9dcfc8228750b0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b26a1dd124ff748aa02f9dd34a378a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3b26a1dd124ff748aa02f9dd34a378a">write_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:ab3b26a1dd124ff748aa02f9dd34a378a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a row.  <a href="#ab3b26a1dd124ff748aa02f9dd34a378a">More...</a><br /></td></tr>
<tr class="separator:ab3b26a1dd124ff748aa02f9dd34a378a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3483fb841777f6e50a8b890ce95527e8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3483fb841777f6e50a8b890ce95527e8">update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>)</td></tr>
<tr class="memdesc:a3483fb841777f6e50a8b890ce95527e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a single row.  <a href="#a3483fb841777f6e50a8b890ce95527e8">More...</a><br /></td></tr>
<tr class="separator:a3483fb841777f6e50a8b890ce95527e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f4e049d9c85be8efb799be07c41db8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae8f4e049d9c85be8efb799be07c41db8">delete_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="separator:ae8f4e049d9c85be8efb799be07c41db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161c615e45f4bd9c285a0e3c1e332af"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">reset</a> ()</td></tr>
<tr class="memdesc:a1161c615e45f4bd9c285a0e3c1e332af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset state of file to after 'open'.  <a href="#a1161c615e45f4bd9c285a0e3c1e332af">More...</a><br /></td></tr>
<tr class="separator:a1161c615e45f4bd9c285a0e3c1e332af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfa0934ac54d557e2dc9bd2bb634645"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8dfa0934ac54d557e2dc9bd2bb634645">table_flags</a> (void) const =0</td></tr>
<tr class="separator:a8dfa0934ac54d557e2dc9bd2bb634645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e9f55268d9cf941080231994e0710c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a61e9f55268d9cf941080231994e0710c">external_lock</a> (<a class="el" href="classTHD.html">THD</a> *thd, int lock_type)</td></tr>
<tr class="memdesc:a61e9f55268d9cf941080231994e0710c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is not invoked for non-transactional temporary tables.  <a href="#a61e9f55268d9cf941080231994e0710c">More...</a><br /></td></tr>
<tr class="separator:a61e9f55268d9cf941080231994e0710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c86ff21b8c2db61977f93746bb6727"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae3c86ff21b8c2db61977f93746bb6727">release_auto_increment</a> ()</td></tr>
<tr class="separator:ae3c86ff21b8c2db61977f93746bb6727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec63958bc0a596400bf987c2c648af01"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aec63958bc0a596400bf987c2c648af01">check_for_upgrade</a> (<a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="memdesc:aec63958bc0a596400bf987c2c648af01"><td class="mdescLeft">&#160;</td><td class="mdescRight">admin commands - called from mysql_admin_table  <a href="#aec63958bc0a596400bf987c2c648af01">More...</a><br /></td></tr>
<tr class="separator:aec63958bc0a596400bf987c2c648af01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45abab7763a52f715ba32e3dcbf7d92c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a45abab7763a52f715ba32e3dcbf7d92c">check</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="separator:a45abab7763a52f715ba32e3dcbf7d92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b135bbe1f8a1b6de46b9c45618c9f8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a02b135bbe1f8a1b6de46b9c45618c9f8">repair</a> (<a class="el" href="classTHD.html">THD</a> *, <a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *)</td></tr>
<tr class="memdesc:a02b135bbe1f8a1b6de46b9c45618c9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this method check_opt can be modified to specify CHECK option to use to call check() upon the table.  <a href="#a02b135bbe1f8a1b6de46b9c45618c9f8">More...</a><br /></td></tr>
<tr class="separator:a02b135bbe1f8a1b6de46b9c45618c9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c060d0929c74e72c8c6f0d44fe45cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa5c060d0929c74e72c8c6f0d44fe45cc">start_bulk_insert</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>)</td></tr>
<tr class="separator:aa5c060d0929c74e72c8c6f0d44fe45cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7d63db38d9257bb09cb9b5cb436533"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aca7d63db38d9257bb09cb9b5cb436533">end_bulk_insert</a> ()</td></tr>
<tr class="separator:aca7d63db38d9257bb09cb9b5cb436533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9771a747571d6440b274a23d0aa6c43b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9771a747571d6440b274a23d0aa6c43b">is_record_buffer_wanted</a> (<a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *const max_rows) const</td></tr>
<tr class="memdesc:a9771a747571d6440b274a23d0aa6c43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this handler want to get a Record_buffer for multi-row reads via the ha_set_record_buffer() function? And if so, what is the maximum number of records to allocate space for in the buffer?  <a href="#a9771a747571d6440b274a23d0aa6c43b">More...</a><br /></td></tr>
<tr class="separator:a9771a747571d6440b274a23d0aa6c43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8691b98cbb43c5a930149f25d1e55ac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad8691b98cbb43c5a930149f25d1e55ac">upgrade_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *dbname, const char *table_name, <a class="el" href="classdd_1_1Table.html">dd::Table</a> *dd_table)</td></tr>
<tr class="separator:ad8691b98cbb43c5a930149f25d1e55ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41795e1f1fba64e38a606b4b844d731"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa41795e1f1fba64e38a606b4b844d731">sample_init</a> (void *&amp;scan_ctx, double sampling_percentage, int sampling_seed, <a class="el" href="sql_2handler_8h.html#ae954cfd46ba0b8300368dccf2bebc842">enum_sampling_method</a> sampling_method)</td></tr>
<tr class="memdesc:aa41795e1f1fba64e38a606b4b844d731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sampling.  <a href="#aa41795e1f1fba64e38a606b4b844d731">More...</a><br /></td></tr>
<tr class="separator:aa41795e1f1fba64e38a606b4b844d731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3757d00cf8932b2ab370164723f830c0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3757d00cf8932b2ab370164723f830c0">sample_next</a> (void *scan_ctx, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a3757d00cf8932b2ab370164723f830c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next record for sampling.  <a href="#a3757d00cf8932b2ab370164723f830c0">More...</a><br /></td></tr>
<tr class="separator:a3757d00cf8932b2ab370164723f830c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0014408fc37a178d96063b809c0eab90"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0014408fc37a178d96063b809c0eab90">sample_end</a> (void *scan_ctx)</td></tr>
<tr class="memdesc:a0014408fc37a178d96063b809c0eab90"><td class="mdescLeft">&#160;</td><td class="mdescRight">End sampling.  <a href="#a0014408fc37a178d96063b809c0eab90">More...</a><br /></td></tr>
<tr class="separator:a0014408fc37a178d96063b809c0eab90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02950211099f733185515d9ccaa2853c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a02950211099f733185515d9ccaa2853c">load_table</a> (const <a class="el" href="structTABLE.html">TABLE</a> &amp;<a class="el" href="classhandler.html#abb0d051d1ef534891b27612cc4ff56f7">table</a>)</td></tr>
<tr class="memdesc:a02950211099f733185515d9ccaa2853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a table into its defined secondary storage engine.  <a href="#a02950211099f733185515d9ccaa2853c">More...</a><br /></td></tr>
<tr class="separator:a02950211099f733185515d9ccaa2853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62ac2819bb9b2187e4e20ac954a5d99"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac62ac2819bb9b2187e4e20ac954a5d99">unload_table</a> (const char *db_name, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> error_if_not_loaded)</td></tr>
<tr class="memdesc:ac62ac2819bb9b2187e4e20ac954a5d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads a table from its defined secondary storage engine.  <a href="#ac62ac2819bb9b2187e4e20ac954a5d99">More...</a><br /></td></tr>
<tr class="separator:ac62ac2819bb9b2187e4e20ac954a5d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad010849c65ff0fb7630ab7af27887741"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad010849c65ff0fb7630ab7af27887741">mv_key_capacity</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *num_keys, size_t *keys_length) const</td></tr>
<tr class="memdesc:ad010849c65ff0fb7630ab7af27887741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Engine-specific function for ha_can_store_mv_keys().  <a href="#ad010849c65ff0fb7630ab7af27887741">More...</a><br /></td></tr>
<tr class="separator:ad010849c65ff0fb7630ab7af27887741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384004c3992ec848bdf45799702bee3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a384004c3992ec848bdf45799702bee3c">filter_dup_records</a> ()</td></tr>
<tr class="memdesc:a384004c3992ec848bdf45799702bee3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter duplicate records when multi-valued index is used for retrieval.  <a href="#a384004c3992ec848bdf45799702bee3c">More...</a><br /></td></tr>
<tr class="separator:a384004c3992ec848bdf45799702bee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abf6a6b8b8ed8c7b0a77d07aeea1ab44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRecord__buffer.html">Record_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abf6a6b8b8ed8c7b0a77d07aeea1ab44e">m_record_buffer</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="memdesc:abf6a6b8b8ed8c7b0a77d07aeea1ab44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer for multi-row reads.  <a href="#abf6a6b8b8ed8c7b0a77d07aeea1ab44e">More...</a><br /></td></tr>
<tr class="separator:abf6a6b8b8ed8c7b0a77d07aeea1ab44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7be2189144804352df9694dee41697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkey__range.html">key_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adc7be2189144804352df9694dee41697">save_end_range</a></td></tr>
<tr class="separator:adc7be2189144804352df9694dee41697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25db78fcce70b0b1034534c1a5d11964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">enum_range_scan_direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25db78fcce70b0b1034534c1a5d11964">range_scan_direction</a></td></tr>
<tr class="separator:a25db78fcce70b0b1034534c1a5d11964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dcf02628357621b80f80086d8b3de8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0dcf02628357621b80f80086d8b3de8">key_compare_result_on_equal</a></td></tr>
<tr class="separator:af0dcf02628357621b80f80086d8b3de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c8aa312359cbf7221bb4236af01a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a08c8aa312359cbf7221bb4236af01a93">m_primary_handler</a> {<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>}</td></tr>
<tr class="memdesc:a08c8aa312359cbf7221bb4236af01a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the handler of the table in the primary storage engine, if this handler represents a table in a secondary storage engine.  <a href="#a08c8aa312359cbf7221bb4236af01a93">More...</a><br /></td></tr>
<tr class="separator:a08c8aa312359cbf7221bb4236af01a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904b90a3376e972147b008c5f8f7c64a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220a">batch_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a904b90a3376e972147b008c5f8f7c64a">m_psi_batch_mode</a></td></tr>
<tr class="memdesc:a904b90a3376e972147b008c5f8f7c64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch mode state.  <a href="#a904b90a3376e972147b008c5f8f7c64a">More...</a><br /></td></tr>
<tr class="separator:a904b90a3376e972147b008c5f8f7c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b9772a63139e9589d810bb445518d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af4b9772a63139e9589d810bb445518d8">m_psi_numrows</a></td></tr>
<tr class="memdesc:af4b9772a63139e9589d810bb445518d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows in the batch.  <a href="#af4b9772a63139e9589d810bb445518d8">More...</a><br /></td></tr>
<tr class="separator:af4b9772a63139e9589d810bb445518d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a2aef2dae7913d5814784f2c77ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__table.html#ga65d968f386d9f08741feee0874b8e1db">PSI_table_locker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa46a2aef2dae7913d5814784f2c77ec9">m_psi_locker</a></td></tr>
<tr class="memdesc:aa46a2aef2dae7913d5814784f2c77ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current event in a batch.  <a href="#aa46a2aef2dae7913d5814784f2c77ec9">More...</a><br /></td></tr>
<tr class="separator:aa46a2aef2dae7913d5814784f2c77ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaa2fdf26cdf68edd9bcb7c5d6e6914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPSI__table__locker__state.html">PSI_table_locker_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adcaa2fdf26cdf68edd9bcb7c5d6e6914">m_psi_locker_state</a></td></tr>
<tr class="memdesc:adcaa2fdf26cdf68edd9bcb7c5d6e6914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the event in a batch.  <a href="#adcaa2fdf26cdf68edd9bcb7c5d6e6914">More...</a><br /></td></tr>
<tr class="separator:adcaa2fdf26cdf68edd9bcb7c5d6e6914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391dcf2f67a2d4d48e915c3bcd6609be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a391dcf2f67a2d4d48e915c3bcd6609be">m_lock_type</a></td></tr>
<tr class="memdesc:a391dcf2f67a2d4d48e915c3bcd6609be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock type set by when calling::ha_external_lock().  <a href="#a391dcf2f67a2d4d48e915c3bcd6609be">More...</a><br /></td></tr>
<tr class="separator:a391dcf2f67a2d4d48e915c3bcd6609be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f83e0c7122ec3d276dcb0a0b940754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHandler__share.html">Handler_share</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a97f83e0c7122ec3d276dcb0a0b940754">ha_share</a></td></tr>
<tr class="memdesc:a97f83e0c7122ec3d276dcb0a0b940754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer where to store/retrieve the Handler_share pointer.  <a href="#a97f83e0c7122ec3d276dcb0a0b940754">More...</a><br /></td></tr>
<tr class="separator:a97f83e0c7122ec3d276dcb0a0b940754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c3fdd584db91b0bacf3fcedbd8a220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13c3fdd584db91b0bacf3fcedbd8a220">m_update_generated_read_fields</a></td></tr>
<tr class="memdesc:a13c3fdd584db91b0bacf3fcedbd8a220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some non-virtual ha_* functions, responsible for reading rows, like ha_rnd_pos(), must ensure that virtual generated columns are calculated before they return.  <a href="#a13c3fdd584db91b0bacf3fcedbd8a220">More...</a><br /></td></tr>
<tr class="separator:a13c3fdd584db91b0bacf3fcedbd8a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10198f1c6fe8a62faed994417774d7ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUnique__on__insert.html">Unique_on_insert</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a10198f1c6fe8a62faed994417774d7ce">m_unique</a></td></tr>
<tr class="separator:a10198f1c6fe8a62faed994417774d7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0e1b518f74dfed5dde6f5f902f264f39"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0e1b518f74dfed5dde6f5f902f264f39">Partition_handler</a></td></tr>
<tr class="separator:a0e1b518f74dfed5dde6f5f902f264f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576b2e6999b5b4fbe40abb7870fe33b2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a576b2e6999b5b4fbe40abb7870fe33b2">DsMrr_impl</a></td></tr>
<tr class="separator:a576b2e6999b5b4fbe40abb7870fe33b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The handler class is the interface for dynamically loadable storage engines. </p>
<p>Do not add ifdefs and take care when adding or changing virtual functions to avoid vtable confusion</p>
<p>Functions in this class accept and return table columns data. Two data representation formats are used:</p><ol type="1">
<li>TableRecordFormat - Used to pass [partial] table records to/from storage engine</li>
<li>KeyTupleFormat - used to pass index search tuples (aka "keys") to storage engine. See opt_range.cc for description of this format.</li>
</ol>
<h1>TableRecordFormat </h1>
<p>[Warning: this description is work in progress and may be incomplete] The table record is stored in a fixed-size buffer:</p>
<p>record: null_bytes, column1_data, column2_data, ...</p>
<p>The offsets of the parts of the buffer are also fixed: every column has an offset to its column{i}_data, and if it is nullable it also has its own bit in null_bytes.</p>
<p>The record buffer only includes data about columns that are marked in the relevant column set (table-&gt;read_set and/or table-&gt;write_set, depending on the situation). &lt;not-sure&gt;It could be that it is required that null bits of non-present columns are set to 1&lt;/not-sure&gt;</p>
<p>VARIOUS EXCEPTIONS AND SPECIAL CASES</p>
<p>If the table has no nullable columns, then null_bytes is still present, its length is one byte &lt;not-sure&gt; which must be set to 0xFF at all times. &lt;/not-sure&gt;</p>
<p>If the table has columns of type BIT, then certain bits from those columns may be stored in null_bytes as well. Grep around for Field_bit for details.</p>
<p>For blob columns (see Field_blob), the record buffer stores length of the data, following by memory pointer to the blob data. The pointer is owned by the storage engine and is valid until the next operation.</p>
<p>If a blob column has NULL value, then its length and blob data pointer must be set to 0.</p>
<h1>Overview of main modules of the handler API </h1>
<p>The overview below was copied from the storage/partition/ha_partition.h when support for non-native partitioning was removed. </p><hr/>
 <h2>MODULE create/delete handler object </h2>
<p>Object create/delete method. Normally called when a table object exists. </p><hr/>
 <h2>MODULE meta data changes </h2>
<p>Meta data routines to CREATE, DROP, RENAME table are often used at ALTER TABLE (update_create_info used from ALTER TABLE and SHOW ..).</p>
<p>Methods: delete_table() rename_table() create() update_create_info() </p><hr/>
 <h2>MODULE open/close object </h2>
<p>Open and close handler object to ensure all underlying files and objects allocated and deallocated for query handling is handled properly.</p>
<p>A handler object is opened as part of its initialisation and before being used for normal queries (not before meta-data changes always. If the object was opened it will also be closed before being deleted.</p>
<p>Methods: open() close() </p><hr/>
 <h2>MODULE start/end statement </h2>
<p>This module contains methods that are used to understand start/end of statements, transaction boundaries, and aid for proper concurrency control.</p>
<p>Methods: store_lock() external_lock() start_stmt() lock_count() unlock_row() was_semi_consistent_read() try_semi_consistent_read() </p><hr/>
 <h2>MODULE change record </h2>
<p>This part of the handler interface is used to change the records after INSERT, DELETE, UPDATE, REPLACE method calls but also other special meta-data operations as ALTER TABLE, LOAD DATA, TRUNCATE.</p>
<p>These methods are used for insert (write_row), update (update_row) and delete (delete_row). All methods to change data always work on one row at a time. update_row and delete_row also contains the old row. delete_all_rows will delete all rows in the table in one call as a special optimization for DELETE from table;</p>
<p>Bulk inserts are supported if all underlying handlers support it. start_bulk_insert and end_bulk_insert is called before and after a number of calls to write_row.</p>
<p>Methods: write_row() update_row() delete_row() delete_all_rows() start_bulk_insert() end_bulk_insert() </p><hr/>
 <h2>MODULE full table scan </h2>
<p>This module is used for the most basic access method for any table handler. This is to fetch all data through a full table scan. No indexes are needed to implement this part. It contains one method to start the scan (rnd_init) that can also be called multiple times (typical in a nested loop join). Then proceeding to the next record (rnd_next) and closing the scan (rnd_end). To remember a record for later access there is a method (position) and there is a method used to retrieve the record based on the stored position. The position can be a file position, a primary key, a ROWID dependent on the handler below.</p>
<p>All functions that retrieve records and are callable through the handler interface must indicate whether a record is present after the call or not. Record found is indicated by returning 0 and setting table status to "has row". Record not found is indicated by returning a non-zero value and setting table status to "no row". </p><dl class="section see"><dt>See also</dt><dd>TABLE::set_found_row() and TABLE::set_no_row(). By enforcing these rules in the handler interface, storage handler functions need not set any status in struct TABLE. These notes also apply to module index scan, documented below.</dd></dl>
<p>Methods:</p>
<p>rnd_init() rnd_end() rnd_next() rnd_pos() rnd_pos_by_record() position() </p><hr/>
 <h2>MODULE index scan </h2>
<p>This part of the handler interface is used to perform access through indexes. The interface is defined as a scan interface but the handler can also use key lookup if the index is a unique index or a primary key index. Index scans are mostly useful for SELECT queries but are an important part also of UPDATE, DELETE, REPLACE and CREATE TABLE table AS SELECT and so forth. Naturally an index is needed for an index scan and indexes can either be ordered, hash based. Some ordered indexes can return data in order but not necessarily all of them. There are many flags that define the behavior of indexes in the various handlers. These methods are found in the optimizer module.</p>
<p>index_read is called to start a scan of an index. The find_flag defines the semantics of the scan. These flags are defined in include/my_base.h index_read_idx is the same but also initializes index before calling doing the same thing as index_read. Thus it is similar to index_init followed by index_read. This is also how we implement it.</p>
<p>index_read/index_read_idx does also return the first row. Thus for key lookups, the index_read will be the only call to the handler in the index scan.</p>
<p>index_init initializes an index before using it and index_end does any end processing needed.</p>
<p>Methods: index_read_map() index_init() index_end() index_read_idx_map() index_next() index_prev() index_first() index_last() index_next_same() index_read_last_map() read_range_first() read_range_next() </p><hr/>
 <h2>MODULE information calls </h2>
<p>This calls are used to inform the handler of specifics of the ongoing scans and other actions. Most of these are used for optimisation purposes.</p>
<p>Methods: info() get_dynamic_partition_info extra() extra_opt() reset() </p><hr/>
 <h2>MODULE optimizer support </h2>
<p>NOTE: One important part of the public handler interface that is not depicted in the methods is the attribute records which is defined in the base class. This is looked upon directly and is set by calling info(HA_STATUS_INFO) ?</p>
<p>Methods: min_rows_for_estimate() get_biggest_used_partition() scan_time() read_time() records_in_range() estimate_rows_upper_bound() records() </p><hr/>
 <h2>MODULE print messages </h2>
<p>This module contains various methods that returns text messages for table types, index type and error messages.</p>
<p>Methods: table_type() get_row_type() print_error() get_error_message() </p><hr/>
 <h2>MODULE handler characteristics </h2>
<p>This module contains a number of methods defining limitations and characteristics of the handler (see also documentation regarding the individual flags).</p>
<p>Methods: table_flags() index_flags() min_of_the_max_uint() max_supported_record_length() max_supported_keys() max_supported_key_parts() max_supported_key_length() max_supported_key_part_length() low_byte_first() extra_rec_buf_length() min_record_length(uint options) primary_key_is_clustered() ha_key_alg get_default_index_algorithm() is_index_algorithm_supported() </p><hr/>
 <h2>MODULE compare records </h2>
<p>cmp_ref checks if two references are the same. For most handlers this is a simple memcmp of the reference. However some handlers use primary key as reference and this can be the same even if memcmp says they are different. This is due to character sets and end spaces and so forth.</p>
<p>Methods: cmp_ref() </p><hr/>
 <h2>MODULE auto increment </h2>
<p>This module is used to handle the support of auto increments.</p>
<p>This variable in the handler is used as part of the handler interface It is maintained by the parent handler object and should not be touched by child handler objects (see handler.cc for its use).</p>
<p>Methods: get_auto_increment() release_auto_increment() </p><hr/>
 <h2>MODULE initialize handler for HANDLER call </h2>
<p>This method is a special InnoDB method called before a HANDLER query.</p>
<p>Methods: init_table_handle_for_HANDLER() </p><hr/>
 <h2>MODULE fulltext index </h2>
<p>Fulltext index support.</p>
<p>Methods: ft_init_ext_with_hints() ft_init() ft_init_ext() ft_read() </p><hr/>
 <h2>MODULE in-place ALTER TABLE </h2>
<p>Methods for in-place ALTER TABLE support (implemented by InnoDB and NDB).</p>
<p>Methods: check_if_supported_inplace_alter() prepare_inplace_alter_table() inplace_alter_table() commit_inplace_alter_table() notify_table_changed() </p><hr/>
 <h2>MODULE tablespace support </h2>
<p>Methods: discard_or_import_tablespace() </p><hr/>
 <h2>MODULE administrative DDL </h2>
<p>Methods: optimize() analyze() check() repair() check_and_repair() auto_repair() is_crashed() check_for_upgrade() checksum() assign_to_keycache() </p><hr/>
 <h2>MODULE enable/disable indexes </h2>
<p>Enable/Disable Indexes are only supported by HEAP and MyISAM.</p>
<p>Methods: disable_indexes() enable_indexes() indexes_are_disabled() </p><hr/>
 <h2>MODULE append_create_info </h2>
<p>Only used by MyISAM MERGE tables.</p>
<p>Methods: append_create_info() </p><hr/>
 <h2>MODULE partitioning specific handler API </h2>
<p>Methods: get_partition_handler() </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af9d8794466270fec22f8a676eaa0c90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d8794466270fec22f8a676eaa0c90a">&#9670;&nbsp;</a></span>Load_cbk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">handler::Load_cbk</a> =  std::function&lt;<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(void *cookie, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> nrows, void *rowdata, uint64_t partition_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback is called by each parallel load thread when processing of rows is required for the adapter scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cookie</td><td>The cookie for this thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows</td><td>The nrows that are available </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowdata</td><td>The mysql-in-memory row data buffer. This is a memory buffer for nrows records. The length of each record is fixed and communicated via Load_init_cbk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partition_id</td><td>Partition id if it's a partitioned table, else std::numeric_limits&lt;uint64_t&gt;::max() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is an error, false otherwise. </dd></dl>

</div>
</div>
<a id="a24e65d325f0e08107186740bcb248756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e65d325f0e08107186740bcb248756">&#9670;&nbsp;</a></span>Load_end_cbk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandler.html#a24e65d325f0e08107186740bcb248756">handler::Load_end_cbk</a> =  std::function&lt;void(void *cookie)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback is called by each parallel load thread when processing of rows has ended for the adapter scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cookie</td><td>The cookie for this thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aa6c4d02e61680defa11a4081f1e24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa6c4d02e61680defa11a4081f1e24b">&#9670;&nbsp;</a></span>Load_init_cbk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">handler::Load_init_cbk</a> =  std::function&lt;<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>( void *cookie, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> ncols, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> row_len, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *col_offsets, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *null_byte_offsets, const <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *null_bitmasks)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback is called by each parallel load thread at the beginning of the parallel load for the adapter scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>The cookie for this thread </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns in each row </td></tr>
    <tr><td class="paramname">row_len</td><td>The size of a row in bytes </td></tr>
    <tr><td class="paramname">col_offsets</td><td>An array of size ncols, where each element represents the offset of a column in the row data. The memory of this array belongs to the caller and will be free-ed after the pload_end_cbk call. </td></tr>
    <tr><td class="paramname">null_byte_offsets</td><td>An array of size ncols, where each element represents the offset of a column in the row data. The memory of this array belongs to the caller and will be free-ed after the pload_end_cbk call. </td></tr>
    <tr><td class="paramname">null_bitmasks</td><td>An array of size ncols, where each element represents the bitmask required to get the null bit. The memory of this array belongs to the caller and will be free-ed after the pload_end_cbk call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4c241e50948859d98ceae6e39066838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c241e50948859d98ceae6e39066838">&#9670;&nbsp;</a></span>my_gcolumn_template_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* handler::my_gcolumn_template_callback_t) (const <a class="el" href="structTABLE.html">TABLE</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function that will be called by my_prepare_gcolumn_template once the table has been opened. </p>

</div>
</div>
<a id="a67af5473a36655c922682399d4c5b6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67af5473a36655c922682399d4c5b6ec">&#9670;&nbsp;</a></span>Table_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> <a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">handler::Table_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aedf7978057d7f5cf7b58f37727a1ce6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf7978057d7f5cf7b58f37727a1ce6c">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aedf7978057d7f5cf7b58f37727a1ce6ca448bbe9d4d955739e67450e94458076d"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aedf7978057d7f5cf7b58f37727a1ce6ca992cf6748d817c1cf1d7961455ed4be4"></a>INDEX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aedf7978057d7f5cf7b58f37727a1ce6cab713692ea5c27311b0a69f8617599c45"></a>RND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aedf7978057d7f5cf7b58f37727a1ce6ca0ebae1da94d3f9a811c564316d5c67f2"></a>SAMPLING&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a14d149dcfec8790b8e58e8b10e22220a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d149dcfec8790b8e58e8b10e22220a">&#9670;&nbsp;</a></span>batch_mode_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220a">handler::batch_mode_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal state of the batch instrumentation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a14d149dcfec8790b8e58e8b10e22220aaef015eb1bfde96f1ebd602ffed674bd6"></a>PSI_BATCH_MODE_NONE&#160;</td><td class="fielddoc"><p>Batch mode not used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14d149dcfec8790b8e58e8b10e22220aa09617d6a8778563537351083b81917a9"></a>PSI_BATCH_MODE_STARTING&#160;</td><td class="fielddoc"><p>Batch mode used, before first table io. </p>
</td></tr>
<tr><td class="fieldname"><a id="a14d149dcfec8790b8e58e8b10e22220aaadb8d9e383084d6e79f2a426a3eb5cd2"></a>PSI_BATCH_MODE_STARTED&#160;</td><td class="fielddoc"><p>Batch mode used, after first table io. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab5b14b11876fb5ac53a4cc7aceea6a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b14b11876fb5ac53a4cc7aceea6a2d">&#9670;&nbsp;</a></span>enum_range_scan_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">handler::enum_range_scan_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab5b14b11876fb5ac53a4cc7aceea6a2da9b3cccc513b9642d3f98dc18781feae5"></a>RANGE_SCAN_ASC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5b14b11876fb5ac53a4cc7aceea6a2daa9e3a542611729d0b0825b523c603b8a"></a>RANGE_SCAN_DESC&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9ae8f7f7b4f67773b73906143238dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae8f7f7b4f67773b73906143238dc9f">&#9670;&nbsp;</a></span>handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">handler::handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>ht_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09926fc18e0dad27e77f0834ee4075cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09926fc18e0dad27e77f0834ee4075cf">&#9670;&nbsp;</a></span>~handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual handler::~handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad4c090210fefb7e95d885688f5717028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c090210fefb7e95d885688f5717028">&#9670;&nbsp;</a></span>adjust_next_insert_id_after_explicit_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::adjust_next_insert_id_after_explicit_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a992137f9f725825c7046029667aeab8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992137f9f725825c7046029667aeab8a">&#9670;&nbsp;</a></span>analyze()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::analyze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a32573dc5d607d3e48c1d88032753f0f5">temptable::Handler</a>, <a class="el" href="classha__innobase.html#aabbeedc88b2cc26817feffcf5c8febca">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a9f89a611801fcb29d8e3468b87bf5219">ha_myisam</a>.</p>

</div>
</div>
<a id="a441afeebcb5b56e598fb7f860c9247d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441afeebcb5b56e598fb7f860c9247d1">&#9670;&nbsp;</a></span>append_create_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::append_create_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__myisammrg.html#a475577d2715c0b4b61eba80b5edd333e">ha_myisammrg</a>.</p>

</div>
</div>
<a id="a73f356517f0bbed3e92061117e003f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f356517f0bbed3e92061117e003f20">&#9670;&nbsp;</a></span>assign_to_keycache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::assign_to_keycache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__myisam.html#a44b91584a63e45813327fef59571b106">ha_myisam</a>.</p>

</div>
</div>
<a id="aca08387779d587f8d3ea84b965ddc391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca08387779d587f8d3ea84b965ddc391">&#9670;&nbsp;</a></span>auto_repair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::auto_repair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the table can be automatically repaired. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Can be auto repaired </td></tr>
    <tr><td class="paramname">false</td><td>Cannot be auto repaired </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__myisam.html#a9891213b164ff4f8b60ca3eb098b96aa">ha_myisam</a>, <a class="el" href="classha__tina.html#a5d6022c4a033a373e1513e4cc20b8e16">ha_tina</a>, and <a class="el" href="classha__archive.html#a3058527e273b3aa4e16845a496fdc331">ha_archive</a>.</p>

</div>
</div>
<a id="ac8dd7e44bc71120ace1e467ccb02ad06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dd7e44bc71120ace1e467ccb02ad06">&#9670;&nbsp;</a></span>bulk_update_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::bulk_update_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time. </p>
<p>The handler can be certain that another call to bulk_update_row will occur OR a call to exec_bulk_update before the set of updates in this query is concluded.</p>
<p>Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>Old record </td></tr>
    <tr><td class="paramname">new_data</td><td>New record </td></tr>
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e746c224b70d3b03b2886ecf4563394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e746c224b70d3b03b2886ecf4563394">&#9670;&nbsp;</a></span>calculate_key_hash_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> handler::calculate_key_hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>field_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innopart.html#ac23f48296b5f38c892811d50b702e0d4">ha_innopart</a>.</p>

</div>
</div>
<a id="a41cc6ba204aa4d1bacc35d9d1d75ab15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cc6ba204aa4d1bacc35d9d1d75ab15">&#9670;&nbsp;</a></span>cancel_pushed_idx_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::cancel_pushed_idx_cond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset information about pushed index conditions. </p>

</div>
</div>
<a id="a2b117a976fc9423d2337da59f35d128c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b117a976fc9423d2337da59f35d128c">&#9670;&nbsp;</a></span>change_table_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::change_table_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the internal TABLE_SHARE pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_arg</td><td>TABLE object </td></tr>
    <tr><td class="paramname">share</td><td>New share to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Is used in error handling in ha_delete_table. </dd></dl>

</div>
</div>
<a id="a45abab7763a52f715ba32e3dcbf7d92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45abab7763a52f715ba32e3dcbf7d92c">&#9670;&nbsp;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a00bbe62dfe6f77607149ba46ba6a7fff">temptable::Handler</a>, <a class="el" href="classha__innopart.html#a1f2779ce526bd725c7882d9802ff4f2b">ha_innopart</a>, <a class="el" href="classha__innobase.html#aeb381d782e3dd2cefe882fb3fb686870">ha_innobase</a>, <a class="el" href="classha__archive.html#a1819d6161fcd83115deb3dbf43369950">ha_archive</a>, <a class="el" href="classha__myisam.html#a4100ec9679b0a6a04ba96f2aa1a2d303">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#a7c40a2db5005c3b48d5a3eb0c24f1a38">ha_myisammrg</a>, and <a class="el" href="classha__tina.html#aaecfc5ca19c92779402da13b1f22f5e7">ha_tina</a>.</p>

</div>
</div>
<a id="ac9c1378edb4813d141f666ce2b9382a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c1378edb4813d141f666ce2b9382a4">&#9670;&nbsp;</a></span>check_and_repair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::check_and_repair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check and repair the table if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread object</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error/Not supported </td></tr>
    <tr><td class="paramname">false</td><td>Success</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Called if open_table_from_share fails and is_crashed(). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__archive.html#ac63752ff3e408ab62fe22f9cace14173">ha_archive</a>, <a class="el" href="classha__myisam.html#af79751df7f0a7cc0da9dce455a293928">ha_myisam</a>, and <a class="el" href="classha__tina.html#afb0c90e0bcffcdb31af46b4d1ad98df8">ha_tina</a>.</p>

</div>
</div>
<a id="a234580f9765751ce185182dd1edc3bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234580f9765751ce185182dd1edc3bdb">&#9670;&nbsp;</a></span>check_collation_compatibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::check_collation_compatibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for incompatible collation changes. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table may have data requiring upgrade. </td></tr>
    <tr><td class="paramname">0</td><td>No upgrade required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec63958bc0a596400bf987c2c648af01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec63958bc0a596400bf987c2c648af01">&#9670;&nbsp;</a></span>check_for_upgrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::check_for_upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>admin commands - called from mysql_admin_table </p>

<p>Reimplemented in <a class="el" href="classha__archive.html#ae69d02ca6536366c974c73f2ad5dfe1f">ha_archive</a>.</p>

</div>
</div>
<a id="a36d800c8dafbc9efde9af932305529e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d800c8dafbc9efde9af932305529e4">&#9670;&nbsp;</a></span>check_if_incompatible_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::check_if_incompatible_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Part of old, deprecated in-place ALTER API. </p>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a34bbb92638219595c60471086c57d0f4">temptable::Handler</a>, <a class="el" href="classha__innopart.html#a88df16f68605b9e2c3c275e9cd442c13">ha_innopart</a>, <a class="el" href="classha__innobase.html#a9d8aba3a3633ed6dc7324d9725b0526f">ha_innobase</a>, <a class="el" href="classha__myisam.html#af127f8668e7f012e42695df3d6132dd4">ha_myisam</a>, <a class="el" href="classha__archive.html#a8e5b8d67d3bd8e39784f031cb2d5f2c5">ha_archive</a>, <a class="el" href="classha__tina.html#a167818bd93172364f6814dd74198ed9f">ha_tina</a>, <a class="el" href="classha__myisammrg.html#a26df6922a029990c0420bc12e6555d6e">ha_myisammrg</a>, and <a class="el" href="classha__heap.html#a459367c094a596ce4fde88cbf1aff286">ha_heap</a>.</p>

</div>
</div>
<a id="a67890a9deb89b9ef0128601e7687fcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67890a9deb89b9ef0128601e7687fcba">&#9670;&nbsp;</a></span>check_if_supported_inplace_alter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sql_2handler_8h.html#a66da1d8166f880283aefe422280ce631">enum_alter_inplace_result</a> handler::check_if_supported_inplace_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a storage engine supports a particular alter table in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td>TABLE object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER TABLE and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_ERROR</td><td>Unexpected error. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported, must use copy. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_EXCLUSIVE_LOCK</td><td>Supported, but requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires SNW lock during main phase. Prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK</td><td>Supported, but requires SNW lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported, concurrent reads/writes allowed. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_INSTANT</td><td>Instant algorithm is supported. Prepare and main phases are no-op. Changes happen during commit phase and it should be "instant". We keep SU lock, allowing concurrent reads and writes during no-op phases and upgrade it to X lock before commit phase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation uses the old in-place ALTER API to determine if the storage engine supports in-place ALTER or not.</dd>
<dd>
In cases when there is difference between in-place and instant algorithm and explicit ALGORITHM=INPLACE clause was provided SE MUST return one of values corresponding to in-place algorithm and not HA_ALTER_INPLACE_INSTANT from this method.</dd>
<dd>
Called without holding thr_lock.c lock. </dd></dl>

<p>Reimplemented in <a class="el" href="group__ALTER__TABLE__INTERFACE.html#ga9b55cba48f15017a7d8acd28872dbcb7">ha_innobase</a>, and <a class="el" href="group__ONLINE__ALTER__TABLE__INTERFACE.html#gad97015f2c07080c4e396c43996539d42">ha_innopart</a>.</p>

</div>
</div>
<a id="ad00ca688822b5d3c9db5ce5d6a982b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00ca688822b5d3c9db5ce5d6a982b44">&#9670;&nbsp;</a></span>checksum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MYSYS.html#ga31ef2f6273d26427fe4a13ed5049b050">ha_checksum</a> handler::checksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__myisam.html#ab6c7bb94ba8eea1748dd801c07cb310e">ha_myisam</a>.</p>

</div>
</div>
<a id="a97fc340039f5cf37a26e7c3b53685794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fc340039f5cf37a26e7c3b53685794">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html">handler</a> * handler::clone </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>mem_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a76429a427d90f2d7fe819e7c33ce13da">temptable::Handler</a>, <a class="el" href="classha__innopart.html#a56359f1cbc9093c071799a915cefefce">ha_innopart</a>, <a class="el" href="classha__myisammrg.html#a96e90224ce3f8e540420f28c0c84a2a1">ha_myisammrg</a>, <a class="el" href="classha__innobase.html#a3a1929d99568428c342c15ff9a081e92">ha_innobase</a>, <a class="el" href="classha__myisam.html#abd4a16bbadd9c395724adee02708b658">ha_myisam</a>, and <a class="el" href="classha__heap.html#a70b05803fdf2c7fdcb3ced6695649d32">ha_heap</a>.</p>

</div>
</div>
<a id="a71d762c5bae301ed92e1f393ed39d347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d762c5bae301ed92e1f393ed39d347">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga1693c8027c0450cf42f9fe78a32593cc">ha_innopart</a>, <a class="el" href="classha__federated.html#a5c075660794988dd47171f8e9573e945">ha_federated</a>, <a class="el" href="classtemptable_1_1Handler.html#a9f87c5845a51cd7f144b2ed4414dbdaf">temptable::Handler</a>, <a class="el" href="classha__example.html#a2c9aeafe288ddc386e8d8a2a574f9003">ha_example</a>, <a class="el" href="classha__perfschema.html#ae2db1c1ade5562a72fe3517bceb222d4">ha_perfschema</a>, <a class="el" href="classha__tina.html#a31567622a99c67afad6da49f3e678ac9">ha_tina</a>, <a class="el" href="classha__archive.html#a26e58ab6be333389b614bbe9bb590c37">ha_archive</a>, <a class="el" href="classha__myisammrg.html#aa690d54222a310ed685d14f5a52cd398">ha_myisammrg</a>, <a class="el" href="classha__innobase.html#a8644a1842b94dae86679d3166d85c2a6">ha_innobase</a>, <a class="el" href="classha__myisam.html#acefdb0cd6f8c3142810851295c7bc8e7">ha_myisam</a>, <a class="el" href="classha__blackhole.html#a688d327727db1a10883d252602b4f672">ha_blackhole</a>, <a class="el" href="classha__heap.html#a3a7f7c149e7f157b1fdec91430a86c1f">ha_heap</a>, and <a class="el" href="classmock_1_1ha__mock.html#a4df67fd530c6916d89bbb71d66f214a6">mock::ha_mock</a>.</p>

</div>
</div>
<a id="af3caf4144919df570d9f0554fc718f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3caf4144919df570d9f0554fc718f74">&#9670;&nbsp;</a></span>cmp_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::cmp_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ref1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ref2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref1</td><td>First position. </td></tr>
    <tr><td class="paramname">ref2</td><td>Second position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>ref1 &lt; ref2. </td></tr>
    <tr><td class="paramname">0</td><td>Equal. </td></tr>
    <tr><td class="paramname">&gt;0</td><td>ref1 &gt; ref2. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#abe97c379a96e2823febf4fc46c72202b">temptable::Handler</a>, <a class="el" href="classha__innopart.html#ab85ee7e3833038f4e26fe91e00d997e2">ha_innopart</a>, <a class="el" href="classha__innobase.html#aaa25ab9f3a03803bea3f710bc0b269e1">ha_innobase</a>, and <a class="el" href="classha__heap.html#a714bf06135172cdb0062d784bd1626ca">ha_heap</a>.</p>

</div>
</div>
<a id="a4de97045e5381007565fd2b0da235c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de97045e5381007565fd2b0da235c07">&#9670;&nbsp;</a></span>column_bitmaps_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::column_bitmaps_signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal that the table-&gt;read_set and table-&gt;write_set table maps changed The handler is allowed to set additional bits in the above map in this call. </p>
<p>MySQL signal that it changed the column bitmap.</p>
<p>Normally the handler should ignore all calls until we have done a ha_rnd_init() or ha_index_init(), write_row(), update_row or delete_row() as there may be several calls to this routine.</p>
<p>USAGE This is for handlers that needs to setup their own column bitmaps. Normally the handler should set up their own column bitmaps in index_init() or rnd_init() and in any column_bitmaps_signal() call after this.</p>
<p>The handler is allowd to do changes to the bitmap after a index_init or rnd_init() call is made as after this, MySQL will not use the bitmap for any program logic checking. </p>

</div>
</div>
<a id="af510478303632967d1c14b430187b531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af510478303632967d1c14b430187b531">&#9670;&nbsp;</a></span>commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>old_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>new_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit or rollback the changes made during prepare_inplace_alter_table() and inplace_alter_table() inside the storage engine. </p>
<p>Note that in case of rollback the allowed level of concurrency during this operation will be the same as for inplace_alter_table() and thus might be higher than during prepare_inplace_alter_table(). (For example, concurrent writes were blocked during prepare, but might not be during rollback).</p>
<dl class="section note"><dt>Note</dt><dd>This is the place where SE changes happen for instant algorithm.</dd>
<dd>
For storage engines supporting atomic DDL this method should only prepare for the commit but do not finalize it. Real commit should happen later when the whole statement is committed. Also in some situations statement might be rolled back after call to commit_inplace_alter_table() for such storage engines. In the latter special case SE might require call to handlerton::dict_cache_reset() in order to invalidate its internal table definition cache after rollback.</dd>
<dd>
Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function with commit= true reports error, it will be called again with commit= false.</dd>
<dd>
In case of partitioning, this function might be called for rollback without prepare_inplace_alter_table() having been called first. Also partitioned tables sets ha_alter_info-&gt;group_commit_ctx to a NULL terminated array of the partitions handlers and if all of them are committed as one, then group_commit_ctx should be set to NULL to indicate to the partitioning handler that all partitions handlers are committed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>prepare_inplace_alter_table().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td>TABLE object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER TABLE and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>True =&gt; Commit, False =&gt; Rollback. </td></tr>
    <tr><td class="paramname">old_table_def</td><td>dd::Table object describing old version of the table. </td></tr>
    <tr><td class="paramname">new_table_def</td><td>dd::Table object for the new version of the table. Can be adjusted by this call if SE supports atomic DDL. These changes to the table definition will be persisted in the data-dictionary at statement commit time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__ALTER__TABLE__INTERFACE.html#ga6c9266f596cd73ca385c7c1ed55a217d">ha_innobase</a>, and <a class="el" href="group__ONLINE__ALTER__TABLE__INTERFACE.html#ga425950b162c754d012977fafdd1f444d">ha_innopart</a>.</p>

</div>
</div>
<a id="af0ef38e7407e87ba5d1ccde59c3e94bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ef38e7407e87ba5d1ccde59c3e94bb">&#9670;&nbsp;</a></span>compare_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::compare_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare if found key (in row) is over max-value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>range to compare to row. May be 0 for no range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>key.cc::key_cmp()</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is SIGN(key_in_row - range_key):</dd></dl>
<ul>
<li>0 : Key is equal to range or 'range' == 0 (no range)</li>
<li>-1 : Key is less than range</li>
<li>1 : Key is larger than range </li>
</ul>

</div>
</div>
<a id="ab767345668267e3c8881fab6e351e6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab767345668267e3c8881fab6e351e6c8">&#9670;&nbsp;</a></span>compare_key_icp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::compare_key_icp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeac3d9b9796d3bfb18b96a1989d6f516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac3d9b9796d3bfb18b96a1989d6f516">&#9670;&nbsp;</a></span>compare_key_in_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::compare_key_in_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the key in the given buffer (which is not necessarily TABLE::record[0]) is within range. </p>
<p>Called by the storage engine to avoid reading too many rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer that holds the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the key is within the range </td></tr>
    <tr><td class="paramname">0</td><td>if the key is equal to the end_range key, and key_compare_result_on_equal is 0 </td></tr>
    <tr><td class="paramname">1</td><td>if the key is outside the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a818d1203804da43f05fa666d4a0c83a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818d1203804da43f05fa666d4a0c83a9">&#9670;&nbsp;</a></span>cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classItem.html">Item</a>* handler::cond_push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>other_tbls_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push condition down to the table handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to be pushed. The condition tree must not be modified by the caller. </td></tr>
    <tr><td class="paramname">other_tbls_ok</td><td>Are other tables than than 'this' allowed to be referred by the condition terms being pushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 'remainder' condition that caller must use to filter out records. NULL means the handler will not return rows that do not match the passed condition.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>handler-&gt;ha_reset() call discard any pushed conditions. Calls to rnd_init/rnd_end, index_init/index_end etc do not affect the pushed conditions. </dd></dl>

</div>
</div>
<a id="af642f26e84f63386742df472343be117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af642f26e84f63386742df472343be117">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create table (implementation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Table name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">form</td><td>TABLE object describing the table to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>HA_CREATE_INFO describing table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_def</td><td>dd::Table object describing the table to be created. This object can be adjusted by storage engine if it supports atomic DDL (i.e. has HTON_SUPPORTS_ATOMIC_DDL flag set). These changes will be persisted in the data-dictionary. Can be NULL for temporary tables created by optimizer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">non-0</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classha__innopart.html#ae5c540fba9c540797278ea33b37dabcf">ha_innopart</a>, <a class="el" href="classha__innobase.html#a34323a614547239877b26d408708fda8">ha_innobase</a>, <a class="el" href="classha__example.html#aa95f52de15d246d765c386b843d9bc88">ha_example</a>, <a class="el" href="classha__federated.html#a0990d9912ba9e35ebebe9c58ec89cded">ha_federated</a>, <a class="el" href="classha__perfschema.html#a977150dc3476715b2b478dcd1a378b08">ha_perfschema</a>, <a class="el" href="classha__tina.html#a4bd2d4a2389507a7b78ae7024e54f39f">ha_tina</a>, <a class="el" href="classha__archive.html#a856bfc9f0be0cbb43dcbe324d5a346c3">ha_archive</a>, <a class="el" href="classha__myisam.html#ae544beb0c21a0d8ffb1ac1b87b60aa9b">ha_myisam</a>, <a class="el" href="classtemptable_1_1Handler.html#a0bc509241e670d3a1cc8c98270bed7a7">temptable::Handler</a>, <a class="el" href="classha__myisammrg.html#a6c95fb7ccdc02e6b595b8961bf2a3b46">ha_myisammrg</a>, <a class="el" href="classha__heap.html#a01bad5aaeeb3e05a7f541439b2e32543">ha_heap</a>, <a class="el" href="classha__blackhole.html#abeb17fe13cc7e124e4a011c3d99844bc">ha_blackhole</a>, and <a class="el" href="classmock_1_1ha__mock.html#a33a2f80a3b395c705e9aff11653c424f">mock::ha_mock</a>.</p>

</div>
</div>
<a id="ac24fcaab09a75e81702c2e2c34fa0b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24fcaab09a75e81702c2e2c34fa0b62">&#9670;&nbsp;</a></span>delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::delete_all_rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete all rows in a table. </p>
<p>This is called both for cases of truncate and for cases where the optimizer realizes that all rows will be removed as a result of an SQL statement.</p>
<p>If the handler don't support this, then this function will return HA_ERR_WRONG_COMMAND and MySQL will delete the rows one by one. </p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ae570f80412285f65eef8eb8608c2a49c">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#af5fd603b34640f3e60bf3a353739d752">temptable::Handler</a>, <a class="el" href="classha__example.html#adddb711239019f681dc29b79688057f1">ha_example</a>, <a class="el" href="classha__federated.html#a817322262fdb097932be38e53c13543c">ha_federated</a>, <a class="el" href="classha__perfschema.html#ae1b801797df673b543bb7da5b1b5b094">ha_perfschema</a>, <a class="el" href="classha__tina.html#a80da8e6e68f064af280997804ca377b7">ha_tina</a>, <a class="el" href="classha__myisam.html#a9d871f5a781bdf8a38dde4f88f40b36e">ha_myisam</a>, <a class="el" href="classha__innobase.html#af174cbf38ed3d1363f32d2772537ceee">ha_innobase</a>, and <a class="el" href="classha__heap.html#af6253c19d9ca25349db6f486503f3a77">ha_heap</a>.</p>

</div>
</div>
<a id="ae8f4e049d9c85be8efb799be07c41db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f4e049d9c85be8efb799be07c41db8">&#9670;&nbsp;</a></span>delete_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::delete_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#gae30201abe4fb1340b988ce3a277bdfe6">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a717e7449bacda4a6db826c76a2581c33">temptable::Handler</a>, <a class="el" href="classha__federated.html#a3204c89b13f0cfa3612f6f04209c6982">ha_federated</a>, <a class="el" href="classha__example.html#a268421076b6b9b86064a77e91c3c52b1">ha_example</a>, <a class="el" href="classha__perfschema.html#a5435862add1a17ed083331900a871d01">ha_perfschema</a>, <a class="el" href="classha__tina.html#a0704cb22adf54c561923a9a4bc728d0f">ha_tina</a>, <a class="el" href="classha__innobase.html#afca34d7d3d9efcb40f6143fc11f9d5af">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a7a5c2bc8fdcb1638a06499a05072094f">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a972835622a545d2650321bb33c36fd0d">ha_myisam</a>, <a class="el" href="classha__blackhole.html#a6bac159bea7e92adf35b9b75dd4c3d19">ha_blackhole</a>, and <a class="el" href="classha__heap.html#a6c7d389c57394ba0ebad3db2dd4585fd">ha_heap</a>.</p>

</div>
</div>
<a id="ad91031fadbe7d634ab58bfeb984c3e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91031fadbe7d634ab58bfeb984c3e0b">&#9670;&nbsp;</a></span>delete_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a table. </p>
<p>Used to delete a table. By the time delete_table() has been called all opened references to this table will have been closed (and your globally shared references released. The variable name will just be the name of the table. You will need to remove any files you have created at this point. Called for base as well as temporary tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Full path of table name. </td></tr>
    <tr><td class="paramname">table_def</td><td>dd::Table describing table being deleted (can be NULL for temporary tables created by optimizer).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, nonzero otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a5a5c17abd4fa849a011e5754ad81d951">ha_innopart</a>, <a class="el" href="classha__innobase.html#aa8d95a18bb01bd7aab0e995da4535549">ha_innobase</a>, <a class="el" href="classha__example.html#a45c6a3844e6eb1ef0ab48fb585ce4c21">ha_example</a>, <a class="el" href="classha__perfschema.html#a9a0c0e02531859b1d1d85c835bd1e4f0">ha_perfschema</a>, <a class="el" href="classtemptable_1_1Handler.html#a8254e327bfbeddc877dc5f69d5efad2f">temptable::Handler</a>, <a class="el" href="classha__myisam.html#ac19500effbea00dc7b2d27c1e72fe082">ha_myisam</a>, and <a class="el" href="classha__heap.html#ac4866a033562a3b90907926106327b15">ha_heap</a>.</p>

</div>
</div>
<a id="a272e3a0622ad461a5a86c74ddb9289c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272e3a0622ad461a5a86c74ddb9289c6">&#9670;&nbsp;</a></span>disable_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::disable_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable indexes for a while. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a814e1803181506f9d3e6d042a0456986">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a8a78cc39db10884bee2a3682f742b7a3">temptable::Handler</a>, <a class="el" href="classha__innobase.html#a1546e4057641f48c81fc60c1ea1a46b9">ha_innobase</a>, <a class="el" href="classha__myisam.html#a24b462817c45813441bec871c68b8064">ha_myisam</a>, and <a class="el" href="classha__heap.html#a0db212bca2e3862f7ed8fedd7736918a">ha_heap</a>.</p>

</div>
</div>
<a id="a88684b7fb4f91836331a71d43f233fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88684b7fb4f91836331a71d43f233fc8">&#9670;&nbsp;</a></span>discard_or_import_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::discard_or_import_tablespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>discard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discard or import tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">discard</td><td>Indicates whether this is discard operation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_def</td><td>dd::Table object describing the table in which tablespace needs to be discarded or imported. This object can be adjusted by storage engine if it supports atomic DDL (i.e. has HTON_SUPPORTS_ATOMIC_DDL flag set). These changes will be persisted in the data-dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a1f7882d6bc40d58f050e2f5f657a33af">ha_innopart</a>, and <a class="el" href="classha__innobase.html#a390184a3611fa9b62312bc2654ea511f">ha_innobase</a>.</p>

</div>
</div>
<a id="ac61d474cf912188a562e9f419872031e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61d474cf912188a562e9f419872031e">&#9670;&nbsp;</a></span>drop_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::drop_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__heap.html#a17e5da0df9c0a5e0bcf6353fd1c9bc8e">ha_heap</a>.</p>

</div>
</div>
<a id="a22328b49eac2417561360bd00bbe8299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22328b49eac2417561360bd00bbe8299">&#9670;&nbsp;</a></span>enable_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::enable_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable indexes again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a2d990f2f9cf5190ded2e2b8a7bee2598">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a0110781c549897d6eb961b16da9e296d">temptable::Handler</a>, <a class="el" href="classha__innobase.html#a66b6e1d81bc96709e0aff70761bf9166">ha_innobase</a>, <a class="el" href="classha__myisam.html#a09ec2ac7f8215bf21028209c1cf78fa0">ha_myisam</a>, and <a class="el" href="classha__heap.html#a675798f4afa1b9fab0add25bcb6a811c">ha_heap</a>.</p>

</div>
</div>
<a id="af5f9f1ca2b5efc0b41e96c6b793d9bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f9f1ca2b5efc0b41e96c6b793d9bb1">&#9670;&nbsp;</a></span>end_bulk_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::end_bulk_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute all outstanding deletes and close down the bulk delete. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca7d63db38d9257bb09cb9b5cb436533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7d63db38d9257bb09cb9b5cb436533">&#9670;&nbsp;</a></span>end_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::end_bulk_insert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__federated.html#a8b15f75ea7892b9b8e94670b10a7f17f">ha_federated</a>, <a class="el" href="classha__archive.html#a9dd7c097476a4dc0f448ff4c454e4b26">ha_archive</a>, and <a class="el" href="classha__myisam.html#a81dd6729b266aa136c3f396832a2f101">ha_myisam</a>.</p>

</div>
</div>
<a id="a2bf6c46d66ca282a4cbd6118e4c99e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf6c46d66ca282a4cbd6118e4c99e03">&#9670;&nbsp;</a></span>end_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::end_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any needed clean-up, no outstanding updates are there at the moment. </p>

</div>
</div>
<a id="ab6a860cb6d6cb731416080acc8f179e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a860cb6d6cb731416080acc8f179e0">&#9670;&nbsp;</a></span>end_psi_batch_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::end_psi_batch_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End a batch started with <code>start_psi_batch_mode</code>. </p>

</div>
</div>
<a id="a75494b6dc9eb0d9fbbcd91cf0ab1d365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75494b6dc9eb0d9fbbcd91cf0ab1d365">&#9670;&nbsp;</a></span>end_psi_batch_mode_if_started()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::end_psi_batch_mode_if_started </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a PSI batch was started, turn if off. </p>
<dl class="section return"><dt>Returns</dt><dd>true if it was started. </dd></dl>

</div>
</div>
<a id="a517d99c283e85e8d97460f07a781dabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517d99c283e85e8d97460f07a781dabf">&#9670;&nbsp;</a></span>end_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> handler::end_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End read (before write) removal and return the number of rows really written. </p>
<dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

</div>
</div>
<a id="accb375aeab783a6c520296c7621fb559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb375aeab783a6c520296c7621fb559">&#9670;&nbsp;</a></span>engine_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::engine_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAQP_1_1Table__access.html">AQP::Table_access</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let storage engine inspect the optimized 'plan' and pick whatever it like for being pushed down to the engine. </p>
<p>(Join, conditions, ..)</p>
<p>The handler implementation should keep track of what it 'pushed', such that later calls to the handlers access methods should activate the pushed (part of) the execution plan on the storage engines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Abstract Query Plan 'table' object for the table being pushed to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success error otherwise </dd></dl>

</div>
</div>
<a id="aeec2493f2d1fc3a22a496ae694d0d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec2493f2d1fc3a22a496ae694d0d458">&#9670;&nbsp;</a></span>estimate_in_memory_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double handler::estimate_in_memory_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>table_index_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a guestimate for how much of a table or index is in a memory buffer in the case where the storage engine has not provided any estimate for this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_index_size</td><td>size of the table or index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fraction of the table or index in main memory buffer </dd></dl>

</div>
</div>
<a id="ae59e9a1d36d852f4dd5dd00bff5f1ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59e9a1d36d852f4dd5dd00bff5f1ae4">&#9670;&nbsp;</a></span>estimate_rows_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> handler::estimate_rows_upper_bound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return upper bound of current number of records in the table (max. </p>
<p>of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a5d73bb43e401237d9037b4de05db670d">ha_innopart</a>, <a class="el" href="classha__innobase.html#a8d47bcd9368043b44b59c1f24f690201">ha_innobase</a>, <a class="el" href="classha__federated.html#afc7808f1f0927f6eb4927906b5247e2f">ha_federated</a>, <a class="el" href="classha__tina.html#abeb836f0aaeab9776d2890fd179dd320">ha_tina</a>, and <a class="el" href="classha__perfschema.html#a75bdfd6b30a0f80409aaff26a7d7bf35">ha_perfschema</a>.</p>

</div>
</div>
<a id="a886bf2fbf16de7e200e3ebc0765fb6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886bf2fbf16de7e200e3ebc0765fb6e4">&#9670;&nbsp;</a></span>exec_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::exec_bulk_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>dup_key_found</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After this call all outstanding updates must be performed. </p>
<p>The number of duplicate key errors are reported in the duplicate key parameter. It is allowed to continue to the batched update after this call, the handler has to wait until end_bulk_update with changing state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab256be9b37a44ba83d26732e5197823a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab256be9b37a44ba83d26732e5197823a">&#9670;&nbsp;</a></span>explain_extra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string handler::explain_extra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return extra handler specific text for EXPLAIN. </p>

</div>
</div>
<a id="a61e9f55268d9cf941080231994e0710c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e9f55268d9cf941080231994e0710c">&#9670;&nbsp;</a></span>external_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::external_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is not invoked for non-transactional temporary tables. </p>
<p>Tells the storage engine that we intend to read or write data from the table. This call is prefixed with a call to handler::store_lock() and is invoked only for those handler instances that stored the lock.</p>
<p>Calls to <code>rnd_init</code> / <code>index_init</code> are prefixed with this call. When table IO is complete, we call</p><div class="fragment"><div class="line"><a class="code" href="classhandler.html#a61e9f55268d9cf941080231994e0710c">external_lock</a>(F_UNLCK) </div></div><!-- fragment --><p>. A storage engine writer should expect that each call to </p><div class="fragment"><div class="line"><a class="code" href="classhandler.html#a61e9f55268d9cf941080231994e0710c">::external_lock</a>(F_[RD|WR]<a class="code" href="components_2libminchassis_2dynamic__loader_8cc.html#a0376b2ead2de10bb7ab6a4d21ec304e9">LOCK</a> </div></div><!-- fragment --><p> is followed by a call to </p><div class="fragment"><div class="line"><a class="code" href="classhandler.html#a61e9f55268d9cf941080231994e0710c">::external_lock</a>(F_UNLCK) </div></div><!-- fragment --><p>. If it is not, it is a bug in MySQL.</p>
<p>The name and signature originate from the first implementation in MyISAM, which would call <code>fcntl</code> to set/clear an advisory lock on the data file in this method.</p>
<p>Originally this method was used to set locks on file level to enable several MySQL Servers to work on the same data. For transactional engines it has been "abused" to also mean start and end of statements to enable proper rollback of statements and transactions. When LOCK TABLES has been issued the start_stmt method takes over the role of indicating start of statement but in this case there is no end of statement indicator(?).</p>
<p>Called from lock.cc by lock_external() and unlock_external(). Also called from sql_table.cc by copy_data_between_tables().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the current thread </td></tr>
    <tr><td class="paramname">lock_type</td><td>F_RDLCK, F_WRLCK, F_UNLCK</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-0 in case of failure, 0 in case of success. When lock_type is F_UNLCK, the return value is ignored. </dd></dl>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#gac8b49ac0f42b6e6c6a79eb326f5522e4">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a837b7d113c18a439a4c99c0769406416">temptable::Handler</a>, <a class="el" href="classha__federated.html#adf9741f5e558384c275129c8ee62a718">ha_federated</a>, <a class="el" href="classha__example.html#a51e9ddeafec5d368f83dba6b8f3bf377">ha_example</a>, <a class="el" href="classha__innobase.html#aa9ee606c8a0bcb787cd57b3f0f808adc">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a51be129a4496b1272b42a39c6ba50c9d">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a41256d55a7aa8f49e0c9219d36fdc3a8">ha_myisam</a>, <a class="el" href="classha__heap.html#a1ef4d4ff9d144c415addf5b2b9873a0f">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a19d186876fcbe1ef168da8482e09ef5b">ha_blackhole</a>.</p>

</div>
</div>
<a id="a2b7687330aaf0d97540db07ab436e349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7687330aaf0d97540db07ab436e349">&#9670;&nbsp;</a></span>extra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::extra </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage engine specific implementation of ha_extra() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>the operation to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success error otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ae3001ea8866f1b521dcb38b994641424">ha_innopart</a>, <a class="el" href="classha__example.html#a99a54b2f07d55ab1b7d5fe05241e9468">ha_example</a>, <a class="el" href="classha__federated.html#a7cbec696058f89c5072205b408d834f2">ha_federated</a>, <a class="el" href="classha__innobase.html#a2859bf5d18cdf1b9fcf43ab2194b2631">ha_innobase</a>, <a class="el" href="classha__tina.html#af753c6e56772f6ac01ab291f0ea3772d">ha_tina</a>, <a class="el" href="classha__archive.html#a3c0944549597e386118b3d218ae8c460">ha_archive</a>, <a class="el" href="classha__myisammrg.html#a13e772616aeacdfad5ebdd919d794f3b">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a3cfa14a3b30c18da1e916ca11fc79d0c">ha_myisam</a>, and <a class="el" href="classha__heap.html#a7b309e805b747fb0145f8a5ce0fc1049">ha_heap</a>.</p>

</div>
</div>
<a id="a6b7e72da94a7f5577f00ab5c89204ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7e72da94a7f5577f00ab5c89204ec1">&#9670;&nbsp;</a></span>extra_opt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::extra_opt </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>cache_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__myisammrg.html#ad319fb28d6ec4d385299d4588d1e4e3c">ha_myisammrg</a>, and <a class="el" href="classha__myisam.html#a17ed779a576a950c4e82cd742241bf80">ha_myisam</a>.</p>

</div>
</div>
<a id="a27fd434bc44b88f4e47f44f02c877c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fd434bc44b88f4e47f44f02c877c91">&#9670;&nbsp;</a></span>extra_rec_buf_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::extra_rec_buf_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a384004c3992ec848bdf45799702bee3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384004c3992ec848bdf45799702bee3c">&#9670;&nbsp;</a></span>filter_dup_records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::filter_dup_records </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter duplicate records when multi-valued index is used for retrieval. </p>
<dl class="section return"><dt>Returns</dt><dd>true duplicate, such row id was already seen false row id is seen for the first time </dd></dl>

</div>
</div>
<a id="a72693b6e25765a4290f531f578bcf2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72693b6e25765a4290f531f578bcf2eb">&#9670;&nbsp;</a></span>ft_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ft_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab734678f90b9e7cc6b000047f7c89bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab734678f90b9e7cc6b000047f7c89bb1">&#9670;&nbsp;</a></span>ft_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::ft_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innopart.html#ad8083230f3406f28570a3c3e70d17a59">ha_innopart</a>, <a class="el" href="classha__innobase.html#a072d6c2f3e9989b4d787f0eaf760144c">ha_innobase</a>, and <a class="el" href="classha__myisam.html#af72525a52a30b70d547c98bd845b6d6a">ha_myisam</a>.</p>

</div>
</div>
<a id="a109448e09ee2c456b1471b74bb9eb8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109448e09ee2c456b1471b74bb9eb8e6">&#9670;&nbsp;</a></span>ft_init_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structFT__INFO.html">FT_INFO</a>* handler::ft_init_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>inx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innopart.html#a27e140f9a2fe931115ac3e8ccee65746">ha_innopart</a>, <a class="el" href="classha__innobase.html#aa9a89032a14685b3aa83f8f33ef52a55">ha_innobase</a>, and <a class="el" href="classha__myisam.html#aeb8fe2d870d4087a7d527dc584fa538f">ha_myisam</a>.</p>

</div>
</div>
<a id="a9ceb6075e1b3ad667596b30eea85feb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ceb6075e1b3ad667596b30eea85feb6">&#9670;&nbsp;</a></span>ft_init_ext_with_hints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structFT__INFO.html">FT_INFO</a>* handler::ft_init_ext_with_hints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>inx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFt__hints.html">Ft_hints</a> *&#160;</td>
          <td class="paramname"><em>hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innopart.html#a20044380efb596ab0c70c9eaebd2eec7">ha_innopart</a>, and <a class="el" href="classha__innobase.html#acfd00e39b5172edbd35a7b3e062787e0">ha_innobase</a>.</p>

</div>
</div>
<a id="a015fbf835ec7f952aa4b4698023af196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015fbf835ec7f952aa4b4698023af196">&#9670;&nbsp;</a></span>ft_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::ft_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innopart.html#adcca541201935703314356690fc85843">ha_innopart</a>, <a class="el" href="classha__innobase.html#aadf4ab2a217ef0a9ee3be49f4b054346">ha_innobase</a>, and <a class="el" href="classha__myisam.html#ab00a92cd98fa300ae2304d888dfb0b05">ha_myisam</a>.</p>

</div>
</div>
<a id="aaf6af760a4ef09984a5cc1dc58db9a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6af760a4ef09984a5cc1dc58db9a40">&#9670;&nbsp;</a></span>get_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::get_auto_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves an interval of auto_increment values from the handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>offset (modulus increment) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increment</td><td>increment between calls </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_desired_values</td><td>how many values we want </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_value</td><td>the first value reserved by the handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_reserved_values</td><td>how many values the handler reserved</td></tr>
  </table>
  </dd>
</dl>
<p>offset and increment means that we want values to be of the form offset + N * increment, where N&gt;=0 is integer. If the function sets *first_value to ULLONG_MAX it means an error. If the function sets *nb_reserved_values to ULLONG_MAX it means it has reserved to "positive infinite". </p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#af358184d36d80575d994e527521740a2">ha_innopart</a>, <a class="el" href="classha__innobase.html#aa3ce8ab38b9a25fa3bffda31659d112b">ha_innobase</a>, <a class="el" href="classha__myisam.html#a3f7a275de530e7d29114f0ea10fb431a">ha_myisam</a>, <a class="el" href="classha__archive.html#ae7f696c9254ccf09cbb7e92b4fc77f65">ha_archive</a>, and <a class="el" href="classha__heap.html#add09f7e66d6f2dcce4b18d050f31de94">ha_heap</a>.</p>

</div>
</div>
<a id="a170e714527e670014e9fb4395f0b187f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170e714527e670014e9fb4395f0b187f">&#9670;&nbsp;</a></span>get_default_index_algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a> handler::get_default_index_algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get default key algorithm for SE. </p>
<p>It is used when user has not provided algorithm explicitly or when algorithm specified is not supported by SE. </p>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#aefc92f0e642cadb55464204826376f29">temptable::Handler</a>, <a class="el" href="classha__perfschema.html#a3fcf3d04f2e5c9faa558a710d4a8b4b4">ha_perfschema</a>, <a class="el" href="classha__myisammrg.html#a2089a4626d5fdcbcbbee815b68739312">ha_myisammrg</a>, <a class="el" href="classha__innobase.html#ae9a5dd9df94dce8ab69fbf79e4d9dd64">ha_innobase</a>, <a class="el" href="classha__myisam.html#ab9eeb380159e6ff5ce28987023cb39c3">ha_myisam</a>, <a class="el" href="classha__example.html#a04f8e4d5f80f39c2ddf219b77834ff0d">ha_example</a>, <a class="el" href="classha__blackhole.html#aeb8bed91d548583ea366b5b24c6ef3e5">ha_blackhole</a>, and <a class="el" href="classha__heap.html#a3b7aaebbe533d50ebe1fd2140069b714">ha_heap</a>.</p>

</div>
</div>
<a id="ad5eede0999f8273864faa40c5e181793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eede0999f8273864faa40c5e181793">&#9670;&nbsp;</a></span>get_dup_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::get_dup_key </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>key if error because of duplicated keys </dd></dl>

</div>
</div>
<a id="afce8ffd064ce683481494c7503ef820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce8ffd064ce683481494c7503ef820c">&#9670;&nbsp;</a></span>get_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::get_error_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an error message specific to this handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code previously returned by handler </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to String where to add error message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this is a temporary error </dd></dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#add10dbc445f42177c103e68ac14114da">temptable::Handler</a>, <a class="el" href="classha__innobase.html#a90bf8de2efb608179fa4462fdc990949">ha_innobase</a>, and <a class="el" href="classha__federated.html#a6206dad1b29293dd2c73bcd85e1e8d60">ha_federated</a>.</p>

</div>
</div>
<a id="ad9ab2b12bb621c43438531c67e4278e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ab2b12bb621c43438531c67e4278e0">&#9670;&nbsp;</a></span>get_extra_columns_and_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::get_extra_columns_and_keys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; *&#160;</td>
          <td class="paramname"><em>create_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust definition of table to be created by adding implicit columns and indexes necessary for the storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">create_info</td><td>HA_CREATE_INFO describing the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">create_list</td><td>List of columns in the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_info</td><td>Array of KEY objects describing table indexes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_count</td><td>Number of indexes in the table. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_obj</td><td>dd::Table object describing the table to be created. Implicit columns and indexes are to be added to this object. Adjusted table description will be saved into the data-dictionary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">non-0</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a5db15d03fe482536527801f0df446543">ha_innobase</a>.</p>

</div>
</div>
<a id="a018ba4b85de71ff265bdb1157bf95894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018ba4b85de71ff265bdb1157bf95894">&#9670;&nbsp;</a></span>get_foreign_dup_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::get_foreign_dup_key </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>child_table_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_key_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>child_key_name_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY. </p>
<p>If any of the table or key name is not available this method will return false and will not change any of child_table_name or child_key_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">child_table_name</td><td>Table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_table_name_len</td><td>Table name buffer size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">child_key_name</td><td>Key name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_key_name_len</td><td>Key name buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>table and key names were available and were written into the corresponding out parameters. </td></tr>
    <tr><td class="paramname">false</td><td>table and key names were not available, the out parameters were not touched. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a7466f8dd3a7b6899dd980443d4dd7ef5">ha_innopart</a>, and <a class="el" href="classha__innobase.html#afa619024bc4a2075068278c575a39982">ha_innobase</a>.</p>

</div>
</div>
<a id="a13bf21a8ad4be872bbfe94f5cb40abca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bf21a8ad4be872bbfe94f5cb40abca">&#9670;&nbsp;</a></span>get_ha_share_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHandler__share.html">Handler_share</a> * handler::get_ha_share_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an initialized ha_share. </p>
<dl class="section return"><dt>Returns</dt><dd>Initialized ha_share </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>ha_share is not yet initialized. </td></tr>
    <tr><td class="paramname">!=</td><td>NULL previous initialized ha_share.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a id="aacdf0aed6539181d465676ebc661f2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf0aed6539181d465676ebc661f2b5">&#9670;&nbsp;</a></span>get_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::get_index </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a271a4a135d110cf6f22ae8ce664664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a271a4a135d110cf6f22ae8ce664664">&#9670;&nbsp;</a></span>get_lock_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::get_lock_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a475f7fbe39f6ff0e9da2ac6c3d6c629e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475f7fbe39f6ff0e9da2ac6c3d6c629e">&#9670;&nbsp;</a></span>get_memory_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="my__inttypes_8h.html#a9c0acdcb1b083d30069a62cee1ece644">longlong</a> handler::get_memory_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an estimate on the amount of memory the storage engine will use for caching data in memory. </p>
<p>If this is unknown or the storage engine does not cache data in memory -1 is returned. </p>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#ab4fd0eae9ecdcf2fd3b0eff143cff2cf">temptable::Handler</a>, and <a class="el" href="classha__innobase.html#a9365e00b6cdae0dde50563fa9c40a162">ha_innobase</a>.</p>

</div>
</div>
<a id="a6dad27a5b6b7320e6270138f7d5a0a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dad27a5b6b7320e6270138f7d5a0a30">&#9670;&nbsp;</a></span>get_partition_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartition__handler.html">Partition_handler</a>* handler::get_partition_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innopart.html#a7df76f8ec13490c450b45dd0199e475a">ha_innopart</a>.</p>

</div>
</div>
<a id="af8877c5cafa237927cc9917e3a422a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8877c5cafa237927cc9917e3a422a2d">&#9670;&nbsp;</a></span>get_real_row_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum <a class="el" href="sql_2handler_8h.html#aae164ec549f5dd7e890b40de79fd76c8">row_type</a> handler::get_real_row_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get real row type for the table created based on one specified by user, CREATE TABLE options and SE capabilities. </p>

<p>Reimplemented in <a class="el" href="classha__archive.html#ad5776b6e12d94f648ab26da5c7f7f3b4">ha_archive</a>, <a class="el" href="classha__innobase.html#acfac6b212f587b7d8c4fbd059907ded0">ha_innobase</a>, and <a class="el" href="classha__heap.html#a8c4ed43c9bdaa2ebb8e36a345d28ce00">ha_heap</a>.</p>

</div>
</div>
<a id="ad252f8049754e2ac8a2064ae90ee5055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad252f8049754e2ac8a2064ae90ee5055">&#9670;&nbsp;</a></span>get_se_private_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::get_se_private_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>dd_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innobase.html#a8b6abd57a949186466989472944c0f94">ha_innobase</a>.</p>

</div>
</div>
<a id="ac0e5d856e729be3f3ebee87e6857c45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e5d856e729be3f3ebee87e6857c45d">&#9670;&nbsp;</a></span>get_table_share()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* handler::get_table_share </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66cc9e4971b8e768c102398da0656a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cc9e4971b8e768c102398da0656a7f">&#9670;&nbsp;</a></span>ha_analyze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_analyze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze table: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::analyze() </dd></dl>

</div>
</div>
<a id="a49c8ce82a564b0cbf6340dc9b74a9c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c8ce82a564b0cbf6340dc9b74a9c23">&#9670;&nbsp;</a></span>ha_bulk_update_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_bulk_update_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk update row: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::bulk_update_row() </dd></dl>

</div>
</div>
<a id="a56545ec9967544c80d5612f8ac9b8e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56545ec9967544c80d5612f8ac9b8e6e">&#9670;&nbsp;</a></span>ha_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to be actually called to get 'check()' functionality </p>
<p>Performs checks upon the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread doing CHECK TABLE operation </td></tr>
    <tr><td class="paramname">check_opt</td><td>options from the parser</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_OK</td><td>Successful upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table has structures requiring upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_ALTER</td><td>Table has structures requiring ALTER TABLE </td></tr>
    <tr><td class="paramname">HA_ADMIN_NOT_IMPLEMENTED</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169d5287bdf480f8cd20f758bb2d9bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169d5287bdf480f8cd20f758bb2d9bd1">&#9670;&nbsp;</a></span>ha_check_and_repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::ha_check_and_repair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check and repair table: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::check_and_repair() </dd></dl>

</div>
</div>
<a id="a79a8030a4a3928d216599e1c03e9b28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a8030a4a3928d216599e1c03e9b28c">&#9670;&nbsp;</a></span>ha_check_for_upgrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_check_for_upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae28824cdff2c1812e282463c908e84c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28824cdff2c1812e282463c908e84c2">&#9670;&nbsp;</a></span>ha_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close handler. </p>
<p>Called from sql_base.cc, sql_select.cc, and table.cc. In sql_select.cc it is only used to close up temporary tables or during the process where a temporary table is converted over to being a myisam table. For sql_base.cc look at close_data_tables().</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6902ffe7fd0afa8a32969f606e4302e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6902ffe7fd0afa8a32969f606e4302e7">&#9670;&nbsp;</a></span>ha_commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::ha_commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>old_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>new_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public function wrapping the actual handler call. </p>
<p>Allows us to enforce asserts regardless of handler implementation. </p><dl class="section see"><dt>See also</dt><dd>commit_inplace_alter_table() </dd></dl>

</div>
</div>
<a id="a3cdeebefcfc1390a0e89ac7ef04586a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdeebefcfc1390a0e89ac7ef04586a1">&#9670;&nbsp;</a></span>ha_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a table in the engine: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::create() </dd></dl>

</div>
</div>
<a id="a1fef228137a11565f7d52a60ad802004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef228137a11565f7d52a60ad802004">&#9670;&nbsp;</a></span>ha_delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_delete_all_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all rows: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::delete_all_rows() </dd></dl>

</div>
</div>
<a id="a3f0e3b24f5bb5b2a8fa0c45732db8cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0e3b24f5bb5b2a8fa0c45732db8cdd">&#9670;&nbsp;</a></span>ha_delete_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_delete_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf699c767f76315ce2500f18cb20eb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf699c767f76315ce2500f18cb20eb71">&#9670;&nbsp;</a></span>ha_delete_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete table: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::delete_table() </dd></dl>

</div>
</div>
<a id="aeeb079b3dc59160ba828ef89b4463921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb079b3dc59160ba828ef89b4463921">&#9670;&nbsp;</a></span>ha_disable_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_disable_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable indexes: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::disable_indexes() </dd></dl>

</div>
</div>
<a id="a4d065a0acbb43dda3bec8d2d17c64362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d065a0acbb43dda3bec8d2d17c64362">&#9670;&nbsp;</a></span>ha_discard_or_import_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_discard_or_import_tablespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>discard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard or import tablespace: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::discard_or_import_tablespace() </dd></dl>

</div>
</div>
<a id="a6bcc37ec84386f5d6cc86448781666cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcc37ec84386f5d6cc86448781666cb">&#9670;&nbsp;</a></span>ha_drop_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_drop_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop table in the engine: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::drop_table() </dd></dl>

</div>
</div>
<a id="a36e9c53758728e07eb37cbb65ea3ab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e9c53758728e07eb37cbb65ea3ab50">&#9670;&nbsp;</a></span>ha_enable_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_enable_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable indexes: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::enable_indexes() </dd></dl>

</div>
</div>
<a id="a30f3cbf4a769155c994ed39f76433106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f3cbf4a769155c994ed39f76433106">&#9670;&nbsp;</a></span>ha_end_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_end_bulk_insert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End bulk insert. </p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Failure (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a99b5f8ae28bc5c374919396f8dcf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a99b5f8ae28bc5c374919396f8dcf08">&#9670;&nbsp;</a></span>ha_external_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_external_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions represent the public interface to <em>users</em> of the handler class, hence they are <em>not</em> virtual. </p>
<p>For the inheritance interface, see the (private) functions write_row(), update_row(), and delete_row() below. </p>

</div>
</div>
<a id="a62a7e1c60d82baca1890cf9805d1694b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a7e1c60d82baca1890cf9805d1694b">&#9670;&nbsp;</a></span>ha_extra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_extra </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request storage engine to do an extra operation: enable,disable or run some functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>the operation to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success error otherwise </dd></dl>

</div>
</div>
<a id="adb6ed6e67d0d9891569f90f4122d3855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6ed6e67d0d9891569f90f4122d3855">&#9670;&nbsp;</a></span>ha_ft_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_ft_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4b1766c3ce158b96a006cf148b31f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1766c3ce158b96a006cf148b31f18">&#9670;&nbsp;</a></span>ha_get_primary_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html">handler</a>* handler::ha_get_primary_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a handler for the table in the primary storage engine, if this handler is for a table in a secondary storage engine. </p>

</div>
</div>
<a id="a2f6fecd2d8d525592027049e61db9471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6fecd2d8d525592027049e61db9471">&#9670;&nbsp;</a></span>ha_get_record_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRecord__buffer.html">Record_buffer</a>* handler::ha_get_record_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the record buffer that was set with ha_set_record_buffer(). </p>
<dl class="section return"><dt>Returns</dt><dd>the buffer to use for multi-row reads, or nullptr if there is none </dd></dl>

</div>
</div>
<a id="a7e49e88aeec6d85f9f7b94f6ed2ee487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e49e88aeec6d85f9f7b94f6ed2ee487">&#9670;&nbsp;</a></span>ha_get_se_private_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::ha_get_se_private_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>dd_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a dd::Table object representing a core DD table having hardcoded data to be filled in by the DDSE. </p>
<p>Get the hard coded SE private data from the handler for a DD table.</p>
<p>This function can be used for retrieving the hard coded SE private data for the mysql.dd_properties table, before creating or opening it, or for retrieving the hard coded SE private data for a core table, before creating or opening them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd_table</td><td>[in,out] A dd::Table object representing a core DD table. </td></tr>
    <tr><td class="paramname">reset</td><td>Reset counters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>An error occurred. </td></tr>
    <tr><td class="paramname">false</td><td>Success - no errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>handler::get_se_private_data() </dd></dl>

</div>
</div>
<a id="afa6bd01057c6cdd86d2ea2ee4ea65ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6bd01057c6cdd86d2ea2ee4ea65ca3">&#9670;&nbsp;</a></span>ha_index_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End use of index. </p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd574a3025588e9b0cd49e0d6908e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd574a3025588e9b0cd49e0d6908e3b8">&#9670;&nbsp;</a></span>ha_index_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the first row via index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af23462b249041a0db03c1c7139d76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af23462b249041a0db03c1c7139d76b">&#9670;&nbsp;</a></span>ha_index_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize use of index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index to use </td></tr>
    <tr><td class="paramname">sorted</td><td>Use sorted order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a7415f1744039a51ef15e923ef7da1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7415f1744039a51ef15e923ef7da1b">&#9670;&nbsp;</a></span>ha_index_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the last row via index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c99e96a8350ff577a94529be9387a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c99e96a8350ff577a94529be9387a30">&#9670;&nbsp;</a></span>ha_index_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the next row via index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d9b89354e9938d79b1f72e11c8e7626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9b89354e9938d79b1f72e11c8e7626">&#9670;&nbsp;</a></span>ha_index_next_pushed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_next_pushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f79360a45d50c6b558feb1c308c4157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f79360a45d50c6b558feb1c308c4157">&#9670;&nbsp;</a></span>ha_index_next_same()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_next_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the next same row via index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>Key to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e1ef9b6ab27156116f91bf50b1ac19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1ef9b6ab27156116f91bf50b1ac19f">&#9670;&nbsp;</a></span>ha_index_or_rnd_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_or_rnd_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb977dac0435158be227e45e04c8b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb977dac0435158be227e45e04c8b798">&#9670;&nbsp;</a></span>ha_index_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the previous row via index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac831321e8d33958db4fd4968de932acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac831321e8d33958db4fd4968de932acf">&#9670;&nbsp;</a></span>ha_index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an index and read it. </p>
<dl class="section see"><dt>See also</dt><dd>handler::ha_index_read_map. </dd></dl>

</div>
</div>
<a id="a3fa9be09b8d0b1c03c96eb95f79dd7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa9be09b8d0b1c03c96eb95f79dd7c9">&#9670;&nbsp;</a></span>ha_index_read_last_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_last_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a729d9c9c011527b81287574294887bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729d9c9c011527b81287574294887bf3">&#9670;&nbsp;</a></span>ha_index_read_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read [part of] row via [part of] index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer where store the data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>Key to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keypart_map</td><td>Which part of key to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">find_flag</td><td>Direction/condition on key usage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success (found a record, and function has set table status to "has row") </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found (function has set table status to "no row"). End of index passed. </td></tr>
    <tr><td class="paramname">HA_ERR_KEY_NOT_FOUND</td><td>Row not found (function has set table status to "no row"). Index cursor positioned. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Positions an index cursor to the index specified in the handle. Fetches the row if available. If the key value is null, begin at the first key of the index. ha_index_read_map can be restarted without calling index_end on the previous index scan and without calling ha_index_init. In this case the ha_index_read_map is on the same index as the previous ha_index_scan. This is particularly used in conjunction with multi read ranges. </dd></dl>

</div>
</div>
<a id="a972eaf8824b8e5fbbafc0f76d8ab0d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972eaf8824b8e5fbbafc0f76d8ab0d8a">&#9670;&nbsp;</a></span>ha_index_read_pushed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_pushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf2d24ed82fba01ba93d3ed5059789e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d24ed82fba01ba93d3ed5059789e7">&#9670;&nbsp;</a></span>ha_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::ha_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>old_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>new_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Public function wrapping the actual handler call. </p>
<dl class="section see"><dt>See also</dt><dd>inplace_alter_table() </dd></dl>

</div>
</div>
<a id="af3e9c0e51efed08a7ba13f4d1c30b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e9c0e51efed08a7ba13f4d1c30b1ee">&#9670;&nbsp;</a></span>ha_is_record_buffer_wanted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::ha_is_record_buffer_wanted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *const&#160;</td>
          <td class="paramname"><em>max_rows</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this handler want to get a Record_buffer for multi-row reads via the ha_set_record_buffer() function? And if so, what is the maximum number of records to allocate space for in the buffer? </p>
<p>Storage engines that support using a Record_buffer should override handler::is_record_buffer_wanted().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max_rows</td><td>gets set to the maximum number of records to allocate space for in the buffer if the function returns true</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the handler would like a Record_buffer </td></tr>
    <tr><td class="paramname">false</td><td>if the handler does not want a Record_buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac530d2a77ce857389f6d32dcfeb10002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac530d2a77ce857389f6d32dcfeb10002">&#9670;&nbsp;</a></span>ha_load_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_load_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE.html">TABLE</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a table into its defined secondary storage engine: public interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to load into the secondary engine. Its read_set tells which columns to load.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>handler::load_table() </dd></dl>

</div>
</div>
<a id="a2e7462a72e9f19ae676d9eb6735a8204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7462a72e9f19ae676d9eb6735a8204">&#9670;&nbsp;</a></span>ha_multi_range_read_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_multi_range_read_next </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6a5386c0ecf6cc739bdaf7b61e5b027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a5386c0ecf6cc739bdaf7b61e5b027">&#9670;&nbsp;</a></span>ha_mv_key_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_mv_key_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>keys_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return max limits for a single set of multi-valued keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_keys</td><td>number of keys to store </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keys_length</td><td>total length of keys, bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8d36387a3cb7301ee63d842198d328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8d36387a3cb7301ee63d842198d328">&#9670;&nbsp;</a></span>ha_notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_notify_table_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Public function wrapping the actual handler call. </p>
<dl class="section see"><dt>See also</dt><dd>notify_table_changed() </dd></dl>

</div>
</div>
<a id="aa4a3a986805a5cf0312f3f1575d2343c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a3a986805a5cf0312f3f1575d2343c">&#9670;&nbsp;</a></span>ha_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>test_if_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a980a8a7650a41fd9a05a32521826ccd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980a8a7650a41fd9a05a32521826ccd5">&#9670;&nbsp;</a></span>ha_optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize table: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::optimize() </dd></dl>

</div>
</div>
<a id="a6c9ef0d5918463a152ffa763dd8d794a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9ef0d5918463a152ffa763dd8d794a">&#9670;&nbsp;</a></span>ha_prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::ha_prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>old_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>new_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public functions wrapping the actual handler call. </p>
<dl class="section see"><dt>See also</dt><dd>prepare_inplace_alter_table() </dd></dl>

</div>
</div>
<a id="ae4bc3e86490651704ce5b928169dd725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bc3e86490651704ce5b928169dd725">&#9670;&nbsp;</a></span>ha_read_first_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_read_first_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>primary_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read first row (only) from a table. </p>
<p>This is never called for tables whose storage engine do not contain exact statistics on number of records, e.g. InnoDB.</p>
<dl class="section note"><dt>Note</dt><dd>Since there is only one implementation for this function, it is non-virtual and does not call a protected inner function, like most other handler functions.</dd>
<dd>
Implementation only calls other handler functions, so there is no need to update generated columns nor set table status. </dd></dl>

</div>
</div>
<a id="a57496d1b472f836f21ef273b661949ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57496d1b472f836f21ef273b661949ee">&#9670;&nbsp;</a></span>ha_read_range_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_read_range_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>eq_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c81a68cc8e83e75f5b87a8fb1922271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c81a68cc8e83e75f5b87a8fb1922271">&#9670;&nbsp;</a></span>ha_read_range_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fe4a9e78c818aa2823c302f0fe65522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe4a9e78c818aa2823c302f0fe65522">&#9670;&nbsp;</a></span>ha_records() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_records </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>num_rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper function to call records() in storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>[out] Number of rows in table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5545cfccfcb87c61521d140c55c328c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5545cfccfcb87c61521d140c55c328c9">&#9670;&nbsp;</a></span>ha_records() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_records </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper function to call records_from_index() in storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>[out] Number of rows in table. </td></tr>
    <tr><td class="paramname">index</td><td>Index chosen by optimizer for counting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfbcbef5b9b8ed0f76d700a29091ad3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbcbef5b9b8ed0f76d700a29091ad3f">&#9670;&nbsp;</a></span>ha_release_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_release_auto_increment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6fdba3807d26163cf0bcebcf9fb2664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fdba3807d26163cf0bcebcf9fb2664">&#9670;&nbsp;</a></span>ha_rename_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>from_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>to_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename table: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::rename_table() </dd></dl>

</div>
</div>
<a id="ad28d70543d9566894b5a81d25eca2e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28d70543d9566894b5a81d25eca2e8e">&#9670;&nbsp;</a></span>ha_repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_repair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repair table: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::repair() </dd></dl>

</div>
</div>
<a id="a53d38f167906d8aaa9e560c71e595a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d38f167906d8aaa9e560c71e595a42">&#9670;&nbsp;</a></span>ha_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check handler usage and reset state of file to after 'open'. </p>
<dl class="section note"><dt>Note</dt><dd>can be called regardless of it is locked or not. </dd></dl>

</div>
</div>
<a id="ad4d9bf34ac0a004d8c5c32267f20842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d9bf34ac0a004d8c5c32267f20842f">&#9670;&nbsp;</a></span>ha_rnd_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End use of random access. </p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb5c99736cb400350e007578889b8375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5c99736cb400350e007578889b8375">&#9670;&nbsp;</a></span>ha_rnd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize table for random read or scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>if true: Initialize for random scans through rnd_next() if false: Initialize for random reads through rnd_pos()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3743f3a48e7be751dbb2691be4c992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3743f3a48e7be751dbb2691be4c992a">&#9670;&nbsp;</a></span>ha_rnd_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next row via random scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to read the row into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcd8615219b3e692e7d484d2ba6cfa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd8615219b3e692e7d484d2ba6cfa86">&#9670;&nbsp;</a></span>ha_rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read row via random scan from position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to read the row into </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>Position from position() call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e3147b1facb5846b2ecdf2a0d77775d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3147b1facb5846b2ecdf2a0d77775d">&#9670;&nbsp;</a></span>ha_sample_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_sample_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>Scan context of the sampling</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else one of the HA_xxx values in case of error. </dd></dl>

</div>
</div>
<a id="a0014e351a991fe9c77b4657e4f75dbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0014e351a991fe9c77b4657e4f75dbab">&#9670;&nbsp;</a></span>ha_sample_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_sample_init </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_percentage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampling_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql_2handler_8h.html#ae954cfd46ba0b8300368dccf2bebc842">enum_sampling_method</a>&#160;</td>
          <td class="paramname"><em>sampling_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">scan_ctx</td><td>A scan context created by this method that has to be used in sample_next </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_percentage</td><td>percentage of records that need to be sampled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_seed</td><td>random seed that the random generator will use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_method</td><td>sampling method to be used; currently only SYSTEM sampling is supported</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else one of the HA_xxx values in case of error. </dd></dl>

</div>
</div>
<a id="a72a7ed7143700cada199b11f231876c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a7ed7143700cada199b11f231876c3">&#9670;&nbsp;</a></span>ha_sample_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_sample_next </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next record for sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>Scan context of the sampling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>buffer to place the read record</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else one of the HA_xxx values in case of error. </dd></dl>

</div>
</div>
<a id="a64d5a87a9d7efac748885280b87cfd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d5a87a9d7efac748885280b87cfd04">&#9670;&nbsp;</a></span>ha_set_primary_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_set_primary_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandler.html">handler</a> *&#160;</td>
          <td class="paramname"><em>primary_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a pointer to the handler of the primary table that corresponds to the secondary table in this handler. </p>

</div>
</div>
<a id="ace90f37b16640dc3c5f313c415e5fee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace90f37b16640dc3c5f313c415e5fee6">&#9670;&nbsp;</a></span>ha_set_record_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_set_record_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRecord__buffer.html">Record_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a record buffer that the storage engine can use for multi-row reads. </p>
<p>The buffer has to be provided prior to the first read from an index or a table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer to use for multi-row reads </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f09a15d46c019a621b0a65bb1ec89d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f09a15d46c019a621b0a65bb1ec89d3">&#9670;&nbsp;</a></span>ha_start_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_start_bulk_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start bulk insert. </p>
<p>Allow the handler to optimize for multiple row insert.</p>
<dl class="section note"><dt>Note</dt><dd>rows == 0 means we will probably insert many rows.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Estimated rows to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4999b9c5fba920ee4e45da810dc32cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4999b9c5fba920ee4e45da810dc32cda">&#9670;&nbsp;</a></span>ha_statistic_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_statistic_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> System_status_var::*&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b3015577f49008561db1d34ae750e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3015577f49008561db1d34ae750e70">&#9670;&nbsp;</a></span>ha_table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a> handler::ha_table_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cached_table_flags is set at ha_open and ha_external_lock. </p>

</div>
</div>
<a id="a69803cd29d92bfecd97212354212c516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69803cd29d92bfecd97212354212c516">&#9670;&nbsp;</a></span>ha_table_share_psi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__table.html#gada4ffe8c7b58d5fd0b8bd8c793819184">PSI_table_share</a> * handler::ha_table_share_psi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the instrumented table information from a table share. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>a table share </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instrumented table share, or NULL. </dd></dl>

</div>
</div>
<a id="a9df65ee64bcedb5a4b34bf752b2fab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df65ee64bcedb5a4b34bf752b2fab08">&#9670;&nbsp;</a></span>ha_thd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTHD.html">THD</a> * handler::ha_thd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6faa3573d855956938bdc5171e7bada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6faa3573d855956938bdc5171e7bada5">&#9670;&nbsp;</a></span>ha_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate table: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::truncate() </dd></dl>

</div>
</div>
<a id="afb2066c996d7f772dc0483494de4e3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2066c996d7f772dc0483494de4e3bd">&#9670;&nbsp;</a></span>ha_unload_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_unload_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>error_if_not_loaded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads a table from its defined secondary storage engine: public interface. </p>
<dl class="section see"><dt>See also</dt><dd>handler::unload_table() </dd></dl>

</div>
</div>
<a id="a1f6bb19636dda0f1537fe780b6aca17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6bb19636dda0f1537fe780b6aca17a">&#9670;&nbsp;</a></span>ha_update_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_update_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>new_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the current row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>the old contents of the row </td></tr>
    <tr><td class="paramname">new_data</td><td>the new contents of the row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error status (zero on success, HA_ERR_* error code on error) </dd></dl>

</div>
</div>
<a id="a44adf6e8563f65c68edcb47e8e442f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44adf6e8563f65c68edcb47e8e442f7e">&#9670;&nbsp;</a></span>ha_upgrade_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::ha_upgrade_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>dd_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set se_private_id and se_private_data during upgrade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer of THD </td></tr>
    <tr><td class="paramname">dbname</td><td>Database name </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name </td></tr>
    <tr><td class="paramname">dd_table</td><td>dd::Table for the table </td></tr>
    <tr><td class="paramname">table_arg</td><td>TABLE object for the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success </td></tr>
    <tr><td class="paramname">true</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8e651543ba0dbb2257a50dc1cdb5ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e651543ba0dbb2257a50dc1cdb5ea9">&#9670;&nbsp;</a></span>ha_write_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_write_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fa35b7a8c85125767371878c45c8cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa35b7a8c85125767371878c45c8cbe">&#9670;&nbsp;</a></span>handle_records_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::handle_records_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function will handle the error code from call to records() and records_from_index(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>return code from records() and records_from_index(). </td></tr>
    <tr><td class="paramname">num_rows</td><td>Check if it contains HA_POS_ERROR in case error &lt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae73d4ecfa5cfe85d8179aa52488016d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73d4ecfa5cfe85d8179aa52488016d0">&#9670;&nbsp;</a></span>has_transactions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::has_transactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bb554282443af443fc8aae4533e1407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb554282443af443fc8aae4533e1407">&#9670;&nbsp;</a></span>idx_cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classItem.html">Item</a>* handler::idx_cond_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>idx_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push down an index condition to the handler. </p>
<p>The server will use this method to push down a condition it wants the handler to evaluate when retrieving records using a specified index. The pushed index condition will only refer to fields from this handler that is contained in the index (but it may also refer to fields in other handlers). Before the handler evaluates the condition it must read the content of the index entry into the record buffer.</p>
<p>The handler is free to decide if and how much of the condition it will take responsibility for evaluating. Based on this evaluation it should return the part of the condition it will not evaluate. If it decides to evaluate the entire condition it should return NULL. If it decides not to evaluate any part of the condition it should return a pointer to the same condition as given as argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>the index number to evaluate the condition on </td></tr>
    <tr><td class="paramname">idx_cond</td><td>the condition to be evaluated by the handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of the pushed condition that the handler decides not to evaluate </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a1d09e4715e6cbecad9c68bc6d1b7b679">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a47861540cc01fcfb49ab0d30af247139">ha_myisam</a>.</p>

</div>
</div>
<a id="abfec3aae2f0c2981d6c17d6a46107e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfec3aae2f0c2981d6c17d6a46107e67">&#9670;&nbsp;</a></span>index_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga410bd45d099e12e2d372ad7229566d25">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a35e50fcb96eccd22c3ffa76ff445b39d">temptable::Handler</a>, <a class="el" href="classha__federated.html#a6a16986c66525b5098809a487cfacab3">ha_federated</a>, <a class="el" href="classha__innobase.html#a539589601452095deb50f43eed9153e0">ha_innobase</a>, <a class="el" href="classha__perfschema.html#a43cb7003cad8bfd437cb7a394f8fa494">ha_perfschema</a>, and <a class="el" href="classha__myisam.html#a33f7c0c284a4a06ff3eb7e6cfc6f94e1">ha_myisam</a>.</p>

</div>
</div>
<a id="a1386e0dc6f31536470b7b6d89243b7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1386e0dc6f31536470b7b6d89243b7bb">&#9670;&nbsp;</a></span>index_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#aff4e6f0f69a9a16c5c7d2de96698b113">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a293a879cb3d9208bd83b7594784eab72">temptable::Handler</a>, <a class="el" href="classha__example.html#a6ce70c1eab8b74792cd6bc98f41693c6">ha_example</a>, <a class="el" href="classha__innobase.html#aad308cb08362d1241caecb2e585061d2">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#aeb4de93e6438ad0147ddec3ffc2176c4">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#adee11c6c305ab7a37c82d65a2f58af53">ha_myisam</a>, <a class="el" href="classha__heap.html#a0686382234d1cc88ebe1b0274a02d95f">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a8c9c5cce423cdf05f04abbe8a642474a">ha_blackhole</a>.</p>

</div>
</div>
<a id="a612375d87a4cbb6e7c190ea7d05cf945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612375d87a4cbb6e7c190ea7d05cf945">&#9670;&nbsp;</a></span>index_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> handler::index_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>all_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classtemptable_1_1Handler.html#a343f95254fd9a674c7ec6fe8df4c9d5c">temptable::Handler</a>, <a class="el" href="classha__federated.html#ac878b6689d889f3ab802e1d535676b7f">ha_federated</a>, <a class="el" href="classha__archive.html#a460c6f2af7525f657438f8c9b387b455">ha_archive</a>, <a class="el" href="classha__tina.html#ac699e671a0c45f89df9475d943288d50">ha_tina</a>, <a class="el" href="classha__example.html#af2f5ef64701b3b7354351921c330399a">ha_example</a>, <a class="el" href="classha__innobase.html#a4e16bca7a00ede3aa7bfd6386ca0ea56">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#adb0deb317049d8f32fa28792e56e5d07">ha_myisammrg</a>, <a class="el" href="classha__perfschema.html#a1437203e5bd011121fc82f15a22df252">ha_perfschema</a>, <a class="el" href="classha__myisam.html#a7d66527c89ce4511904e41f7634d89da">ha_myisam</a>, <a class="el" href="classmock_1_1ha__mock.html#a9906d952a2a0c29d99807e68918c2c7f">mock::ha_mock</a>, <a class="el" href="classha__blackhole.html#a2950441c2b6ef0d3796142e14de2e213">ha_blackhole</a>, and <a class="el" href="classha__heap.html#a99b3be96b9239a8e6d1548f4804e0e8e">ha_heap</a>.</p>

</div>
</div>
<a id="a375fdfc86f021f336777324dd5a98a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375fdfc86f021f336777324dd5a98a02">&#9670;&nbsp;</a></span>index_in_memory_estimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double handler::index_in_memory_estimate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an estimate of how much of the index that is currently stored in main memory. </p>
<p>This estimate should be the fraction of the index that currently is available in a main memory buffer. The estimate should be in the range from 0.0 (nothing in memory) to 1.0 (entire index in memory).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>the index to get an estimate for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fraction of the index in main memory buffer </dd></dl>

</div>
</div>
<a id="a1fefa98fca726c4807e5a763603ff22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fefa98fca726c4807e5a763603ff22d">&#9670;&nbsp;</a></span>index_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga83c8a1c634d734625f5b02356b558593">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a388b3107370409511b65b5871b1bf399">temptable::Handler</a>, <a class="el" href="classha__federated.html#a3bd1b18e2c4cb68aea6db74f79508c5f">ha_federated</a>, <a class="el" href="classha__innobase.html#aba62194dbbc6666c763284c900781cde">ha_innobase</a>, <a class="el" href="classha__archive.html#ae7c7ee5370c936d59a2b51174edc8ec4">ha_archive</a>, <a class="el" href="classha__perfschema.html#aac1f4f085ac8bce8dc39c74f162c6ee4">ha_perfschema</a>, and <a class="el" href="classha__myisam.html#ad273ad4d14b4a631e429a6228176e2e4">ha_myisam</a>.</p>

</div>
</div>
<a id="aeec72a3f0dba086e9e9279cee1a78efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec72a3f0dba086e9e9279cee1a78efd">&#9670;&nbsp;</a></span>index_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a3e65cf4574cbf00341843a4b85b6b389">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#ac1fb5a2f27473e90a3d539ce1800b544">temptable::Handler</a>, <a class="el" href="classha__example.html#af6730d279dbee338a5b187250f94434c">ha_example</a>, <a class="el" href="classha__innobase.html#ab0256fd00023ef5d65a6aca868aa07fc">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a583bb51c8db986164e1039a703a7b6ac">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#ad12290c12103972de8f3f2ab771528c0">ha_myisam</a>, <a class="el" href="classha__heap.html#a5c7e985286a9b378f79a024c762d2d27">ha_heap</a>, and <a class="el" href="classha__blackhole.html#abeaf356d84b27ee0b16b4028367c0005">ha_blackhole</a>.</p>

</div>
</div>
<a id="a57310b473c83de0515ded4481925fa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57310b473c83de0515ded4481925fa43">&#9670;&nbsp;</a></span>index_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a7388d5e245839db619773c47a4665688">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#ad94a94367482613e207cf9a88b70db99">temptable::Handler</a>, <a class="el" href="classha__federated.html#a236648ea223139c50386a9013b1c856d">ha_federated</a>, <a class="el" href="classha__example.html#a4f8ae965f5a9ac2a3720ccca59f9416a">ha_example</a>, <a class="el" href="classha__innobase.html#a6b6e17b5c471ee9a0c83a3b1cc392236">ha_innobase</a>, <a class="el" href="classha__archive.html#a8606213d574280db5532ad46bbd2652b">ha_archive</a>, <a class="el" href="classha__myisammrg.html#a922bac4abe1d480035db58312f4273c8">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a9f42f4d669a9a1663628610909a8026f">ha_myisam</a>, <a class="el" href="classha__perfschema.html#af1aac197a9654de49a05632d93bc1558">ha_perfschema</a>, <a class="el" href="classha__heap.html#a34ce91bdf2d1141fbc7452ad25771bd0">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a62d8609343b7aff734aa85edea331c67">ha_blackhole</a>.</p>

</div>
</div>
<a id="a91b953412855f4339ce3ed022fc043dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b953412855f4339ce3ed022fc043dd">&#9670;&nbsp;</a></span>index_next_pushed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_next_pushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5459b92420f74e6f88dec137e1941d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5459b92420f74e6f88dec137e1941d22">&#9670;&nbsp;</a></span>index_next_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::index_next_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a2a0002980ac07a15c0e11d807b73b0d3">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a51e79fdbed6239b8a782919eeaed831c">temptable::Handler</a>, <a class="el" href="classha__innobase.html#a63e2b8ad7471f6b41dde23898aae216f">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a1bc4554af51a05a875c982e979b8e796">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a649dbee300b95b7e205c26c895aec60d">ha_myisam</a>, and <a class="el" href="classha__perfschema.html#ab1539deb7bb1134cfe7513ba46a8d09e">ha_perfschema</a>.</p>

</div>
</div>
<a id="a4a2ac6b2908a899c0ce230818bb7a993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2ac6b2908a899c0ce230818bb7a993">&#9670;&nbsp;</a></span>index_only_read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double handler::index_only_read_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate cost of 'index only' scan for given index and number of records. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>This function is deprecated and will be removed in a future version.</dd></dl>
<p>Use index_scan_cost() instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>Index number </td></tr>
    <tr><td class="paramname">records</td><td>Estimated number of records to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is assumed that we will read trough the whole key range and that all key blocks are half full (normally things are much better). It is also assumed that each time we read the next key from the index, the handler performs a random seek, thus the cost is proportional to the number of blocks read.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Estimated cost of 'index only' scan </dd></dl>

</div>
</div>
<a id="a0b8373c14364e6b45df26b5b77cc7e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8373c14364e6b45df26b5b77cc7e9c">&#9670;&nbsp;</a></span>index_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a9f91f1c63629957f2d6f588e0524de37">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a226dd0e6399bd9f275d558dad9123e44">temptable::Handler</a>, <a class="el" href="classha__example.html#aa61e9e9d047ad068c61536d67fd8337b">ha_example</a>, <a class="el" href="classha__innobase.html#ae598ae464f20eb0e7dde35d100da1899">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#aa0578b30eb89ceb224ab81447ea3672a">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#aeec97d5f92ca64a69debedf874f7c091">ha_myisam</a>, <a class="el" href="classha__heap.html#af636aced3ba2ffa9b8cb93d28b1b0e0f">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a10fcb6d1f7625d87a7f8610c31466eab">ha_blackhole</a>.</p>

</div>
</div>
<a id="a4ccf806316a9d88a7130d70e7637e8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccf806316a9d88a7130d70e7637e8e5">&#9670;&nbsp;</a></span>index_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#af5b0385c33aaede9d300f455e57dea9e">temptable::Handler</a>, <a class="el" href="classha__federated.html#a43a85fa545a4558d7ee153bdcf7d3877">ha_federated</a>, <a class="el" href="classha__innobase.html#ad57ed745e3cbbc2d7f68904e222baa9e">ha_innobase</a>, <a class="el" href="classha__archive.html#ac9595b79c64fa32c6d426c262d686bd4">ha_archive</a>, and <a class="el" href="classha__perfschema.html#a63c6368131f7890e6f059e466d2a0454">ha_perfschema</a>.</p>

</div>
</div>
<a id="acba0c549a00023dd44682cd9452cf830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba0c549a00023dd44682cd9452cf830">&#9670;&nbsp;</a></span>index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in argument. </p>
<p>Fetches the row if available. If the key value is null, begin at the first key of the index. </p><dl class="section see"><dt>See also</dt><dd>index_read_map() </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#aba3f4bee92c61c7e2dc6b53a4b10d711">ha_innopart</a>, <a class="el" href="classha__federated.html#a8e1ebd6e15f07b4a1ab6a3b144266d2a">ha_federated</a>, <a class="el" href="classha__myisammrg.html#aa8342c47f6650053fa91831d475c7cfb">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a727b9570271b98f9b1b17712b20cef69">ha_myisam</a>, <a class="el" href="classha__heap.html#a12a2ae8776fc4be65876912fab66e39f">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a36a768e282992bc30fa844ca6f93fc45">ha_blackhole</a>.</p>

</div>
</div>
<a id="a90af353b21f935dc95212e1cfef50452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90af353b21f935dc95212e1cfef50452">&#9670;&nbsp;</a></span>index_read_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a6191ab0c8428bac052f3ce172c180d7d">temptable::Handler</a>, and <a class="el" href="classha__innobase.html#ac65348e1f6565d897704540a4c9743be">ha_innobase</a>.</p>

</div>
</div>
<a id="ae069d5991214e1fdf14cc44fd865a180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae069d5991214e1fdf14cc44fd865a180">&#9670;&nbsp;</a></span>index_read_last_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_last_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p>
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a48168bac9c47a7b36bbf96be2bb0733c">ha_innopart</a>, <a class="el" href="classha__myisammrg.html#ad58764222f12560854db040f7c9b1671">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a7c2a28ffa24a46ba9e7e702d817e1e04">ha_myisam</a>, <a class="el" href="classha__blackhole.html#aeb7999c83892bb923a1473aeb035d7c4">ha_blackhole</a>, and <a class="el" href="classha__heap.html#ac93cb6959e7d4729ffca695ecdafbcaa">ha_heap</a>.</p>

</div>
</div>
<a id="af8c2b258691e5baac8dd22d19c084b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c2b258691e5baac8dd22d19c084b37">&#9670;&nbsp;</a></span>index_read_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in the handle ('active_index'). </p>
<p>Fetches the row if available. If the key value is null, begin at the first key of the index. </p><dl class="section return"><dt>Returns</dt><dd>0 if success (found a record); non-zero if no record. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a2341cade17dc207e954667f5e7428d90">ha_innopart</a>, <a class="el" href="classha__example.html#ae763c1059e351da03a66a7235cc82b4c">ha_example</a>, <a class="el" href="classha__myisammrg.html#ab642ff075d8587b973614b27e19e9709">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a87bb5566eb22519651a14087023702a6">ha_myisam</a>, <a class="el" href="classha__heap.html#ae3425c752bad3422b35d4309814e51c8">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a1072a8ad530fbca239e6e1282356c7c8">ha_blackhole</a>.</p>

</div>
</div>
<a id="a34f216ddcf2eed269254ed5f6c764342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f216ddcf2eed269254ed5f6c764342">&#9670;&nbsp;</a></span>index_read_pushed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_pushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5575d58c0acbb1924f7f3d3eb756612a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5575d58c0acbb1924f7f3d3eb756612a">&#9670;&nbsp;</a></span>index_scan_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCost__estimate.html">Cost_estimate</a> handler::index_scan_cost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost estimate for reading a number of ranges from an index. </p>
<p>The cost estimate will only include the cost of reading data that is contained in the index. If the records need to be read, use read_cost() instead.</p>
<dl class="section note"><dt>Note</dt><dd>The ranges parameter is currently ignored and is not taken into account in the cost estimate.</dd>
<dd>
For this version it is recommended that storage engines continue to override index_only_read_time() instead of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index number </td></tr>
    <tr><td class="paramname">ranges</td><td>the number of ranges to be read </td></tr>
    <tr><td class="paramname">rows</td><td>total number of rows to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated cost </dd></dl>

</div>
</div>
<a id="a8bc45e93a1b669fa750f73a617c46bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc45e93a1b669fa750f73a617c46bac">&#9670;&nbsp;</a></span>indexes_are_disabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::indexes_are_disabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if indexes are disabled. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Indexes are enabled. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Indexes are disabled. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__myisam.html#addfd16e5353968aa0167cc8961d5754c">ha_myisam</a>, and <a class="el" href="classha__heap.html#af784e0b71b0d4bc75b2fd84530f9a86f">ha_heap</a>.</p>

</div>
</div>
<a id="a3de6f276d98eba4327f1a9a860d65f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de6f276d98eba4327f1a9a860d65f3c">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General method to gather info from handler. </p>
<p>info() is used to return information to the optimizer. SHOW also makes use of this data Another note, if your handler doesn't proved exact record count, you will probably want to have the following in your code: if (records &lt; 2) records = 2; The reason is that the server will optimize for cases of only a single record. If in a table scan you don't know the number of records it will probably be better to set records to two so you can return as many records as you need.</p>
<p>Along with records a few more variables you may wish to set are: records deleted data_file_length index_file_length delete_length check_time Take a look at the public variables in handler.h for more information. See also my_base.h for a full description.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Specifies what info is requested </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classtemptable_1_1Handler.html#adc1271a0f40df7e3901f17b4a59c1741">temptable::Handler</a>, <a class="el" href="classha__example.html#afd3ff83dc6305b49316610ca3c22f1a4">ha_example</a>, <a class="el" href="classha__federated.html#ade69f0c01f17490f12fefcf231690050">ha_federated</a>, <a class="el" href="classha__perfschema.html#aa4b801c2f82827f7741ebd14b05bb73f">ha_perfschema</a>, <a class="el" href="classha__innobase.html#aa73c12cb2f26e5ea83d7a007ae1b1691">ha_innobase</a>, <a class="el" href="classha__tina.html#a3b2ca8e9c6f29d1f2f0648e1d235f0f5">ha_tina</a>, <a class="el" href="classha__archive.html#a435625fd6d311dae230d8ce66589f152">ha_archive</a>, <a class="el" href="classha__myisammrg.html#ab42c99a5d2268c5a9070e0be1e404083">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a2aa1173a938765bc3b07a296363d018a">ha_myisam</a>, <a class="el" href="classha__heap.html#ac274f907bb962c56c1ba796cca459564">ha_heap</a>, <a class="el" href="classha__blackhole.html#a3e05fa10740dcdba1b0755e266ea3154">ha_blackhole</a>, and <a class="el" href="classmock_1_1ha__mock.html#a624ded507088343bb50eeee36b886eaa">mock::ha_mock</a>.</p>

</div>
</div>
<a id="ab1ad6edb66592b200a7c7ac0f947dc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ad6edb66592b200a7c7ac0f947dc66">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called after create to allow us to set up cached variables. </p>

</div>
</div>
<a id="a28dfb73f9401996a25b9cf925db74149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dfb73f9401996a25b9cf925db74149">&#9670;&nbsp;</a></span>init_table_handle_for_HANDLER()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::init_table_handle_for_HANDLER </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#ae82cab28b79211fb36b86459b7cc93b1">temptable::Handler</a>, and <a class="el" href="classha__innobase.html#aafd8b745fdac5b31abd0bd105ee50a08">ha_innobase</a>.</p>

</div>
</div>
<a id="aa878645217548a566d5ea7dd6609f345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa878645217548a566d5ea7dd6609f345">&#9670;&nbsp;</a></span>inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>old_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>new_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and Alter_inplace_info. </p>
<p>The level of concurrency allowed during this operation depends on the return value from check_if_supported_inplace_alter().</p>
<dl class="section note"><dt>Note</dt><dd>Should be no-op for instant algorithm.</dd>
<dd>
Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, commit_inplace_alter_table() will be called with commit= false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td>TABLE object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER TABLE and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">old_table_def</td><td>dd::Table object describing old version of the table. </td></tr>
    <tr><td class="paramname">new_table_def</td><td>dd::Table object for the new version of the table. Can be adjusted by this call if SE supports atomic DDL. These changes to the table definition will be persisted in the data-dictionary at statement commit time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__ALTER__TABLE__INTERFACE.html#gaade6f8038f7afc0bed72e91299ab0243">ha_innobase</a>, and <a class="el" href="group__ONLINE__ALTER__TABLE__INTERFACE.html#ga7b5fc9e5dccb1696b87b17ed0de9c141">ha_innopart</a>.</p>

</div>
</div>
<a id="a6ea4b726707284210cc365ad454add03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea4b726707284210cc365ad454add03">&#9670;&nbsp;</a></span>is_crashed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::is_crashed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the table is crashed. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Crashed </td></tr>
    <tr><td class="paramname">false</td><td>Not crashed </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__myisam.html#a391a5ec692b7f41bdb0aa438b090a032">ha_myisam</a>, <a class="el" href="classha__archive.html#ad92b87bbea60fb3f929b9e14428bd73e">ha_archive</a>, and <a class="el" href="classha__tina.html#a1cecb1d98228af0e60b0bb5065b8169c">ha_tina</a>.</p>

</div>
</div>
<a id="a37413b5d60b340ffe26a6713b65bab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37413b5d60b340ffe26a6713b65bab75">&#9670;&nbsp;</a></span>is_fatal_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::is_fatal_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an error is fatal or not. </p>
<p>This method is used to analyse the error to see whether the error is fatal or not.</p>
<p>This method is used to analyze the error to see whether the error is fatal or not. A fatal error is an error that will not be possible to handle with SP handlers and will not be subject to retry attempts on the slave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code received from the handler interface (HA_ERR_...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the error is fatal or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the error is fatal </td></tr>
    <tr><td class="paramname">false</td><td>the error is not fatal</td></tr>
  </table>
  </dd>
</dl>
<p>Further comments in header file. </p>

</div>
</div>
<a id="a39c5919d6a3f3098353f4517e2c81037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c5919d6a3f3098353f4517e2c81037">&#9670;&nbsp;</a></span>is_ignorable_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::is_ignorable_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an error can be ignored or not. </p>
<p>This method is used to analyse the error to see whether the error is ignorable or not.</p>
<p>This method is used to analyze the error to see whether the error is ignorable or not. Such errors will be reported as warnings instead of errors for IGNORE statements. This means that the statement will not abort, but instead continue to the next row.</p>
<p>HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY, but can in some cases lead to a slightly different error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code received from the handler interface (HA_ERR_...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the error is ignorablel or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the error is ignorable </td></tr>
    <tr><td class="paramname">false</td><td>the error is not ignorable</td></tr>
  </table>
  </dd>
</dl>
<p>Further comments in header file. </p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#aeb93a4712de2dcb666ae68fd178ef078">ha_innopart</a>.</p>

</div>
</div>
<a id="a05f77c614e5852c3058d6b7a1f5d701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f77c614e5852c3058d6b7a1f5d701b">&#9670;&nbsp;</a></span>is_index_algorithm_supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::is_index_algorithm_supported </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a80fc764d5467c7477910728106943783">ha_key_alg</a>&#160;</td>
          <td class="paramname"><em>key_alg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if SE supports specific key algorithm. </p>
<dl class="section note"><dt>Note</dt><dd>This method is never used for FULLTEXT or SPATIAL keys. We rely on handler::ha_table_flags() to check if such keys are supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#ab0d812248a3556b00b431a37cac9fb9c">temptable::Handler</a>, <a class="el" href="classha__myisammrg.html#a923fd6a4fa9f4ce8e27e5a70d6a7bac8">ha_myisammrg</a>, <a class="el" href="classha__innobase.html#a8c73e564960485a3450ed5d6990a52a6">ha_innobase</a>, <a class="el" href="classha__example.html#a454f19ea5dcf138c3e0b842298406e64">ha_example</a>, <a class="el" href="classha__myisam.html#a97eedb12ce417dac9893dd910a99bb0f">ha_myisam</a>, <a class="el" href="classha__blackhole.html#a0c2be938fcdcf80160f650904baccb0f">ha_blackhole</a>, and <a class="el" href="classha__heap.html#a1c16e2a13a6737bc0ffedfec70388d5d">ha_heap</a>.</p>

</div>
</div>
<a id="a9771a747571d6440b274a23d0aa6c43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9771a747571d6440b274a23d0aa6c43b">&#9670;&nbsp;</a></span>is_record_buffer_wanted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::is_record_buffer_wanted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *const&#160;</td>
          <td class="paramname"><em>max_rows</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this handler want to get a Record_buffer for multi-row reads via the ha_set_record_buffer() function? And if so, what is the maximum number of records to allocate space for in the buffer? </p>
<p>Storage engines that support using a Record_buffer should override this function and return true for scans that could benefit from a buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max_rows</td><td>gets set to the maximum number of records to allocate space for in the buffer if the function returns true</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the handler would like a Record_buffer </td></tr>
    <tr><td class="paramname">false</td><td>if the handler does not want a Record_buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a34e2ca85a1df3d0873915209aabb2a21">ha_innobase</a>.</p>

</div>
</div>
<a id="a02950211099f733185515d9ccaa2853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02950211099f733185515d9ccaa2853c">&#9670;&nbsp;</a></span>load_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::load_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE.html">TABLE</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a table into its defined secondary storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table opened in primary storage engine. Its read_set tells which columns to load.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, error code otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classmock_1_1ha__mock.html#a2b606e707bbe6518e86e86fba4336092">mock::ha_mock</a>.</p>

</div>
</div>
<a id="a2447668275a831bcf73b5c00818254a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2447668275a831bcf73b5c00818254a6">&#9670;&nbsp;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::lock_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of lock objects returned in store_lock. </p>
<p>Returns the number of store locks needed in call to store lock. We return number of partitions we will lock multiplied with number of locks needed by each partition. Assists the above functions in allocating sufficient space for lock structures.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of locks returned in call to store_lock.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>lock_count() can return &gt; 1 if the table is MERGE or partitioned. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a9d6b5e69a443ec396cfec6f324a0e4f9">ha_innobase</a>, and <a class="el" href="classha__myisammrg.html#a9afc4dd510c63168bdf281dd96db390a">ha_myisammrg</a>.</p>

</div>
</div>
<a id="aa3a39db9dc1cca31f4a3ec0e0e1d7300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a39db9dc1cca31f4a3ec0e0e1d7300">&#9670;&nbsp;</a></span>lock_shared_ha_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::lock_shared_ha_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a lock for protecting shared handler data. </p>

</div>
</div>
<a id="a64a20da13aaa177f1a256e5fb63e7c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a20da13aaa177f1a256e5fb63e7c78">&#9670;&nbsp;</a></span>low_byte_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::low_byte_first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8556e08dd260c7856c7b5952e316e533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8556e08dd260c7856c7b5952e316e533">&#9670;&nbsp;</a></span>mark_trx_read_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::mark_trx_read_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function to mark a transaction read-write, if it is started. </p>

</div>
</div>
<a id="a9e1b1d6fe7e717fe234c18915cb26e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1b1d6fe7e717fe234c18915cb26e87">&#9670;&nbsp;</a></span>max_key_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_key_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3699689407f76a90ea62a3f5f593e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3699689407f76a90ea62a3f5f593e15">&#9670;&nbsp;</a></span>max_key_part_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_key_part_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1adabba96b635533f31d5e38e6d2a74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adabba96b635533f31d5e38e6d2a74c">&#9670;&nbsp;</a></span>max_key_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_key_parts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a493c1ac62569e6cc89cbfde66fea47f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493c1ac62569e6cc89cbfde66fea47f3">&#9670;&nbsp;</a></span>max_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ee9c5a03956913d75de1fca3af7833a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee9c5a03956913d75de1fca3af7833a">&#9670;&nbsp;</a></span>max_record_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_record_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c2216dba316fe13117f00e8d21cbdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2216dba316fe13117f00e8d21cbdab">&#9670;&nbsp;</a></span>max_supported_key_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_supported_key_length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a24b1e3716429e993c0d595348b625e93">temptable::Handler</a>, <a class="el" href="classha__federated.html#a0356d0754701db68d58453d743312e3f">ha_federated</a>, <a class="el" href="classha__example.html#aa3a8afe52c1d9c207bdf4cdf727bb10b">ha_example</a>, <a class="el" href="classha__archive.html#a238ebb9e0c255854bac159eb5eb75402">ha_archive</a>, <a class="el" href="classha__perfschema.html#abdc582b54537a5782a7508fe7192678f">ha_perfschema</a>, <a class="el" href="classha__myisammrg.html#a6ebeb7747ed819f769a2f3e52d4cc1bd">ha_myisammrg</a>, <a class="el" href="classha__innobase.html#a92dfcee2676166f64d87d561aebbe813">ha_innobase</a>, <a class="el" href="classha__myisam.html#ad77014b9bb99b3a4d85a0380b446aae7">ha_myisam</a>, and <a class="el" href="classha__blackhole.html#a6b499d5278a857a80931a98411e3c978">ha_blackhole</a>.</p>

</div>
</div>
<a id="a44a45b6e069b4c13b85bdaf4992f7828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a45b6e069b4c13b85bdaf4992f7828">&#9670;&nbsp;</a></span>max_supported_key_part_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_supported_key_part_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#aaeecca65bdb1b067b8d1908df0278818">temptable::Handler</a>, <a class="el" href="classha__federated.html#a6a5dcdb1385a55fe500c05dcbfb84613">ha_federated</a>, <a class="el" href="classha__archive.html#addbd6752c3f70715ece391bdcab6861e">ha_archive</a>, <a class="el" href="classha__perfschema.html#ab29b2c8d4607ad31d9f4ec5d7b939df2">ha_perfschema</a>, <a class="el" href="classha__myisammrg.html#ab8f5d2dfddc6ca18507e5110169ad5ac">ha_myisammrg</a>, <a class="el" href="classha__innobase.html#a5d98d1b9c8e9874003e01132a1ac5641">ha_innobase</a>, <a class="el" href="classha__myisam.html#a54efc2ac5beecb47acf10fe9c1012916">ha_myisam</a>, <a class="el" href="classha__blackhole.html#ad7d86096e77709368b333afe84767ef7">ha_blackhole</a>, and <a class="el" href="classha__heap.html#adf9629d7277a2c6e413a03b80178018a">ha_heap</a>.</p>

</div>
</div>
<a id="a25d5b6de2843435371dc9045403e3d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d5b6de2843435371dc9045403e3d07">&#9670;&nbsp;</a></span>max_supported_key_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_supported_key_parts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__federated.html#ae82458f4b941747a0dd59c5a46151efd">ha_federated</a>, <a class="el" href="classha__example.html#ab6f215f39e49e512f1ab9902e1d29ce1">ha_example</a>, and <a class="el" href="classha__perfschema.html#adc7ebedd5316130d9004a6fe5242d460">ha_perfschema</a>.</p>

</div>
</div>
<a id="a9c7b335988ea24ea8b685c4278442cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7b335988ea24ea8b685c4278442cf8">&#9670;&nbsp;</a></span>max_supported_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_supported_keys </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__federated.html#af99074f9db9cafcb356acaf79cce43eb">ha_federated</a>, <a class="el" href="classha__example.html#ad6bd9090df6e0ecbe5b987fb8bc99065">ha_example</a>, <a class="el" href="classha__archive.html#ad610e1a30c0eea30b981471cfd82c0df">ha_archive</a>, <a class="el" href="classha__perfschema.html#a0335ee97561f0a1eec13daab94a47209">ha_perfschema</a>, <a class="el" href="classha__myisammrg.html#a1e85ffc65de7cdae3b728c7116f31dc4">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a64050625c8a702620d59139ae6749bd4">ha_myisam</a>, <a class="el" href="classha__innobase.html#aa9b40d6aceeb7c9927d8765861e22bd7">ha_innobase</a>, <a class="el" href="classha__blackhole.html#aa9131377743b1e2d800a957016684ef9">ha_blackhole</a>, and <a class="el" href="classha__heap.html#af11433df3b3114bb71ab7efe8acfec63">ha_heap</a>.</p>

</div>
</div>
<a id="a672a498859c2d47448100e5e703622bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672a498859c2d47448100e5e703622bb">&#9670;&nbsp;</a></span>max_supported_record_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::max_supported_record_length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__federated.html#ab406225504a33444da58e1fda06f132e">ha_federated</a>, <a class="el" href="classha__example.html#a596a6977475f9a3cf4a1d55600d50ccc">ha_example</a>, and <a class="el" href="classha__perfschema.html#ad47bf2e8953a0bcaaafb26ef0b427c6a">ha_perfschema</a>.</p>

</div>
</div>
<a id="a777443226094990f74c6008c8a67168b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777443226094990f74c6008c8a67168b">&#9670;&nbsp;</a></span>member_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structTABLE.html">TABLE</a>* handler::member_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this handler instance is part of a pushed join sequence returned TABLE instance being root of the pushed query? </p>

</div>
</div>
<a id="ab082d2a49764e8548b8104dc514877b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab082d2a49764e8548b8104dc514877b3">&#9670;&nbsp;</a></span>min_record_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::min_record_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5add40a6cd7088ffef25a3816294b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5add40a6cd7088ffef25a3816294b624">&#9670;&nbsp;</a></span>multi_range_read_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> handler::multi_range_read_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cost and other information about MRR scan over some sequence of ranges. </p>
<p>Calculate estimated cost and other information about an MRR scan for some sequence of ranges.</p>
<p>The ranges themselves will be known only at execution phase. When this function is called we only know number of ranges and a (rough) E(records) within those ranges.</p>
<p>Currently this function is only called for "n-keypart singlepoint" ranges, i.e. each range is "keypart1=someconst1 AND ... AND keypartN=someconstN"</p>
<p>The flags parameter is a combination of those flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION, HA_MRR_LIMITS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n_ranges</td><td>Estimated number of ranges (i.e. intervals) in the range sequence. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n_rows</td><td>Estimated total number of records contained within all of the ranges </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufsz</td><td>IN: Size of the buffer available for use OUT: Size of the buffer that will be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">flags</td><td>A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cost</td><td>Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
    <tr><td class="paramname">other</td><td>Error or can't perform the requested scan </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a3bf8d905383ec74b3283d40cd9c3aa51">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a9bb7ae575cfa597114a8eb778599bb7b">ha_myisam</a>.</p>

</div>
</div>
<a id="a5ee356d2340552eb121d423fc01597f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee356d2340552eb121d423fc01597f8">&#9670;&nbsp;</a></span>multi_range_read_info_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> handler::multi_range_read_info_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cost and other information about MRR scan over a known list of ranges. </p>
<p>Calculate estimated cost and other information about an MRR scan for given sequence of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;init() </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n_ranges_arg</td><td>Number of ranges in the sequence, or 0 if the caller can't efficiently determine it </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufsz</td><td>IN: Size of the buffer available for use OUT: Size of the buffer that is expected to be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">flags</td><td>A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cost</td><td>Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method (or an overriding one in a derived class) must check for <code>thd-&gt;killed</code> and return HA_POS_ERROR if it is not zero. This is required for a user to be able to interrupt the calculation by killing the connection/query.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_POS_ERROR</td><td>Error or the engine is unable to perform the requested scan. Values of OUT parameters are undefined. </td></tr>
    <tr><td class="paramname">other</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#ae7f9cc89de8eea56d8a6bd661ab1c440">ha_innobase</a>, and <a class="el" href="classha__myisam.html#aef1908515808ca1af962a010c1cf131a">ha_myisam</a>.</p>

</div>
</div>
<a id="a33e8899f4bae262b6b91c7284f1d946e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e8899f4bae262b6b91c7284f1d946e">&#9670;&nbsp;</a></span>multi_range_read_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::multi_range_read_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the MRR scan. </p>
<p>This function may do heavyweight scan initialization like row prefetching/sorting/etc (NOTE: but better not do it here as we may not need it, e.g. if we never satisfy WHERE clause on previous tables. For many implementations it would be natural to do such initializations in the first multi_read_range_next() call)</p>
<p>mode is a combination of the following flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_funcs</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;init() </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Number of ranges in the sequence </td></tr>
    <tr><td class="paramname">mode</td><td>Flags, see the description section for the details </td></tr>
    <tr><td class="paramname">buf</td><td>INOUT: memory buffer to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One must have called index_init() before calling this function. Several multi_range_read_init() calls may be made in course of one query.</dd></dl>
<p>Until WL#2623 is done (see its text, section 3.2), the following will also hold: The caller will guarantee that if "seq-&gt;init == mrr_ranges_array_init" then seq_init_param is an array of n_ranges KEY_MULTI_RANGE structures. This property will only be used by NDB handler until WL#2623 is done.</p>
<p>Buffer memory management is done according to the following scenario: The caller allocates the buffer and provides it to the callee by filling the members of HANDLER_BUFFER structure. The callee consumes all or some fraction of the provided buffer space, and sets the HANDLER_BUFFER members accordingly. The callee may use the buffer memory until the next multi_range_read_init() call is made, all records have been read, or until index_end() call is made, whichever comes first.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a78a2d449b902956fe2c9fd93dde38115">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a78c641ab04f3be642a4b66f64d8b7a6b">ha_myisam</a>.</p>

</div>
</div>
<a id="a3419071f3d4abf183dac95ef565adfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3419071f3d4abf183dac95ef565adfff">&#9670;&nbsp;</a></span>multi_range_read_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::multi_range_read_next </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next record in MRR scan. </p>
<p>Default MRR implementation: read the next record</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_info</td><td>OUT Undefined if HA_MRR_NO_ASSOCIATION flag is in effect Otherwise, the opaque value associated with the range that contains the returned record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a5f55001fcfd247fc65e444392e36659d">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a5c93799154c5e0b2494eabb0df94175d">ha_myisam</a>.</p>

</div>
</div>
<a id="ad010849c65ff0fb7630ab7af27887741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad010849c65ff0fb7630ab7af27887741">&#9670;&nbsp;</a></span>mv_key_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::mv_key_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>keys_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Engine-specific function for ha_can_store_mv_keys(). </p>
<p>Dummy function. SE's overloaded method is used instead. </p>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a00aa41314a91727810c195bde3843bdb">ha_innobase</a>.</p>

</div>
</div>
<a id="aff12cbff0ca6dad2c5565b8930ff698b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff12cbff0ca6dad2c5565b8930ff698b">&#9670;&nbsp;</a></span>my_eval_gcolumn_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::my_eval_gcolumn_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *const&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>mv_data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *&#160;</td>
          <td class="paramname"><em>mv_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback for computing generated column values. </p>
<p>Storage engines that need to have virtual column values for a row can use this function to get the values computed. The storage engine must have filled in the values for the base columns that the virtual columns depend on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>table object </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fields</td><td>bitmap of field index of evaluated generated column </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">record</td><td>buff of base columns generated column depends. After calling this function, it will be used to return the value of the generated columns. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mv_data_ptr</td><td>When given (not null) and the field needs to be calculated is a typed array field, it will contain pointer to field's calculated value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mv_length</td><td>Length of the data above</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>in case of error </td></tr>
    <tr><td class="paramname">false</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1bedac06ed1345e080b5eb35075ac17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bedac06ed1345e080b5eb35075ac17">&#9670;&nbsp;</a></span>my_eval_gcolumn_expr_with_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::my_eval_gcolumn_expr_with_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *const&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>mv_data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> *&#160;</td>
          <td class="paramname"><em>mv_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback for generated columns processing. </p>
<p>Will open the table, in the server <em>only</em>, and call my_eval_gcolumn_expr_helper() to do the actual processing. This function is a variant of the other handler::my_eval_gcolumn_expr() but is intended for use when no TABLE object already exists - e.g. from purge threads.</p>
<p>Note! The call to open_table_uncached() must be made with the second-to-last argument (open_in_engine) set to false. Failing to do so will cause deadlocks and incorrect behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">db_name</td><td>database containing the table to open </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_name</td><td>name of table to open </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fields</td><td>bitmap of field index of evaluated generated column </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">record</td><td>record buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mv_data_ptr</td><td>For a typed array field in this arg the pointer to its value is returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mv_length</td><td>Length of the value above</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of error, false otherwise. </dd></dl>

</div>
</div>
<a id="aa6c449e2194c590eb53b6a6b5dbb362c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c449e2194c590eb53b6a6b5dbb362c">&#9670;&nbsp;</a></span>my_prepare_gcolumn_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::my_prepare_gcolumn_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a>&#160;</td>
          <td class="paramname"><em>myc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ib_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback to allow InnoDB to prepare a template for generated column processing. </p>
<p>This function will open the table without opening in the engine and call the provided function with the TABLE object made. The function will then close the TABLE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">db_name</td><td>Name of database containing the table </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table to open </td></tr>
    <tr><td class="paramname">myc</td><td>InnoDB function to call for processing TABLE </td></tr>
    <tr><td class="paramname">ib_table</td><td>Argument for InnoDB function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of error, false otherwise. </dd></dl>

</div>
</div>
<a id="a9ac6921759060b252db86f800e46fc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac6921759060b252db86f800e46fc99">&#9670;&nbsp;</a></span>notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::notify_table_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the storage engine that the table definition has been updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes done by ALTER TABLE and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No errors are allowed during notify_table_changed().</dd>
<dd>
For storage engines supporting atomic DDL this method is invoked after the whole ALTER TABLE is completed and committed. Particularly this means that for ALTER TABLE statements with RENAME clause TABLE/handler object used for invoking this method will be associated with new table name. If storage engine needs to know the old schema and table name in this method for some reason it has to use ha_alter_info object to figure it out. </dd></dl>

</div>
</div>
<a id="a86930bf10b20ad19b3df07e07d28116e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86930bf10b20ad19b3df07e07d28116e">&#9670;&nbsp;</a></span>number_of_pushed_joins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::number_of_pushed_joins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports number of tables included in pushed join which this handler instance is part of. </p>
<p>==0 -&gt; Not pushed </p>

</div>
</div>
<a id="a12158d5ad8caae47ffe4ac111adb65fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12158d5ad8caae47ffe4ac111adb65fe">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>test_if_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga66a08d8985fdef61524c17bb9b704096">ha_innopart</a>, <a class="el" href="classha__federated.html#a327d10be521311c920b73e31b8ef82e9">ha_federated</a>, <a class="el" href="classha__example.html#ab94a847ff70b2ff3402a74c2de2b059c">ha_example</a>, <a class="el" href="classtemptable_1_1Handler.html#a1bacbfbf24fadab2563dd4304873245e">temptable::Handler</a>, <a class="el" href="classha__tina.html#a89093d53f625edc0ef44767138c7d208">ha_tina</a>, <a class="el" href="classha__perfschema.html#a2de6d7694e0044c170c11148a25e9566">ha_perfschema</a>, <a class="el" href="classha__archive.html#acb11e1d6a97d92f854f26bbd92982f98">ha_archive</a>, <a class="el" href="classha__myisammrg.html#a3e484ab0760d2ddf6ba84fc2e0153745">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a511d30e90e2469c20f3383a003835579">ha_myisam</a>, <a class="el" href="classha__innobase.html#a928d9a737a350ec3bdc246bce46c469a">ha_innobase</a>, <a class="el" href="classha__blackhole.html#a1efdb6f9678ab95b34a86c2214dd93c4">ha_blackhole</a>, <a class="el" href="classha__heap.html#a6956c0649e4b9b069edf51a6e448de57">ha_heap</a>, and <a class="el" href="classmock_1_1ha__mock.html#abd6c8be6916030c108555ad1d8967157">mock::ha_mock</a>.</p>

</div>
</div>
<a id="ac8025ebb1cabba85cdf0df9c8a1b7c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8025ebb1cabba85cdf0df9c8a1b7c6f">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#aaa96013074dbfdbe12770091abb8ed8e">temptable::Handler</a>, <a class="el" href="classha__innopart.html#ac5f876f83625935a5f402272f694df23">ha_innopart</a>, <a class="el" href="classha__federated.html#af9b7546007cc126dbcde5393e9929052">ha_federated</a>, <a class="el" href="classha__innobase.html#afa2b8a0b92d0997d0fa57ccc83968f80">ha_innobase</a>, <a class="el" href="classha__myisam.html#afc17e3e6499f9287ad6a29402af59383">ha_myisam</a>, and <a class="el" href="classha__archive.html#aeba10ffb5546ac53d2ccced7a7d162fb">ha_archive</a>.</p>

</div>
</div>
<a id="aebd6632fba224ccdaf229a9886cbe0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd6632fba224ccdaf229a9886cbe0b4">&#9670;&nbsp;</a></span>parallel_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::parallel_scan </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>thread_ctxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">Load_init_cbk</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">Load_cbk</a>&#160;</td>
          <td class="paramname"><em>load_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html#a24e65d325f0e08107186740bcb248756">Load_end_cbk</a>&#160;</td>
          <td class="paramname"><em>end_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the parallel read of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>Scan context of the parallel read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thread_ctxs</td><td>Caller thread contexts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback called by each parallel load thread at the beginning of the parallel load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_fn</td><td>Callback called by each parallel load thread when processing of rows is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_fn</td><td>Callback called by each parallel load thread when processing of rows has ended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ac77cf6540726d6766e92597dbca4bb58">ha_innopart</a>, and <a class="el" href="classha__innobase.html#a6bf884273500d55cfae842aa7bd0159b">ha_innobase</a>.</p>

</div>
</div>
<a id="a680f73512eef288b1ddca958933c2016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680f73512eef288b1ddca958933c2016">&#9670;&nbsp;</a></span>parallel_scan_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::parallel_scan_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of the parallel scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>A scan context created by parallel_scan_init. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a197dfbb668e3e7f046d434b404bc90e3">ha_innopart</a>, and <a class="el" href="classha__innobase.html#ad68072931c05a5c76b2a9d251f130672">ha_innobase</a>.</p>

</div>
</div>
<a id="a826010c8deb55ee4435b1b3fc18fe7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826010c8deb55ee4435b1b3fc18fe7a0">&#9670;&nbsp;</a></span>parallel_scan_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::parallel_scan_init </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_reserved_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a parallel scan. </p>
<p>It creates a parallel_scan_ctx that has to be used across all parallel_scan methods. Also, gets the number of threads that would be spawned for parallel scan. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">scan_ctx</td><td>The parallel scan context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_threads</td><td>Number of threads used for the scan. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_reserved_threads</td><td>true if reserved threads are to be used if we exhaust the max cap of number of parallel read threads that can be spawned at a time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#acfc3fdafebbca7392369159b706842b6">ha_innopart</a>, and <a class="el" href="classha__innobase.html#ad5a01c18a2f2badc827709aef7151482">ha_innobase</a>.</p>

</div>
</div>
<a id="aaef865015edc575d0a50d1a6f5b13e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef865015edc575d0a50d1a6f5b13e4a">&#9670;&nbsp;</a></span>parent_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structTABLE.html">TABLE</a>* handler::parent_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this handler instance is a child in a pushed join sequence returned TABLE instance being my parent? </p>

</div>
</div>
<a id="ad3c1515e7a936fa9cbc19f93d43495b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c1515e7a936fa9cbc19f93d43495b6">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classha__innopart.html#ac36839a8e456e5ea2f6322c9a9746f1f">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a6c9a51605bde4fa4c94a8f73c2b2444d">temptable::Handler</a>, <a class="el" href="classha__example.html#a9bfc00bdbde189aedca3c4a8b82d3ea0">ha_example</a>, <a class="el" href="classha__federated.html#ac961b27ff59c148b220aafbab1e1bb55">ha_federated</a>, <a class="el" href="classha__perfschema.html#a4ccdfc1055b907edde2f8b03bb6353fc">ha_perfschema</a>, <a class="el" href="classha__innobase.html#a74733f5cbd26a05bab60b709071a1053">ha_innobase</a>, <a class="el" href="classha__tina.html#adf1dad012d5ee487b99d98a274d45ec5">ha_tina</a>, <a class="el" href="classha__archive.html#ac917b720d698eedcf5628372cba3ceca">ha_archive</a>, <a class="el" href="classha__myisam.html#a4128c431384646964bfe3400da406c8b">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#a299c7bcf7f41cb5f9fbafa7af2e97dd4">ha_myisammrg</a>, <a class="el" href="classha__heap.html#a8fbc891f2e7f4dbbbacad7a939466fd3">ha_heap</a>, <a class="el" href="classha__blackhole.html#a5771f8833cf5ac4f18336a55946d46a9">ha_blackhole</a>, and <a class="el" href="classmock_1_1ha__mock.html#a5ae753035db677f1a8db182928f8f7cb">mock::ha_mock</a>.</p>

</div>
</div>
<a id="a49396e778b671ffd7eade208e0e32054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49396e778b671ffd7eade208e0e32054">&#9670;&nbsp;</a></span>preload_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::preload_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__myisam.html#a74439c287be913d4322aa4451a7ca486">ha_myisam</a>.</p>

</div>
</div>
<a id="aafaacf167ca0a32694e0074b86e11e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaacf167ca0a32694e0074b86e11e89">&#9670;&nbsp;</a></span>prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>old_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>new_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the storage engine to update internal structures with concurrent writes blocked. </p>
<p>If check_if_supported_inplace_alter() returns HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE or HA_ALTER_INPLACE_SHARED_AFTER_PREPARE, this function is called with exclusive lock otherwise the same level of locking as for inplace_alter_table() will be used.</p>
<dl class="section note"><dt>Note</dt><dd>Should be no-op for instant algorithm.</dd>
<dd>
Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, commit_inplace_alter_table() will be called with commit= false.</dd>
<dd>
For partitioning, failing to prepare one partition, means that commit_inplace_alter_table() will be called to roll back changes for all partitions. This means that commit_inplace_alter_table() might be called without prepare_inplace_alter_table() having been called first for a given partition.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td>TABLE object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER TABLE and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">old_table_def</td><td>dd::Table object describing old version of the table. </td></tr>
    <tr><td class="paramname">new_table_def</td><td>dd::Table object for the new version of the table. Can be adjusted by this call if SE supports atomic DDL. These changes to the table definition will be persisted in the data-dictionary at statement commit time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__ALTER__TABLE__INTERFACE.html#gabcf0978ed576288f07bcda60b1212b53">ha_innobase</a>, and <a class="el" href="group__ONLINE__ALTER__TABLE__INTERFACE.html#ga52d6e17b176981ecbae9a2e81393853b">ha_innopart</a>.</p>

</div>
</div>
<a id="a1c885f4b3b5bf6d2878225a188b5599f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c885f4b3b5bf6d2878225a188b5599f">&#9670;&nbsp;</a></span>primary_key_is_clustered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::primary_key_is_clustered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the primary key is clustered or not. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Primary key (if there is one) is a clustered key covering all fields </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a38dc4611e23a621aa20fbf548e9d038c">temptable::Handler</a>, and <a class="el" href="classha__innobase.html#a436003354606af48dbce6de74e4e8b86">ha_innobase</a>.</p>

</div>
</div>
<a id="afda4f1390385a4dc0bfd2981fee23e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda4f1390385a4dc0bfd2981fee23e6c">&#9670;&nbsp;</a></span>print_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::print_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a0db1f888c3bc329e7b0b340dbd41eb2b">myf</a>&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print error that we got from handler function. </p>
<dl class="section note"><dt>Note</dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ad45df6782f4a82239685ab9efde642d4">ha_innopart</a>, and <a class="el" href="classha__perfschema.html#ac1e383d42d7570c1d191538e21e9031a">ha_perfschema</a>.</p>

</div>
</div>
<a id="a196d85fe55a71cc09c642592e771b662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196d85fe55a71cc09c642592e771b662">&#9670;&nbsp;</a></span>read_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCost__estimate.html">Cost_estimate</a> handler::read_cost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost estimate for reading a set of ranges from the table using an index to access it. </p>
<dl class="section note"><dt>Note</dt><dd>For this version it is recommended that storage engines continue to override read_time() instead of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index number </td></tr>
    <tr><td class="paramname">ranges</td><td>the number of ranges to be read </td></tr>
    <tr><td class="paramname">rows</td><td>total number of rows to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated cost </dd></dl>

</div>
</div>
<a id="a3a0d596ff3ddc77b4f0ad990c4c4cb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">&#9670;&nbsp;</a></span>read_range_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_range_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read first row between two ranges. </p>
<p>Store ranges for future calls to read_range_next.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#ab158d52ba2f106fa837b8ec424618d10">ha_innopart</a>, <a class="el" href="classha__federated.html#a7305fd923e361b458d909e020a615749">ha_federated</a>, and <a class="el" href="classha__innobase.html#aefe5d93d70b0a29facf31a419025db83">ha_innobase</a>.</p>

</div>
</div>
<a id="ae4632aa56c9c66a57558f849f8e01271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4632aa56c9c66a57558f849f8e01271">&#9670;&nbsp;</a></span>read_range_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a7804617e6e16bb1585ddeeab21e28039">ha_innopart</a>, <a class="el" href="classha__federated.html#aef5534f6ab158634d5dd2ebd042f5d0a">ha_federated</a>, and <a class="el" href="classha__innobase.html#abf847dd084d581e207005c608d0c3a32">ha_innobase</a>.</p>

</div>
</div>
<a id="a061b519fb16fbff126b0e21530973c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061b519fb16fbff126b0e21530973c2e">&#9670;&nbsp;</a></span>read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double handler::read_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cost of reading a set of ranges from the table using an index to access it. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>This function is deprecated and will be removed in a future version. Use read_cost() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index number. </td></tr>
    <tr><td class="paramname">ranges</td><td>The number of ranges to be read. </td></tr>
    <tr><td class="paramname">rows</td><td>Total number of rows to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to calculate the total cost of scanning a table using an index by calling it using read_time(index, 1, table_size). </p>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#aa374aa124f71e2aefe1d9f113bbd39ec">temptable::Handler</a>, <a class="el" href="classha__federated.html#a75dc79ae7890a52a4f20e1d09fa06f23">ha_federated</a>, <a class="el" href="classha__example.html#a7a360b089da0067424aa7905675fda56">ha_example</a>, <a class="el" href="classha__innobase.html#af5d4680d4c79132b72063091b54c8d34">ha_innobase</a>, and <a class="el" href="classha__heap.html#a77d3ab10936d3aef6628cb34949bc588">ha_heap</a>.</p>

</div>
</div>
<a id="a1e335a403d8203854bc5b94111992b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e335a403d8203854bc5b94111992b79">&#9670;&nbsp;</a></span>rebind_psi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::rebind_psi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d2371385a8f73f1258965f5f7cfdf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2371385a8f73f1258965f5f7cfdf93">&#9670;&nbsp;</a></span>records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::records </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>num_rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows in table. </p>
<p>If HA_COUNT_ROWS_INSTANT is set, count is available instantly. Else do a table scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>[out] num_rows number of rows in table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a240eacfa94d0cb64105cfbed5a383ed8">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a807ef10d11b75d6ba8001dd639b04cae">temptable::Handler</a>, <a class="el" href="classha__innobase.html#a95463460839f5ffce360cf02024da29b">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a14767bfb0e4717921b417ab78d68ac8b">ha_myisammrg</a>, and <a class="el" href="classha__archive.html#acbf66cf2757bf16fcad68513784e335f">ha_archive</a>.</p>

</div>
</div>
<a id="a11a4096cff6dd66d0fa5cbb5992f3169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a4096cff6dd66d0fa5cbb5992f3169">&#9670;&nbsp;</a></span>records_from_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::records_from_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows in table counted using the secondary index chosen by optimizer. </p>
<p>See comments in optimize_aggregated_query() .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rows</td><td>[out] Number of rows in table. </td></tr>
    <tr><td class="paramname">index</td><td>Index chosen by optimizer for counting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a84ab468112746def6ef39168d0f28225">ha_innopart</a>, and <a class="el" href="classha__innobase.html#a20799b459cb132c6ec4aa643e3d4d946">ha_innobase</a>.</p>

</div>
</div>
<a id="a33ac874ad6fd5a2e6b97376befacb165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac874ad6fd5a2e6b97376befacb165">&#9670;&nbsp;</a></span>records_in_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> handler::records_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>inx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>min_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>max_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find number of records in a range. </p>
<p>Given a starting key, and an ending key estimate the number of rows that will exist between the two. max_key may be empty which in case determine if start_key matches any rows. Used by optimizer to calculate cost of using a particular index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inx</td><td>Index number </td></tr>
    <tr><td class="paramname">min_key</td><td>Start of range </td></tr>
    <tr><td class="paramname">max_key</td><td>End of range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of rows in range. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innopart.html#a48dc6d640d137eb38317cf19e621e3fa">ha_innopart</a>, <a class="el" href="classha__federated.html#ad0e1bddfa8423cfd05c8ae18291f4831">ha_federated</a>, <a class="el" href="classha__example.html#a93e07d794c32bdef3f83979465df01ac">ha_example</a>, <a class="el" href="classha__innobase.html#a583aa37f0683cb54012bc9804e268737">ha_innobase</a>, <a class="el" href="classha__myisam.html#aba918d9390fa22bdd6dec6dd0967d6ea">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#aea348fa16d901554db25358a222d9b7a">ha_myisammrg</a>, <a class="el" href="classha__heap.html#aee5ef00aa848213f75dc0fe5d98f9d9a">ha_heap</a>, and <a class="el" href="classmock_1_1ha__mock.html#a95195ecc8009b923b0866638642aac18">mock::ha_mock</a>.</p>

</div>
</div>
<a id="ae3c86ff21b8c2db61977f93746bb6727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c86ff21b8c2db61977f93746bb6727">&#9670;&nbsp;</a></span>release_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::release_auto_increment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innopart.html#a8c0d26f8aa4a03b7fce16e595d19b7ee">ha_innopart</a>, and <a class="el" href="classha__innobase.html#ada5ed7bbf91a0eddc4ce709a378215dd">ha_innobase</a>.</p>

</div>
</div>
<a id="a9fde9c902c411ed3ccd8e6ca8e99b2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fde9c902c411ed3ccd8e6ca8e99b2e9">&#9670;&nbsp;</a></span>rename_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>from_table_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>to_table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default rename_table() and delete_table() rename/delete files with a given name and extensions from handlerton::file_extensions. </p>
<p>These methods can be overridden, but their default implementation provide useful functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Path for the old table name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Path for the new table name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_table_def</td><td>Old version of definition for table being renamed (i.e. prior to rename). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">to_table_def</td><td>New version of definition for table being renamed. Storage engines which support atomic DDL (i.e. having HTON_SUPPORTS_ATOMIC_DDL flag set) are allowed to adjust this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>Error. </td></tr>
    <tr><td class="paramname">0</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a5df5ac96106f2c427c12c5de21ab1955">temptable::Handler</a>, <a class="el" href="classha__innopart.html#a3e6de240a7efecddd94ca0c2b27b6add">ha_innopart</a>, <a class="el" href="classha__innobase.html#a7da78c60f55e2141137af9a0846b2e9e">ha_innobase</a>, <a class="el" href="classha__example.html#ac7cbdcb48008b8fc8886a4dff2fe0aa4">ha_example</a>, <a class="el" href="classha__perfschema.html#a405b925cbd59e7096b1580dd98d6bb4c">ha_perfschema</a>, <a class="el" href="classha__myisam.html#a8960ca5d20b49c895ed532a833f5a924">ha_myisam</a>, and <a class="el" href="classha__heap.html#ae0f8809086b8f927dee6ef40e1e91509">ha_heap</a>.</p>

</div>
</div>
<a id="a02b135bbe1f8a1b6de46b9c45618c9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b135bbe1f8a1b6de46b9c45618c9f8">&#9670;&nbsp;</a></span>repair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::repair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHA__CHECK__OPT.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In this method check_opt can be modified to specify CHECK option to use to call check() upon the table. </p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#af71544e8990eca41b9590a2bdc77790f">ha_innopart</a>, <a class="el" href="classha__federated.html#a9d7f7f8b1a8da9f0e8c09783577cece6">ha_federated</a>, <a class="el" href="classha__myisam.html#ae7d9ff20704d46b6686790060cee84b0">ha_myisam</a>, <a class="el" href="classha__archive.html#a595e9a05a8c019b5dda7328bb3b1b0f0">ha_archive</a>, and <a class="el" href="classha__tina.html#a087ffecc76b539cc6679534030cb764c">ha_tina</a>.</p>

</div>
</div>
<a id="a1161c615e45f4bd9c285a0e3c1e332af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1161c615e45f4bd9c285a0e3c1e332af">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset state of file to after 'open'. </p>
<p>This function is called after every statement for all tables used by that statement. </p>

<p>Reimplemented in <a class="el" href="classha__innopart.html#adaa0c9dde8956878db8ca937138f3462">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a87e80164279d8009495783e9b5a43897">temptable::Handler</a>, <a class="el" href="classha__federated.html#a59f2f5bd61aa865671e37058eefffcff">ha_federated</a>, <a class="el" href="classha__innobase.html#a056b13565fedbaf700d52c15d3145b0d">ha_innobase</a>, <a class="el" href="classha__myisam.html#af7cc36f6a0a0c27c0111e76c29e2870f">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#a1e1d4c899209d2b12242d26e73ad1ef4">ha_myisammrg</a>, and <a class="el" href="classha__heap.html#acad2ca04dabda48d0112476cfe754226">ha_heap</a>.</p>

</div>
</div>
<a id="a15b51670b2497f01f19f587a4a969386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b51670b2497f01f19f587a4a969386">&#9670;&nbsp;</a></span>restore_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::restore_auto_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>prev_insert_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a590d32e2e1c26e4e9dcfc8228750b0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590d32e2e1c26e4e9dcfc8228750b0ab">&#9670;&nbsp;</a></span>rnd_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#gac16c679b99fbcf88b1651e50726b8b6b">ha_innopart</a>, <a class="el" href="classha__example.html#a663c671629a0feb376a008a178b710a8">ha_example</a>, <a class="el" href="classha__federated.html#ad60721521ecb611fa8234a45ec81b36b">ha_federated</a>, <a class="el" href="classtemptable_1_1Handler.html#ae3c3cb7f34ab4ec4a4a2067c4c723caf">temptable::Handler</a>, <a class="el" href="classha__perfschema.html#ae1925991d89bb918052629283f31ee66">ha_perfschema</a>, <a class="el" href="classha__innobase.html#a4f3100a96ea13005f90e2b65e391f9eb">ha_innobase</a>, <a class="el" href="classha__tina.html#a7ea3a08f04e0e0e841eab33c04fb4d0d">ha_tina</a>, and <a class="el" href="classha__myisam.html#aba8deb9265e154670d13939b68941d7b">ha_myisam</a>.</p>

</div>
</div>
<a id="a9ddfc5530e45a9340e2de99626085da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddfc5530e45a9340e2de99626085da6">&#9670;&nbsp;</a></span>rnd_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rnd_init() can be called two times without rnd_end() in between (it only makes sense if scan=1). </p>
<p>then the second call should prepare for the new table scan (e.g if rnd_init allocates the cursor, second call should position it to the start of the table, no need to deallocate and allocate it again </p>

<p>Implemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga251b5008a845bb57a23b38a8c339c90f">ha_innopart</a>, <a class="el" href="classha__example.html#a160c1bb92f69e17feb7ba684d400b7c6">ha_example</a>, <a class="el" href="classha__federated.html#ad9b5666de6ce890c44402ec0d9dcf7c2">ha_federated</a>, <a class="el" href="classtemptable_1_1Handler.html#a490d6249ef6311aefffb0d0c053f8b3c">temptable::Handler</a>, <a class="el" href="classha__perfschema.html#aabb0d35c53fa0dce93c28597996712c3">ha_perfschema</a>, <a class="el" href="classha__innobase.html#a6a8e8805da5c40b0ab44d83815865aa6">ha_innobase</a>, <a class="el" href="classha__tina.html#a45bf179760cc049c2cf46c674bc35756">ha_tina</a>, <a class="el" href="classha__archive.html#a5b11cb4bdbd4d6475a1e85636303a07a">ha_archive</a>, <a class="el" href="classha__myisam.html#a92b13a8f3632c94d4840b1569fe637e5">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#a6ab42770aaf8b701d69d33679ffc4567">ha_myisammrg</a>, <a class="el" href="classha__heap.html#ae2a15e15e7c1586a3aa807cfa45f93ff">ha_heap</a>, <a class="el" href="classha__blackhole.html#abc348e8e7597d045ca315655b89b0fc2">ha_blackhole</a>, and <a class="el" href="classmock_1_1ha__mock.html#a2029f43d742ede96e87188ddaa79a0ed">mock::ha_mock</a>.</p>

</div>
</div>
<a id="a48cb9c94ca93dbfbb7e92822caba82a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cb9c94ca93dbfbb7e92822caba82a1">&#9670;&nbsp;</a></span>rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Implemented in <a class="el" href="classha__innopart.html#a06e882ae034f6be670c486332d281ec0">ha_innopart</a>, <a class="el" href="classha__example.html#ad2caf4db029c90824a7ee40385cf6c48">ha_example</a>, <a class="el" href="classha__federated.html#a29fd190c7384d657a4ba2e3bcc9260e7">ha_federated</a>, <a class="el" href="classtemptable_1_1Handler.html#ae0113765ec36507e6616e540c9af5647">temptable::Handler</a>, <a class="el" href="classha__perfschema.html#af5fac9dbd8ce25da9412c6af319cf783">ha_perfschema</a>, <a class="el" href="classha__innobase.html#a65b2dc1d51146907892ccb345aff9c94">ha_innobase</a>, <a class="el" href="classha__tina.html#a7cc6a79ee4b85fa562d9198bfa033e5a">ha_tina</a>, <a class="el" href="classha__archive.html#a5be6871ada166463e5ec5146afec9c7d">ha_archive</a>, <a class="el" href="classha__myisam.html#afaaea6f02217f92219af9bcb3125a04c">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#a7c7eb63e4c9ac1762d8c9538771ac516">ha_myisammrg</a>, <a class="el" href="classha__heap.html#a3161f37c5dbf5d1ede5483224b53b5a6">ha_heap</a>, <a class="el" href="classha__blackhole.html#a1be2cb4f0816e9a04eee7b4c4b1c4363">ha_blackhole</a>, and <a class="el" href="classmock_1_1ha__mock.html#aa8df2462cb6292ac9c9c294489327a08">mock::ha_mock</a>.</p>

</div>
</div>
<a id="adf659edd9d870e90c8974ae0eba7a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf659edd9d870e90c8974ae0eba7a082">&#9670;&nbsp;</a></span>rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>index_read_map(). </dd></dl>

<p>Implemented in <a class="el" href="classha__innopart.html#af6e836398b1cc1e50876eef3cf7fd918">ha_innopart</a>, <a class="el" href="classha__example.html#af5939e6aba431ffdf360f830a415f579">ha_example</a>, <a class="el" href="classha__federated.html#ad600a658d16fa4254b65a072d0e40be7">ha_federated</a>, <a class="el" href="classtemptable_1_1Handler.html#a3e300a0607eaf772955264ff36992f85">temptable::Handler</a>, <a class="el" href="classha__perfschema.html#ab64095847d4d24ce318d641ab05efda5">ha_perfschema</a>, <a class="el" href="classha__innobase.html#a272db42b6b4a31203c0fa201e4b5f80f">ha_innobase</a>, <a class="el" href="classha__tina.html#a24018a16caeb3e8dcda8996f7acae699">ha_tina</a>, <a class="el" href="classha__archive.html#a39cfdc2cba4943c3dc7d379fc93d5e9a">ha_archive</a>, <a class="el" href="classha__myisam.html#a1bca786db82470d6410044219988a757">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#aefcc7857bf9c24f0bc5af43082c9f58c">ha_myisammrg</a>, <a class="el" href="classha__heap.html#a071bbc240e128aca8becbcb173e0c8b1">ha_heap</a>, <a class="el" href="classha__blackhole.html#ae93c159b968ba92b469a7f0f5d700c19">ha_blackhole</a>, and <a class="el" href="classmock_1_1ha__mock.html#a9420f166fb02c85e952f1d74981368b5">mock::ha_mock</a>.</p>

</div>
</div>
<a id="ac2be2fa5d347252f8a28dce931654b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be2fa5d347252f8a28dce931654b76">&#9670;&nbsp;</a></span>rnd_pos_by_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_pos_by_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set. </p>
<p>It will return the row with the PK given in the record argument. </p>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga9a383b0ca3b72c8221ea49c25c27c115">ha_innopart</a>.</p>

</div>
</div>
<a id="a0014408fc37a178d96063b809c0eab90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0014408fc37a178d96063b809c0eab90">&#9670;&nbsp;</a></span>sample_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::sample_end </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>Scan context of the sampling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else failure. </dd></dl>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga902d0aacd5e6da14739d93a6e2a4423f">ha_innopart</a>, and <a class="el" href="classha__innobase.html#ab394b0c7fdded101aef186c683ce76c7">ha_innobase</a>.</p>

</div>
</div>
<a id="aa41795e1f1fba64e38a606b4b844d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41795e1f1fba64e38a606b4b844d731">&#9670;&nbsp;</a></span>sample_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::sample_init </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_percentage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampling_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql_2handler_8h.html#ae954cfd46ba0b8300368dccf2bebc842">enum_sampling_method</a>&#160;</td>
          <td class="paramname"><em>sampling_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">scan_ctx</td><td>A scan context created by this method that has to be used in sample_next </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_percentage</td><td>percentage of records that need to be sampled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_seed</td><td>random seed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampling_method</td><td>sampling method to be used; currently only SYSTEM sampling is supported </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else failure. </dd></dl>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga799e71a922942685475d8043c603b005">ha_innopart</a>, and <a class="el" href="classha__innobase.html#a0a70836644799aa8f325cfaa7707e451">ha_innobase</a>.</p>

</div>
</div>
<a id="a3757d00cf8932b2ab370164723f830c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3757d00cf8932b2ab370164723f830c0">&#9670;&nbsp;</a></span>sample_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::sample_next </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scan_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next record for sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_ctx</td><td>Scan context of the sampling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>buffer to place the read record </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, else failure. </dd></dl>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga60b26b3819afb7b708e2f661f79a1d39">ha_innopart</a>, and <a class="el" href="classha__innobase.html#af55969372fcf3cb364249daba74da2e9">ha_innobase</a>.</p>

</div>
</div>
<a id="a65f8e5188e2bd9636a564bbc0c3fef86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f8e5188e2bd9636a564bbc0c3fef86">&#9670;&nbsp;</a></span>scan_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double handler::scan_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>This function is deprecated and will be removed in a future version.</dd></dl>
<p>Use table_scan_cost() instead. </p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga25bb5886aa04e2b4488ee3a82e5cbc02">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a7652724a0ab417142e38f5dbfd1ddff7">temptable::Handler</a>, <a class="el" href="classha__federated.html#a4da87c7b2e58aeb9151c903d4d03387e">ha_federated</a>, <a class="el" href="classha__example.html#a0f6c9b824c96fa88f10548d9066fca3d">ha_example</a>, <a class="el" href="classha__perfschema.html#a2595709d17eefa3ce016234f127d0fb2">ha_perfschema</a>, <a class="el" href="classha__tina.html#a5a14f2953cd7f4c3602f229729e9b6ce">ha_tina</a>, <a class="el" href="classha__innobase.html#a3505b4fcd544e155238c18326eaac51a">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a0dea900c597e4bcfac8680836db653d4">ha_myisammrg</a>, and <a class="el" href="classha__heap.html#abe70ff927820c5c8830308440d8d0a29">ha_heap</a>.</p>

</div>
</div>
<a id="a4b7dfb95a0da2e828ac018aa2b4abe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7dfb95a0da2e828ac018aa2b4abe3a">&#9670;&nbsp;</a></span>set_end_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_end_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">enum_range_scan_direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the end position for a range scan. </p>
<p>This is used for checking for when to end the range scan and by the ICP code to determine that the next record is within the current range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The end value for the range scan </td></tr>
    <tr><td class="paramname">direction</td><td>Direction of the range scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24470ac1d4ac336cedbe7c245d321c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24470ac1d4ac336cedbe7c245d321c9">&#9670;&nbsp;</a></span>set_ha_share_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_ha_share_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td>
          <td class="paramname"><em>arg_ha_share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set ha_share to be used by all instances of the same table/partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg_ha_share</td><td>Handler_share to be shared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a id="ae370a0f787c1b936e475a5762b91350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae370a0f787c1b936e475a5762b91350c">&#9670;&nbsp;</a></span>set_ha_share_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::set_ha_share_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHandler__share.html">Handler_share</a> **&#160;</td>
          <td class="paramname"><em>arg_ha_share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fcbbed1055c74444efa8e21dc3b84af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcbbed1055c74444efa8e21dc3b84af">&#9670;&nbsp;</a></span>set_ha_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_ha_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6f9bf8ee63f3b8312fdc31be3819ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f9bf8ee63f3b8312fdc31be3819ede">&#9670;&nbsp;</a></span>set_next_insert_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_next_insert_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdaf7319a6498f655f8f07b1b34b12fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaf7319a6498f655f8f07b1b34b12fc">&#9670;&nbsp;</a></span>start_bulk_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::start_bulk_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Bulk delete used by handler </td></tr>
    <tr><td class="paramname">true</td><td>Bulk delete not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5c060d0929c74e72c8c6f0d44fe45cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c060d0929c74e72c8c6f0d44fe45cc">&#9670;&nbsp;</a></span>start_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::start_bulk_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__federated.html#a79f7ef72becad6ceae7f700a81e9fe4b">ha_federated</a>, <a class="el" href="classha__archive.html#adbeaa75af2545655011f107f3e756bf7">ha_archive</a>, and <a class="el" href="classha__myisam.html#a28b9ea2eee3c97dcf15ccb604922a35a">ha_myisam</a>.</p>

</div>
</div>
<a id="a7488245f51aa4676c872bb0564dbe71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7488245f51aa4676c872bb0564dbe71f">&#9670;&nbsp;</a></span>start_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::start_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Bulk update used by handler </td></tr>
    <tr><td class="paramname">true</td><td>Bulk update not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cadefb8724982848541e06a394917e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cadefb8724982848541e06a394917e8">&#9670;&nbsp;</a></span>start_psi_batch_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::start_psi_batch_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the handler in 'batch' mode when collecting table io instrumented events. </p>
<p>When operating in batch mode:</p><ul>
<li>a single start event is generated in the performance schema.</li>
<li>all table io performed between <code>start_psi_batch_mode</code> and <code>end_psi_batch_mode</code> is not instrumented: the number of rows affected is counted instead in <code>m_psi_numrows</code>.</li>
<li>a single end event is generated in the performance schema when the batch mode ends with <code>end_psi_batch_mode</code>. </li>
</ul>

</div>
</div>
<a id="a3e2428788c2437e4e33c4b390cc697f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2428788c2437e4e33c4b390cc697f7">&#9670;&nbsp;</a></span>start_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::start_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start read (before write) removal on the current table. </p>
<dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

</div>
</div>
<a id="a90c625117fcff640b7af11e7018519cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c625117fcff640b7af11e7018519cd">&#9670;&nbsp;</a></span>start_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::start_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a>&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a statement when table is locked. </p>
<p>This method is called instead of external lock when the table is locked before the statement is executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread object. </td></tr>
    <tr><td class="paramname">lock_type</td><td>Type of external lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>Error code. </td></tr>
    <tr><td class="paramname">0</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a9df082eb7862295131351da08aa8e51b">temptable::Handler</a>, <a class="el" href="classha__innopart.html#aaaa9bd51ec41066cc54c7e39f76a7c58">ha_innopart</a>, and <a class="el" href="classha__innobase.html#a48b1b3e128043290847d250756b66f53">ha_innobase</a>.</p>

</div>
</div>
<a id="a2502e460566f2c4b506cc1b30eb79e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2502e460566f2c4b506cc1b30eb79e0a">&#9670;&nbsp;</a></span>store_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a>** handler::store_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTHR__LOCK__DATA.html">THR_LOCK_DATA</a> **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a>&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is not invoked for non-transactional temporary tables. </p>
<dl class="section note"><dt>Note</dt><dd>store_lock() can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in store_lock(). It may refer to a different thread if called from mysql_lock_abort_for_thread().</dd>
<dd>
If the table is MERGE, store_lock() can return less locks than lock_count() claimed. This can happen when the MERGE children are not attached when this is called from another thread.</dd></dl>
<p>The idea with handler::store_lock() is the following:</p>
<p>The statement decided which locks we should need for the table for updates/deletes/inserts we get WRITE locks, for SELECT... we get read locks.</p>
<p>Before adding the lock into the table lock handler (see thr_lock.c) mysqld calls store lock with the requested locks. Store lock can now modify a write lock to a read lock (or some other lock), ignore the lock (if we don't want to use MySQL table locks at all) or add locks for many tables (like we do when we are using a MERGE handler).</p>
<p>In some exceptional cases MySQL may send a request for a TL_IGNORE; This means that we are requesting the same lock as last time and this should also be ignored.</p>
<p>Called from lock.cc by get_lock_data(). </p>

<p>Implemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga9774a407435944f61025ab5c3d8a2347">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a9a0844f8fa4f505624c5c980662ce503">temptable::Handler</a>, <a class="el" href="classha__innobase.html#a9d647e97f555625b358f8916af249c0d">ha_innobase</a>, <a class="el" href="classha__example.html#a8c2f2b53098a7dacc031eb3d568e5167">ha_example</a>, <a class="el" href="classha__federated.html#af223a20bf219a6cfe6e1cac3acd7d7b3">ha_federated</a>, <a class="el" href="classha__perfschema.html#a537baab98efeda2cf1ab0a55c26e3a28">ha_perfschema</a>, <a class="el" href="classha__archive.html#a8ab2ae2903370d5ac234a58be9cb0e60">ha_archive</a>, <a class="el" href="classha__tina.html#acbb61919b78d89d5ef9c35933470d51b">ha_tina</a>, <a class="el" href="classha__myisam.html#a79a6c6d6faa5d4bab8766562259af96c">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#aa3899f4a96bfefced3cd6d4b0f366b10">ha_myisammrg</a>, <a class="el" href="classha__heap.html#a5a421ea4d862d9c3f3f4e96d95124026">ha_heap</a>, <a class="el" href="classha__blackhole.html#a6bd09e338ad47f813ef79c741c12efb2">ha_blackhole</a>, and <a class="el" href="classmock_1_1ha__mock.html#ab3f38f1e8ea72f64d1fe86e0c1b358aa">mock::ha_mock</a>.</p>

</div>
</div>
<a id="a8dfa0934ac54d557e2dc9bd2bb634645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfa0934ac54d557e2dc9bd2bb634645">&#9670;&nbsp;</a></span>table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a> handler::table_flags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classha__innopart.html#a9d19fbf38d1854e3d4b69875b1a7f7ce">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#accb9074aa80625086c7d7e9777dcaecb">temptable::Handler</a>, <a class="el" href="classha__federated.html#a6258e8f362b7345ad336bcccd89a07dd">ha_federated</a>, <a class="el" href="classha__tina.html#af036e4b6e44d994e2eaf945727a10f03">ha_tina</a>, <a class="el" href="classha__archive.html#a6d98a746bcd0bcfb7d42fc03077d3b14">ha_archive</a>, <a class="el" href="classha__innobase.html#a0ca84fffd74ffd0394230883dffa75dc">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#ac091c4da6680decb0d1f9f21d842f320">ha_myisammrg</a>, <a class="el" href="classha__example.html#a831bbdbb3499f2bc00b7f44e551494de">ha_example</a>, <a class="el" href="classha__myisam.html#a72efa6a6537e2e788fee02cfc8b2cbb3">ha_myisam</a>, <a class="el" href="classmock_1_1ha__mock.html#a9a066df8a0ed23fcf328f88559cac0ed">mock::ha_mock</a>, <a class="el" href="classha__perfschema.html#adff01ac6dff09bf2aeb83290841ad82d">ha_perfschema</a>, <a class="el" href="classha__blackhole.html#a5a2402abccb4aac2885d103b02635e4c">ha_blackhole</a>, and <a class="el" href="classha__heap.html#ae4b749c0f366b41a5c07f4121c1acdcd">ha_heap</a>.</p>

</div>
</div>
<a id="a171927b3afde9e800755b834bd8d31bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171927b3afde9e800755b834bd8d31bd">&#9670;&nbsp;</a></span>table_in_memory_estimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double handler::table_in_memory_estimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an estimate of how much of the table that is currently stored in main memory. </p>
<p>This estimate should be the fraction of the table that currently is available in a main memory buffer. The estimate should be in the range from 0.0 (nothing in memory) to 1.0 (entire table in memory).</p>
<dl class="section return"><dt>Returns</dt><dd>The fraction of the table in main memory buffer </dd></dl>

</div>
</div>
<a id="a5e9380355a7eea5386ef061f36479258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9380355a7eea5386ef061f36479258">&#9670;&nbsp;</a></span>table_scan_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCost__estimate.html">Cost_estimate</a> handler::table_scan_cost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost estimate for doing a complete table scan. </p>
<dl class="section note"><dt>Note</dt><dd>For this version it is recommended that storage engines continue to override scan_time() instead of this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated cost </dd></dl>

</div>
</div>
<a id="ad38f5d3f1e026a0af32b5542aa5ac2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38f5d3f1e026a0af32b5542aa5ac2f9">&#9670;&nbsp;</a></span>table_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* handler::table_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following can be called without an open handler. </p>

<p>Implemented in <a class="el" href="classtemptable_1_1Handler.html#a972c3590781195c1e7cbede4fe0c4e9c">temptable::Handler</a>, <a class="el" href="classha__federated.html#a4e23f78c8108326697cd0ac66d4ec073">ha_federated</a>, <a class="el" href="classha__tina.html#a151d0ed8bfd6b7b32547e2822dd7d22e">ha_tina</a>, <a class="el" href="classha__archive.html#a461e86bc8b312a96eea2da1710d37397">ha_archive</a>, <a class="el" href="classha__myisammrg.html#a0bb15704bc89d25abd8a0b34cafde789">ha_myisammrg</a>, <a class="el" href="classmock_1_1ha__mock.html#a5e71fe7f7f365b8eafa07979e6927375">mock::ha_mock</a>, <a class="el" href="classha__innobase.html#af59155263e0c49220461c9d80ae7a72c">ha_innobase</a>, <a class="el" href="classha__myisam.html#a66c00f97dfb7826667864682e45ad249">ha_myisam</a>, <a class="el" href="classha__example.html#ad7a7eee3fd69037d1c42d6d3e458591e">ha_example</a>, <a class="el" href="classha__perfschema.html#ae3e7c79ce8f0405163c8b063ea4382d5">ha_perfschema</a>, <a class="el" href="classha__blackhole.html#a2ffcd56bdfaf5c16b2c9f5c6dc53617a">ha_blackhole</a>, and <a class="el" href="classha__heap.html#ab667dfa54a348bf2a1e67817287bd045">ha_heap</a>.</p>

</div>
</div>
<a id="ac17a6fa82ef1a46a8772118ce98c6867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17a6fa82ef1a46a8772118ce98c6867">&#9670;&nbsp;</a></span>tables_in_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> handler::tables_in_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a map of the tables involved in this pushed join, or 0 if not part of a pushed join. </dd></dl>

</div>
</div>
<a id="abfbfc4312adf397f421dba81d65186ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbfc4312adf397f421dba81d65186ab">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quickly remove all rows from a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_def</td><td>dd::Table object for table being truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is responsible for implementing MySQL's TRUNCATE TABLE statement, which is a DDL operation. As such, a engine can bypass certain integrity checks and in some cases avoid fine-grained locking (e.g. row locks) which would normally be required for a DELETE statement.</dd>
<dd>
Typically, truncate is not used if it can result in integrity violation. For example, truncate is not used when a foreign key references the table, but it might be used if foreign key checks are disabled.</dd>
<dd>
Engine is responsible for resetting the auto-increment counter.</dd>
<dd>
The table is locked in exclusive mode. All open TABLE/handler instances except the one which is used for truncate() call are closed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is assumed that transactional storage engines implementing this method can revert its effects if transaction is rolled back (e.g. because we failed to write statement to the binary log).</dd>
<dd>
Changes to dd::Table object done by this method will be saved to data-dictionary only if storage engine supports atomic DDL (i.e. has HTON_SUPPORTS_ATOMIC_DDL flag set). </dd></dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#ab70b73dc567e8db592549db38df9ffa7">temptable::Handler</a>, <a class="el" href="classha__federated.html#a029ac937a3c7f85999b6ffe7e68597b2">ha_federated</a>, <a class="el" href="classha__perfschema.html#a5b652919b1357c07f615cd3ce2cf7e0b">ha_perfschema</a>, <a class="el" href="classha__myisammrg.html#ab7b2dd5650e5833274c9a5237d617021">ha_myisammrg</a>, and <a class="el" href="classha__archive.html#a0fad1c2af2cb39eb82d694e3ead2b46a">ha_archive</a>.</p>

</div>
</div>
<a id="ab3e767094bff139a26743e9314df8476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e767094bff139a26743e9314df8476">&#9670;&nbsp;</a></span>try_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::try_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the engine whether it should avoid unnecessary lock waits. </p>
<p>If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga92a0f60851cef91f64a913af312ed240">ha_innopart</a>, and <a class="el" href="classha__innobase.html#ac9584f11c212c4ad6e1e270055122435">ha_innobase</a>.</p>

</div>
</div>
<a id="a72cfeaceefd05a2f700c138c194770fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cfeaceefd05a2f700c138c194770fc">&#9670;&nbsp;</a></span>unbind_psi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::unbind_psi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac62ac2819bb9b2187e4e20ac954a5d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62ac2819bb9b2187e4e20ac954a5d99">&#9670;&nbsp;</a></span>unload_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::unload_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>error_if_not_loaded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unloads a table from its defined secondary storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db_name</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">error_if_not_loaded</td><td>If true, then errors will be reported by this function. If false, no errors will be reported (silently fail). This case of false is useful during DROP TABLE where a failure to unload should not prevent dropping the whole table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, error code otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classmock_1_1ha__mock.html#a395713e81f2dbf3448b805977c6fdcb3">mock::ha_mock</a>.</p>

</div>
</div>
<a id="a48e6fd090f73a8e7e5e94769c9a10733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e6fd090f73a8e7e5e94769c9a10733">&#9670;&nbsp;</a></span>unlock_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::unlock_row </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock last accessed row. </p>
<p>Record currently processed was not in the result set of the statement and is thus unlocked. Used for UPDATE and DELETE queries. </p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga7ac38c8df0ffeb09b7de13f3a6cd10d3">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#ab64489da78833f40387d66967df9ba58">temptable::Handler</a>, and <a class="el" href="classha__innobase.html#a79f39bfde37d1a055be72730da08c0d4">ha_innobase</a>.</p>

</div>
</div>
<a id="a8059bbed3de416b3bea51c69dc064e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8059bbed3de416b3bea51c69dc064e79">&#9670;&nbsp;</a></span>unlock_shared_ha_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::unlock_shared_ha_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release lock for protecting ha_share. </p>

</div>
</div>
<a id="a8a7d2f9da11425e388640206b4d22241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d2f9da11425e388640206b4d22241">&#9670;&nbsp;</a></span>update_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::update_auto_increment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58141e7b51aaf97bdf63ea68c411f401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58141e7b51aaf97bdf63ea68c411f401">&#9670;&nbsp;</a></span>update_create_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::update_create_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHA__CREATE__INFO.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update create info as part of ALTER TABLE. </p>
<p>Forward this handler call to the storage engine foreach partition handler. The data_file_name for each partition may need to be reset if the tablespace was moved. Use a dummy HA_CREATE_INFO structure and transfer necessary data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_info</td><td>Create info from ALTER TABLE. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classtemptable_1_1Handler.html#a404ffb68c00addf080c1c6ecd25e3796">temptable::Handler</a>, <a class="el" href="classha__innopart.html#afda3c6c261bb3b6bbd428eebb97551eb">ha_innopart</a>, <a class="el" href="classha__innobase.html#ad7d9ce11b0e2884e151e005bd74f3a1f">ha_innobase</a>, <a class="el" href="classha__archive.html#a493e7ac3dee5210ad02ff92c389c3b42">ha_archive</a>, <a class="el" href="classha__myisam.html#a716143f06be1d7fd92b36fcc9153fb7c">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#a7b7becf66370b5b7ee14cda95f438197">ha_myisammrg</a>, and <a class="el" href="classha__heap.html#afe93766e4c3566c4987a9841d4591f66">ha_heap</a>.</p>

</div>
</div>
<a id="a3483fb841777f6e50a8b890ce95527e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3483fb841777f6e50a8b890ce95527e8">&#9670;&nbsp;</a></span>update_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::update_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>new_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a single row. </p>
<p>Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage. </p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga94fc3f3ee0e1c409a055d8447a783f26">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#af0f5c131bc974c5a23a974376096a0f1">temptable::Handler</a>, <a class="el" href="classha__federated.html#aa2b422f7a3b402a802af5a2e12eb76e0">ha_federated</a>, <a class="el" href="classha__example.html#a8a23a0d95ca0bed51d52fefcee00850b">ha_example</a>, <a class="el" href="classha__perfschema.html#abef18a282aaa842279835ff90e306965">ha_perfschema</a>, <a class="el" href="classha__tina.html#a8e0d32deca772cae63ee5ccf215abd47">ha_tina</a>, <a class="el" href="classha__innobase.html#a517b1ecde7d65b3da61b8d2bba00389c">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#ab77cc2a7b3039a5397847094f92df009">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#aa95bf5da2debab782e138cbae9ca2f4b">ha_myisam</a>, <a class="el" href="classha__blackhole.html#af2d2bb580e1c1d948a932a4338b12c8e">ha_blackhole</a>, and <a class="el" href="classha__heap.html#aae700f29af37ae7ebe26dcfd8859ad68">ha_heap</a>.</p>

</div>
</div>
<a id="ad8691b98cbb43c5a930149f25d1e55ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8691b98cbb43c5a930149f25d1e55ac">&#9670;&nbsp;</a></span>upgrade_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::upgrade_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>dd_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classha__innobase.html#aae7f6f94a9e464716bb3b99b7a9b85ba">ha_innobase</a>.</p>

</div>
</div>
<a id="adac21f2d10c4463fb1d7e14882c6314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac21f2d10c4463fb1d7e14882c6314f">&#9670;&nbsp;</a></span>use_hidden_primary_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::use_hidden_primary_key </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key </p>

<p>Reimplemented in <a class="el" href="classha__perfschema.html#a0d71fd4c64b120387339518db59c7a7f">ha_perfschema</a>.</p>

</div>
</div>
<a id="a54d92f647a4ca5a3b7867fa5538242a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d92f647a4ca5a3b7867fa5538242a6">&#9670;&nbsp;</a></span>was_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::was_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normally, when running UPDATE or DELETE queries, we need to wait for other transactions to release their locks on a given row before we can read it and potentially update it. </p>
<p>However, in READ UNCOMMITTED and READ COMMITTED, we can ignore these locks if we don't intend to modify the row (e.g., because it failed a WHERE). This is signaled through enabling “semi-consistent read”, by calling try_semi_consistent_read(true) (and then setting it back to false after finishing the query).</p>
<p>If semi-consistent read is enabled, and we are in READ UNCOMMITTED or READ COMMITTED, the storage engine is permitted to return rows that are locked and thus un-updatable. If the optimizer doesn't want the row, e.g., because it got filtered out, it can call unlock_row() as usual. However, if it intends to update the row, it needs to call was_semi_consistent_read() before doing so. If was_semi_consistent_read() returns false, the row was never locked to begin with and can be updated as usual. However, if it returns 1, it was read optimistically, must be discarded (ie., do not try to update the row) and must be re-read with locking enabled. The next read call after was_semi_consistent_read() will automatically re-read the same row, this time with locking enabled.</p>
<p>Thus, typical use in an UPDATE scenario would look like this: </p><pre class="fragment">file-&gt;try_semi_consistent_read(true);
file-&gt;ha_rnd_init(true);
while (file-&gt;ha_rnd_next(table-&gt;record[0]) == 0) {
  if (row is filtered...) {
    file-&gt;unlock_row();
    continue;
  }
  if (file-&gt;was_semi_consistent_read()) {
</pre><p> Discard the row; next ha_rnd_next() will read it again with locking. continue; } Process row here. } file-&gt;ha_rnd_end(); file-&gt;try_semi_consistent_read(false);</p>
<p>If the transaction isolation level is REPEATABLE READ or SERIALIZABLE, enabling this flag has no effect. </p>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga4144012d1f7d568dfcb896d1131af698">ha_innopart</a>, and <a class="el" href="classha__innobase.html#a82ed82289ef82d7553b4dde7536bab3e">ha_innobase</a>.</p>

</div>
</div>
<a id="ab3b26a1dd124ff748aa02f9dd34a378a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b26a1dd124ff748aa02f9dd34a378a">&#9670;&nbsp;</a></span>write_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::write_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a row. </p>
<p>write_row() inserts a row. buf is a byte array of data, normally record[0].</p>
<p>You can use the field information to extract the data from the native byte array type.</p>
<p>Example of this would be: for (Field **field=table-&gt;field ; *field ; field++) { ... }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to write from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__PRIVATE__HANDLER.html#ga450ee9e6861663b2a9e814d3ee5bbf01">ha_innopart</a>, <a class="el" href="classtemptable_1_1Handler.html#a349333335c9b4fa6114c40df3e238b5e">temptable::Handler</a>, <a class="el" href="classha__federated.html#ae53dfbd170e206c4d4b2ba372e6b9230">ha_federated</a>, <a class="el" href="classha__example.html#a4a4f4cb5e6581fd77bbad95265d97a54">ha_example</a>, <a class="el" href="classha__perfschema.html#ac456634bf94acf586677b6d32b23bae4">ha_perfschema</a>, <a class="el" href="classha__tina.html#a1056a198eb99ca54e737351601bbb5e4">ha_tina</a>, <a class="el" href="classha__archive.html#a287ee234e5683e59b59efca7e317adb3">ha_archive</a>, <a class="el" href="classha__myisammrg.html#aa2fe850f49a3cc5f487954d487b7c325">ha_myisammrg</a>, <a class="el" href="classha__innobase.html#ae89861bd4a0fd74b4a8b0d495472a363">ha_innobase</a>, <a class="el" href="classha__myisam.html#a2f3161fdd904798c0cfecdb294d47919">ha_myisam</a>, <a class="el" href="classha__blackhole.html#a4a861aad3eb8404df62a36a3ff750de9">ha_blackhole</a>, and <a class="el" href="classha__heap.html#a5629f651f575a8730e39c36b4944f836">ha_heap</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a576b2e6999b5b4fbe40abb7870fe33b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576b2e6999b5b4fbe40abb7870fe33b2">&#9670;&nbsp;</a></span>DsMrr_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classDsMrr__impl.html">DsMrr_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e1b518f74dfed5dde6f5f902f264f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1b518f74dfed5dde6f5f902f264f39">&#9670;&nbsp;</a></span>Partition_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classPartition__handler.html">Partition_handler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a29f2838eebffef46663c19f85d2ad2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f2838eebffef46663c19f85d2ad2cc">&#9670;&nbsp;</a></span>active_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::active_index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1540a47a05c03724f1102aaaa623131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1540a47a05c03724f1102aaaa623131e">&#9670;&nbsp;</a></span>auto_inc_interval_for_cur_row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a> handler::auto_inc_interval_for_cur_row</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interval returned by get_auto_increment() and being consumed by the inserter. </p>

</div>
</div>
<a id="acdfcef0738a89138c8f41ded8da17c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfcef0738a89138c8f41ded8da17c0a">&#9670;&nbsp;</a></span>auto_inc_intervals_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::auto_inc_intervals_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of reserved auto-increment intervals. </p>
<p>Serves as a heuristic when we have no estimation of how many records the statement will insert: the more intervals we have reserved, the bigger the next one. Reset in handler::ha_release_auto_increment(). </p>

</div>
</div>
<a id="a98743b18a24c8baef7e22a11df74d6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98743b18a24c8baef7e22a11df74d6c9">&#9670;&nbsp;</a></span>cached_table_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html#a67af5473a36655c922682399d4c5b6ec">Table_flags</a> handler::cached_table_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7501dc41ecb010069e8bc9d035aae6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7501dc41ecb010069e8bc9d035aae6aa">&#9670;&nbsp;</a></span>dup_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* handler::dup_ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to duplicate row. </p>

</div>
</div>
<a id="a28d698fe9901f0f487c9618ddbb0f1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d698fe9901f0f487c9618ddbb0f1be">&#9670;&nbsp;</a></span>end_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkey__range.html">key_range</a>* handler::end_range</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End value for a range scan. </p>
<p>If this is NULL the range scan has no end value. Should also be NULL when there is no ongoing range scan. Used by the read_range() functions and also evaluated by pushed index conditions. </p>

</div>
</div>
<a id="a272c3d9b40a9e7c5de20ed390d23a636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272c3d9b40a9e7c5de20ed390d23a636">&#9670;&nbsp;</a></span>eq_range</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::eq_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3186b7c7a70634a8e9758ed51708359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3186b7c7a70634a8e9758ed51708359c">&#9670;&nbsp;</a></span>errkey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::errkey</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf44b6a4c101f982cd13a344dce5a870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf44b6a4c101f982cd13a344dce5a870">&#9670;&nbsp;</a></span>estimation_rows_to_insert</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> handler::estimation_rows_to_insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a943005f89e7a6d5cee246e1c5b46e9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943005f89e7a6d5cee246e1c5b46e9ab">&#9670;&nbsp;</a></span>ft_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFT__INFO.html">FT_INFO</a>* handler::ft_handler</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97f83e0c7122ec3d276dcb0a0b940754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f83e0c7122ec3d276dcb0a0b940754">&#9670;&nbsp;</a></span>ha_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHandler__share.html">Handler_share</a>** handler::ha_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer where to store/retrieve the Handler_share pointer. </p>
<p>For non partitioned handlers this is &amp;TABLE_SHARE::ha_share. </p>

</div>
</div>
<a id="a395bae75af9e51a116097a788b2cf57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395bae75af9e51a116097a788b2cf57f">&#9670;&nbsp;</a></span>ht</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlerton.html">handlerton</a>* handler::ht</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd47d68a7b406d8777396a657095d5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd47d68a7b406d8777396a657095d5e8">&#9670;&nbsp;</a></span>implicit_emptied</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::implicit_emptied</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a159ca294d8dafe32405e6ad546e6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a159ca294d8dafe32405e6ad546e6a4">&#9670;&nbsp;</a></span>in_range_check_pushed_down</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::in_range_check_pushed_down</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4562b84f0a9dd9a138e2329d8e0c2175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4562b84f0a9dd9a138e2329d8e0c2175">&#9670;&nbsp;</a></span>inited</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum { ... }   handler::inited</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05dd2cafd83ae60562649bf9688aebf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd2cafd83ae60562649bf9688aebf1">&#9670;&nbsp;</a></span>insert_id_for_cur_row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> handler::insert_id_for_cur_row</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert id for the current row (<em>autogenerated</em>; if not autogenerated, it's 0). </p>
<p>At first successful insertion, this variable is stored into THD::first_successful_insert_id_in_cur_stmt. </p>

</div>
</div>
<a id="af0dcf02628357621b80f80086d8b3de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dcf02628357621b80f80086d8b3de8">&#9670;&nbsp;</a></span>key_compare_result_on_equal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::key_compare_result_on_equal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ad5efc62f32ef66b55667fd8370ef33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad5efc62f32ef66b55667fd8370ef33">&#9670;&nbsp;</a></span>key_used_on_scan</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::key_used_on_scan</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a391dcf2f67a2d4d48e915c3bcd6609be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391dcf2f67a2d4d48e915c3bcd6609be">&#9670;&nbsp;</a></span>m_lock_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::m_lock_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lock type set by when calling::ha_external_lock(). </p>
<p>This is propagated down to the storage engine. The reason for also storing it here, is that when doing MRR we need to create/clone a second handler object. This cloned handler object needs to know about the lock_type used. </p>

</div>
</div>
<a id="a08c8aa312359cbf7221bb4236af01a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c8aa312359cbf7221bb4236af01a93">&#9670;&nbsp;</a></span>m_primary_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html">handler</a>* handler::m_primary_handler {<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the handler of the table in the primary storage engine, if this handler represents a table in a secondary storage engine. </p>

</div>
</div>
<a id="a881e7cba3fe3bf9731a91be82983cc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881e7cba3fe3bf9731a91be82983cc35">&#9670;&nbsp;</a></span>m_psi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__table.html#gadcd09ac8bc8a8fcecb5e7cf78033a18b">PSI_table</a>* handler::m_psi</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instrumented table associated with this handler. </p>

</div>
</div>
<a id="a904b90a3376e972147b008c5f8f7c64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904b90a3376e972147b008c5f8f7c64a">&#9670;&nbsp;</a></span>m_psi_batch_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html#a14d149dcfec8790b8e58e8b10e22220a">batch_mode_t</a> handler::m_psi_batch_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Batch mode state. </p>
<dl class="section see"><dt>See also</dt><dd>start_psi_batch_mode. </dd>
<dd>
end_psi_batch_mode. </dd></dl>

</div>
</div>
<a id="aa46a2aef2dae7913d5814784f2c77ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46a2aef2dae7913d5814784f2c77ec9">&#9670;&nbsp;</a></span>m_psi_locker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__table.html#ga65d968f386d9f08741feee0874b8e1db">PSI_table_locker</a>* handler::m_psi_locker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current event in a batch. </p>
<dl class="section see"><dt>See also</dt><dd>start_psi_batch_mode. </dd>
<dd>
end_psi_batch_mode. </dd></dl>

</div>
</div>
<a id="adcaa2fdf26cdf68edd9bcb7c5d6e6914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaa2fdf26cdf68edd9bcb7c5d6e6914">&#9670;&nbsp;</a></span>m_psi_locker_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPSI__table__locker__state.html">PSI_table_locker_state</a> handler::m_psi_locker_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage for the event in a batch. </p>
<dl class="section see"><dt>See also</dt><dd>start_psi_batch_mode. </dd>
<dd>
end_psi_batch_mode. </dd></dl>

</div>
</div>
<a id="af4b9772a63139e9589d810bb445518d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b9772a63139e9589d810bb445518d8">&#9670;&nbsp;</a></span>m_psi_numrows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> handler::m_psi_numrows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of rows in the batch. </p>
<dl class="section see"><dt>See also</dt><dd>start_psi_batch_mode. </dd>
<dd>
end_psi_batch_mode. </dd></dl>

</div>
</div>
<a id="a110bb2ddff9878db7a7dd92ce768243a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110bb2ddff9878db7a7dd92ce768243a">&#9670;&nbsp;</a></span>m_random_number_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mt19937 handler::m_random_number_engine</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf6a6b8b8ed8c7b0a77d07aeea1ab44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6a6b8b8ed8c7b0a77d07aeea1ab44e">&#9670;&nbsp;</a></span>m_record_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRecord__buffer.html">Record_buffer</a>* handler::m_record_buffer = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer for multi-row reads. </p>

</div>
</div>
<a id="a4b25b6f921e217b471ef2d372f15aeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b25b6f921e217b471ef2d372f15aeb7">&#9670;&nbsp;</a></span>m_sampling_percentage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double handler::m_sampling_percentage</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10198f1c6fe8a62faed994417774d7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10198f1c6fe8a62faed994417774d7ce">&#9670;&nbsp;</a></span>m_unique</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUnique__on__insert.html">Unique_on_insert</a>* handler::m_unique</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13c3fdd584db91b0bacf3fcedbd8a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c3fdd584db91b0bacf3fcedbd8a220">&#9670;&nbsp;</a></span>m_update_generated_read_fields</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::m_update_generated_read_fields</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some non-virtual ha_* functions, responsible for reading rows, like ha_rnd_pos(), must ensure that virtual generated columns are calculated before they return. </p>
<p>For that, they should set this member to true at their start, and check it before they return: if the member is still true, it means they should calculate; if it's false, it means the calculation has been done by some called lower-level function and does not need to be re-done (which is why we need this status flag: to avoid redundant calculations, for performance).</p>
<p>Note that when updating generated fields, the NULL row status in the underlying TABLE objects matter, so be sure to reset them if needed! </p>

</div>
</div>
<a id="a1d0f0786eed8e5cca4422f700bc1f5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0f0786eed8e5cca4422f700bc1f5bb">&#9670;&nbsp;</a></span>m_virt_gcol_in_end_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::m_virt_gcol_in_end_range = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag which tells if end_range contains a virtual generated column. </p>
<p>The content is invalid when end_range is <code>nullptr</code>. </p>

</div>
</div>
<a id="af2347edc229832e533d1fb73b236e32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2347edc229832e533d1fb73b236e32b">&#9670;&nbsp;</a></span>mrr_cur_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> handler::mrr_cur_range</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a51e423645829d3e540c109556931fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a51e423645829d3e540c109556931fa">&#9670;&nbsp;</a></span>mrr_funcs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRANGE__SEQ__IF.html">RANGE_SEQ_IF</a> handler::mrr_funcs</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2632d137c3a17fa583f08db5681e80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2632d137c3a17fa583f08db5681e80a">&#9670;&nbsp;</a></span>mrr_have_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::mrr_have_range</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adff4dfb21c4583b55afc4fe5aba50389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff4dfb21c4583b55afc4fe5aba50389">&#9670;&nbsp;</a></span>mrr_is_output_sorted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handler::mrr_is_output_sorted</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec520eba79eb9f182c534e82c60ebc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec520eba79eb9f182c534e82c60ebc6">&#9670;&nbsp;</a></span>mrr_iter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> handler::mrr_iter</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52372127bd238a7f622190316ba8124f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52372127bd238a7f622190316ba8124f">&#9670;&nbsp;</a></span>multi_range_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a>* handler::multi_range_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62ab295e407d8a5c50087fed0f4fcd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ab295e407d8a5c50087fed0f4fcd18">&#9670;&nbsp;</a></span>next_insert_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> handler::next_insert_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>next_insert_id is the next value which should be inserted into the auto_increment column: in a inserting-multi-row statement (like INSERT SELECT), for the first row where the autoinc value is not specified by the statement, get_auto_increment() called and asked to generate a value, next_insert_id is set to the next value, then for all other rows next_insert_id is used (and increased each time) without calling get_auto_increment(). </p>

</div>
</div>
<a id="a0ed2f8d7155cb44162bb4181cb09f2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed2f8d7155cb44162bb4181cb09f2f3">&#9670;&nbsp;</a></span>pushed_cond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classItem.html">Item</a>* handler::pushed_cond</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b3d956f73649657bad389acfad5f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b3d956f73649657bad389acfad5f0b">&#9670;&nbsp;</a></span>pushed_idx_cond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* handler::pushed_idx_cond</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4dc8d81143d1c9c10b976711fe44cf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc8d81143d1c9c10b976711fe44cf37">&#9670;&nbsp;</a></span>pushed_idx_cond_keyno</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::pushed_idx_cond_keyno</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a011df14ecc738037499572c304d8ee90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011df14ecc738037499572c304d8ee90">&#9670;&nbsp;</a></span>range_key_part</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a>* handler::range_key_part</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25db78fcce70b0b1034534c1a5d11964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25db78fcce70b0b1034534c1a5d11964">&#9670;&nbsp;</a></span>range_scan_direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html#ab5b14b11876fb5ac53a4cc7aceea6a2d">enum_range_scan_direction</a> handler::range_scan_direction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a476dfe8526807dfc820c4b09f7a6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a476dfe8526807dfc820c4b09f7a6d1">&#9670;&nbsp;</a></span>ranges_in_seq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::ranges_in_seq</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53c7037216007ba6140e6cff5162024d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c7037216007ba6140e6cff5162024d">&#9670;&nbsp;</a></span>ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* handler::ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to current row. </p>

</div>
</div>
<a id="a64def328ff0ca7e391b217c2d3a758ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64def328ff0ca7e391b217c2d3a758ec">&#9670;&nbsp;</a></span>ref_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> handler::ref_length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of ref (1-8 or the clustered key length) </p>

</div>
</div>
<a id="adc7be2189144804352df9694dee41697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7be2189144804352df9694dee41697">&#9670;&nbsp;</a></span>save_end_range</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkey__range.html">key_range</a> handler::save_end_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1df561df4b2b6552a7b42189feb0400a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df561df4b2b6552a7b42189feb0400a">&#9670;&nbsp;</a></span>stats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classha__statistics.html">ha_statistics</a> handler::stats</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb0d051d1ef534891b27612cc4ff56f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0d051d1ef534891b27612cc4ff56f7">&#9670;&nbsp;</a></span>table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* handler::table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b094cfe680aa06a7d8b70194415aa3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b094cfe680aa06a7d8b70194415aa3b">&#9670;&nbsp;</a></span>table_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* handler::table_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="sql_2handler_8h_source.html">handler.h</a></li>
<li>sql/<a class="el" href="sql_2handler_8cc.html">handler.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classhandler.html">handler</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
