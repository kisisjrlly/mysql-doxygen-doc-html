<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Ref Optimizer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__RefOptimizerModule.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ref Optimizer<div class="ingroups"><a class="el" href="group__Query__Optimizer.html">Query Optimizer</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This module analyzes all equality predicates to determine the best independent ref/eq_ref/ref_or_null index access methods.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKey__field.html">Key_field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Key_field is a descriptor of a predicate of the form (column &lt;op&gt; val).  <a href="structKey__field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga58297bde0da4187801e718c29d5d6b5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga58297bde0da4187801e718c29d5d6b5e">KEY_OPTIMIZE_EXISTS</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga58297bde0da4187801e718c29d5d6b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0658a5d9673135da1c2f6463f0537405"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga0658a5d9673135da1c2f6463f0537405">KEY_OPTIMIZE_REF_OR_NULL</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga0658a5d9673135da1c2f6463f0537405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1de27fe9f2c08ca72261a3eb995c5b76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structKey__field.html">Key_field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga1de27fe9f2c08ca72261a3eb995c5b76">merge_key_fields</a> (<a class="el" href="structKey__field.html">Key_field</a> *<a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>, <a class="el" href="structKey__field.html">Key_field</a> *new_fields, <a class="el" href="structKey__field.html">Key_field</a> *end, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> and_level)</td></tr>
<tr class="memdesc:ga1de27fe9f2c08ca72261a3eb995c5b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge new key definitions to old ones, remove those not used in both.  <a href="#ga1de27fe9f2c08ca72261a3eb995c5b76">More...</a><br /></td></tr>
<tr class="separator:ga1de27fe9f2c08ca72261a3eb995c5b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60622475937affeb43647813b9b5ad7e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga60622475937affeb43647813b9b5ad7e">get_semi_join_select_list_index</a> (<a class="el" href="classItem__field.html">Item_field</a> *item_field)</td></tr>
<tr class="memdesc:ga60622475937affeb43647813b9b5ad7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a field, return its index in semi-join's select list, or UINT_MAX.  <a href="#ga60622475937affeb43647813b9b5ad7e">More...</a><br /></td></tr>
<tr class="separator:ga60622475937affeb43647813b9b5ad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab014025731a851b69071a35210d5297c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#gab014025731a851b69071a35210d5297c">warn_index_not_applicable</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="classField.html">Field</a> *field, const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> cant_use_index)</td></tr>
<tr class="memdesc:gab014025731a851b69071a35210d5297c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If EXPLAIN or if the &ndash;safe-updates option is enabled, add a warning that an index cannot be used for ref access.  <a href="#gab014025731a851b69071a35210d5297c">More...</a><br /></td></tr>
<tr class="separator:gab014025731a851b69071a35210d5297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aad4fefab19fa26ba55e43e2698d392"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga9aad4fefab19fa26ba55e43e2698d392">add_key_field</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structKey__field.html">Key_field</a> **key_fields, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> and_level, <a class="el" href="classItem__func.html">Item_func</a> *cond, <a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="item__xmlfunc_8cc.html#a9b75368e602abb0c0ecc828cd5df57dc">eq_func</a>, <a class="el" href="classItem.html">Item</a> **<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> num_values, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> usable_tables, <a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="memdesc:ga9aad4fefab19fa26ba55e43e2698d392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a possible key to array of possible keys if it's usable as a key.  <a href="#ga9aad4fefab19fa26ba55e43e2698d392">More...</a><br /></td></tr>
<tr class="separator:ga9aad4fefab19fa26ba55e43e2698d392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab881bea02300169cb168cbd95d0cbd8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#gab881bea02300169cb168cbd95d0cbd8a">add_key_equal_fields</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structKey__field.html">Key_field</a> **key_fields, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> and_level, <a class="el" href="classItem__func.html">Item_func</a> *cond, <a class="el" href="classItem__field.html">Item_field</a> *field_item, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="item__xmlfunc_8cc.html#a9b75368e602abb0c0ecc828cd5df57dc">eq_func</a>, <a class="el" href="classItem.html">Item</a> **val, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> num_values, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> usable_tables, <a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="memdesc:gab881bea02300169cb168cbd95d0cbd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add possible keys to array of possible keys originated from a simple predicate.  <a href="#gab881bea02300169cb168cbd95d0cbd8a">More...</a><br /></td></tr>
<tr class="separator:gab881bea02300169cb168cbd95d0cbd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155464f8c15576de13e9aba1e6ca875a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga155464f8c15576de13e9aba1e6ca875a">is_local_field</a> (<a class="el" href="classItem.html">Item</a> *field)</td></tr>
<tr class="memdesc:ga155464f8c15576de13e9aba1e6ca875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an expression is a non-outer field.  <a href="#ga155464f8c15576de13e9aba1e6ca875a">More...</a><br /></td></tr>
<tr class="separator:ga155464f8c15576de13e9aba1e6ca875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307ffdd8c09469bd41945b50d4fe5adf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga307ffdd8c09469bd41945b50d4fe5adf">is_row_of_local_columns</a> (<a class="el" href="classItem__row.html">Item_row</a> *item_row)</td></tr>
<tr class="memdesc:ga307ffdd8c09469bd41945b50d4fe5adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a row constructor expression is over columns in the same query block.  <a href="#ga307ffdd8c09469bd41945b50d4fe5adf">More...</a><br /></td></tr>
<tr class="separator:ga307ffdd8c09469bd41945b50d4fe5adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f3d016b241ed75704f70a47f2f69c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga94f3d016b241ed75704f70a47f2f69c0">add_key_fields</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structKey__field.html">Key_field</a> **key_fields, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *and_level, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> usable_tables, <a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="memdesc:ga94f3d016b241ed75704f70a47f2f69c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The guts of the ref optimizer.  <a href="#ga94f3d016b241ed75704f70a47f2f69c0">More...</a><br /></td></tr>
<tr class="separator:ga94f3d016b241ed75704f70a47f2f69c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbcf94e4ec6f957ea1252d7b8326021"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga6bbcf94e4ec6f957ea1252d7b8326021">add_key_part</a> (<a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a> *keyuse_array, <a class="el" href="structKey__field.html">Key_field</a> *<a class="el" href="mi__test1_8cc.html#aee58d5cbe55d4320750fa66bda380486">key_field</a>)</td></tr>
<tr class="separator:ga6bbcf94e4ec6f957ea1252d7b8326021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ffb7df9b29e9a6017c1c480a13e498"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga19ffb7df9b29e9a6017c1c480a13e498">add_ft_keys</a> (<a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a> *keyuse_array, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *stat, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> usable_tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> simple_match_expr)</td></tr>
<tr class="memdesc:ga19ffb7df9b29e9a6017c1c480a13e498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function parses WHERE condition and add key_use for FT index into key_use array if suitable MATCH function is found.  <a href="#ga19ffb7df9b29e9a6017c1c480a13e498">More...</a><br /></td></tr>
<tr class="separator:ga19ffb7df9b29e9a6017c1c480a13e498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c0f7848c39b558f0052c7979ae8365"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga45c0f7848c39b558f0052c7979ae8365">sort_keyuse</a> (const <a class="el" href="classKey__use.html">Key_use</a> &amp;a, const <a class="el" href="classKey__use.html">Key_use</a> &amp;b)</td></tr>
<tr class="memdesc:ga45c0f7848c39b558f0052c7979ae8365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two keyuse elements.  <a href="#ga45c0f7848c39b558f0052c7979ae8365">More...</a><br /></td></tr>
<tr class="separator:ga45c0f7848c39b558f0052c7979ae8365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb193b442028d7a278d4cd14538d225"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html#ga4fb193b442028d7a278d4cd14538d225">add_key_fields_for_nj</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *nested_join_table, <a class="el" href="structKey__field.html">Key_field</a> **end, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *and_level, <a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="separator:ga4fb193b442028d7a278d4cd14538d225"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module analyzes all equality predicates to determine the best independent ref/eq_ref/ref_or_null index access methods. </p>
<p>The 'ref' optimizer determines the columns (and expressions over them) that reference columns in other tables via an equality, and analyzes which keys and key parts can be used for index lookup based on these references. The main outcomes of the 'ref' optimizer are:</p>
<ul>
<li>A bi-directional graph of all equi-join conditions represented as an array of Key_use elements. This array is stored in JOIN::keyuse_array in table, key, keypart order. Each JOIN_TAB::keyuse points to the first Key_use element with the same table as JOIN_TAB::table.</li>
<li>The table dependencies needed by the optimizer to determine what tables must be before certain table so that they provide the necessary column bindings for the equality predicates.</li>
<li>Computed properties of the equality predicates such as null_rejecting and the result size of each separate condition.</li>
</ul>
<p>Updates in JOIN_TAB:</p><ul>
<li>JOIN_TAB::keys Bitmap of all used keys.</li>
<li>JOIN_TAB::const_keys Bitmap of all keys that may be used with quick_select.</li>
<li>JOIN_TAB::keyuse Pointer to possible keys. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga58297bde0da4187801e718c29d5d6b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58297bde0da4187801e718c29d5d6b5e">&#9670;&nbsp;</a></span>KEY_OPTIMIZE_EXISTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KEY_OPTIMIZE_EXISTS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0658a5d9673135da1c2f6463f0537405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0658a5d9673135da1c2f6463f0537405">&#9670;&nbsp;</a></span>KEY_OPTIMIZE_REF_OR_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KEY_OPTIMIZE_REF_OR_NULL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga19ffb7df9b29e9a6017c1c480a13e498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19ffb7df9b29e9a6017c1c480a13e498">&#9670;&nbsp;</a></span>add_ft_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_ft_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a> *&#160;</td>
          <td class="paramname"><em>keyuse_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>usable_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>simple_match_expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function parses WHERE condition and add key_use for FT index into key_use array if suitable MATCH function is found. </p>
<p>Condition should be a set of AND expression, OR is not supported. MATCH function should be a part of simple expression. Simple expression is MATCH only function or MATCH is a part of comparison expression ('&gt;=' or '&gt;' operations are supported). It also sets FT_HINTS values(op_type, op_value).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyuse_array</td><td>Key_use array </td></tr>
    <tr><td class="paramname">stat</td><td>JOIN_TAB structure </td></tr>
    <tr><td class="paramname">cond</td><td>WHERE condition </td></tr>
    <tr><td class="paramname">usable_tables</td><td>usable tables </td></tr>
    <tr><td class="paramname">simple_match_expr</td><td>true if this is the first call false otherwise. if MATCH function is found at first call it means that MATCH is simple expression, otherwise, in case of AND/OR condition this parameter will be false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if FT key was added to Key_use array </td></tr>
    <tr><td class="paramname">false</td><td>if no key was added to Key_use array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab881bea02300169cb168cbd95d0cbd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab881bea02300169cb168cbd95d0cbd8a">&#9670;&nbsp;</a></span>add_key_equal_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_key_equal_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> **&#160;</td>
          <td class="paramname"><em>key_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>and_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>field_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>usable_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add possible keys to array of possible keys originated from a simple predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>session context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_fields</td><td>Pointer to add key, if usable is incremented if key was stored in the array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">and_level</td><td>And level, to be stored in Key_field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>Condition predicate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">field_item</td><td>Field used in comparision </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eq_func</td><td>True if we used =, &lt;=&gt; or IS NULL </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">val</td><td>Value used for comparison with field Is NULL for BETWEEN and IN </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_values</td><td>Number of elements in the array of values </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">usable_tables</td><td>Tables which can be used for key optimization </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sargables</td><td>IN/OUT Array of found sargable candidates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If field items f1 and f2 belong to the same multiple equality and a key is added for f1, the the same key is added for f2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga9aad4fefab19fa26ba55e43e2698d392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aad4fefab19fa26ba55e43e2698d392">&#9670;&nbsp;</a></span>add_key_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_key_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> **&#160;</td>
          <td class="paramname"><em>key_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>and_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>usable_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a possible key to array of possible keys if it's usable as a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_fields</td><td>Used as an input parameter in the sense that it is a pointer to a pointer to a memory area where an array of Key_field objects will stored. It is used as an out parameter in the sense that the pointer will be updated to point beyond the last Key_field written.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>session context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">and_level</td><td>And level, to be stored in Key_field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>Condition predicate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">item_field</td><td>Field used in comparison </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eq_func</td><td>True if we used =, &lt;=&gt; or IS NULL </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value</td><td>Array of values used for comparison with field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_values</td><td>Number of elements in the array of values </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">usable_tables</td><td>Tables which can be used for key optimization </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sargables</td><td>IN/OUT Array of found sargable candidates. Will be ignored in case eq_func is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If we are doing a NOT NULL comparison on a NOT NULL field in a outer join table, we store this to be able to do not exists optimization later.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga94f3d016b241ed75704f70a47f2f69c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f3d016b241ed75704f70a47f2f69c0">&#9670;&nbsp;</a></span>add_key_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_key_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> **&#160;</td>
          <td class="paramname"><em>key_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>and_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>usable_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The guts of the ref optimizer. </p>
<p>This function, along with the other add_key_* functions, make up a recursive procedure that analyzes a condition expression (a tree of AND and OR predicates) and does many things.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>session context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>The query block involving the condition. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_fields</td><td>Start of memory buffer, see below. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">and_level</td><td>Current 'and level', see below. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>The conditional expression to analyze. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">usable_tables</td><td>Tables not in this bitmap will not be examined. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sargables</td><td>End of memory buffer, see below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>This documentation is the result of reverse engineering and may therefore not capture the full gist of the procedure, but it is known to do the following:</p>
<ul>
<li>Populate a raw memory buffer from two directions at the same time. An 'array' of Key_field objects fill the buffer from low to high addresses whilst an 'array' of SARGABLE_PARAM's fills the buffer from high to low addresses. At the first call to this function, it is assumed that key_fields points to the beginning of the buffer and sargables point to the end (except for a poor-mans 'null element' at the very end).</li>
<li>Update a number of properties in the JOIN_TAB's that can be used to find search keys (sargables).<ul>
<li>JOIN_TAB::keys</li>
<li>JOIN_TAB::key_dependent</li>
<li>JOIN_TAB::const_keys (dictates if the range optimizer will be run later.)</li>
</ul>
</li>
</ul>
<p>The Key_field objects are marked with something called an 'and_level', which does <b>not</b> correspond to their nesting depth within the expression tree. It is rather a tag to group conjunctions together. For instance, in the conditional expression</p>
<div class="fragment"><div class="line">a = 0 AND b = 0</div></div><!-- fragment --><p>two Key_field's are produced, both having an and_level of 0.</p>
<p>In an expression such as</p>
<div class="fragment"><div class="line">a = 0 AND b = 0 OR a = 1</div></div><!-- fragment --><p>three Key_field's are produced, the first two corresponding to 'a = 0' and 'b = 0', respectively, both with and_level 0. The third one corresponds to 'a = 1' and has an and_level of 1.</p>
<p>A separate function, merge_key_fields() performs ref access validation on the Key_field array on the recursice ascent. If some Key_field's cannot be used for ref access, the key_fields pointer is rolled back. All other modifications to the query plan remain. </p>

</div>
</div>
<a id="ga4fb193b442028d7a278d4cd14538d225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb193b442028d7a278d4cd14538d225">&#9670;&nbsp;</a></span>add_key_fields_for_nj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_key_fields_for_nj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>nested_join_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> **&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>and_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6bbcf94e4ec6f957ea1252d7b8326021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bbcf94e4ec6f957ea1252d7b8326021">&#9670;&nbsp;</a></span>add_key_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_key_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a> *&#160;</td>
          <td class="paramname"><em>keyuse_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> *&#160;</td>
          <td class="paramname"><em>key_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga60622475937affeb43647813b9b5ad7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60622475937affeb43647813b9b5ad7e">&#9670;&nbsp;</a></span>get_semi_join_select_list_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> get_semi_join_select_list_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a field, return its index in semi-join's select list, or UINT_MAX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_field</td><td>Field to be looked up in select list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">=UINT_MAX</td><td>Field is not from a semijoin-transformed subquery </td></tr>
    <tr><td class="paramname">&lt;UINT_MAX</td><td>Index in select list of subquery</td></tr>
  </table>
  </dd>
</dl>
<p>Given a field, find its table; then see if the table is within a semi-join nest and if the field was in select list of the subquery (if subquery was part of a quantified comparison predicate), or the field was a result of subquery decorrelation. If it was, then return the field's index in the select list. The value is used by LooseScan strategy. </p>

</div>
</div>
<a id="ga155464f8c15576de13e9aba1e6ca875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga155464f8c15576de13e9aba1e6ca875a">&#9670;&nbsp;</a></span>is_local_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_local_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an expression is a non-outer field. </p>
<p>Checks if an expression is a field and belongs to the current select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>Item expression to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the expression is a local field </td></tr>
    <tr><td class="paramname">false</td><td>it's something else </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga307ffdd8c09469bd41945b50d4fe5adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga307ffdd8c09469bd41945b50d4fe5adf">&#9670;&nbsp;</a></span>is_row_of_local_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_row_of_local_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__row.html">Item_row</a> *&#160;</td>
          <td class="paramname"><em>item_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a row constructor expression is over columns in the same query block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_row</td><td>Row expression to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The expression is a local column reference. </td></tr>
    <tr><td class="paramname">false</td><td>It's something else. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1de27fe9f2c08ca72261a3eb995c5b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1de27fe9f2c08ca72261a3eb995c5b76">&#9670;&nbsp;</a></span>merge_key_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structKey__field.html">Key_field</a>* merge_key_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> *&#160;</td>
          <td class="paramname"><em>new_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKey__field.html">Key_field</a> *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>and_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge new key definitions to old ones, remove those not used in both. </p>
<p>This is called for OR between different levels.</p>
<p>To be able to do 'ref_or_null' we merge a comparison of a column and 'column IS NULL' to one test. This is useful for sub select queries that are internally transformed to something like:.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.key=outer_ref_field or t1.key <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a6cc1972e6d9d37556d516f78205a682b">IS</a> <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div></div><!-- fragment --><p>Key_field::null_rejecting is processed as follows: <br />
result has null_rejecting=true if it is set for both ORed references. for example:</p><ul>
<li>(t2.key = t1.field OR t2.key = t1.field) -&gt; null_rejecting=true</li>
<li>(t2.key = t1.field OR t2.key &lt;=&gt; t1.field) -&gt; null_rejecting=false</li>
</ul>

</div>
</div>
<a id="ga45c0f7848c39b558f0052c7979ae8365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45c0f7848c39b558f0052c7979ae8365">&#9670;&nbsp;</a></span>sort_keyuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sort_keyuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classKey__use.html">Key_use</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKey__use.html">Key_use</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two keyuse elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first Key_use element </td></tr>
    <tr><td class="paramname">b</td><td>second Key_use element</td></tr>
  </table>
  </dd>
</dl>
<p>Compare Key_use elements so that they are sorted as follows:</p><ol type="1">
<li>By table.</li>
<li>By key for each table.</li>
<li>By keypart for each key.</li>
<li>Const values.</li>
<li>Ref_or_null.</li>
</ol>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If a &lt; b. </td></tr>
    <tr><td class="paramname">false</td><td>If a &gt;= b. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab014025731a851b69071a35210d5297c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab014025731a851b69071a35210d5297c">&#9670;&nbsp;</a></span>warn_index_not_applicable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void warn_index_not_applicable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a>&#160;</td>
          <td class="paramname"><em>cant_use_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If EXPLAIN or if the &ndash;safe-updates option is enabled, add a warning that an index cannot be used for ref access. </p>
<p>If EXPLAIN or if the &ndash;safe-updates option is enabled, add a warning for each index that cannot be used for ref access due to either type conversion or different collations on the field used for comparison</p>
<p>Example type conversion (char compared to int):</p>
<p>CREATE TABLE t1 (url char(1) PRIMARY KEY); SELECT * FROM t1 WHERE url=1;</p>
<p>Example different collations (danish vs german2):</p>
<p>CREATE TABLE t1 (url char(1) PRIMARY KEY) collate latin1_danish_ci; SELECT * FROM t1 WHERE url='1' collate latin1_german2_ci;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread for the connection that submitted the query </td></tr>
    <tr><td class="paramname">field</td><td>Field used in comparison </td></tr>
    <tr><td class="paramname">cant_use_index</td><td>Indexes that cannot be used for lookup </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
