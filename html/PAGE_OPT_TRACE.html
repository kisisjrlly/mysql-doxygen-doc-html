<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: The Optimizer Trace</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PAGE_OPT_TRACE.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Optimizer Trace </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="INTRODUCTION"></a>
Introduction</h1>
<p>This optimizer trace is aimed at producing output, which is readable by humans and by programs, to aid understanding of decisions and actions taken by the MySQL Optimizer.</p>
<h1><a class="anchor" id="OUTPUT_FORMAT"></a>
Output format</h1>
<p>The chosen output format is JSON (JavaScript Object Notation). In JSON there are: </p><ul>
<li>"objects" (unordered set of key-value pairs); equivalent to Python's dictionary or Perl's associative array or hash or STL's hash_map. </li>
<li>"arrays" (ordered set of values); equivalent to Python's and Perl's list or STL's vector. </li>
<li>"values": a value can be a string, number, boolean, null, which we all call "scalars", or be an object, array.</li>
</ul>
<p>For example (explanations after "&lt;&lt;" are not part of output): </p><pre class="fragment">  {                           &lt;&lt; start of top object
    "first_name": "Gustave",  &lt;&lt; key/value pair (value is string)
    "last_name": "Eiffel",    &lt;&lt; key/value pair (value is string)
    "born": 1832,             &lt;&lt; key/value pair (value is integer)
    "contributions_to": [     &lt;&lt; key/value pair (value is array)
       {                      &lt;&lt; 1st item of array is an object (a building)
         "name": "Eiffel tower",
         "location": Paris
       },                     &lt;&lt; end of 1st item of array
       {
         "name": "Liberty statue",
         "location": "New York"
       }                      &lt;&lt; end of 2nd item of array
    ]                         &lt;&lt; end of array
  }                           &lt;&lt; end of top object
</pre><p> For more details, have a look at the syntax at json.org. Note that indentation and newlines are superfluous, useful only for human-readability. Note also that there is nothing like a "named object": an object, array or value has no name; but if it is the value of a key/value pair in an enclosing, outer object, then the key can be seen as the inner object's "name".</p>
<h1><a class="anchor" id="USER_ENABLE_TRACING"></a>
How a user enables/views the trace</h1>
<pre class="fragment">  SET SESSION OPTIMIZER_TRACE="enabled=on"; # enable tracing
  &lt;statement to trace&gt;; # like SELECT, EXPLAIN SELECT, UPDATE, DELETE...
  SELECT * FROM information_schema.OPTIMIZER_TRACE;
  [ repeat last two steps at will ]
  SET SESSION OPTIMIZER_TRACE="enabled=off"; # disable tracing
</pre><p><code>SELECT</code> and <code>EXPLAIN</code> SELECT produce the same trace. But there are exceptions regarding subqueries because the two commands treat subqueries differently, for example in </p><pre class="fragment">  SELECT ... WHERE x IN (subq1) AND y IN (subq2)
</pre><p> SELECT terminates after executing the first subquery if the related IN predicate is false, so we won't see <code>JOIN::optimize()</code> tracing for subq2; whereas EXPLAIN SELECT analyzes all subqueries (see loop at the end of <code>select_describe()</code>).</p>
<h1><a class="anchor" id="USER_SELECT_TRACING_STATEMENTS"></a>
How a user traces only certain</h1>
<p>statements</p>
<p>When tracing is in force, each SQL statement generates a trace; more exactly, so does any of SELECT, EXPLAIN SELECT, INSERT or REPLACE ( with VALUES or SELECT), UPDATE/DELETE and their multi-table variants, SET (unless it manipulates @@optimizer_trace), DO, DECLARE/CASE/IF/RETURN (stored routines language elements), CALL. If a command above is prepared and executed in separate steps, preparation and execution are separately traced. By default each new trace overwrites the previous trace. Thus, if a statement contains sub-statements (example: invokes stored procedures, stored functions, triggers), the top statement and sub-statements each generate traces, but at the execution's end only the last sub-statement's trace is visible. If the user wants to see the trace of another sub-statement, she/he can enable/disable tracing around the desired sub-statement, but this requires editing the routine's code, which may not be possible. Another solution is to use </p><pre class="fragment">  SET optimizer_trace_offset=&lt;OFFSET&gt;, optimizer_trace_limit=&lt;LIMIT&gt;
</pre><p> where OFFSET is a signed integer, and LIMIT is a positive integer. The effect of this SET is the following:</p>
<ul>
<li>all remembered traces are cleared</li>
</ul>
<ul>
<li>a later SELECT on OPTIMIZER_TRACE returns the first LIMIT traces of the OFFSET oldest remembered traces (if OFFSET &gt;= 0), or the first LIMIT traces of the -OFFSET newest remembered traces (if OFFSET &lt; 0).</li>
</ul>
<p>For example, a combination of OFFSET=-1 and LIMIT=1 will make the last trace be shown (as is default), OFFSET=-2 and LIMIT=1 will make the next-to-last be shown, OFFSET=-5 and LIMIT=5 will make the last five traces be shown. Such negative OFFSET can be useful when one knows that the interesting sub-statements are the few last ones of a stored routine, like this: </p><pre class="fragment">  SET optimizer_trace_offset=-5, optimizer_trace_limit=5;
  CALL stored_routine(); # more than 5 sub-statements in this routine
  SELECT * FROM information_schema.OPTIMIZER_TRACE; # see only last 5 traces
</pre><p> On the opposite, a positive OFFSET can be useful when one knows that the interesting sub-statements are the few first ones of a stored routine.</p>
<p>The more those two variables are accurately adjusted, the less memory is used. For example, OFFSET=0 and LIMIT=5 will use memory to remember 5 traces, so if only the three first are needed, OFFSET=0 and LIMIT=3 is better (tracing stops after the LIMITth trace, so the 4th and 5th trace are not created and don't take up memory). A stored routine may have a loop which executes many sub-statements and thus generates many traces, which would use a lot of memory; proper OFFSET and LIMIT can restrict tracing to one iteration of the loop for example. This also gains speed, as tracing a sub-statement impacts performance.</p>
<p>If OFFSET&gt;=0, only LIMIT traces are kept in memory. If OFFSET&lt;0, that is not true: instead, (-OFFSET) traces are kept in memory; indeed even if LIMIT is smaller than (-OFFSET), so excludes the last statement, the last statement must still be traced because it will be inside LIMIT after executing one more statement (remember than OFFSET&lt;0 is counted from the end: the "window" slides as more statements execute).</p>
<p>Such memory and speed gains are the reason why optimizer_trace_offset/limit, which are restrictions at the trace producer level, are offered. They are better than using </p><pre class="fragment">  SELECT * FROM OPTIMIZER_TRACE LIMIT &lt;LIMIT&gt; OFFSET &lt;OFFSET&gt;;
</pre><p> which is a restriction on the trace consumer level, which saves almost nothing.</p>
<h1><a class="anchor" id="USER_SELECT_TRACING_FEATURES"></a>
How a user traces only certain</h1>
<p>optimizer features</p>
<pre class="fragment">  SET OPTIMIZER_TRACE_FEATURES="feature1=on|off,...";
</pre><p> where "feature1" is one optimizer feature. For example "greedy_search": a certain Opt_trace_array at the start of <code>Optimize_table_order::choose_table_order()</code> has a flag "GREEDY_SEARCH" passed to its constructor: this means that if the user has turned tracing of greedy search off, this array will not be written to the I_S trace, neither will any children structures. All this disabled "trace chunk" will be replaced by an ellipsis "...".</p>
<h1><a class="anchor" id="DEV_ADDS_TRACING"></a>
How a developer adds tracing to a function</h1>
<p>Check <code>Opt_trace*</code> usage in <code>advance_sj_state()</code>:</p>
<pre class="fragment">  Opt_trace_array trace_choices(trace, "semijoin_strategy_choice");
</pre><p>This creates an array for key "semijoin_strategy_choice". We are going to list possible semijoin strategy choices.</p>
<pre class="fragment">  Opt_trace_object trace_one_strategy(trace);
</pre><p>This creates an object without key (normal, it's in an array). This object will describe one single strategy choice.</p>
<pre class="fragment">  trace_one_strategy.add_alnum("strategy", "FirstMatch");
</pre><p>This adds a key/value pair to the just-created object: key is "strategy", value is "FirstMatch". This is the strategy to be described in the just-created object.</p>
<pre class="fragment">  trace_one_strategy.add("cost", *current_read_time).
    add("records", *current_record_count);
  trace_one_strategy.add("chosen", (pos-&gt;sj_strategy == SJ_OPT_FIRST_MATCH));
</pre><p>This adds 3 key/value pairs: cost of strategy, number of records produced by this strategy, and whether this strategy is chosen.</p>
<p>After that, there is similar code for other semijoin strategies.</p>
<p>The resulting trace piece (seen in <code>information_schema.OPTIMIZER_TRACE</code>) is </p><pre class="fragment">          "semijoin_strategy_choice": [
            {
              "strategy": "FirstMatch",
              "cost": 1,
              "records": 1,
              "chosen": true
            },
            {
              "strategy": "DuplicatesWeedout",
              "cost": 1.1,
              "records": 1,
              "duplicate_tables_left": false,
              "chosen": false
            }
          ]
</pre><p>For more output examples, check result files of the opt_trace suite in <code>mysql-test</code>.</p>
<p>Feature can be un-compiled with</p><div class="fragment"><div class="line">cmake -DOPTIMIZER_TRACE=0 </div></div><!-- fragment --><p>.</p>
<h1><a class="anchor" id="WITH_DBUG"></a>
Interaction between trace and DBUG</h1>
<p>We don't want to have to duplicate code like this: </p><pre class="fragment">  DBUG_PRINT("info",("cost %g",cost));
  Opt_trace_object(thd-&gt;opt_trace).add("cost",cost);
</pre><p>Thus, any optimizer trace operation, <em>even</em> if tracing is run-time disabled, has an implicit DBUG_PRINT("opt",...) inside. This way, only the second line above is needed, and several DBUG_PRINT() could be removed from the Optimizer code. When tracing is run-time disabled, in a debug binary, traces are still created in order to catch the <code>add()</code> calls and write their text to DBUG, but those traces are not visible into INFORMATION_SCHEMA.OPTIMIZER_TRACE: we then say that they "don't support I_S". A debug binary without optimizer trace compiled in, will intentionally not compile.</p>
<p>Because opening an object or array, or add()-ing to it, writes to DBUG immediately, a key/value pair and its outer object may be 100 lines apart in the DBUG log.</p>
<h1><a class="anchor" id="ADDING_TRACING"></a>
Guidelines for adding tracing</h1>
<ul>
<li>Try to limit the number of distinct "words". For example, when describing an optimizer's decision, the words "chosen" (true/false value, tells whether we are choosing the said optimization), "cause" (free text value, tells why we are making this choice, when it's not obvious) can and should often be used. Having a restricted vocabulary helps consistency. Use "row" instead of "record". Use "tmp" instead of "temporary".</li>
</ul>
<ul>
<li>Use only simple characters for key names: a-ZA-Z_#, and no space. '#' serves to denote a number, like in "select#" .</li>
</ul>
<ul>
<li>Keep in mind than in an object, keys are not ordered; an application may parse the JSON output and output it again with keys order changed; thus when order matters, use an array (which may imply having anonymous objects as items of the array, with keys inside the anonymous objects, see how it's done in <code>JOIN::optimize()</code>). Keep in mind that in an object keys should be unique, an application may lose duplicate keys.</li>
</ul>
<h1><a class="anchor" id="OOM_HANDLING"></a>
Handling of "out-of-memory" errors</h1>
<p>All memory allocations (with exceptions: see below) in the Optimizer trace use <code>my_error()</code> to report errors, which itself calls <code>error_handler_hook</code>. It is the responsibility of the API user to set up a proper <code>error_handler_hook</code> which will alert her/him of the OOM problem. When in the server, this is already the case (<code>error_handler_hook</code> is <code>my_message_sql()</code> which makes the statement fail). Note that the debug binary may crash if OOM (OOM can cause syntax errors...).</p>
<h1><a class="anchor" id="TRACE_SECURITY"></a>
Description of trace-induced security checks.</h1>
<p>A trace exposes information. For example if one does SELECT on a view, the trace contains the view's body. So, the user should be allowed to see the trace only if she/he has privilege to see the body, i.e. privilege to do SHOW CREATE VIEW. There are similar issues with stored procedures, functions, triggers.</p>
<p>We implement this by doing additional checks on SQL objects when tracing is on: </p><ul>
<li>stored procedures, functions, triggers: checks are done when executing those objects </li>
<li>base tables and views.</li>
</ul>
<p>Base tables or views are listed in some <code>LEX::query_tables</code>. The LEX may be of the executing statement (statement executed by <code>mysql_execute_command()</code>, or by <code>sp_lex_keeper::reset_lex_and_exec_core()</code>), we check this LEX in the constructor of Opt_trace_start. Or it may be a LEX describing a view, we check this LEX when opening the view (<code>open_and_read_view()</code>).</p>
<p>Those checks are greatly simplified by disabling traces in case of security context changes. </p><dl class="section see"><dt>See also</dt><dd>opt_trace_disable_if_no_security_context_access().</dd></dl>
<p>Those checks must be done with the security context of the connected user. Checks with the SUID context would be useless: assume the design is that the basic user does not have DML privileges on tables, but only EXECUTE on SUID-highly-privileged routines (which implement <em>controlled</em> <em>approved</em> DMLs): then the SUID context would successfully pass all additional privilege checks, routine would generate tracing, and the connected user would view the trace after the routine's execution, seeing secret information.</p>
<h1><a class="anchor" id="NEXT"></a>
What a developer should read next</h1>
<p>The documentation of those classes, in order </p><div class="fragment"><div class="line"><a class="code" href="classOpt__trace__context.html">Opt_trace_context</a></div><div class="line">Opt_trace_context_impl</div><div class="line"><a class="code" href="classOpt__trace__stmt.html">Opt_trace_stmt</a></div><div class="line"><a class="code" href="classOpt__trace__struct.html">Opt_trace_struct</a></div><div class="line"><a class="code" href="classOpt__trace__object.html">Opt_trace_object</a></div><div class="line"><a class="code" href="classOpt__trace__array.html">Opt_trace_array</a></div></div><!-- fragment --><p> and then <a class="el" href="opt__trace_8h.html">opt_trace.h</a> as a whole. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_SQL_EXECUTION.html">SQL Query Execution</a></li><li class="navelem"><a class="el" href="PAGE_SQL_Optimizer.html">SQL Optimizer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
