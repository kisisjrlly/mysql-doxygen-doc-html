<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/row/row0upd.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('row0upd_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">row0upd.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Update of a row.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__byteorder_8h_source.html">my_byteorder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0rec_8h_source.html">rem0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="current__thd_8h_source.html">current_thd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0crea_8h_source.html">dict0crea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eval0eval_8h_source.html">eval0eval.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fts0fts_8h_source.html">fts0fts.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fts0types_8h_source.html">fts0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lob0lob_8h_source.html">lob0lob.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0sym_8h_source.html">pars0sym.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0ext_8h_source.html">row0ext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0ins_8h_source.html">row0ins.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0log_8h_source.html">row0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0sel_8h_source.html">row0sel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0rec_8h_source.html">trx0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dd_8h_source.html">dict0dd.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1c350f15c30918fa6b48dee634f0b9d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a1c350f15c30918fa6b48dee634f0b9d6">row_upd_ext_fetch</a>(clust_index,  data,  local_len,  page_size,  len,  is_sdi,  heap)</td></tr>
<tr class="separator:a1c350f15c30918fa6b48dee634f0b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb22f0d802978a752740185b9e05f30e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#aeb22f0d802978a752740185b9e05f30e">row_upd_index_replace_new_col_val</a>(<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>,  dfield,  field,  col,  uf,  heap,  is_sdi,  page_size)</td></tr>
<tr class="separator:aeb22f0d802978a752740185b9e05f30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b68f78ad7c133d8003cf33b059c72d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a6b68f78ad7c133d8003cf33b059c72d8">row_upd_clust_rec_by_insert_inherit</a>(rec,  offsets,  <a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>,  <a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)&#160;&#160;&#160;<a class="el" href="row0upd_8cc.html#a07c376516b1f7519ffa7ac41efd7db0e">row_upd_clust_rec_by_insert_inherit_func</a>(rec, offsets, <a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="separator:a6b68f78ad7c133d8003cf33b059c72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa55bb5d9756a5bc30ffffa5ec4f6f1cc"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#aa55bb5d9756a5bc30ffffa5ec4f6f1cc">row_upd_changes_first_fields_binary</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:aa55bb5d9756a5bc30ffffa5ec4f6f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an update vector changes some of the first ordering fields of an index record.  <a href="#aa55bb5d9756a5bc30ffffa5ec4f6f1cc">More...</a><br /></td></tr>
<tr class="separator:aa55bb5d9756a5bc30ffffa5ec4f6f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f593cb7ea3cc077bd99a96b699ff334"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a2f593cb7ea3cc077bd99a96b699ff334">row_upd_index_is_referenced</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a2f593cb7ea3cc077bd99a96b699ff334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if index currently is mentioned as a referenced index in a foreign key constraint.  <a href="#a2f593cb7ea3cc077bd99a96b699ff334">More...</a><br /></td></tr>
<tr class="separator:a2f593cb7ea3cc077bd99a96b699ff334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21ed0cd4cc80c91ea4abf6a9b873bb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#aa21ed0cd4cc80c91ea4abf6a9b873bb3">row_upd_check_references_constraints</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa21ed0cd4cc80c91ea4abf6a9b873bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if possible foreign key constraints hold after a delete of the record under pcur.  <a href="#aa21ed0cd4cc80c91ea4abf6a9b873bb3">More...</a><br /></td></tr>
<tr class="separator:aa21ed0cd4cc80c91ea4abf6a9b873bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655590bf847503b6297d9d8d246201ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a655590bf847503b6297d9d8d246201ff">upd_node_create</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a655590bf847503b6297d9d8d246201ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an update node for a query graph.  <a href="#a655590bf847503b6297d9d8d246201ff">More...</a><br /></td></tr>
<tr class="separator:a655590bf847503b6297d9d8d246201ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb05f212ddac2808ee035ef4d22f917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#abfb05f212ddac2808ee035ef4d22f917">row_upd_rec_sys_fields_in_recovery</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const ulint *offsets, ulint <a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr)</td></tr>
<tr class="memdesc:abfb05f212ddac2808ee035ef4d22f917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the trx id and roll ptr field in a clustered index record in database recovery.  <a href="#abfb05f212ddac2808ee035ef4d22f917">More...</a><br /></td></tr>
<tr class="separator:abfb05f212ddac2808ee035ef4d22f917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa516d2dc3d1ddcdf1a73b31cd5cbce0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#aa516d2dc3d1ddcdf1a73b31cd5cbce0b">row_upd_index_entry_sys_field</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint type, ib_uint64_t val)</td></tr>
<tr class="memdesc:aa516d2dc3d1ddcdf1a73b31cd5cbce0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the trx id or roll ptr field of a clustered index entry.  <a href="#aa516d2dc3d1ddcdf1a73b31cd5cbce0b">More...</a><br /></td></tr>
<tr class="separator:aa516d2dc3d1ddcdf1a73b31cd5cbce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8da72b47b7afc4a67c12584cce14db"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a5c8da72b47b7afc4a67c12584cce14db">row_upd_changes_field_size_or_external</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:a5c8da72b47b7afc4a67c12584cce14db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if row update changes size of some field in index or if some field to be updated is stored externally in rec or update.  <a href="#a5c8da72b47b7afc4a67c12584cce14db">More...</a><br /></td></tr>
<tr class="separator:a5c8da72b47b7afc4a67c12584cce14db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902192e6824406c3796068d2173b2aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a902192e6824406c3796068d2173b2aff">row_upd_changes_disowned_external</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:a902192e6824406c3796068d2173b2aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if row update contains disowned external fields.  <a href="#a902192e6824406c3796068d2173b2aff">More...</a><br /></td></tr>
<tr class="separator:a902192e6824406c3796068d2173b2aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4c4ef5c26a83086f51130897c89dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#add4c4ef5c26a83086f51130897c89dd9">row_upd_rec_in_place</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="memdesc:add4c4ef5c26a83086f51130897c89dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector to the record given.  <a href="#add4c4ef5c26a83086f51130897c89dd9">More...</a><br /></td></tr>
<tr class="separator:add4c4ef5c26a83086f51130897c89dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2720d792e43ac476db80779bba13544c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a2720d792e43ac476db80779bba13544c">row_upd_write_sys_vals_to_log</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a2720d792e43ac476db80779bba13544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes into the redo log the values of trx id and roll ptr and enough info to determine their positions within a clustered index record.  <a href="#a2720d792e43ac476db80779bba13544c">More...</a><br /></td></tr>
<tr class="separator:a2720d792e43ac476db80779bba13544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae304da2bc13e35c67c164467960b27ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ae304da2bc13e35c67c164467960b27ac">row_upd_parse_sys_vals</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, ulint *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *roll_ptr)</td></tr>
<tr class="memdesc:ae304da2bc13e35c67c164467960b27ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the log data of system field values.  <a href="#ae304da2bc13e35c67c164467960b27ac">More...</a><br /></td></tr>
<tr class="separator:ae304da2bc13e35c67c164467960b27ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7fba00a40039307f4605056af9c54b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a3b7fba00a40039307f4605056af9c54b">row_upd_index_write_log</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a3b7fba00a40039307f4605056af9c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the redo log the new values of the fields occurring in the index.  <a href="#a3b7fba00a40039307f4605056af9c54b">More...</a><br /></td></tr>
<tr class="separator:a3b7fba00a40039307f4605056af9c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0960639c762f39cce1d29241e8b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a8bf0960639c762f39cce1d29241e8b1e">row_upd_index_parse</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structupd__t.html">upd_t</a> **update_out)</td></tr>
<tr class="memdesc:a8bf0960639c762f39cce1d29241e8b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the log data written by row_upd_index_write_log.  <a href="#a8bf0960639c762f39cce1d29241e8b1e">More...</a><br /></td></tr>
<tr class="separator:a8bf0960639c762f39cce1d29241e8b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cf371b11d50c6ad635038a71306b73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a00cf371b11d50c6ad635038a71306b73">row_upd_build_sec_rec_difference_binary</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a00cf371b11d50c6ad635038a71306b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an update vector from those fields which in a secondary index entry differ from a record that has the equal ordering fields.  <a href="#a00cf371b11d50c6ad635038a71306b73">More...</a><br /></td></tr>
<tr class="separator:a00cf371b11d50c6ad635038a71306b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838bfedaa4543cf09a38da782a458217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a838bfedaa4543cf09a38da782a458217">row_upd_build_difference_binary</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> no_sys, <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structTABLE.html">TABLE</a> *mysql_table, <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *error)</td></tr>
<tr class="memdesc:a838bfedaa4543cf09a38da782a458217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an update vector from those fields, excluding the roll ptr and trx id fields, which in an index entry differ from a record that has the equal ordering fields.  <a href="#a838bfedaa4543cf09a38da782a458217">More...</a><br /></td></tr>
<tr class="separator:a838bfedaa4543cf09a38da782a458217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d2a5f1af92104f5dc3eb09a34b663d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ae9d2a5f1af92104f5dc3eb09a34b663d">row_upd_ext_fetch_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *data, ulint local_len, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint *len, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_sdi, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:ae9d2a5f1af92104f5dc3eb09a34b663d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a prefix of an externally stored column.  <a href="#ae9d2a5f1af92104f5dc3eb09a34b663d">More...</a><br /></td></tr>
<tr class="separator:ae9d2a5f1af92104f5dc3eb09a34b663d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fb9a44189c96055a63a34aa8879a71"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a30fb9a44189c96055a63a34aa8879a71">row_upd_index_replace_new_col_val_func</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdfield__t.html">dfield_t</a> *dfield, const <a class="el" href="structdict__field__t.html">dict_field_t</a> *field, const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col, const <a class="el" href="structupd__field__t.html">upd_field_t</a> *uf, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_sdi, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size)</td></tr>
<tr class="memdesc:a30fb9a44189c96055a63a34aa8879a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column value stored in the update vector in the given index entry field.  <a href="#a30fb9a44189c96055a63a34aa8879a71">More...</a><br /></td></tr>
<tr class="separator:a30fb9a44189c96055a63a34aa8879a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdbead3f6bc4683c091c025761b28c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#afbdbead3f6bc4683c091c025761b28c7">row_upd_index_replace_new_col_vals_index_pos</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ibool order_only, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:afbdbead3f6bc4683c091c025761b28c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector to the index entry given.  <a href="#afbdbead3f6bc4683c091c025761b28c7">More...</a><br /></td></tr>
<tr class="separator:afbdbead3f6bc4683c091c025761b28c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9a7b3c3d7c1127f608f91ae11b41ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a9a9a7b3c3d7c1127f608f91ae11b41ef">row_upd_index_replace_new_col_vals</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a9a9a7b3c3d7c1127f608f91ae11b41ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector to the index entry given.  <a href="#a9a9a7b3c3d7c1127f608f91ae11b41ef">More...</a><br /></td></tr>
<tr class="separator:a9a9a7b3c3d7c1127f608f91ae11b41ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89885847c96734248b50c2176061091d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a89885847c96734248b50c2176061091d">row_upd_set_vcol_data</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *row, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *field, ulint len, <a class="el" href="structdict__v__col__t.html">dict_v_col_t</a> *vcol)</td></tr>
<tr class="memdesc:a89885847c96734248b50c2176061091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the virtual column values stored in the update vector.  <a href="#a89885847c96734248b50c2176061091d">More...</a><br /></td></tr>
<tr class="separator:a89885847c96734248b50c2176061091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0039db94d3ed183135cfa8d4a49b42d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ae0039db94d3ed183135cfa8d4a49b42d">row_upd_replace_vcol</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *row, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> upd_new, <a class="el" href="structdtuple__t.html">dtuple_t</a> *undo_row, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr)</td></tr>
<tr class="memdesc:ae0039db94d3ed183135cfa8d4a49b42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the virtual column values stored in a dtuple with that of a update vector.  <a href="#ae0039db94d3ed183135cfa8d4a49b42d">More...</a><br /></td></tr>
<tr class="separator:ae0039db94d3ed183135cfa8d4a49b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc29008c34ee2e8c776a6d73b76f61e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#acc29008c34ee2e8c776a6d73b76f61e4">row_upd_replace</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdtuple__t.html">dtuple_t</a> *row, <a class="el" href="structrow__ext__t.html">row_ext_t</a> **ext, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:acc29008c34ee2e8c776a6d73b76f61e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector.  <a href="#acc29008c34ee2e8c776a6d73b76f61e4">More...</a><br /></td></tr>
<tr class="separator:acc29008c34ee2e8c776a6d73b76f61e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a462bcc93bd912d846fb253463bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#af70a462bcc93bd912d846fb253463bf0">row_upd_changes_ord_field_binary_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, const <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *row, const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *ext, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *non_mv_upd, ulint <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>)</td></tr>
<tr class="memdesc:af70a462bcc93bd912d846fb253463bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an update vector changes an ordering field of an index record.  <a href="#af70a462bcc93bd912d846fb253463bf0">More...</a><br /></td></tr>
<tr class="separator:af70a462bcc93bd912d846fb253463bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e7dba0ba7d65289f702a3d3f8ec00"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a0b3e7dba0ba7d65289f702a3d3f8ec00">row_upd_changes_some_index_ord_field_binary</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:a0b3e7dba0ba7d65289f702a3d3f8ec00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an update vector changes an ordering field of an index record.  <a href="#a0b3e7dba0ba7d65289f702a3d3f8ec00">More...</a><br /></td></tr>
<tr class="separator:a0b3e7dba0ba7d65289f702a3d3f8ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedafd388956767bd826a954029de13f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#aedafd388956767bd826a954029de13f4">row_upd_changes_doc_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field)</td></tr>
<tr class="memdesc:aedafd388956767bd826a954029de13f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an FTS Doc ID column is affected by an UPDATE.  <a href="#aedafd388956767bd826a954029de13f4">More...</a><br /></td></tr>
<tr class="separator:aedafd388956767bd826a954029de13f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34c7757393893c9ac19cd3dfaf1befe"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ab34c7757393893c9ac19cd3dfaf1befe">row_upd_changes_fts_column</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field)</td></tr>
<tr class="memdesc:ab34c7757393893c9ac19cd3dfaf1befe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an FTS indexed column is affected by an UPDATE.  <a href="#ab34c7757393893c9ac19cd3dfaf1befe">More...</a><br /></td></tr>
<tr class="separator:ab34c7757393893c9ac19cd3dfaf1befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe1724f880f26e91726ae2a8ab1635"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#abdfe1724f880f26e91726ae2a8ab1635">row_upd_copy_columns</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structsym__node__t.html">sym_node_t</a> *column)</td></tr>
<tr class="memdesc:abdfe1724f880f26e91726ae2a8ab1635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the column values from a record.  <a href="#abdfe1724f880f26e91726ae2a8ab1635">More...</a><br /></td></tr>
<tr class="separator:abdfe1724f880f26e91726ae2a8ab1635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1323c4b32a084eff6d66e53478e74b1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ad1323c4b32a084eff6d66e53478e74b1">row_upd_eval_new_vals</a> (<a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:ad1323c4b32a084eff6d66e53478e74b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the new values for fields to update.  <a href="#ad1323c4b32a084eff6d66e53478e74b1">More...</a><br /></td></tr>
<tr class="separator:ad1323c4b32a084eff6d66e53478e74b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf69cf45689b146f7537a2659d943166"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#abf69cf45689b146f7537a2659d943166">row_upd_store_v_row</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *mysql_table)</td></tr>
<tr class="memdesc:abf69cf45689b146f7537a2659d943166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores to the heap the virtual columns that need for any indexes.  <a href="#abf69cf45689b146f7537a2659d943166">More...</a><br /></td></tr>
<tr class="separator:abf69cf45689b146f7537a2659d943166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b88335c2bea8df94e814325e117c491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a8b88335c2bea8df94e814325e117c491">row_upd_store_row</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *mysql_table)</td></tr>
<tr class="memdesc:a8b88335c2bea8df94e814325e117c491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores to the heap the row on which the node-&gt;pcur is positioned.  <a href="#a8b88335c2bea8df94e814325e117c491">More...</a><br /></td></tr>
<tr class="separator:a8b88335c2bea8df94e814325e117c491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6794e63bacff453cf0236989dc5a423f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a6794e63bacff453cf0236989dc5a423f">srv_mbr_print</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *data)</td></tr>
<tr class="memdesc:a6794e63bacff453cf0236989dc5a423f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a MBR data from disk.  <a href="#a6794e63bacff453cf0236989dc5a423f">More...</a><br /></td></tr>
<tr class="separator:a6794e63bacff453cf0236989dc5a423f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cc5d0f5d6300fc1d6b91639b302800"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ad4cc5d0f5d6300fc1d6b91639b302800">row_upd_del_one_multi_sec_index_entry</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:ad4cc5d0f5d6300fc1d6b91639b302800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete mark a secondary index entry of a row, when the index is built on multi-value field.  <a href="#ad4cc5d0f5d6300fc1d6b91639b302800">More...</a><br /></td></tr>
<tr class="separator:ad4cc5d0f5d6300fc1d6b91639b302800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae235166fa0eb68e24974fe6fbcabfc96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ae235166fa0eb68e24974fe6fbcabfc96">row_upd_multi_sec_index_entry</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> non_mv_upd)</td></tr>
<tr class="memdesc:ae235166fa0eb68e24974fe6fbcabfc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates secondary index entries of a row, when the index is built on multi-value field.  <a href="#ae235166fa0eb68e24974fe6fbcabfc96">More...</a><br /></td></tr>
<tr class="separator:ae235166fa0eb68e24974fe6fbcabfc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59844e0b7daf983dfae1ec395a96426a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a59844e0b7daf983dfae1ec395a96426a">row_upd_sec_index_entry_low</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structdtuple__t.html">dtuple_t</a> *old_entry, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a59844e0b7daf983dfae1ec395a96426a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a secondary index entry of a row.  <a href="#a59844e0b7daf983dfae1ec395a96426a">More...</a><br /></td></tr>
<tr class="separator:a59844e0b7daf983dfae1ec395a96426a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a669713345b47c7af55460196f9d40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a87a669713345b47c7af55460196f9d40">row_upd_sec_index_entry</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a87a669713345b47c7af55460196f9d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a secondary index entry of a row.  <a href="#a87a669713345b47c7af55460196f9d40">More...</a><br /></td></tr>
<tr class="separator:a87a669713345b47c7af55460196f9d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9237ad8130cd6abb0839a43d3d29f448"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a9237ad8130cd6abb0839a43d3d29f448">row_upd_del_multi_sec_index_entry</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a9237ad8130cd6abb0839a43d3d29f448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete secondary index entries of a row, when the index is built on multi-value field.  <a href="#a9237ad8130cd6abb0839a43d3d29f448">More...</a><br /></td></tr>
<tr class="separator:a9237ad8130cd6abb0839a43d3d29f448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293cc7dd95e743ef02740eb1d5db1ff0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a293cc7dd95e743ef02740eb1d5db1ff0">row_upd_sec_step</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a293cc7dd95e743ef02740eb1d5db1ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the secondary index record if it is changed in the row update or deletes it if this is a delete.  <a href="#a293cc7dd95e743ef02740eb1d5db1ff0">More...</a><br /></td></tr>
<tr class="separator:a293cc7dd95e743ef02740eb1d5db1ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c376516b1f7519ffa7ac41efd7db0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a07c376516b1f7519ffa7ac41efd7db0e">row_upd_clust_rec_by_insert_inherit_func</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:a07c376516b1f7519ffa7ac41efd7db0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark non-updated off-page columns inherited when the primary key is updated.  <a href="#a07c376516b1f7519ffa7ac41efd7db0e">More...</a><br /></td></tr>
<tr class="separator:a07c376516b1f7519ffa7ac41efd7db0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89bb5a2c8412d680ed73a1e2d611e6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ac89bb5a2c8412d680ed73a1e2d611e6e">row_upd_clust_rec_by_insert</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, ibool referenced, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac89bb5a2c8412d680ed73a1e2d611e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the clustered index record deleted and inserts the updated version of the record to the index.  <a href="#ac89bb5a2c8412d680ed73a1e2d611e6e">More...</a><br /></td></tr>
<tr class="separator:ac89bb5a2c8412d680ed73a1e2d611e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfdb6c921068d3859455412321acc28"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a5cfdb6c921068d3859455412321acc28">row_upd_get_new_autoinc_counter</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint autoinc_field_no)</td></tr>
<tr class="memdesc:a5cfdb6c921068d3859455412321acc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the new autoinc counter from the update vector when there is an autoinc field defined in this table.  <a href="#a5cfdb6c921068d3859455412321acc28">More...</a><br /></td></tr>
<tr class="separator:a5cfdb6c921068d3859455412321acc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7f358ae7e7592f1997b6295ab80246"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a8f7f358ae7e7592f1997b6295ab80246">row_upd_check_autoinc_counter</a> (const <a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a8f7f358ae7e7592f1997b6295ab80246"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the table has autoinc column and the counter is updated to some bigger value, we need to log the new autoinc counter.  <a href="#a8f7f358ae7e7592f1997b6295ab80246">More...</a><br /></td></tr>
<tr class="separator:a8f7f358ae7e7592f1997b6295ab80246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe293bc753225db9edc8858fa0080f16"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#afe293bc753225db9edc8858fa0080f16">row_upd_clust_rec</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint *offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offsets_heap, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:afe293bc753225db9edc8858fa0080f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a clustered index record of a row when the ordering fields do not change.  <a href="#afe293bc753225db9edc8858fa0080f16">More...</a><br /></td></tr>
<tr class="separator:afe293bc753225db9edc8858fa0080f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acfef1fe86af5121e658c93f83b0f8d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a0acfef1fe86af5121e658c93f83b0f8d">row_upd_del_mark_clust_rec</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, ibool referenced, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a0acfef1fe86af5121e658c93f83b0f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete marks a clustered index record.  <a href="#a0acfef1fe86af5121e658c93f83b0f8d">More...</a><br /></td></tr>
<tr class="separator:a0acfef1fe86af5121e658c93f83b0f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5057795d0fa20a648d790c09e86a21"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a8c5057795d0fa20a648d790c09e86a21">row_upd_clust_step</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *const thr)</td></tr>
<tr class="memdesc:a8c5057795d0fa20a648d790c09e86a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the clustered index record.  <a href="#a8c5057795d0fa20a648d790c09e86a21">More...</a><br /></td></tr>
<tr class="separator:a8c5057795d0fa20a648d790c09e86a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd49999333aef51b832b638258d10c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a7bd49999333aef51b832b638258d10c1">row_upd</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a7bd49999333aef51b832b638258d10c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the affected index records of a row.  <a href="#a7bd49999333aef51b832b638258d10c1">More...</a><br /></td></tr>
<tr class="separator:a7bd49999333aef51b832b638258d10c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33265d5ab656dba287eb974c407bcf18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a33265d5ab656dba287eb974c407bcf18">row_upd_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a33265d5ab656dba287eb974c407bcf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a row in a table.  <a href="#a33265d5ab656dba287eb974c407bcf18">More...</a><br /></td></tr>
<tr class="separator:a33265d5ab656dba287eb974c407bcf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d91bac73733a3eabd351c3c82f9a7b"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#ac4d91bac73733a3eabd351c3c82f9a7b">print_binary_diff</a> (std::ostream &amp;out, <a class="el" href="structupd__field__t.html">upd_field_t</a> *uf, const <a class="el" href="classBinary__diff.html">Binary_diff</a> *bdiff, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr class="memdesc:ac4d91bac73733a3eabd351c3c82f9a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given binary diff into the given output stream.  <a href="#ac4d91bac73733a3eabd351c3c82f9a7b">More...</a><br /></td></tr>
<tr class="separator:ac4d91bac73733a3eabd351c3c82f9a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2522b883af6618c18e80d1427d467d38"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a2522b883af6618c18e80d1427d467d38">print_binary_diff</a> (std::ostream &amp;out, const <a class="el" href="classBinary__diff.html">Binary_diff</a> *bdiff, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr class="memdesc:a2522b883af6618c18e80d1427d467d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given binary diff into the given output stream.  <a href="#a2522b883af6618c18e80d1427d467d38">More...</a><br /></td></tr>
<tr class="separator:a2522b883af6618c18e80d1427d467d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3631d6626fdd2e421642e2d355175d78"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8cc.html#a3631d6626fdd2e421642e2d355175d78">print_binary_diff</a> (std::ostream &amp;out, const <a class="el" href="classBinary__diff.html">Binary_diff</a> *bdiff, <a class="el" href="classField.html">Field</a> *fld)</td></tr>
<tr class="separator:a3631d6626fdd2e421642e2d355175d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Update of a row. </p>
<p>Created 12/27/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6b68f78ad7c133d8003cf33b059c72d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b68f78ad7c133d8003cf33b059c72d8">&#9670;&nbsp;</a></span>row_upd_clust_rec_by_insert_inherit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define row_upd_clust_rec_by_insert_inherit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">offsets, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="row0upd_8cc.html#a07c376516b1f7519ffa7ac41efd7db0e">row_upd_clust_rec_by_insert_inherit_func</a>(rec, offsets, <a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c350f15c30918fa6b48dee634f0b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c350f15c30918fa6b48dee634f0b9d6">&#9670;&nbsp;</a></span>row_upd_ext_fetch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define row_upd_ext_fetch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">clust_index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">local_len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_sdi, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="row0upd_8cc.html#ae9d2a5f1af92104f5dc3eb09a34b663d">row_upd_ext_fetch_func</a>(clust_index, data, local_len, page_size, len, is_sdi, \</div><div class="line">                         heap)</div><div class="ttc" id="row0upd_8cc_html_ae9d2a5f1af92104f5dc3eb09a34b663d"><div class="ttname"><a href="row0upd_8cc.html#ae9d2a5f1af92104f5dc3eb09a34b663d">row_upd_ext_fetch_func</a></div><div class="ttdeci">static byte * row_upd_ext_fetch_func(dict_index_t *clust_index, const byte *data, ulint local_len, const page_size_t &amp;page_size, ulint *len, bool is_sdi, mem_heap_t *heap)</div><div class="ttdoc">Fetch a prefix of an externally stored column. </div><div class="ttdef"><b>Definition:</b> row0upd.cc:997</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb22f0d802978a752740185b9e05f30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb22f0d802978a752740185b9e05f30e">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define row_upd_index_replace_new_col_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dfield, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_sdi, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="row0upd_8cc.html#a30fb9a44189c96055a63a34aa8879a71">row_upd_index_replace_new_col_val_func</a>(<a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, dfield, field, col, uf, heap,  \</div><div class="line">                                         is_sdi, page_size)</div><div class="ttc" id="row0upd_8cc_html_a30fb9a44189c96055a63a34aa8879a71"><div class="ttname"><a href="row0upd_8cc.html#a30fb9a44189c96055a63a34aa8879a71">row_upd_index_replace_new_col_val_func</a></div><div class="ttdeci">static void row_upd_index_replace_new_col_val_func(const dict_index_t *index, dfield_t *dfield, const dict_field_t *field, const dict_col_t *col, const upd_field_t *uf, mem_heap_t *heap, bool is_sdi, const page_size_t &amp;page_size)</div><div class="ttdoc">Replaces the new column value stored in the update vector in the given index entry field...</div><div class="ttdef"><b>Definition:</b> row0upd.cc:1030</div></div>
<div class="ttc" id="mysql_8cc_html_adfa69ae672499b1037123a1f17c5552b"><div class="ttname"><a href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></div><div class="ttdeci">char * index(const char *, int c)</div><div class="ttdef"><b>Definition:</b> mysql.cc:2928</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac4d91bac73733a3eabd351c3c82f9a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d91bac73733a3eabd351c3c82f9a7b">&#9670;&nbsp;</a></span>print_binary_diff() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::ostream&amp; print_binary_diff </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>uf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBinary__diff.html">Binary_diff</a> *&#160;</td>
          <td class="paramname"><em>bdiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the given binary diff into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uf</td><td>the update vector of concerned field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bdiff</td><td>binary diff to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table dictionary object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>mysql field object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<a id="a2522b883af6618c18e80d1427d467d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2522b883af6618c18e80d1427d467d38">&#9670;&nbsp;</a></span>print_binary_diff() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; print_binary_diff </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBinary__diff.html">Binary_diff</a> *&#160;</td>
          <td class="paramname"><em>bdiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the given binary diff into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bdiff</td><td>binary diff to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table dictionary object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>mysql field object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<a id="a3631d6626fdd2e421642e2d355175d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3631d6626fdd2e421642e2d355175d78">&#9670;&nbsp;</a></span>print_binary_diff() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; print_binary_diff </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBinary__diff.html">Binary_diff</a> *&#160;</td>
          <td class="paramname"><em>bdiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>fld</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bd49999333aef51b832b638258d10c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd49999333aef51b832b638258d10c1">&#9670;&nbsp;</a></span>row_upd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the affected index records of a row. </p>
<p>When the control is transferred to this node, we assume that we have a persistent cursor which was on a record, and the position of the cursor is stored in the cursor. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row update node </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838bfedaa4543cf09a38da782a458217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838bfedaa4543cf09a38da782a458217">&#9670;&nbsp;</a></span>row_upd_build_difference_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_difference_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>no_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>mysql_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an update vector from those fields, excluding the roll ptr and trx id fields, which in an index entry differ from a record that has the equal ordering fields. </p>
<p>NOTE: we compare the fields as binary strings! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>clustered index entry to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>clustered index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec,index), or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_sys</td><td>skip the system columns DB_TRX_ID and DB_ROLL_PTR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction (for diagnostics), or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap from which allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mysql_table</td><td>NULL, or mysql table object when user thread invokes dml </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>error number in case of failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields, excluding roll ptr and trx id </dd></dl>

</div>
</div>
<a id="a00cf371b11d50c6ad635038a71306b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cf371b11d50c6ad635038a71306b73">&#9670;&nbsp;</a></span>row_upd_build_sec_rec_difference_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_sec_rec_difference_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an update vector from those fields which in a secondary index entry differ from a record that has the equal ordering fields. </p>
<p>NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: secondary index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap from which allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a902192e6824406c3796068d2173b2aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902192e6824406c3796068d2173b2aff">&#9670;&nbsp;</a></span>row_upd_changes_disowned_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_upd_changes_disowned_external </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if row update contains disowned external fields. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the update contains disowned external fields. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedafd388956767bd826a954029de13f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedafd388956767bd826a954029de13f4">&#9670;&nbsp;</a></span>row_upd_changes_doc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_upd_changes_doc_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an FTS Doc ID column is affected by an UPDATE. </p>
<dl class="section return"><dt>Returns</dt><dd>whether the Doc ID column is changed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">upd_field</td><td>in: field to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c8da72b47b7afc4a67c12584cce14db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8da72b47b7afc4a67c12584cce14db">&#9670;&nbsp;</a></span>row_upd_changes_field_size_or_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_upd_changes_field_size_or_external </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if row update changes size of some field in index or if some field to be updated is stored externally in rec or update. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the update changes the size of some field in index or the field is external in rec or update </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa55bb5d9756a5bc30ffffa5ec4f6f1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55bb5d9756a5bc30ffffa5ec4f6f1cc">&#9670;&nbsp;</a></span>row_upd_changes_first_fields_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool row_upd_changes_first_fields_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an update vector changes some of the first ordering fields of an index record. </p>
<p>This is only used in foreign key checks and we can assume that index does not contain column prefixes. </p><dl class="section return"><dt>Returns</dt><dd>true if changes in: how many first fields to check</dd></dl>
<p>This is only used in foreign key checks and we can assume that index does not contain column prefixes. </p><dl class="section return"><dt>Returns</dt><dd>true if changes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in: old value of index entry </td></tr>
    <tr><td class="paramname">index</td><td>in: index of entry </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector for the row </td></tr>
    <tr><td class="paramname">n</td><td>in: how many first fields to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34c7757393893c9ac19cd3dfaf1befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34c7757393893c9ac19cd3dfaf1befe">&#9670;&nbsp;</a></span>row_upd_changes_fts_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_upd_changes_fts_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an FTS indexed column is affected by an UPDATE. </p>
<dl class="section return"><dt>Returns</dt><dd>offset within fts_t::indexes if FTS indexed column updated else ULINT_UNDEFINED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">upd_field</td><td>in: field to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af70a462bcc93bd912d846fb253463bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70a462bcc93bd912d846fb253463bf0">&#9670;&nbsp;</a></span>row_upd_changes_ord_field_binary_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_upd_changes_ord_field_binary_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>non_mv_upd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an update vector changes an ordering field of an index record. </p>
<p>It will also help check if any non-multi-value field on the multi-value index gets updated or not.</p>
<p>This function is fast if the update vector is short or the number of ordering fields in the index is small. Otherwise, this can be quadratic. NOTE: we compare the fields as binary strings! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>update vector for the row; NOTE: the field numbers in this MUST be clustered index positions! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread, or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>old value of row, or NULL if the row and the data values in update are not known when this function is called, e.g., at compile time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>NULL, or prefixes of the externally stored columns in the old row </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">non_mv_upd</td><td>NULL, or not NULL pointer to get the information about whether any non-multi-value field on the multi-value index gets updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>ROW_BUILD_NORMAL, ROW_BUILD_FOR_PURGE or ROW_BUILD_FOR_UNDO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if update vector changes an ordering field in the index record </dd></dl>

</div>
</div>
<a id="a0b3e7dba0ba7d65289f702a3d3f8ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e7dba0ba7d65289f702a3d3f8ec00">&#9670;&nbsp;</a></span>row_upd_changes_some_index_ord_field_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_upd_changes_some_index_ord_field_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an update vector changes an ordering field of an index record. </p>
<p>NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>true if update vector may change an ordering field in an index record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector for the row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f7f358ae7e7592f1997b6295ab80246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7f358ae7e7592f1997b6295ab80246">&#9670;&nbsp;</a></span>row_upd_check_autoinc_counter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_upd_check_autoinc_counter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the table has autoinc column and the counter is updated to some bigger value, we need to log the new autoinc counter. </p>
<p>We will use the given mtr to do logging for performance reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Row update node </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa21ed0cd4cc80c91ea4abf6a9b873bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21ed0cd4cc80c91ea4abf6a9b873bb3">&#9670;&nbsp;</a></span>row_upd_check_references_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_check_references_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if possible foreign key constraints hold after a delete of the record under pcur. </p>
<p>NOTE that this function will temporarily commit mtr and lose the pcur position!</p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or an error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row update node </td></tr>
    <tr><td class="paramname">pcur</td><td>in: cursor positioned on a record; NOTE: the cursor position is lost in this function! </td></tr>
    <tr><td class="paramname">table</td><td>in: table in question </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the cursor </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: rec_get_offsets(pcur.rec, index) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe293bc753225db9edc8858fa0080f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe293bc753225db9edc8858fa0080f16">&#9670;&nbsp;</a></span>row_upd_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_clust_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a clustered index record of a row when the ordering fields do not change. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">node</td><td>in: row update node </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets() on node-&gt;pcur </td></tr>
    <tr><td class="paramname">offsets_heap</td><td>in/out: memory heap, can be emptied </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; gets committed here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac89bb5a2c8412d680ed73a1e2d611e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89bb5a2c8412d680ed73a1e2d611e6e">&#9670;&nbsp;</a></span>row_upd_clust_rec_by_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_clust_rec_by_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the clustered index record deleted and inserts the updated version of the record to the index. </p>
<p>This function should be used when the ordering fields of the clustered index record change. This should be quite rare in database applications. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">node</td><td>in/out: row update node </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index of the record </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">referenced</td><td>in: TRUE if index may be referenced in a foreign key constraint </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr; gets committed here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07c376516b1f7519ffa7ac41efd7db0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c376516b1f7519ffa7ac41efd7db0e">&#9670;&nbsp;</a></span>row_upd_clust_rec_by_insert_inherit_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_upd_clust_rec_by_insert_inherit_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark non-updated off-page columns inherited when the primary key is updated. </p>
<p>We must mark them as inherited in entry, so that they are not freed in a rollback. A limited version of this function used to be called btr_cur_mark_dtuple_inherited_extern(). </p><dl class="section return"><dt>Returns</dt><dd>whether any columns were inherited </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: old record, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec), or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: updated entry to be inserted into the clustered index </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c5057795d0fa20a648d790c09e86a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5057795d0fa20a648d790c09e86a21">&#9670;&nbsp;</a></span>row_upd_clust_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_clust_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *const&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the clustered index record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, DB_LOCK_WAIT in case of a lock wait, else error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row update node </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdfe1724f880f26e91726ae2a8ab1635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfe1724f880f26e91726ae2a8ab1635">&#9670;&nbsp;</a></span>row_upd_copy_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_upd_copy_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the column values from a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record in a clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index where record resides </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>first column in a column list, or nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0acfef1fe86af5121e658c93f83b0f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acfef1fe86af5121e658c93f83b0f8d">&#9670;&nbsp;</a></span>row_upd_del_mark_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_del_mark_clust_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete marks a clustered index record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">node</td><td>in: row update node </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: rec_get_offsets() for the record under the cursor </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">referenced</td><td>in: TRUE if index may be referenced in a foreign key constraint </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; gets committed here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9237ad8130cd6abb0839a43d3d29f448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9237ad8130cd6abb0839a43d3d29f448">&#9670;&nbsp;</a></span>row_upd_del_multi_sec_index_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_del_multi_sec_index_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete secondary index entries of a row, when the index is built on multi-value field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">node</td><td>row update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>

</div>
</div>
<a id="ad4cc5d0f5d6300fc1d6b91639b302800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cc5d0f5d6300fc1d6b91639b302800">&#9670;&nbsp;</a></span>row_upd_del_one_multi_sec_index_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_del_one_multi_sec_index_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete mark a secondary index entry of a row, when the index is built on multi-value field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the multi-value index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>the entry to handle on the index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS on success, otherwise error code </dd></dl>

</div>
</div>
<a id="ad1323c4b32a084eff6d66e53478e74b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1323c4b32a084eff6d66e53478e74b1">&#9670;&nbsp;</a></span>row_upd_eval_new_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_upd_eval_new_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the new values for fields to update. </p>
<p>Note that row_upd_copy_columns must have been called first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in/out: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9d2a5f1af92104f5dc3eb09a34b663d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d2a5f1af92104f5dc3eb09a34b663d">&#9670;&nbsp;</a></span>row_upd_ext_fetch_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_upd_ext_fetch_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>local_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_sdi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch a prefix of an externally stored column. </p>
<p>This is similar to row_ext_lookup(), but the row_ext_t holds the old values of the column and must not be poisoned with the new values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>the clustered index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>'internally' stored part of the field containing also the reference to the external part </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_len</td><td>length of data, in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>BLOB page size </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>input - length of prefix to fetch; output: fetched length of the prefix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_sdi</td><td>true for SDI indexes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>heap where to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BLOB prefix </dd></dl>

</div>
</div>
<a id="a5cfdb6c921068d3859455412321acc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfdb6c921068d3859455412321acc28">&#9670;&nbsp;</a></span>row_upd_get_new_autoinc_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t row_upd_get_new_autoinc_counter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>autoinc_field_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the new autoinc counter from the update vector when there is an autoinc field defined in this table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>update vector for the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoinc_field_no</td><td>autoinc field's order in clustered index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new counter if we find it in the update vector, otherwise 0. We don't mind that the new counter happens to be 0, we just care about non-zero counters. </dd></dl>

</div>
</div>
<a id="aa516d2dc3d1ddcdf1a73b31cd5cbce0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa516d2dc3d1ddcdf1a73b31cd5cbce0b">&#9670;&nbsp;</a></span>row_upd_index_entry_sys_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_entry_sys_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the trx id or roll ptr field of a clustered index entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>Index entry, where the memory buffers for sys fields are already allocated: the function just copies the new values to them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Data_trx_id or data_roll_ptr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f593cb7ea3cc077bd99a96b699ff334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f593cb7ea3cc077bd99a96b699ff334">&#9670;&nbsp;</a></span>row_upd_index_is_referenced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool row_upd_index_is_referenced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if index currently is mentioned as a referenced index in a foreign key constraint. </p>
<p>NOTE that since we do not hold dict_operation_lock when leaving the function, it may be that the referencing table has been dropped when we leave this function: this function is only for heuristic use!</p>
<dl class="section return"><dt>Returns</dt><dd>true if referenced </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bf0960639c762f39cce1d29241e8b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf0960639c762f39cce1d29241e8b1e">&#9670;&nbsp;</a></span>row_upd_index_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_upd_index_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__t.html">upd_t</a> **&#160;</td>
          <td class="paramname"><em>update_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the log data written by row_upd_index_write_log. </p>
<dl class="section return"><dt>Returns</dt><dd>log data end or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where update vector is built </td></tr>
    <tr><td class="paramname">update_out</td><td>out: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30fb9a44189c96055a63a34aa8879a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fb9a44189c96055a63a34aa8879a71">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_val_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_upd_index_replace_new_col_val_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>dfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__field__t.html">dict_field_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>uf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_sdi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the new column value stored in the update vector in the given index entry field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index dictionary object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dfield</td><td>data field of the index entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>index field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>field-&gt;col </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uf</td><td>update field </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap for allocating and copying the new value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_sdi</td><td>true for SDI indexes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9a7b3c3d7c1127f608f91ae11b41ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9a7b3c3d7c1127f608f91ae11b41ef">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_replace_new_col_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>Index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index; note that this may also be a non-clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>An update vector built for the clustered index so that the field number in an upd_field is the clustered index position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbdbead3f6bc4683c091c025761b28c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdbead3f6bc4683c091c025761b28c7">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_vals_index_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_replace_new_col_vals_index_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>order_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>Index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion [rollback or purge] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index; note that this may also be a non-clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>An update vector built for the index so that the field number in an upd_field is the index position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order_only</td><td>If true, limit the replacement to ordering fields of index; note that this does not work for non-clustered indexes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b7fba00a40039307f4605056af9c54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7fba00a40039307f4605056af9c54b">&#9670;&nbsp;</a></span>row_upd_index_write_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_write_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to the redo log the new values of the fields occurring in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index which to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>update vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_ptr</td><td>pointer to mlog buffer: must contain at least MLOG_BUF_MARGIN bytes of free space; the buffer is closed within this function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr into whose log to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae235166fa0eb68e24974fe6fbcabfc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae235166fa0eb68e24974fe6fbcabfc96">&#9670;&nbsp;</a></span>row_upd_multi_sec_index_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_multi_sec_index_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>non_mv_upd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates secondary index entries of a row, when the index is built on multi-value field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">node</td><td>row update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">non_mv_upd</td><td>true if any non-multi-value field on the index gets updated too </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>

</div>
</div>
<a id="ae304da2bc13e35c67c164467960b27ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae304da2bc13e35c67c164467960b27ac">&#9670;&nbsp;</a></span>row_upd_parse_sys_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_upd_parse_sys_vals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the log data of system field values. </p>
<dl class="section return"><dt>Returns</dt><dd>log data end or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">pos</td><td>out: TRX_ID position in record </td></tr>
    <tr><td class="paramname">trx_id</td><td>out: trx id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>out: roll ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add4c4ef5c26a83086f51130897c89dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4c4ef5c26a83086f51130897c89dd9">&#9670;&nbsp;</a></span>row_upd_rec_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_rec_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector to the record given. </p>
<p>No field size changes are allowed. This function is usually invoked on a clustered index. The only use case for a secondary index is row_ins_sec_index_entry_by_modify() or its counterpart in ibuf_insert_to_index_page(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record where replaced </td></tr>
    <tr><td class="paramname">index</td><td>in: the index the record belongs to </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page with enough space available, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb05f212ddac2808ee035ef4d22f917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb05f212ddac2808ee035ef4d22f917">&#9670;&nbsp;</a></span>row_upd_rec_sys_fields_in_recovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_rec_sys_fields_in_recovery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the trx id and roll ptr field in a clustered index record in database recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page_zip</td><td>Compressed page, or null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Trx_id position in rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Transaction id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll_ptr</td><td>Roll ptr of the undo log record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc29008c34ee2e8c776a6d73b76f61e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc29008c34ee2e8c776a6d73b76f61e4">&#9670;&nbsp;</a></span>row_upd_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__ext__t.html">row_ext_t</a> **&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>Current transaction. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">row</td><td>Row where replaced, indexed by col_no; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ext</td><td>Null, or externally stored column prefixes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>An update vector built for the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0039db94d3ed183135cfa8d4a49b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0039db94d3ed183135cfa8d4a49b42d">&#9670;&nbsp;</a></span>row_upd_replace_vcol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_replace_vcol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>upd_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>undo_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the virtual column values stored in a dtuple with that of a update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">row</td><td>dtuple whose column to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>an update vector built for the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upd_new</td><td>update to new or old value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">undo_row</td><td>undo row (if needs to be updated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>remaining part in update undo log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87a669713345b47c7af55460196f9d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a669713345b47c7af55460196f9d40">&#9670;&nbsp;</a></span>row_upd_sec_index_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_sec_index_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a secondary index entry of a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>row update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>

</div>
</div>
<a id="a59844e0b7daf983dfae1ec395a96426a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59844e0b7daf983dfae1ec395a96426a">&#9670;&nbsp;</a></span>row_upd_sec_index_entry_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_sec_index_entry_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>old_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a secondary index entry of a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>row update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_entry</td><td>the old entry to search, or nullptr then it has to be created in this function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>

</div>
</div>
<a id="a293cc7dd95e743ef02740eb1d5db1ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293cc7dd95e743ef02740eb1d5db1ff0">&#9670;&nbsp;</a></span>row_upd_sec_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_upd_sec_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the secondary index record if it is changed in the row update or deletes it if this is a delete. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row update node </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89885847c96734248b50c2176061091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89885847c96734248b50c2176061091d">&#9670;&nbsp;</a></span>row_upd_set_vcol_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_upd_set_vcol_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__v__col__t.html">dict_v_col_t</a> *&#160;</td>
          <td class="paramname"><em>vcol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the virtual column values stored in the update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">row</td><td>row whose column to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>data to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>data length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vcol</td><td>virtual column info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33265d5ab656dba287eb974c407bcf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33265d5ab656dba287eb974c407bcf18">&#9670;&nbsp;</a></span>row_upd_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* row_upd_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a row in a table. </p>
<p>This is a high-level function used in SQL execution graphs. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b88335c2bea8df94e814325e117c491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b88335c2bea8df94e814325e117c491">&#9670;&nbsp;</a></span>row_upd_store_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_store_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>mysql_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores to the heap the row on which the node-&gt;pcur is positioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the transaction object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>row update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>mysql thread handle </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mysql_table</td><td>NULL, or mysql table object when user thread invokes dml </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf69cf45689b146f7537a2659d943166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf69cf45689b146f7537a2659d943166">&#9670;&nbsp;</a></span>row_upd_store_v_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_upd_store_v_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>mysql_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores to the heap the virtual columns that need for any indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">node</td><td>row update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>an update vector if it is update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>mysql thread handle </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mysql_table</td><td>mysql table object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2720d792e43ac476db80779bba13544c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2720d792e43ac476db80779bba13544c">&#9670;&nbsp;</a></span>row_upd_write_sys_vals_to_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_upd_write_sys_vals_to_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes into the redo log the values of trx id and roll ptr and enough info to determine their positions within a clustered index record. </p>
<dl class="section return"><dt>Returns</dt><dd>new pointer to mlog </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr of the undo log record </td></tr>
    <tr><td class="paramname">log_ptr</td><td>pointer to a buffer of size &gt; 20 opened in mlog </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6794e63bacff453cf0236989dc5a423f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6794e63bacff453cf0236989dc5a423f">&#9670;&nbsp;</a></span>srv_mbr_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void srv_mbr_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a MBR data from disk. </p>

</div>
</div>
<a id="a655590bf847503b6297d9d8d246201ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655590bf847503b6297d9d8d246201ff">&#9670;&nbsp;</a></span>upd_node_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__node__t.html">upd_node_t</a>* upd_node_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an update node for a query graph. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: mem heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_4dd6d22ab21a818a66544a670705c483.html">row</a></li><li class="navelem"><a class="el" href="row0upd_8cc.html">row0upd.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
