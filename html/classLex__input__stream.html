<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Lex_input_stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classLex__input__stream.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classLex__input__stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Lex_input_stream Class Reference<div class="ingroups"><a class="el" href="group__GROUP__PARSER.html">Parser</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the character input stream consumed during lexical analysis.  
 <a href="classLex__input__stream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sql__lex_8h_source.html">sql_lex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9eb4d6293e4efa122a4b725922b9ce18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a9eb4d6293e4efa122a4b725922b9ce18">Lex_input_stream</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> grammar_selector_token_arg)</td></tr>
<tr class="memdesc:a9eb4d6293e4efa122a4b725922b9ce18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a9eb4d6293e4efa122a4b725922b9ce18">More...</a><br /></td></tr>
<tr class="separator:a9eb4d6293e4efa122a4b725922b9ce18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a077ed4a6bad4169d6675876fb7e05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a42a077ed4a6bad4169d6675876fb7e05">init</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *buff, size_t length)</td></tr>
<tr class="memdesc:a42a077ed4a6bad4169d6675876fb7e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object initializer.  <a href="#a42a077ed4a6bad4169d6675876fb7e05">More...</a><br /></td></tr>
<tr class="separator:a42a077ed4a6bad4169d6675876fb7e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada17ef8ee29410ae41d5698fd496e77a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ada17ef8ee29410ae41d5698fd496e77a">reset</a> (const char *buff, size_t length)</td></tr>
<tr class="memdesc:ada17ef8ee29410ae41d5698fd496e77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare Lex_input_stream instance state for use for handling next SQL statement.  <a href="#ada17ef8ee29410ae41d5698fd496e77a">More...</a><br /></td></tr>
<tr class="separator:ada17ef8ee29410ae41d5698fd496e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bea2c3e4e0babcbda627ff39670fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ad6bea2c3e4e0babcbda627ff39670fb8">set_echo</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> echo)</td></tr>
<tr class="memdesc:ad6bea2c3e4e0babcbda627ff39670fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the echo mode.  <a href="#ad6bea2c3e4e0babcbda627ff39670fb8">More...</a><br /></td></tr>
<tr class="separator:ad6bea2c3e4e0babcbda627ff39670fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17c2d5753ae6ee11724b7d1ab93db65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#aa17c2d5753ae6ee11724b7d1ab93db65">save_in_comment_state</a> ()</td></tr>
<tr class="separator:aa17c2d5753ae6ee11724b7d1ab93db65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccb8737723e3c35901e675fb9885b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a1ccb8737723e3c35901e675fb9885b20">restore_in_comment_state</a> ()</td></tr>
<tr class="separator:a1ccb8737723e3c35901e675fb9885b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce3b51028b33febdbcd7fc0fbb71df8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a0ce3b51028b33febdbcd7fc0fbb71df8">skip_binary</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a0ce3b51028b33febdbcd7fc0fbb71df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip binary from the input stream.  <a href="#a0ce3b51028b33febdbcd7fc0fbb71df8">More...</a><br /></td></tr>
<tr class="separator:a0ce3b51028b33febdbcd7fc0fbb71df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59640cd71bf5fe64306d200a9673c4c"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#aa59640cd71bf5fe64306d200a9673c4c">yyGet</a> ()</td></tr>
<tr class="memdesc:aa59640cd71bf5fe64306d200a9673c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a character, and advance in the stream.  <a href="#aa59640cd71bf5fe64306d200a9673c4c">More...</a><br /></td></tr>
<tr class="separator:aa59640cd71bf5fe64306d200a9673c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57f247cba607116a6e6e7b279444550"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ac57f247cba607116a6e6e7b279444550">yyGetLast</a> () const</td></tr>
<tr class="memdesc:ac57f247cba607116a6e6e7b279444550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last character accepted.  <a href="#ac57f247cba607116a6e6e7b279444550">More...</a><br /></td></tr>
<tr class="separator:ac57f247cba607116a6e6e7b279444550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e0984cbdae4667aa14a07a47e80e10"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ae3e0984cbdae4667aa14a07a47e80e10">yyPeek</a> () const</td></tr>
<tr class="memdesc:ae3e0984cbdae4667aa14a07a47e80e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look at the next character to parse, but do not accept it.  <a href="#ae3e0984cbdae4667aa14a07a47e80e10">More...</a><br /></td></tr>
<tr class="separator:ae3e0984cbdae4667aa14a07a47e80e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13b44eed648794e2aa724e12d12c3cf"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ae13b44eed648794e2aa724e12d12c3cf">yyPeekn</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:ae13b44eed648794e2aa724e12d12c3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look ahead at some character to parse.  <a href="#ae13b44eed648794e2aa724e12d12c3cf">More...</a><br /></td></tr>
<tr class="separator:ae13b44eed648794e2aa724e12d12c3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf5e0850c158c34cd8afc964fbf6364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#adaf5e0850c158c34cd8afc964fbf6364">yyUnget</a> ()</td></tr>
<tr class="memdesc:adaf5e0850c158c34cd8afc964fbf6364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the effect of the last yyGet() or yySkip().  <a href="#adaf5e0850c158c34cd8afc964fbf6364">More...</a><br /></td></tr>
<tr class="separator:adaf5e0850c158c34cd8afc964fbf6364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b561cb7a75d0f29902538850f3f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#aad4b561cb7a75d0f29902538850f3f51">yySkip</a> ()</td></tr>
<tr class="memdesc:aad4b561cb7a75d0f29902538850f3f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a character, by advancing the input stream.  <a href="#aad4b561cb7a75d0f29902538850f3f51">More...</a><br /></td></tr>
<tr class="separator:aad4b561cb7a75d0f29902538850f3f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89a2f69e382d5900c2e8d087eb4c8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ab89a2f69e382d5900c2e8d087eb4c8cd">yySkipn</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:ab89a2f69e382d5900c2e8d087eb4c8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept multiple characters at once.  <a href="#ab89a2f69e382d5900c2e8d087eb4c8cd">More...</a><br /></td></tr>
<tr class="separator:ab89a2f69e382d5900c2e8d087eb4c8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d65c43d1a6b615105b64111d7f325a0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a0d65c43d1a6b615105b64111d7f325a0">yyUnput</a> (char ch)</td></tr>
<tr class="memdesc:a0d65c43d1a6b615105b64111d7f325a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a character back into the stream, canceling the effect of the last yyGet() or yySkip().  <a href="#a0d65c43d1a6b615105b64111d7f325a0">More...</a><br /></td></tr>
<tr class="separator:a0d65c43d1a6b615105b64111d7f325a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d549bffa0e044ea8355ea4fe8491ca"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a73d549bffa0e044ea8355ea4fe8491ca">cpp_inject</a> (char ch)</td></tr>
<tr class="memdesc:a73d549bffa0e044ea8355ea4fe8491ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject a character into the pre-processed stream.  <a href="#a73d549bffa0e044ea8355ea4fe8491ca">More...</a><br /></td></tr>
<tr class="separator:a73d549bffa0e044ea8355ea4fe8491ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae705b5ccee549d88adea2285a0c4d792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ae705b5ccee549d88adea2285a0c4d792">eof</a> () const</td></tr>
<tr class="memdesc:ae705b5ccee549d88adea2285a0c4d792"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of file indicator for the query text to parse.  <a href="#ae705b5ccee549d88adea2285a0c4d792">More...</a><br /></td></tr>
<tr class="separator:ae705b5ccee549d88adea2285a0c4d792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aef4d2ba9b3d7e04b959c40224cb145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a5aef4d2ba9b3d7e04b959c40224cb145">eof</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:a5aef4d2ba9b3d7e04b959c40224cb145"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of file indicator for the query text to parse.  <a href="#a5aef4d2ba9b3d7e04b959c40224cb145">More...</a><br /></td></tr>
<tr class="separator:a5aef4d2ba9b3d7e04b959c40224cb145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1972d001dec74ff430150c38da101555"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a1972d001dec74ff430150c38da101555">get_buf</a> () const</td></tr>
<tr class="memdesc:a1972d001dec74ff430150c38da101555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw query buffer.  <a href="#a1972d001dec74ff430150c38da101555">More...</a><br /></td></tr>
<tr class="separator:a1972d001dec74ff430150c38da101555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f9a02e160efaf0c5f097e27b3ef87e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a95f9a02e160efaf0c5f097e27b3ef87e">get_cpp_buf</a> () const</td></tr>
<tr class="memdesc:a95f9a02e160efaf0c5f097e27b3ef87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pre-processed query buffer.  <a href="#a95f9a02e160efaf0c5f097e27b3ef87e">More...</a><br /></td></tr>
<tr class="separator:a95f9a02e160efaf0c5f097e27b3ef87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f9eb85d34254c1478f707eef01dff"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a619f9eb85d34254c1478f707eef01dff">get_end_of_query</a> () const</td></tr>
<tr class="memdesc:a619f9eb85d34254c1478f707eef01dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end of the raw query buffer.  <a href="#a619f9eb85d34254c1478f707eef01dff">More...</a><br /></td></tr>
<tr class="separator:a619f9eb85d34254c1478f707eef01dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c5d7e2c90d6a9d579e0343fcf2d3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ad9c5d7e2c90d6a9d579e0343fcf2d3a9">start_token</a> ()</td></tr>
<tr class="memdesc:ad9c5d7e2c90d6a9d579e0343fcf2d3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the stream position as the start of a new token.  <a href="#ad9c5d7e2c90d6a9d579e0343fcf2d3a9">More...</a><br /></td></tr>
<tr class="separator:ad9c5d7e2c90d6a9d579e0343fcf2d3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080cdebb6b1f29c189ceabe9c930bc91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a080cdebb6b1f29c189ceabe9c930bc91">restart_token</a> ()</td></tr>
<tr class="memdesc:a080cdebb6b1f29c189ceabe9c930bc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the starting position of the current token.  <a href="#a080cdebb6b1f29c189ceabe9c930bc91">More...</a><br /></td></tr>
<tr class="separator:a080cdebb6b1f29c189ceabe9c930bc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591fbee2501521e31ab1b163873443a5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a591fbee2501521e31ab1b163873443a5">get_tok_start</a> () const</td></tr>
<tr class="memdesc:a591fbee2501521e31ab1b163873443a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the token start position, in the raw buffer.  <a href="#a591fbee2501521e31ab1b163873443a5">More...</a><br /></td></tr>
<tr class="separator:a591fbee2501521e31ab1b163873443a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05a1ded30badb4b5f68eea6a64b0439"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#af05a1ded30badb4b5f68eea6a64b0439">get_cpp_tok_start</a> () const</td></tr>
<tr class="memdesc:af05a1ded30badb4b5f68eea6a64b0439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the token start position, in the pre-processed buffer.  <a href="#af05a1ded30badb4b5f68eea6a64b0439">More...</a><br /></td></tr>
<tr class="separator:af05a1ded30badb4b5f68eea6a64b0439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866087eb0ab9f0fd777cfbb33fb1a638"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a866087eb0ab9f0fd777cfbb33fb1a638">get_tok_end</a> () const</td></tr>
<tr class="memdesc:a866087eb0ab9f0fd777cfbb33fb1a638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the token end position, in the raw buffer.  <a href="#a866087eb0ab9f0fd777cfbb33fb1a638">More...</a><br /></td></tr>
<tr class="separator:a866087eb0ab9f0fd777cfbb33fb1a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af1189152c4c1c1dbb9accaeb9e5c4b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a5af1189152c4c1c1dbb9accaeb9e5c4b">get_cpp_tok_end</a> () const</td></tr>
<tr class="memdesc:a5af1189152c4c1c1dbb9accaeb9e5c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the token end position, in the pre-processed buffer.  <a href="#a5af1189152c4c1c1dbb9accaeb9e5c4b">More...</a><br /></td></tr>
<tr class="separator:a5af1189152c4c1c1dbb9accaeb9e5c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38616c405ae44d6623217362430c7386"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a38616c405ae44d6623217362430c7386">get_ptr</a> () const</td></tr>
<tr class="memdesc:a38616c405ae44d6623217362430c7386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current stream pointer, in the raw buffer.  <a href="#a38616c405ae44d6623217362430c7386">More...</a><br /></td></tr>
<tr class="separator:a38616c405ae44d6623217362430c7386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14444da8148be334f126b76fb97289f2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a14444da8148be334f126b76fb97289f2">get_cpp_ptr</a> () const</td></tr>
<tr class="memdesc:a14444da8148be334f126b76fb97289f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current stream pointer, in the pre-processed buffer.  <a href="#a14444da8148be334f126b76fb97289f2">More...</a><br /></td></tr>
<tr class="separator:a14444da8148be334f126b76fb97289f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e89fc04b374a28023b4ac9b72cffae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a4e89fc04b374a28023b4ac9b72cffae3">yyLength</a> () const</td></tr>
<tr class="memdesc:a4e89fc04b374a28023b4ac9b72cffae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the current token, in the raw buffer.  <a href="#a4e89fc04b374a28023b4ac9b72cffae3">More...</a><br /></td></tr>
<tr class="separator:a4e89fc04b374a28023b4ac9b72cffae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59eb01dc9f1b32acaf9617b17c0fe1a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ac59eb01dc9f1b32acaf9617b17c0fe1a">get_body_utf8_str</a> () const</td></tr>
<tr class="memdesc:ac59eb01dc9f1b32acaf9617b17c0fe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the utf8-body string.  <a href="#ac59eb01dc9f1b32acaf9617b17c0fe1a">More...</a><br /></td></tr>
<tr class="separator:ac59eb01dc9f1b32acaf9617b17c0fe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cd073c596785c498cc3d9d26d82bd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a34cd073c596785c498cc3d9d26d82bd3">get_body_utf8_length</a> () const</td></tr>
<tr class="memdesc:a34cd073c596785c498cc3d9d26d82bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the utf8-body length.  <a href="#a34cd073c596785c498cc3d9d26d82bd3">More...</a><br /></td></tr>
<tr class="separator:a34cd073c596785c498cc3d9d26d82bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09050267cb8f0959a35dac888d33cbab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a09050267cb8f0959a35dac888d33cbab">body_utf8_start</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *begin_ptr)</td></tr>
<tr class="memdesc:a09050267cb8f0959a35dac888d33cbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation is called from the parser in order to 1) designate the intention to have utf8 body; 1) Indicate to the lexer that we will need a utf8 representation of this statement; 2) Determine the beginning of the body.  <a href="#a09050267cb8f0959a35dac888d33cbab">More...</a><br /></td></tr>
<tr class="separator:a09050267cb8f0959a35dac888d33cbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14506340b97c5e58cafcc27ec5c3cdc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a14506340b97c5e58cafcc27ec5c3cdc6">body_utf8_append</a> (const char *ptr)</td></tr>
<tr class="memdesc:a14506340b97c5e58cafcc27ec5c3cdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation appends unprocessed part of the pre-processed buffer till the given pointer (ptr) and sets m_cpp_utf8_processed_ptr to ptr.  <a href="#a14506340b97c5e58cafcc27ec5c3cdc6">More...</a><br /></td></tr>
<tr class="separator:a14506340b97c5e58cafcc27ec5c3cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb55ed14731193c629343f9b74033e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#adbb55ed14731193c629343f9b74033e1">body_utf8_append</a> (const char *ptr, const char *end_ptr)</td></tr>
<tr class="memdesc:adbb55ed14731193c629343f9b74033e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation appends unprocessed part of pre-processed buffer till the given pointer (ptr) and sets m_cpp_utf8_processed_ptr to end_ptr.  <a href="#adbb55ed14731193c629343f9b74033e1">More...</a><br /></td></tr>
<tr class="separator:adbb55ed14731193c629343f9b74033e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41c8ff68ea384d277658dce4788a23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ac41c8ff68ea384d277658dce4788a23f">body_utf8_append_literal</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="lex__string_8h.html#a1fb89d4ad1109660fb2b796efdb3933e">LEX_STRING</a> *txt, const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *txt_cs, const char *end_ptr)</td></tr>
<tr class="memdesc:ac41c8ff68ea384d277658dce4788a23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation converts the specified text literal to the utf8 and appends the result to the utf8-body.  <a href="#ac41c8ff68ea384d277658dce4788a23f">More...</a><br /></td></tr>
<tr class="separator:ac41c8ff68ea384d277658dce4788a23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bca3724b42765facddd41a2b9d03bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a5bca3724b42765facddd41a2b9d03bbe">get_lineno</a> (const char *raw_ptr) const</td></tr>
<tr class="separator:a5bca3724b42765facddd41a2b9d03bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d43efacdceb0c156998f4d649d0847a"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a6d43efacdceb0c156998f4d649d0847a">lex_one_token</a> () call</td></tr>
<tr class="separator:a6d43efacdceb0c156998f4d649d0847a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae2ec69ef9e469ca7d7142c4b679285"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the *but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint *<a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> **inside *the&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#aaae2ec69ef9e469ca7d7142c4b679285">lex_one_token</a> () call. <a class="el" href="classLex__input__stream.html#a99eeef1486a99591b70a6ab5893b2e1d">Thus</a></td></tr>
<tr class="separator:aaae2ec69ef9e469ca7d7142c4b679285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffb7408b6c841035ed70a84669461cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a5ffb7408b6c841035ed70a84669461cb">add_digest_token</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> token, <a class="el" href="unionLexer__yystype.html">Lexer_yystype</a> *<a class="el" href="classLex__input__stream.html#a47b7a30d6b738aa17ffe8f15afb54547">yylval</a>)</td></tr>
<tr class="separator:a5ffb7408b6c841035ed70a84669461cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acddc127195ce35469a61466ab67559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a7acddc127195ce35469a61466ab67559">reduce_digest_token</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> token_left, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> token_right)</td></tr>
<tr class="separator:a7acddc127195ce35469a61466ab67559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af201c8bf79b04e9aefb260455e34b0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#af201c8bf79b04e9aefb260455e34b0f8">is_partial_parser</a> () const</td></tr>
<tr class="memdesc:af201c8bf79b04e9aefb260455e34b0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this scanner tokenizes a partial query (partition expression, generated column expression etc.)  <a href="#af201c8bf79b04e9aefb260455e34b0f8">More...</a><br /></td></tr>
<tr class="separator:af201c8bf79b04e9aefb260455e34b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8df25cf19a9c2e89a385dbb3654418e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#aa8df25cf19a9c2e89a385dbb3654418e">warn_on_deprecated_charset</a> (const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *cs, const char *alias) const</td></tr>
<tr class="memdesc:aa8df25cf19a9c2e89a385dbb3654418e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs warnings on deprecated charsets in complete SQL statements.  <a href="#aa8df25cf19a9c2e89a385dbb3654418e">More...</a><br /></td></tr>
<tr class="separator:aa8df25cf19a9c2e89a385dbb3654418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f133c00f7d1e8cd8b3396d957a7501b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a3f133c00f7d1e8cd8b3396d957a7501b">warn_on_deprecated_collation</a> (const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *collation) const</td></tr>
<tr class="memdesc:a3f133c00f7d1e8cd8b3396d957a7501b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs warnings on deprecated collations in complete SQL statements.  <a href="#a3f133c00f7d1e8cd8b3396d957a7501b">More...</a><br /></td></tr>
<tr class="separator:a3f133c00f7d1e8cd8b3396d957a7501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c000488389f2ea29bf4b90bb441b3a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a5c000488389f2ea29bf4b90bb441b3a3">text_string_is_7bit</a> () const</td></tr>
<tr class="separator:a5c000488389f2ea29bf4b90bb441b3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a803114bdf72ff32e00f96cc16b18b476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a803114bdf72ff32e00f96cc16b18b476">m_thd</a></td></tr>
<tr class="memdesc:a803114bdf72ff32e00f96cc16b18b476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current thread.  <a href="#a803114bdf72ff32e00f96cc16b18b476">More...</a><br /></td></tr>
<tr class="separator:a803114bdf72ff32e00f96cc16b18b476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83e2dd819cfd29f06679d5336e901a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ab83e2dd819cfd29f06679d5336e901a0">yylineno</a></td></tr>
<tr class="memdesc:ab83e2dd819cfd29f06679d5336e901a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current line number.  <a href="#ab83e2dd819cfd29f06679d5336e901a0">More...</a><br /></td></tr>
<tr class="separator:ab83e2dd819cfd29f06679d5336e901a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7808434969debc403c93848481a58c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#af7808434969debc403c93848481a58c9">yytoklen</a></td></tr>
<tr class="memdesc:af7808434969debc403c93848481a58c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the last token parsed.  <a href="#af7808434969debc403c93848481a58c9">More...</a><br /></td></tr>
<tr class="separator:af7808434969debc403c93848481a58c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b7a30d6b738aa17ffe8f15afb54547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionLexer__yystype.html">Lexer_yystype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a47b7a30d6b738aa17ffe8f15afb54547">yylval</a></td></tr>
<tr class="memdesc:a47b7a30d6b738aa17ffe8f15afb54547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface with bison, value of the last token parsed.  <a href="#a47b7a30d6b738aa17ffe8f15afb54547">More...</a><br /></td></tr>
<tr class="separator:a47b7a30d6b738aa17ffe8f15afb54547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123fd2ed4f96430b38da09668771127"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ac123fd2ed4f96430b38da09668771127">lookahead_token</a></td></tr>
<tr class="memdesc:ac123fd2ed4f96430b38da09668771127"><td class="mdescLeft">&#160;</td><td class="mdescRight">LALR(2) resolution, look ahead token.  <a href="#ac123fd2ed4f96430b38da09668771127">More...</a><br /></td></tr>
<tr class="separator:ac123fd2ed4f96430b38da09668771127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f3f2f2d2be4f4a1c1d314ded8139b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionLexer__yystype.html">Lexer_yystype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a99f3f2f2d2be4f4a1c1d314ded8139b7">lookahead_yylval</a></td></tr>
<tr class="memdesc:a99f3f2f2d2be4f4a1c1d314ded8139b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">LALR(2) resolution, value of the look ahead token.  <a href="#a99f3f2f2d2be4f4a1c1d314ded8139b7">More...</a><br /></td></tr>
<tr class="separator:a99f3f2f2d2be4f4a1c1d314ded8139b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc8aa813720669af78b55b14cbe5f2"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a6fdc8aa813720669af78b55b14cbe5f2">view</a></td></tr>
<tr class="memdesc:a6fdc8aa813720669af78b55b14cbe5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip adding of the current token's digest since it is already added.  <a href="#a6fdc8aa813720669af78b55b14cbe5f2">More...</a><br /></td></tr>
<tr class="separator:a6fdc8aa813720669af78b55b14cbe5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7f11c985d1aba56ac33fee9091506e"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the *but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint *<a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a7c7f11c985d1aba56ac33fee9091506e">view</a></td></tr>
<tr class="separator:a7c7f11c985d1aba56ac33fee9091506e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b7031a90f611435f84ae688fa3f52f"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the *but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint *<a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> **inside *the the usual data flow adds *tokens from the string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ab4b7031a90f611435f84ae688fa3f52f">first</a></td></tr>
<tr class="separator:ab4b7031a90f611435f84ae688fa3f52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7963742180e34c2bd6f8dbf9b72b4aef"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the *but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint *<a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> **inside *the the usual data flow adds *tokens from the string and only than it appends *the SELECT keyword token to that&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a7963742180e34c2bd6f8dbf9b72b4aef">stream</a>: &quot; SELECT&quot;. * This is not acceptable</td></tr>
<tr class="separator:a7963742180e34c2bd6f8dbf9b72b4aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f9f635ce7263b5d7e7a8bcda12652d"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the *but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint *<a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> **inside *the the usual data flow adds *tokens from the string and only than it appends *the SELECT keyword token to that since we use the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> to restore *<a class="el" href="myisam__ftdump_8cc.html#af26982218484ec3fdcb8f7d92e864a9b">query</a> strings in their normalized&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a18f9f635ce7263b5d7e7a8bcda12652d">forms</a></td></tr>
<tr class="separator:a18f9f635ce7263b5d7e7a8bcda12652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eeef1486a99591b70a6ab5893b2e1d"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the *but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint *<a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> **inside *the the usual data flow adds *tokens from the string and only than it appends *the SELECT keyword token to that since we use the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> to restore *<a class="el" href="myisam__ftdump_8cc.html#af26982218484ec3fdcb8f7d92e864a9b">query</a> strings in their normalized so the order of <a class="el" href="xcom__statistics_8cc.html#a518dc951712ff1f919a3af4897ef91b9">added</a> tokens is *important&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a99eeef1486a99591b70a6ab5893b2e1d">Thus</a></td></tr>
<tr class="separator:a99eeef1486a99591b70a6ab5893b2e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade20c5abf58fb0f29dda5afe6f32ae30"><td class="memItemLeft" align="right" valign="top">is the single *token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT *keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the *but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint *<a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> **inside *the the usual data flow adds *tokens from the string and only than it appends *the SELECT keyword token to that since we use the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> to restore *<a class="el" href="myisam__ftdump_8cc.html#af26982218484ec3fdcb8f7d92e864a9b">query</a> strings in their normalized so the order of <a class="el" href="xcom__statistics_8cc.html#a518dc951712ff1f919a3af4897ef91b9">added</a> tokens is *important we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> tokens of hintable keywords to a digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> *right in the hint <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> and skip adding of them at the caller with the *<a class="el" href="do__ctype_8cc.html#a81ae9faedaa69e3e28e2960a0548df8d">help</a> of skip_digest <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a> *<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ade20c5abf58fb0f29dda5afe6f32ae30">skip_digest</a></td></tr>
<tr class="separator:ade20c5abf58fb0f29dda5afe6f32ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613035cd9ba74aa0387ceddd437c2c1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a613035cd9ba74aa0387ceddd437c2c1f">query_charset</a></td></tr>
<tr class="separator:a613035cd9ba74aa0387ceddd437c2c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bee2a4209db7c2cdf2e63904a0a012"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="sql__chars_8h.html#af586ca2e6e2271cc55f1efe56f224b4c">my_lex_states</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a44bee2a4209db7c2cdf2e63904a0a012">next_state</a></td></tr>
<tr class="memdesc:a44bee2a4209db7c2cdf2e63904a0a012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current state of the lexical analyser.  <a href="#a44bee2a4209db7c2cdf2e63904a0a012">More...</a><br /></td></tr>
<tr class="separator:a44bee2a4209db7c2cdf2e63904a0a012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ae2483b386d48b7fcbfc386310933d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a70ae2483b386d48b7fcbfc386310933d">found_semicolon</a></td></tr>
<tr class="memdesc:a70ae2483b386d48b7fcbfc386310933d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of ';' in the stream, to delimit multiple queries.  <a href="#a70ae2483b386d48b7fcbfc386310933d">More...</a><br /></td></tr>
<tr class="separator:a70ae2483b386d48b7fcbfc386310933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1565168582b6b859f4c3a4bb5467c3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a1565168582b6b859f4c3a4bb5467c3eb">tok_bitmap</a></td></tr>
<tr class="memdesc:a1565168582b6b859f4c3a4bb5467c3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Token character bitmaps, to detect 7bit strings.  <a href="#a1565168582b6b859f4c3a4bb5467c3eb">More...</a><br /></td></tr>
<tr class="separator:a1565168582b6b859f4c3a4bb5467c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ad1b45b6f20ce942c810fb4f9504fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ac5ad1b45b6f20ce942c810fb4f9504fb">ignore_space</a></td></tr>
<tr class="memdesc:ac5ad1b45b6f20ce942c810fb4f9504fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SQL_MODE = IGNORE_SPACE.  <a href="#ac5ad1b45b6f20ce942c810fb4f9504fb">More...</a><br /></td></tr>
<tr class="separator:ac5ad1b45b6f20ce942c810fb4f9504fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4b7f27fdb7c56727cea6a0a3f4e817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a5c4b7f27fdb7c56727cea6a0a3f4e817">stmt_prepare_mode</a></td></tr>
<tr class="memdesc:a5c4b7f27fdb7c56727cea6a0a3f4e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if we're parsing a prepared statement: in this mode we should allow placeholders.  <a href="#a5c4b7f27fdb7c56727cea6a0a3f4e817">More...</a><br /></td></tr>
<tr class="separator:a5c4b7f27fdb7c56727cea6a0a3f4e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276bc97647b5e242f12106febfffa808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a276bc97647b5e242f12106febfffa808">multi_statements</a></td></tr>
<tr class="memdesc:a276bc97647b5e242f12106febfffa808"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if we should allow multi-statements.  <a href="#a276bc97647b5e242f12106febfffa808">More...</a><br /></td></tr>
<tr class="separator:a276bc97647b5e242f12106febfffa808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c09455cf65d25a7e1aa1ed90f4c761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GROUP__PARSER.html#gac6239d9548e1df34f111b7083c6dc542">enum_comment_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ab9c09455cf65d25a7e1aa1ed90f4c761">in_comment</a></td></tr>
<tr class="memdesc:ab9c09455cf65d25a7e1aa1ed90f4c761"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the lexical analyser for comments.  <a href="#ab9c09455cf65d25a7e1aa1ed90f4c761">More...</a><br /></td></tr>
<tr class="separator:ab9c09455cf65d25a7e1aa1ed90f4c761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5752080de11665fde944c3fd602bf5a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GROUP__PARSER.html#gac6239d9548e1df34f111b7083c6dc542">enum_comment_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a5752080de11665fde944c3fd602bf5a6">in_comment_saved</a></td></tr>
<tr class="separator:a5752080de11665fde944c3fd602bf5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad94591422e421c9bae85b7005f41a4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a6ad94591422e421c9bae85b7005f41a4">m_cpp_text_start</a></td></tr>
<tr class="memdesc:a6ad94591422e421c9bae85b7005f41a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting position of the TEXT_STRING or IDENT in the pre-processed buffer.  <a href="#a6ad94591422e421c9bae85b7005f41a4">More...</a><br /></td></tr>
<tr class="separator:a6ad94591422e421c9bae85b7005f41a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7424552eadd7b915f5a90a67033e0d9e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a7424552eadd7b915f5a90a67033e0d9e">m_cpp_text_end</a></td></tr>
<tr class="memdesc:a7424552eadd7b915f5a90a67033e0d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending position of the TEXT_STRING or IDENT in the pre-processed buffer.  <a href="#a7424552eadd7b915f5a90a67033e0d9e">More...</a><br /></td></tr>
<tr class="separator:a7424552eadd7b915f5a90a67033e0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9972f5dd34b7df6b90178d68d56b64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#adb9972f5dd34b7df6b90178d68d56b64">m_underscore_cs</a></td></tr>
<tr class="memdesc:adb9972f5dd34b7df6b90178d68d56b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character set specified by the character-set-introducer.  <a href="#adb9972f5dd34b7df6b90178d68d56b64">More...</a><br /></td></tr>
<tr class="separator:adb9972f5dd34b7df6b90178d68d56b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d2e0ce4fce1944bb9d68511094342a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsql__digest__state.html">sql_digest_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a73d2e0ce4fce1944bb9d68511094342a">m_digest</a></td></tr>
<tr class="memdesc:a73d2e0ce4fce1944bb9d68511094342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current statement digest instrumentation.  <a href="#a73d2e0ce4fce1944bb9d68511094342a">More...</a><br /></td></tr>
<tr class="separator:a73d2e0ce4fce1944bb9d68511094342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094db80ef1285f05d15ac87c222f126e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a094db80ef1285f05d15ac87c222f126e">grammar_selector_token</a></td></tr>
<tr class="memdesc:a094db80ef1285f05d15ac87c222f126e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The synthetic 1st token to prepend token stream with.  <a href="#a094db80ef1285f05d15ac87c222f126e">More...</a><br /></td></tr>
<tr class="separator:a094db80ef1285f05d15ac87c222f126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a57ac1fee85f336b7e9b4ef967b69024f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a57ac1fee85f336b7e9b4ef967b69024f">m_ptr</a></td></tr>
<tr class="memdesc:a57ac1fee85f336b7e9b4ef967b69024f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the current position in the raw input stream.  <a href="#a57ac1fee85f336b7e9b4ef967b69024f">More...</a><br /></td></tr>
<tr class="separator:a57ac1fee85f336b7e9b4ef967b69024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1411c4f3cfe2663f4c8a617437430170"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a1411c4f3cfe2663f4c8a617437430170">m_tok_start</a></td></tr>
<tr class="memdesc:a1411c4f3cfe2663f4c8a617437430170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting position of the last token parsed, in the raw buffer.  <a href="#a1411c4f3cfe2663f4c8a617437430170">More...</a><br /></td></tr>
<tr class="separator:a1411c4f3cfe2663f4c8a617437430170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e576f070be66bad9b5e635e08a713f0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a3e576f070be66bad9b5e635e08a713f0">m_tok_end</a></td></tr>
<tr class="memdesc:a3e576f070be66bad9b5e635e08a713f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending position of the previous token parsed, in the raw buffer.  <a href="#a3e576f070be66bad9b5e635e08a713f0">More...</a><br /></td></tr>
<tr class="separator:a3e576f070be66bad9b5e635e08a713f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a3e06284f023f97add057bfe435920"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a02a3e06284f023f97add057bfe435920">m_end_of_query</a></td></tr>
<tr class="memdesc:a02a3e06284f023f97add057bfe435920"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of the query text in the input stream, in the raw buffer.  <a href="#a02a3e06284f023f97add057bfe435920">More...</a><br /></td></tr>
<tr class="separator:a02a3e06284f023f97add057bfe435920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ee3d904e1b80852781bbfa0db37bc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a9b3ee3d904e1b80852781bbfa0db37bc">m_buf</a></td></tr>
<tr class="memdesc:a9b3ee3d904e1b80852781bbfa0db37bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begining of the query text in the input stream, in the raw buffer.  <a href="#a9b3ee3d904e1b80852781bbfa0db37bc">More...</a><br /></td></tr>
<tr class="separator:a9b3ee3d904e1b80852781bbfa0db37bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7021b00b4175685728302637c5d09e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a6f7021b00b4175685728302637c5d09e">m_buf_length</a></td></tr>
<tr class="memdesc:a6f7021b00b4175685728302637c5d09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the raw buffer.  <a href="#a6f7021b00b4175685728302637c5d09e">More...</a><br /></td></tr>
<tr class="separator:a6f7021b00b4175685728302637c5d09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f2da1eae57cf9e1193eff49bc33805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ab2f2da1eae57cf9e1193eff49bc33805">m_echo</a></td></tr>
<tr class="memdesc:ab2f2da1eae57cf9e1193eff49bc33805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo the parsed stream to the pre-processed buffer.  <a href="#ab2f2da1eae57cf9e1193eff49bc33805">More...</a><br /></td></tr>
<tr class="separator:ab2f2da1eae57cf9e1193eff49bc33805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354314b9509e3173098f86d3738fd3db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a354314b9509e3173098f86d3738fd3db">m_echo_saved</a></td></tr>
<tr class="separator:a354314b9509e3173098f86d3738fd3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e60171bd7155adc5ddb80c72d7ddbe2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a6e60171bd7155adc5ddb80c72d7ddbe2">m_cpp_buf</a></td></tr>
<tr class="memdesc:a6e60171bd7155adc5ddb80c72d7ddbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-processed buffer.  <a href="#a6e60171bd7155adc5ddb80c72d7ddbe2">More...</a><br /></td></tr>
<tr class="separator:a6e60171bd7155adc5ddb80c72d7ddbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19446927c8b0b10fd52405ccc616a2af"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a19446927c8b0b10fd52405ccc616a2af">m_cpp_ptr</a></td></tr>
<tr class="memdesc:a19446927c8b0b10fd52405ccc616a2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the current position in the pre-processed input stream.  <a href="#a19446927c8b0b10fd52405ccc616a2af">More...</a><br /></td></tr>
<tr class="separator:a19446927c8b0b10fd52405ccc616a2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae6514827710db607bb19d0ceb0f03f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a2ae6514827710db607bb19d0ceb0f03f">m_cpp_tok_start</a></td></tr>
<tr class="memdesc:a2ae6514827710db607bb19d0ceb0f03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting position of the last token parsed, in the pre-processed buffer.  <a href="#a2ae6514827710db607bb19d0ceb0f03f">More...</a><br /></td></tr>
<tr class="separator:a2ae6514827710db607bb19d0ceb0f03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bb76560b065cbd7f70ead3493074be"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#ad5bb76560b065cbd7f70ead3493074be">m_cpp_tok_end</a></td></tr>
<tr class="memdesc:ad5bb76560b065cbd7f70ead3493074be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending position of the previous token parsed, in the pre-processed buffer.  <a href="#ad5bb76560b065cbd7f70ead3493074be">More...</a><br /></td></tr>
<tr class="separator:ad5bb76560b065cbd7f70ead3493074be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f90ba8fab100d98d1af5baf0f59afe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a52f90ba8fab100d98d1af5baf0f59afe">m_body_utf8</a></td></tr>
<tr class="memdesc:a52f90ba8fab100d98d1af5baf0f59afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF8-body buffer created during parsing.  <a href="#a52f90ba8fab100d98d1af5baf0f59afe">More...</a><br /></td></tr>
<tr class="separator:a52f90ba8fab100d98d1af5baf0f59afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532db6ba0ff2d8e72c2f1dc8af25747c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a532db6ba0ff2d8e72c2f1dc8af25747c">m_body_utf8_ptr</a></td></tr>
<tr class="memdesc:a532db6ba0ff2d8e72c2f1dc8af25747c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the current position in the UTF8-body buffer.  <a href="#a532db6ba0ff2d8e72c2f1dc8af25747c">More...</a><br /></td></tr>
<tr class="separator:a532db6ba0ff2d8e72c2f1dc8af25747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568ce3895aca603e1c5e8a8dec9e0598"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLex__input__stream.html#a568ce3895aca603e1c5e8a8dec9e0598">m_cpp_utf8_processed_ptr</a></td></tr>
<tr class="memdesc:a568ce3895aca603e1c5e8a8dec9e0598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position in the pre-processed buffer.  <a href="#a568ce3895aca603e1c5e8a8dec9e0598">More...</a><br /></td></tr>
<tr class="separator:a568ce3895aca603e1c5e8a8dec9e0598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents the character input stream consumed during lexical analysis. </p>
<p>In addition to consuming the input stream, this class performs some comment pre processing, by filtering out out-of-bound special text from the query input stream.</p>
<p>Two buffers, with pointers inside each, are maintained in parallel. The 'raw' buffer is the original query text, which may contain out-of-bound comments. The 'cpp' (for comments pre processor) is the pre-processed buffer that contains only the query text that should be seen once out-of-bound data is removed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9eb4d6293e4efa122a4b725922b9ce18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb4d6293e4efa122a4b725922b9ce18">&#9670;&nbsp;</a></span>Lex_input_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Lex_input_stream::Lex_input_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>grammar_selector_token_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grammar_selector_token_arg</td><td>See grammar_selector_token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5ffb7408b6c841035ed70a84669461cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffb7408b6c841035ed70a84669461cb">&#9670;&nbsp;</a></span>add_digest_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::add_digest_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionLexer__yystype.html">Lexer_yystype</a> *&#160;</td>
          <td class="paramname"><em>yylval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14506340b97c5e58cafcc27ec5c3cdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14506340b97c5e58cafcc27ec5c3cdc6">&#9670;&nbsp;</a></span>body_utf8_append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::body_utf8_append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operation appends unprocessed part of the pre-processed buffer till the given pointer (ptr) and sets m_cpp_utf8_processed_ptr to ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer in the pre-processed buffer, which specifies the end of the chunk, which should be appended to the utf8 body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbb55ed14731193c629343f9b74033e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb55ed14731193c629343f9b74033e1">&#9670;&nbsp;</a></span>body_utf8_append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::body_utf8_append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operation appends unprocessed part of pre-processed buffer till the given pointer (ptr) and sets m_cpp_utf8_processed_ptr to end_ptr. </p>
<p>The idea is that some tokens in the pre-processed buffer (like character set introducers) should be skipped.</p>
<p>Example: CPP buffer: SELECT 'str1', _latin1 'str2'; m_cpp_utf8_processed_ptr &ndash; points at the "SELECT ..."; In order to skip "_latin1", the following call should be made: body_utf8_append(&lt;pointer to "_latin1 ..."&gt;, &lt;pointer to " 'str2'..."&gt;)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer in the pre-processed buffer, which specifies the end of the chunk, which should be appended to the utf8 body. </td></tr>
    <tr><td class="paramname">end_ptr</td><td>Pointer in the pre-processed buffer, to which m_cpp_utf8_processed_ptr will be set in the end of the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41c8ff68ea384d277658dce4788a23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41c8ff68ea384d277658dce4788a23f">&#9670;&nbsp;</a></span>body_utf8_append_literal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::body_utf8_append_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lex__string_8h.html#a1fb89d4ad1109660fb2b796efdb3933e">LEX_STRING</a> *&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *&#160;</td>
          <td class="paramname"><em>txt_cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operation converts the specified text literal to the utf8 and appends the result to the utf8-body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">txt</td><td>Text literal. </td></tr>
    <tr><td class="paramname">txt_cs</td><td>Character set of the text literal. </td></tr>
    <tr><td class="paramname">end_ptr</td><td>Pointer in the pre-processed buffer, to which m_cpp_utf8_processed_ptr will be set in the end of the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09050267cb8f0959a35dac888d33cbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09050267cb8f0959a35dac888d33cbab">&#9670;&nbsp;</a></span>body_utf8_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::body_utf8_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operation is called from the parser in order to 1) designate the intention to have utf8 body; 1) Indicate to the lexer that we will need a utf8 representation of this statement; 2) Determine the beginning of the body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">begin_ptr</td><td>Pointer to the start of the body in the pre-processed buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73d549bffa0e044ea8355ea4fe8491ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d549bffa0e044ea8355ea4fe8491ca">&#9670;&nbsp;</a></span>cpp_inject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Lex_input_stream::cpp_inject </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inject a character into the pre-processed stream. </p>
<p>Note, this function is used to inject a space instead of multi-character C-comment. Thus there is no boundary checks here (basically, we replace N-chars by 1-char here). </p>

</div>
</div>
<a id="ae705b5ccee549d88adea2285a0c4d792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae705b5ccee549d88adea2285a0c4d792">&#9670;&nbsp;</a></span>eof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of file indicator for the query text to parse. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there are no more characters to parse </dd></dl>

</div>
</div>
<a id="a5aef4d2ba9b3d7e04b959c40224cb145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aef4d2ba9b3d7e04b959c40224cb145">&#9670;&nbsp;</a></span>eof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::eof </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of file indicator for the query text to parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of characters expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are less than n characters to parse </dd></dl>

</div>
</div>
<a id="a34cd073c596785c498cc3d9d26d82bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cd073c596785c498cc3d9d26d82bd3">&#9670;&nbsp;</a></span>get_body_utf8_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Lex_input_stream::get_body_utf8_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the utf8-body length. </p>

</div>
</div>
<a id="ac59eb01dc9f1b32acaf9617b17c0fe1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59eb01dc9f1b32acaf9617b17c0fe1a">&#9670;&nbsp;</a></span>get_body_utf8_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_body_utf8_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the utf8-body string. </p>

</div>
</div>
<a id="a1972d001dec74ff430150c38da101555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1972d001dec74ff430150c38da101555">&#9670;&nbsp;</a></span>get_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_buf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw query buffer. </p>

</div>
</div>
<a id="a95f9a02e160efaf0c5f097e27b3ef87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f9a02e160efaf0c5f097e27b3ef87e">&#9670;&nbsp;</a></span>get_cpp_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_cpp_buf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pre-processed query buffer. </p>

</div>
</div>
<a id="a14444da8148be334f126b76fb97289f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14444da8148be334f126b76fb97289f2">&#9670;&nbsp;</a></span>get_cpp_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_cpp_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current stream pointer, in the pre-processed buffer. </p>

</div>
</div>
<a id="a5af1189152c4c1c1dbb9accaeb9e5c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af1189152c4c1c1dbb9accaeb9e5c4b">&#9670;&nbsp;</a></span>get_cpp_tok_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_cpp_tok_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the token end position, in the pre-processed buffer. </p>

</div>
</div>
<a id="af05a1ded30badb4b5f68eea6a64b0439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05a1ded30badb4b5f68eea6a64b0439">&#9670;&nbsp;</a></span>get_cpp_tok_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_cpp_tok_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the token start position, in the pre-processed buffer. </p>

</div>
</div>
<a id="a619f9eb85d34254c1478f707eef01dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619f9eb85d34254c1478f707eef01dff">&#9670;&nbsp;</a></span>get_end_of_query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_end_of_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the end of the raw query buffer. </p>

</div>
</div>
<a id="a5bca3724b42765facddd41a2b9d03bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bca3724b42765facddd41a2b9d03bbe">&#9670;&nbsp;</a></span>get_lineno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Lex_input_stream::get_lineno </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38616c405ae44d6623217362430c7386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38616c405ae44d6623217362430c7386">&#9670;&nbsp;</a></span>get_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current stream pointer, in the raw buffer. </p>

</div>
</div>
<a id="a866087eb0ab9f0fd777cfbb33fb1a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866087eb0ab9f0fd777cfbb33fb1a638">&#9670;&nbsp;</a></span>get_tok_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_tok_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the token end position, in the raw buffer. </p>

</div>
</div>
<a id="a591fbee2501521e31ab1b163873443a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591fbee2501521e31ab1b163873443a5">&#9670;&nbsp;</a></span>get_tok_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::get_tok_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the token start position, in the raw buffer. </p>

</div>
</div>
<a id="a42a077ed4a6bad4169d6675876fb7e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a077ed4a6bad4169d6675876fb7e05">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object initializer. </p>
<p>Perform initialization of Lex_input_stream instance.</p>
<p>Must be called before usage.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error</td></tr>
  </table>
  </dd>
</dl>
<p>Basically, a buffer for a pre-processed query. This buffer should be large enough to keep a multi-statement query. The allocation is done once in Lex_input_stream::init() in order to prevent memory pollution when the server is processing large multi-statement queries. </p>

</div>
</div>
<a id="af201c8bf79b04e9aefb260455e34b0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af201c8bf79b04e9aefb260455e34b0f8">&#9670;&nbsp;</a></span>is_partial_parser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::is_partial_parser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this scanner tokenizes a partial query (partition expression, generated column expression etc.) </p>
<dl class="section return"><dt>Returns</dt><dd>true if parsing a partial query, otherwise false. </dd></dl>

</div>
</div>
<a id="a6d43efacdceb0c156998f4d649d0847a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d43efacdceb0c156998f4d649d0847a">&#9670;&nbsp;</a></span>lex_one_token() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the Lex_input_stream::lex_one_token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaae2ec69ef9e469ca7d7142c4b679285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae2ec69ef9e469ca7d7142c4b679285">&#9670;&nbsp;</a></span>lex_one_token() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the * but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint* <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>* * inside* the Lex_input_stream::lex_one_token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7acddc127195ce35469a61466ab67559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acddc127195ce35469a61466ab67559">&#9670;&nbsp;</a></span>reduce_digest_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::reduce_digest_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>token_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>token_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada17ef8ee29410ae41d5698fd496e77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada17ef8ee29410ae41d5698fd496e77a">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare Lex_input_stream instance state for use for handling next SQL statement. </p>
<p>It should be called between two statements in a multi-statement query. The operation resets the input stream to the beginning-of-parse state, but does not reallocate m_cpp_buf. </p>

</div>
</div>
<a id="a080cdebb6b1f29c189ceabe9c930bc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080cdebb6b1f29c189ceabe9c930bc91">&#9670;&nbsp;</a></span>restart_token()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::restart_token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the starting position of the current token. </p>
<p>This is used to compensate for starting whitespace. </p>

</div>
</div>
<a id="a1ccb8737723e3c35901e675fb9885b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccb8737723e3c35901e675fb9885b20">&#9670;&nbsp;</a></span>restore_in_comment_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::restore_in_comment_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa17c2d5753ae6ee11724b7d1ab93db65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17c2d5753ae6ee11724b7d1ab93db65">&#9670;&nbsp;</a></span>save_in_comment_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::save_in_comment_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6bea2c3e4e0babcbda627ff39670fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bea2c3e4e0babcbda627ff39670fb8">&#9670;&nbsp;</a></span>set_echo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::set_echo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>echo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the echo mode. </p>
<p>When echo is true, characters parsed from the raw input stream are preserved. When false, characters parsed are silently ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">echo</td><td>the echo mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce3b51028b33febdbcd7fc0fbb71df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce3b51028b33febdbcd7fc0fbb71df8">&#9670;&nbsp;</a></span>skip_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::skip_binary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip binary from the input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of bytes to accept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c5d7e2c90d6a9d579e0343fcf2d3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c5d7e2c90d6a9d579e0343fcf2d3a9">&#9670;&nbsp;</a></span>start_token()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::start_token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the stream position as the start of a new token. </p>

</div>
</div>
<a id="a5c000488389f2ea29bf4b90bb441b3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c000488389f2ea29bf4b90bb441b3a3">&#9670;&nbsp;</a></span>text_string_is_7bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::text_string_is_7bit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8df25cf19a9c2e89a385dbb3654418e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8df25cf19a9c2e89a385dbb3654418e">&#9670;&nbsp;</a></span>warn_on_deprecated_charset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::warn_on_deprecated_charset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs warnings on deprecated charsets in complete SQL statements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The character set/collation to check for a deprecation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alias</td><td>The name/alias of <code>cs</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f133c00f7d1e8cd8b3396d957a7501b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f133c00f7d1e8cd8b3396d957a7501b">&#9670;&nbsp;</a></span>warn_on_deprecated_collation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::warn_on_deprecated_collation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a> *&#160;</td>
          <td class="paramname"><em>collation</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs warnings on deprecated collations in complete SQL statements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">collation</td><td>The collation to check for a deprecation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa59640cd71bf5fe64306d200a9673c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59640cd71bf5fe64306d200a9673c4c">&#9670;&nbsp;</a></span>yyGet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char Lex_input_stream::yyGet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a character, and advance in the stream. </p>
<dl class="section return"><dt>Returns</dt><dd>the next character to parse. </dd></dl>

</div>
</div>
<a id="ac57f247cba607116a6e6e7b279444550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57f247cba607116a6e6e7b279444550">&#9670;&nbsp;</a></span>yyGetLast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char Lex_input_stream::yyGetLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last character accepted. </p>
<dl class="section return"><dt>Returns</dt><dd>the last character accepted. </dd></dl>

</div>
</div>
<a id="a4e89fc04b374a28023b4ac9b72cffae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e89fc04b374a28023b4ac9b72cffae3">&#9670;&nbsp;</a></span>yyLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Lex_input_stream::yyLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the current token, in the raw buffer. </p>

</div>
</div>
<a id="ae3e0984cbdae4667aa14a07a47e80e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e0984cbdae4667aa14a07a47e80e10">&#9670;&nbsp;</a></span>yyPeek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char Lex_input_stream::yyPeek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look at the next character to parse, but do not accept it. </p>

</div>
</div>
<a id="ae13b44eed648794e2aa724e12d12c3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13b44eed648794e2aa724e12d12c3cf">&#9670;&nbsp;</a></span>yyPeekn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char Lex_input_stream::yyPeekn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look ahead at some character to parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>offset of the character to look up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad4b561cb7a75d0f29902538850f3f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4b561cb7a75d0f29902538850f3f51">&#9670;&nbsp;</a></span>yySkip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::yySkip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept a character, by advancing the input stream. </p>

</div>
</div>
<a id="ab89a2f69e382d5900c2e8d087eb4c8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89a2f69e382d5900c2e8d087eb4c8cd">&#9670;&nbsp;</a></span>yySkipn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::yySkipn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept multiple characters at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of characters to accept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf5e0850c158c34cd8afc964fbf6364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf5e0850c158c34cd8afc964fbf6364">&#9670;&nbsp;</a></span>yyUnget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lex_input_stream::yyUnget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel the effect of the last yyGet() or yySkip(). </p>
<p>Note that the echo mode should not change between calls to yyGet / yySkip and yyUnget. The caller is responsible for ensuring that. </p>

</div>
</div>
<a id="a0d65c43d1a6b615105b64111d7f325a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d65c43d1a6b615105b64111d7f325a0">&#9670;&nbsp;</a></span>yyUnput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Lex_input_stream::yyUnput </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts a character back into the stream, canceling the effect of the last yyGet() or yySkip(). </p>
<p>Note that the echo mode should not change between calls to unput, get, or skip from the stream. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab4b7031a90f611435f84ae688fa3f52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b7031a90f611435f84ae688fa3f52f">&#9670;&nbsp;</a></span>first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the * but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint* <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>* * inside* the the usual data flow adds* tokens from the string Lex_input_stream::first</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18f9f635ce7263b5d7e7a8bcda12652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f9f635ce7263b5d7e7a8bcda12652d">&#9670;&nbsp;</a></span>forms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the * but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint* <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>* * inside* the the usual data flow adds* tokens from the string and only than it appends* the SELECT keyword token to that since we use the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> to restore* <a class="el" href="myisam__ftdump_8cc.html#af26982218484ec3fdcb8f7d92e864a9b">query</a> strings in their normalized Lex_input_stream::forms</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70ae2483b386d48b7fcbfc386310933d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ae2483b386d48b7fcbfc386310933d">&#9670;&nbsp;</a></span>found_semicolon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::found_semicolon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position of ';' in the stream, to delimit multiple queries. </p>
<p>This delimiter is in the raw buffer. </p>

</div>
</div>
<a id="a094db80ef1285f05d15ac87c222f126e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094db80ef1285f05d15ac87c222f126e">&#9670;&nbsp;</a></span>grammar_selector_token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Lex_input_stream::grammar_selector_token</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The synthetic 1st token to prepend token stream with. </p>
<p>This token value tricks parser to simulate multiple start-ing points. Currently the grammar is aware of 4 such synthetic tokens:</p><ol type="1">
<li>GRAMMAR_SELECTOR_PART for partitioning stuff from DD,</li>
<li>GRAMMAR_SELECTOR_GCOL for generated column stuff from DD,</li>
<li>GRAMMAR_SELECTOR_EXPR for generic single expressions from DD/.frm.</li>
<li>GRAMMAR_SELECTOR_CTE for generic subquery expressions from CTEs.</li>
<li>-1 when parsing with the main grammar (no grammar selector available).</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>yylex() is expected to return the value of type int: 0 is for EOF and everything else for real token numbers. Bison, in its turn, generates positive token numbers. So, the negative grammar_selector_token means "not a token". In other words, -1 is "empty value". </dd></dl>

</div>
</div>
<a id="ac5ad1b45b6f20ce942c810fb4f9504fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ad1b45b6f20ce942c810fb4f9504fb">&#9670;&nbsp;</a></span>ignore_space</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::ignore_space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SQL_MODE = IGNORE_SPACE. </p>

</div>
</div>
<a id="ab9c09455cf65d25a7e1aa1ed90f4c761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c09455cf65d25a7e1aa1ed90f4c761">&#9670;&nbsp;</a></span>in_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GROUP__PARSER.html#gac6239d9548e1df34f111b7083c6dc542">enum_comment_state</a> Lex_input_stream::in_comment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of the lexical analyser for comments. </p>

</div>
</div>
<a id="a5752080de11665fde944c3fd602bf5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5752080de11665fde944c3fd602bf5a6">&#9670;&nbsp;</a></span>in_comment_saved</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GROUP__PARSER.html#gac6239d9548e1df34f111b7083c6dc542">enum_comment_state</a> Lex_input_stream::in_comment_saved</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac123fd2ed4f96430b38da09668771127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac123fd2ed4f96430b38da09668771127">&#9670;&nbsp;</a></span>lookahead_token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Lex_input_stream::lookahead_token</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LALR(2) resolution, look ahead token. </p>
<p>Value of the next token to return, if any, or -1, if no token was parsed in advance. Note: 0 is a legal token, and represents YYEOF. </p>

</div>
</div>
<a id="a99f3f2f2d2be4f4a1c1d314ded8139b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f3f2f2d2be4f4a1c1d314ded8139b7">&#9670;&nbsp;</a></span>lookahead_yylval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionLexer__yystype.html">Lexer_yystype</a>* Lex_input_stream::lookahead_yylval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LALR(2) resolution, value of the look ahead token. </p>

</div>
</div>
<a id="a52f90ba8fab100d98d1af5baf0f59afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f90ba8fab100d98d1af5baf0f59afe">&#9670;&nbsp;</a></span>m_body_utf8</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Lex_input_stream::m_body_utf8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF8-body buffer created during parsing. </p>

</div>
</div>
<a id="a532db6ba0ff2d8e72c2f1dc8af25747c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532db6ba0ff2d8e72c2f1dc8af25747c">&#9670;&nbsp;</a></span>m_body_utf8_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Lex_input_stream::m_body_utf8_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the current position in the UTF8-body buffer. </p>

</div>
</div>
<a id="a9b3ee3d904e1b80852781bbfa0db37bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3ee3d904e1b80852781bbfa0db37bc">&#9670;&nbsp;</a></span>m_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begining of the query text in the input stream, in the raw buffer. </p>

</div>
</div>
<a id="a6f7021b00b4175685728302637c5d09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7021b00b4175685728302637c5d09e">&#9670;&nbsp;</a></span>m_buf_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Lex_input_stream::m_buf_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Length of the raw buffer. </p>

</div>
</div>
<a id="a6e60171bd7155adc5ddb80c72d7ddbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e60171bd7155adc5ddb80c72d7ddbe2">&#9670;&nbsp;</a></span>m_cpp_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Lex_input_stream::m_cpp_buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-processed buffer. </p>

</div>
</div>
<a id="a19446927c8b0b10fd52405ccc616a2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19446927c8b0b10fd52405ccc616a2af">&#9670;&nbsp;</a></span>m_cpp_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Lex_input_stream::m_cpp_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the current position in the pre-processed input stream. </p>

</div>
</div>
<a id="a7424552eadd7b915f5a90a67033e0d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7424552eadd7b915f5a90a67033e0d9e">&#9670;&nbsp;</a></span>m_cpp_text_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_cpp_text_end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ending position of the TEXT_STRING or IDENT in the pre-processed buffer. </p>
<p>NOTE: this member must be used within MYSQLlex() function only. </p>

</div>
</div>
<a id="a6ad94591422e421c9bae85b7005f41a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad94591422e421c9bae85b7005f41a4">&#9670;&nbsp;</a></span>m_cpp_text_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_cpp_text_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting position of the TEXT_STRING or IDENT in the pre-processed buffer. </p>
<p>NOTE: this member must be used within MYSQLlex() function only. </p>

</div>
</div>
<a id="ad5bb76560b065cbd7f70ead3493074be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bb76560b065cbd7f70ead3493074be">&#9670;&nbsp;</a></span>m_cpp_tok_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_cpp_tok_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ending position of the previous token parsed, in the pre-processed buffer. </p>

</div>
</div>
<a id="a2ae6514827710db607bb19d0ceb0f03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae6514827710db607bb19d0ceb0f03f">&#9670;&nbsp;</a></span>m_cpp_tok_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_cpp_tok_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starting position of the last token parsed, in the pre-processed buffer. </p>

</div>
</div>
<a id="a568ce3895aca603e1c5e8a8dec9e0598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568ce3895aca603e1c5e8a8dec9e0598">&#9670;&nbsp;</a></span>m_cpp_utf8_processed_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_cpp_utf8_processed_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Position in the pre-processed buffer. </p>
<p>The query from m_cpp_buf to m_cpp_utf_processed_ptr is converted to UTF8-body. </p>

</div>
</div>
<a id="a73d2e0ce4fce1944bb9d68511094342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d2e0ce4fce1944bb9d68511094342a">&#9670;&nbsp;</a></span>m_digest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsql__digest__state.html">sql_digest_state</a>* Lex_input_stream::m_digest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current statement digest instrumentation. </p>

</div>
</div>
<a id="ab2f2da1eae57cf9e1193eff49bc33805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f2da1eae57cf9e1193eff49bc33805">&#9670;&nbsp;</a></span>m_echo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::m_echo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo the parsed stream to the pre-processed buffer. </p>

</div>
</div>
<a id="a354314b9509e3173098f86d3738fd3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354314b9509e3173098f86d3738fd3db">&#9670;&nbsp;</a></span>m_echo_saved</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::m_echo_saved</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02a3e06284f023f97add057bfe435920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a3e06284f023f97add057bfe435920">&#9670;&nbsp;</a></span>m_end_of_query</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_end_of_query</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of the query text in the input stream, in the raw buffer. </p>

</div>
</div>
<a id="a57ac1fee85f336b7e9b4ef967b69024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ac1fee85f336b7e9b4ef967b69024f">&#9670;&nbsp;</a></span>m_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Lex_input_stream::m_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the current position in the raw input stream. </p>

</div>
</div>
<a id="a803114bdf72ff32e00f96cc16b18b476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803114bdf72ff32e00f96cc16b18b476">&#9670;&nbsp;</a></span>m_thd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTHD.html">THD</a>* Lex_input_stream::m_thd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current thread. </p>

</div>
</div>
<a id="a3e576f070be66bad9b5e635e08a713f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e576f070be66bad9b5e635e08a713f0">&#9670;&nbsp;</a></span>m_tok_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_tok_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ending position of the previous token parsed, in the raw buffer. </p>

</div>
</div>
<a id="a1411c4f3cfe2663f4c8a617437430170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1411c4f3cfe2663f4c8a617437430170">&#9670;&nbsp;</a></span>m_tok_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Lex_input_stream::m_tok_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starting position of the last token parsed, in the raw buffer. </p>

</div>
</div>
<a id="adb9972f5dd34b7df6b90178d68d56b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9972f5dd34b7df6b90178d68d56b64">&#9670;&nbsp;</a></span>m_underscore_cs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a>* Lex_input_stream::m_underscore_cs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Character set specified by the character-set-introducer. </p>
<p>NOTE: this member must be used within MYSQLlex() function only. </p>

</div>
</div>
<a id="a276bc97647b5e242f12106febfffa808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276bc97647b5e242f12106febfffa808">&#9670;&nbsp;</a></span>multi_statements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::multi_statements</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true if we should allow multi-statements. </p>

</div>
</div>
<a id="a44bee2a4209db7c2cdf2e63904a0a012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bee2a4209db7c2cdf2e63904a0a012">&#9670;&nbsp;</a></span>next_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sql__chars_8h.html#af586ca2e6e2271cc55f1efe56f224b4c">my_lex_states</a> Lex_input_stream::next_state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current state of the lexical analyser. </p>

</div>
</div>
<a id="a613035cd9ba74aa0387ceddd437c2c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613035cd9ba74aa0387ceddd437c2c1f">&#9670;&nbsp;</a></span>query_charset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structCHARSET__INFO.html">CHARSET_INFO</a>* Lex_input_stream::query_charset</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade20c5abf58fb0f29dda5afe6f32ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade20c5abf58fb0f29dda5afe6f32ae30">&#9670;&nbsp;</a></span>skip_digest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the * but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint* <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>* * inside* the the usual data flow adds* tokens from the string and only than it appends* the SELECT keyword token to that since we use the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> to restore* <a class="el" href="myisam__ftdump_8cc.html#af26982218484ec3fdcb8f7d92e864a9b">query</a> strings in their normalized so the order of <a class="el" href="xcom__statistics_8cc.html#a518dc951712ff1f919a3af4897ef91b9">added</a> tokens is* important we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> tokens of hintable keywords to a digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>* right in the hint <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> and skip adding of them at the caller with the* <a class="el" href="do__ctype_8cc.html#a81ae9faedaa69e3e28e2960a0548df8d">help</a> of skip_digest <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>* <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::skip_digest</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c4b7f27fdb7c56727cea6a0a3f4e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4b7f27fdb7c56727cea6a0a3f4e817">&#9670;&nbsp;</a></span>stmt_prepare_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lex_input_stream::stmt_prepare_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true if we're parsing a prepared statement: in this mode we should allow placeholders. </p>

</div>
</div>
<a id="a7963742180e34c2bd6f8dbf9b72b4aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7963742180e34c2bd6f8dbf9b72b4aef">&#9670;&nbsp;</a></span>stream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the * but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint* <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>* * inside* the the usual data flow adds* tokens from the string and only than it appends* the SELECT keyword token to that Lex_input_stream::stream</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99eeef1486a99591b70a6ab5893b2e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eeef1486a99591b70a6ab5893b2e1d">&#9670;&nbsp;</a></span>Thus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the * but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint* <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> those tokens to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>* * inside* the the usual data flow adds* tokens from the string and only than it appends* the SELECT keyword token to that since we use the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> to restore* <a class="el" href="myisam__ftdump_8cc.html#af26982218484ec3fdcb8f7d92e864a9b">query</a> strings in their normalized so the order of <a class="el" href="xcom__statistics_8cc.html#a518dc951712ff1f919a3af4897ef91b9">added</a> tokens is* important Lex_input_stream::Thus</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1565168582b6b859f4c3a4bb5467c3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1565168582b6b859f4c3a4bb5467c3eb">&#9670;&nbsp;</a></span>tok_bitmap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> Lex_input_stream::tok_bitmap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Token character bitmaps, to detect 7bit strings. </p>

</div>
</div>
<a id="a6fdc8aa813720669af78b55b14cbe5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdc8aa813720669af78b55b14cbe5f2">&#9670;&nbsp;</a></span>view <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of Lex_input_stream::view</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip adding of the current token's digest since it is already added. </p>
<p>Usually we calculate a digest token by token at the top-level function of the lexer: MYSQLlex(). However, some complex ("hintable") tokens break that data flow: for example, the `SELECT /*+ HINT(t) </p>

</div>
</div>
<a id="a7c7f11c985d1aba56ac33fee9091506e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7f11c985d1aba56ac33fee9091506e">&#9670;&nbsp;</a></span>view <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">is the single* token from the <a class="el" href="viotest_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of and we <a class="el" href="suite__stubs_8h.html#af37957fd15ebadd906ca63676049d89c">add</a> the SELECT* keyword to the digest <a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a> right after the * but the is a <a class="el" href="udf__example_8cc.html#aa48a6c218d5a51dadae7378c4e83c109">sequence</a> of separate tokens from the hint* <a class="el" href="mysqltest_8cc.html#aaf0e5e0825758ada2d9879c38fa4f1cb">parser</a> s point of Lex_input_stream::view</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab83e2dd819cfd29f06679d5336e901a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83e2dd819cfd29f06679d5336e901a0">&#9670;&nbsp;</a></span>yylineno</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Lex_input_stream::yylineno</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current line number. </p>

</div>
</div>
<a id="a47b7a30d6b738aa17ffe8f15afb54547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b7a30d6b738aa17ffe8f15afb54547">&#9670;&nbsp;</a></span>yylval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionLexer__yystype.html">Lexer_yystype</a>* Lex_input_stream::yylval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface with bison, value of the last token parsed. </p>

</div>
</div>
<a id="af7808434969debc403c93848481a58c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7808434969debc403c93848481a58c9">&#9670;&nbsp;</a></span>yytoklen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Lex_input_stream::yytoklen</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of the last token parsed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="sql__lex_8h_source.html">sql_lex.h</a></li>
<li>sql/<a class="el" href="sql__lex_8cc.html">sql_lex.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classLex__input__stream.html">Lex_input_stream</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
