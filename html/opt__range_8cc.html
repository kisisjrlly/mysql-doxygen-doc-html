<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: sql/opt_range.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('opt__range_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">opt_range.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange__optimizer__error__handler.html">Range_optimizer_error_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling class for range optimizer.  <a href="classRange__optimizer__error__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A graph of (possible multiple) key ranges, represented as a red-black binary tree.  <a href="classSEL__ROOT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ARG.html">SEL_ARG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__TREE.html">SEL_TREE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPARAM.html">PARAM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTABLE__READ__PLAN.html">TABLE_READ_PLAN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRP__RANGE.html">TRP_RANGE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRP__ROR__INTERSECT.html">TRP_ROR_INTERSECT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRP__ROR__UNION.html">TRP_ROR_UNION</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRP__INDEX__MERGE.html">TRP_INDEX_MERGE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRP__GROUP__MIN__MAX.html">TRP_GROUP_MIN_MAX</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTRP__SKIP__SCAN.html">TRP_SKIP_SCAN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRANGE__SEQ__ENTRY.html">RANGE_SEQ_ENTRY</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSel__arg__range__sequence.html">Sel_arg_range_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a48a58d73bd51e6ab6e0006f4f8c17b21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a48a58d73bd51e6ab6e0006f4f8c17b21">OPT_RANGE_CC_INCLUDED</a></td></tr>
<tr class="separator:a48a58d73bd51e6ab6e0006f4f8c17b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a31273d0cbf966c8485f717409a8a5d80"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a31273d0cbf966c8485f717409a8a5d80">mark_full_part_func</a>) (<a class="el" href="classpartition__info.html">partition_info</a> *, <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>)</td></tr>
<tr class="separator:a31273d0cbf966c8485f717409a8a5d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96a3ff13290057561329a1183ab81bd6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a96a3ff13290057561329a1183ab81bd6">sel_cmp</a> (<a class="el" href="classField.html">Field</a> *f, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *a, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *b, <a class="el" href="my__inttypes_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> a_flag, <a class="el" href="my__inttypes_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a> b_flag)</td></tr>
<tr class="separator:a96a3ff13290057561329a1183ab81bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdf9c54f6992af88f15c49339b0017e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aecdf9c54f6992af88f15c49339b0017e">rb_delete_fixup</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> *root, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *par)</td></tr>
<tr class="separator:aecdf9c54f6992af88f15c49339b0017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b3303913305304906f5dca70b4b10"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a3b6b3303913305304906f5dca70b4b10">test_rb_tree</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> *element, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *parent)</td></tr>
<tr class="separator:a3b6b3303913305304906f5dca70b4b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0f9ba3e66d3f5a4621012de5384474"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a3f0f9ba3e66d3f5a4621012de5384474">invert_min_flag</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> min_flag)</td></tr>
<tr class="memdesc:a3f0f9ba3e66d3f5a4621012de5384474"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to invert min flags to max flags for DESC key parts.  <a href="#a3f0f9ba3e66d3f5a4621012de5384474">More...</a><br /></td></tr>
<tr class="separator:a3f0f9ba3e66d3f5a4621012de5384474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07ba9a2a7d56bd5186585f8b857ae55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ae07ba9a2a7d56bd5186585f8b857ae55">invert_max_flag</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> max_flag)</td></tr>
<tr class="memdesc:ae07ba9a2a7d56bd5186585f8b857ae55"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to invert max flags to min flags for DESC key parts.  <a href="#ae07ba9a2a7d56bd5186585f8b857ae55">More...</a><br /></td></tr>
<tr class="separator:ae07ba9a2a7d56bd5186585f8b857ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3042889cd636db269b9a985349692808"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a3042889cd636db269b9a985349692808">all_same</a> (const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *sa1, const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *sa2)</td></tr>
<tr class="memdesc:a3042889cd636db269b9a985349692808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compare two SEL_ROOTs.  <a href="#a3042889cd636db269b9a985349692808">More...</a><br /></td></tr>
<tr class="separator:a3042889cd636db269b9a985349692808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4601556a9f3b9bc8c9f2ecdf4f36ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aae4601556a9f3b9bc8c9f2ecdf4f36ef">get_mm_parts</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem__func.html">Item_func</a> *cond_func, <a class="el" href="classField.html">Field</a> *field, <a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a> type, <a class="el" href="classItem.html">Item</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="separator:aae4601556a9f3b9bc8c9f2ecdf4f36ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba5f75a44faef3952ccd9a16bdb22e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a4ba5f75a44faef3952ccd9a16bdb22e6">get_mm_leaf</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem.html">Item</a> *cond_func, <a class="el" href="classField.html">Field</a> *field, <a class="el" href="structKEY__PART.html">KEY_PART</a> *key_part, <a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a> type, <a class="el" href="classItem.html">Item</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="separator:a4ba5f75a44faef3952ccd9a16bdb22e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29173f455b1a2cee8c79b993058a89b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a29173f455b1a2cee8c79b993058a89b9">get_mm_tree</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr class="memdesc:a29173f455b1a2cee8c79b993058a89b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Range Analysis Module, which finds range access alternatives applicable to single or multi-index (UNION) access.  <a href="#a29173f455b1a2cee8c79b993058a89b9">More...</a><br /></td></tr>
<tr class="separator:a29173f455b1a2cee8c79b993058a89b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f8d7333662a3737a4766d8b43f4a59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a63f8d7333662a3737a4766d8b43f4a59">is_key_scan_ror</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keynr, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> nparts)</td></tr>
<tr class="separator:a63f8d7333662a3737a4766d8b43f4a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb98e1671535d148565357347c3783e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#acb98e1671535d148565357347c3783e4">check_quick_select</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> index_only, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *tree, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> update_tbl_stats, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *mrr_flags, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *bufsize, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:acb98e1671535d148565357347c3783e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176db9ac71a1f3bbba91cb82dd02df0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQUICK__RANGE__SELECT.html">QUICK_RANGE_SELECT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a176db9ac71a1f3bbba91cb82dd02df0a">get_quick_select</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *key_tree, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mrr_flags, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> mrr_buf_size, <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *alloc, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> num_key_parts=<a class="el" href="sql__const_8h.html#ade6d024ebbd678a7e3e0347e05546ebf">MAX_REF_PARTS</a>)</td></tr>
<tr class="separator:a176db9ac71a1f3bbba91cb82dd02df0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fd6e560182dc2b565b22a73683e42b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTRP__RANGE.html">TRP_RANGE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ab9fd6e560182dc2b565b22a73683e42b">get_key_scans_params</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> index_read_must_be_used, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> update_tbl_stats, const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost_est)</td></tr>
<tr class="separator:ab9fd6e560182dc2b565b22a73683e42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d7cfb69a4d25d3fd93c5b6ffdc1d71"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTRP__ROR__INTERSECT.html">TRP_ROR_INTERSECT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a50d7cfb69a4d25d3fd93c5b6ffdc1d71">get_best_ror_intersect</a> (const <a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree, const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost_est, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> force_index_merge_result)</td></tr>
<tr class="separator:a50d7cfb69a4d25d3fd93c5b6ffdc1d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8d0b6f805cb5ea9095f6c3c61cb9c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTABLE__READ__PLAN.html">TABLE_READ_PLAN</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a4d8d0b6f805cb5ea9095f6c3c61cb9c5">get_best_disjunct_quick</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> *imerge, const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost_est)</td></tr>
<tr class="separator:a4d8d0b6f805cb5ea9095f6c3c61cb9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b351f367cda631b09d7f5f25517633"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTRP__GROUP__MIN__MAX.html">TRP_GROUP_MIN_MAX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a11b351f367cda631b09d7f5f25517633">get_best_group_min_max</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree, const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost_est)</td></tr>
<tr class="memdesc:a11b351f367cda631b09d7f5f25517633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this access method is applicable to a GROUP query with MIN/MAX functions, and if so, construct a new TRP object.  <a href="#a11b351f367cda631b09d7f5f25517633">More...</a><br /></td></tr>
<tr class="separator:a11b351f367cda631b09d7f5f25517633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bb90d8507b92983f1347fbe0a1c5ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTRP__SKIP__SCAN.html">TRP_SKIP_SCAN</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a97bb90d8507b92983f1347fbe0a1c5ce">get_best_skip_scan</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> force_skip_scan)</td></tr>
<tr class="memdesc:a97bb90d8507b92983f1347fbe0a1c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if skip scan is applicable and if so, construct a new TRP object.  <a href="#a97bb90d8507b92983f1347fbe0a1c5ce">More...</a><br /></td></tr>
<tr class="separator:a97bb90d8507b92983f1347fbe0a1c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e37a03a5e54507e76618e1852ae80cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a6e37a03a5e54507e76618e1852ae80cb">print_sel_tree</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree, <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *tree_map, const char *<a class="el" href="test__sql__9__sessions_8cc.html#af6a786aadb2fc26d9c6d8dcb60c181f9">msg</a>)</td></tr>
<tr class="separator:a6e37a03a5e54507e76618e1852ae80cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c6cc52dd0e8774c3bac0fd6f410449"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a07c6cc52dd0e8774c3bac0fd6f410449">print_ror_scans_arr</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *<a class="el" href="test__sql__9__sessions_8cc.html#af6a786aadb2fc26d9c6d8dcb60c181f9">msg</a>, <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **<a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>, <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **end)</td></tr>
<tr class="separator:a07c6cc52dd0e8774c3bac0fd6f410449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20771d29be8493ceb9b1a945447f227e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a20771d29be8493ceb9b1a945447f227e">print_quick</a> (<a class="el" href="classQUICK__SELECT__I.html">QUICK_SELECT_I</a> *<a class="el" href="mysqldump_8cc.html#ae62182872dc71838cc7b3bd687ae8011">quick</a>, const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *needed_reg)</td></tr>
<tr class="separator:a20771d29be8493ceb9b1a945447f227e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5581e347723def9c345a37feea4cb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a2d5581e347723def9c345a37feea4cb5">append_range_all_keyparts</a> (<a class="el" href="classOpt__trace__array.html">Opt_trace_array</a> *range_trace, <a class="el" href="classString.html">String</a> *range_string, <a class="el" href="classString.html">String</a> *range_so_far, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *keypart, const <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_parts, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> print_full)</td></tr>
<tr class="memdesc:a2d5581e347723def9c345a37feea4cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse an R-B tree of range conditions and append all ranges for this keypart and consecutive keyparts to range_trace (if non-NULL) or to range_string (if range_trace is NULL).  <a href="#a2d5581e347723def9c345a37feea4cb5">More...</a><br /></td></tr>
<tr class="separator:a2d5581e347723def9c345a37feea4cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e08efb70763e7a550e705f68a8c9a5a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a1e08efb70763e7a550e705f68a8c9a5a">dbug_print_tree</a> (const char *tree_name, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree, const <a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param)</td></tr>
<tr class="memdesc:a1e08efb70763e7a550e705f68a8c9a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the ranges in a SEL_TREE to debug log.  <a href="#a1e08efb70763e7a550e705f68a8c9a5a">More...</a><br /></td></tr>
<tr class="separator:a1e08efb70763e7a550e705f68a8c9a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6a9896a05b5655d18cb659fd5a94ee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#abb6a9896a05b5655d18cb659fd5a94ee">print_tree</a> (<a class="el" href="classString.html">String</a> *out, const char *tree_name, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree, const <a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> print_full) MY_ATTRIBUTE((unused))</td></tr>
<tr class="separator:abb6a9896a05b5655d18cb659fd5a94ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893e7206b4761fe56129c8a15e5f9a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a893e7206b4761fe56129c8a15e5f9a1e">append_range</a> (<a class="el" href="classString.html">String</a> *out, const <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *min_key, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *max_key, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>)</td></tr>
<tr class="memdesc:a893e7206b4761fe56129c8a15e5f9a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append range info for a key part to a string.  <a href="#a893e7206b4761fe56129c8a15e5f9a1e">More...</a><br /></td></tr>
<tr class="separator:a893e7206b4761fe56129c8a15e5f9a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb1c2f0d47e65dfe761d1d4703f30de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aedb1c2f0d47e65dfe761d1d4703f30de">tree_and</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree1, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree2)</td></tr>
<tr class="separator:aedb1c2f0d47e65dfe761d1d4703f30de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba049d2bba21bc7a0694b23ca5ba1da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a2ba049d2bba21bc7a0694b23ca5ba1da">tree_or</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree1, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree2)</td></tr>
<tr class="separator:a2ba049d2bba21bc7a0694b23ca5ba1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca88a04f4ff1e7872ac2cb12e4e788f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aca88a04f4ff1e7872ac2cb12e4e788f6">null_sel_tree</a> (<a class="el" href="classSEL__TREE.html#ab2c33faad20fa0700f23ed800de66cc8a8067b6c2ad537845bd370b4f2f935d61">SEL_TREE::IMPOSSIBLE</a>, &amp;<a class="el" href="opt__range_8cc.html#a116e635d42e4e76445a547592558c13b">null_root</a>, 0)</td></tr>
<tr class="separator:aca88a04f4ff1e7872ac2cb12e4e788f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37fba8cff839033fc317d7465a6a42e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#af37fba8cff839033fc317d7465a6a42e">sel_add</a> (<a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#a39586bf0934bc10a56cedbf340aded85">key1</a>, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#af8cb0fe63d8fb11a50d3dc772d004576">key2</a>)</td></tr>
<tr class="memdesc:af37fba8cff839033fc317d7465a6a42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new key test to a key when scanning through all keys This will never be called for same key parts.  <a href="#af37fba8cff839033fc317d7465a6a42e">More...</a><br /></td></tr>
<tr class="separator:af37fba8cff839033fc317d7465a6a42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5824e4b3ec752fdbff045f1651bc23f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a5824e4b3ec752fdbff045f1651bc23f9">key_or</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#a39586bf0934bc10a56cedbf340aded85">key1</a>, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#af8cb0fe63d8fb11a50d3dc772d004576">key2</a>)</td></tr>
<tr class="memdesc:a5824e4b3ec752fdbff045f1651bc23f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two range expression under a common OR.  <a href="#a5824e4b3ec752fdbff045f1651bc23f9">More...</a><br /></td></tr>
<tr class="separator:a5824e4b3ec752fdbff045f1651bc23f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1090a671b0743937464df15e7af0f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a5b1090a671b0743937464df15e7af0f7">key_and</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#a39586bf0934bc10a56cedbf340aded85">key1</a>, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#af8cb0fe63d8fb11a50d3dc772d004576">key2</a>)</td></tr>
<tr class="separator:a5b1090a671b0743937464df15e7af0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363e9fef2c372407f9a90478d2a295c9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a363e9fef2c372407f9a90478d2a295c9">get_range</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> **e1, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> **e2, const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *root1)</td></tr>
<tr class="separator:a363e9fef2c372407f9a90478d2a295c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea015b4ee3ada5c982f7a7bbc8ba348a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aea015b4ee3ada5c982f7a7bbc8ba348a">get_quick_keys</a> (<a class="el" href="classPARAM.html">PARAM</a> *param, <a class="el" href="classQUICK__RANGE__SELECT.html">QUICK_RANGE_SELECT</a> *<a class="el" href="mysqldump_8cc.html#ae62182872dc71838cc7b3bd687ae8011">quick</a>, <a class="el" href="structKEY__PART.html">KEY_PART</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *key_tree, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *min_key, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> min_key_flag, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *max_key, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> max_key_flag, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *desc_flag, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> num_key_parts)</td></tr>
<tr class="memdesc:aea015b4ee3ada5c982f7a7bbc8ba348a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate key values for range select from given sel_arg tree.  <a href="#aea015b4ee3ada5c982f7a7bbc8ba348a">More...</a><br /></td></tr>
<tr class="separator:aea015b4ee3ada5c982f7a7bbc8ba348a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92be7be6edb8ebe31ab2903e7257c79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aa92be7be6edb8ebe31ab2903e7257c79">eq_tree</a> (const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *a, const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *b)</td></tr>
<tr class="memdesc:aa92be7be6edb8ebe31ab2903e7257c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if two trees are equal, recursively (not necessarily the same elements, but in terms of structure and values in each leaf).  <a href="#aa92be7be6edb8ebe31ab2903e7257c79">More...</a><br /></td></tr>
<tr class="separator:aa92be7be6edb8ebe31ab2903e7257c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f38837d8f139f9553b71c8d6d492cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a91f38837d8f139f9553b71c8d6d492cc">eq_tree</a> (const <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *a, const <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *b)</td></tr>
<tr class="separator:a91f38837d8f139f9553b71c8d6d492cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed8f2b0f9b3d632731afc604f37c03d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aeed8f2b0f9b3d632731afc604f37c03d">eq_ranges_exceeds_limit</a> (const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *keypart, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="myisam__ftdump_8cc.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> limit)</td></tr>
<tr class="memdesc:aeed8f2b0f9b3d632731afc604f37c03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the R-B range tree for this and later keyparts to see if there are at least as many equality ranges as defined by the limit.  <a href="#aeed8f2b0f9b3d632731afc604f37c03d">More...</a><br /></td></tr>
<tr class="separator:aeed8f2b0f9b3d632731afc604f37c03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c7b1ee258895ae45aac66b7b0694d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a83c7b1ee258895ae45aac66b7b0694d4">null_part_in_key</a> (<a class="el" href="structKEY__PART.html">KEY_PART</a> *key_part, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> length)</td></tr>
<tr class="separator:a83c7b1ee258895ae45aac66b7b0694d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0700b2184f75d76b03a8c7ead06b1c1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a0700b2184f75d76b03a8c7ead06b1c1f">sel_trees_can_be_ored</a> (<a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree1, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree2, <a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param)</td></tr>
<tr class="separator:a0700b2184f75d76b03a8c7ead06b1c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7a6e279a9ab1ac304d1d45395defae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aeb7a6e279a9ab1ac304d1d45395defae">range_optimizer_init</a> ()</td></tr>
<tr class="memdesc:aeb7a6e279a9ab1ac304d1d45395defae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global initialization of the null_element. Call on server start.  <a href="#aeb7a6e279a9ab1ac304d1d45395defae">More...</a><br /></td></tr>
<tr class="separator:aeb7a6e279a9ab1ac304d1d45395defae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad63b16fee3e1922af5fac2f2bd772cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aad63b16fee3e1922af5fac2f2bd772cc">range_optimizer_free</a> ()</td></tr>
<tr class="memdesc:aad63b16fee3e1922af5fac2f2bd772cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global destruction of the null_element. Call on server stop.  <a href="#aad63b16fee3e1922af5fac2f2bd772cc">More...</a><br /></td></tr>
<tr class="separator:aad63b16fee3e1922af5fac2f2bd772cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96986689be1db30f9bc4251538457c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a96986689be1db30f9bc4251538457c84">imerge_list_and_list</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *im1, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *im2)</td></tr>
<tr class="separator:a96986689be1db30f9bc4251538457c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac3937238252019867106caab8574f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#affac3937238252019867106caab8574f">imerge_list_or_list</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *im1, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *im2)</td></tr>
<tr class="separator:affac3937238252019867106caab8574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c93a3b5e9eb9e5cc7578cee0e693d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ac8c93a3b5e9eb9e5cc7578cee0e693d4">imerge_list_or_tree</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *im1, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree)</td></tr>
<tr class="separator:ac8c93a3b5e9eb9e5cc7578cee0e693d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010a983bb12da1780e10d707fafaa5b2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a010a983bb12da1780e10d707fafaa5b2">fill_used_fields_bitmap</a> (<a class="el" href="classPARAM.html">PARAM</a> *param)</td></tr>
<tr class="separator:a010a983bb12da1780e10d707fafaa5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec989f01a2d6048771d5a1b61e4d073a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aec989f01a2d6048771d5a1b61e4d073a">test_quick_select</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> keys_to_use, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> prev_tables, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> limit, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> force_quick_range, const <a class="el" href="key__spec_8h.html#ad747dc49681b256d83aa9a9e35375ded">enum_order</a> interesting_order, const <a class="el" href="classQEP__shared__owner.html">QEP_shared_owner</a> *tab, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *needed_reg, <a class="el" href="classQUICK__SELECT__I.html">QUICK_SELECT_I</a> **<a class="el" href="mysqldump_8cc.html#ae62182872dc71838cc7b3bd687ae8011">quick</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ignore_table_scan)</td></tr>
<tr class="separator:aec989f01a2d6048771d5a1b61e4d073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da6bd9f46445f5df7680d53eae02c2d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a2da6bd9f46445f5df7680d53eae02c2d">create_partition_index_description</a> (<a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *prune_par)</td></tr>
<tr class="separator:a2da6bd9f46445f5df7680d53eae02c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69fc213bb823da25e9b51d0e054d2c1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aa69fc213bb823da25e9b51d0e054d2c1">find_used_partitions</a> (<a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *ppar, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *key_tree)</td></tr>
<tr class="separator:aa69fc213bb823da25e9b51d0e054d2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280aa4c1bf551a67e531a0f61fd4252b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a280aa4c1bf551a67e531a0f61fd4252b">find_used_partitions</a> (<a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *ppar, <a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">SEL_ROOT::Type</a> type, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *key_tree)</td></tr>
<tr class="separator:a280aa4c1bf551a67e531a0f61fd4252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb1881381b1c7c7774824113a3ac7bb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a0eb1881381b1c7c7774824113a3ac7bb">find_used_partitions_imerge</a> (<a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *ppar, <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> *imerge)</td></tr>
<tr class="separator:a0eb1881381b1c7c7774824113a3ac7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699991dd9161a9c78b9fc53218df6117"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a699991dd9161a9c78b9fc53218df6117">find_used_partitions_imerge_list</a> (<a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *ppar, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; &amp;merges)</td></tr>
<tr class="separator:a699991dd9161a9c78b9fc53218df6117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2fd4c62c8dd42cb77eb8f491d927fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a7c2fd4c62c8dd42cb77eb8f491d927fe">mark_all_partitions_as_used</a> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr class="separator:a7c2fd4c62c8dd42cb77eb8f491d927fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3758ade4da5caec2cf836f2a9c1fc0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#acf3758ade4da5caec2cf836f2a9c1fc0">print_partitioning_index</a> (<a class="el" href="structKEY__PART.html">KEY_PART</a> *parts, <a class="el" href="structKEY__PART.html">KEY_PART</a> *parts_end)</td></tr>
<tr class="separator:acf3758ade4da5caec2cf836f2a9c1fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546821bae2ba36fe0dbaf13805c92283"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a546821bae2ba36fe0dbaf13805c92283">dbug_print_segment_range</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> *arg, <a class="el" href="structKEY__PART.html">KEY_PART</a> *part)</td></tr>
<tr class="separator:a546821bae2ba36fe0dbaf13805c92283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa435670d43a8cc3e765f38af61a7cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a4fa435670d43a8cc3e765f38af61a7cb">dbug_print_singlepoint_range</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> **<a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> num)</td></tr>
<tr class="separator:a4fa435670d43a8cc3e765f38af61a7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb637143f6e8ecfd3980c474ed0a19e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#acb637143f6e8ecfd3980c474ed0a19e9">prune_partitions</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classItem.html">Item</a> *pprune_cond)</td></tr>
<tr class="memdesc:acb637143f6e8ecfd3980c474ed0a19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform partition pruning for a given table and condition.  <a href="#acb637143f6e8ecfd3980c474ed0a19e9">More...</a><br /></td></tr>
<tr class="separator:acb637143f6e8ecfd3980c474ed0a19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532bf40caeeb95011cab7d39764af9dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a532bf40caeeb95011cab7d39764af9dd">store_key_image_to_rec</a> (<a class="el" href="classField.html">Field</a> *field, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ptr, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> len)</td></tr>
<tr class="separator:a532bf40caeeb95011cab7d39764af9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad516f1cd6d8ddf7575ec2ef90f7a37"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a3ad516f1cd6d8ddf7575ec2ef90f7a37">store_selargs_to_rec</a> (<a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *ppar, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> **<a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>, int num)</td></tr>
<tr class="separator:a3ad516f1cd6d8ddf7575ec2ef90f7a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab940e5edf5ad57bd223d2b54bb3bd6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aaab940e5edf5ad57bd223d2b54bb3bd6">mark_full_partition_used_no_parts</a> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> part_id)</td></tr>
<tr class="separator:aaab940e5edf5ad57bd223d2b54bb3bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d0d59fc26e3b27a6c278fc92783c40"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#af5d0d59fc26e3b27a6c278fc92783c40">mark_full_partition_used_with_parts</a> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> part_id)</td></tr>
<tr class="separator:af5d0d59fc26e3b27a6c278fc92783c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3725471638750b5017897fd71a32a575"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a3725471638750b5017897fd71a32a575">fields_ok_for_partition_index</a> (<a class="el" href="classField.html">Field</a> **pfield)</td></tr>
<tr class="separator:a3725471638750b5017897fd71a32a575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adb2f8d23dc7cffe127d85c789f32b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a8adb2f8d23dc7cffe127d85c789f32b4">make_ror_scan</a> (const <a class="el" href="classPARAM.html">PARAM</a> *param, int idx, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *sel_root)</td></tr>
<tr class="separator:a8adb2f8d23dc7cffe127d85c789f32b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2df6ecb32a7df75cf2c1f6eb27402ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ab2df6ecb32a7df75cf2c1f6eb27402ac">is_better_intersect_match</a> (const <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *scan1, const <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *scan2)</td></tr>
<tr class="memdesc:ab2df6ecb32a7df75cf2c1f6eb27402ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two ROR_SCAN_INFO* by.  <a href="#ab2df6ecb32a7df75cf2c1f6eb27402ac">More...</a><br /></td></tr>
<tr class="separator:ab2df6ecb32a7df75cf2c1f6eb27402ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8dbea68d528123dd3f10384ce0130a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a5a8dbea68d528123dd3f10384ce0130a">find_intersect_order</a> (<a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **<a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>, <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **end, const <a class="el" href="classPARAM.html">PARAM</a> *param)</td></tr>
<tr class="memdesc:a5a8dbea68d528123dd3f10384ce0130a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort indexes in an order that is likely to be a good index merge intersection order.  <a href="#a5a8dbea68d528123dd3f10384ce0130a">More...</a><br /></td></tr>
<tr class="separator:a5a8dbea68d528123dd3f10384ce0130a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1026dc9ddebaab0b7266b80356971f67"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a1026dc9ddebaab0b7266b80356971f67">ror_intersect_init</a> (const <a class="el" href="classPARAM.html">PARAM</a> *param)</td></tr>
<tr class="separator:a1026dc9ddebaab0b7266b80356971f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b38a3a876e53eaa2c7746adb0fa504"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a58b38a3a876e53eaa2c7746adb0fa504">ror_intersect_cpy</a> (<a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *dst, const <a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *src)</td></tr>
<tr class="separator:a58b38a3a876e53eaa2c7746adb0fa504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbfc5ac90fd28228bd029625ecdb1ee"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#acbbfc5ac90fd28228bd029625ecdb1ee">ror_scan_selectivity</a> (const <a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *<a class="el" href="mysql__ssl__rsa__setup_8cc.html#a5f4e2d00e13f7f971e3fbce0dee76947">info</a>, const <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *scan)</td></tr>
<tr class="separator:acbbfc5ac90fd28228bd029625ecdb1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d856a220b2d2c3d92f78576ced002b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a21d856a220b2d2c3d92f78576ced002b">ror_intersect_add</a> (<a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *<a class="el" href="mysql__ssl__rsa__setup_8cc.html#a5f4e2d00e13f7f971e3fbce0dee76947">info</a>, <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *ror_scan, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_cpk_scan, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *trace_costs, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ignore_cost)</td></tr>
<tr class="separator:a21d856a220b2d2c3d92f78576ced002b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177124b48026b67e3fe1b0e79345ba2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a7177124b48026b67e3fe1b0e79345ba2">warn_index_not_applicable</a> (const <a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_num, const <a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr class="memdesc:a7177124b48026b67e3fe1b0e79345ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If EXPLAIN or if the &ndash;safe-updates option is enabled, add a warning that the index cannot be used for range access due to either type conversion or different collations on the field used for comparison.  <a href="#a7177124b48026b67e3fe1b0e79345ba2">More...</a><br /></td></tr>
<tr class="separator:a7177124b48026b67e3fe1b0e79345ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb3a98c4f5d43d3f8f8dd1b4a34371"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a35cb3a98c4f5d43d3f8f8dd1b4a34371">get_ne_mm_tree</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem__func.html">Item_func</a> *cond_func, <a class="el" href="classField.html">Field</a> *field, <a class="el" href="classItem.html">Item</a> *lt_value, <a class="el" href="classItem.html">Item</a> *gt_value)</td></tr>
<tr class="separator:a35cb3a98c4f5d43d3f8f8dd1b4a34371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bed05e54a1d07dc170fb669e289e6e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a7bed05e54a1d07dc170fb669e289e6e3">get_func_mm_tree_from_in_predicate</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem.html">Item</a> *predicand, <a class="el" href="classItem__func__in.html">Item_func_in</a> *op, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_negated)</td></tr>
<tr class="memdesc:a7bed05e54a1d07dc170fb669e289e6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to build a SEL_TREE from an &lt;in predicate&gt;  <a href="#a7bed05e54a1d07dc170fb669e289e6e3">More...</a><br /></td></tr>
<tr class="separator:a7bed05e54a1d07dc170fb669e289e6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e01999bc0c176e9c59b7f2fc1deb421"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a2e01999bc0c176e9c59b7f2fc1deb421">get_func_mm_tree_from_json_overlaps_contains</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem.html">Item</a> *predicand, <a class="el" href="classItem__func.html">Item_func</a> *op)</td></tr>
<tr class="memdesc:a2e01999bc0c176e9c59b7f2fc1deb421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to build a SEL_TREE from a JSON_OVERLAPS or JSON_CONTAINS functions.  <a href="#a2e01999bc0c176e9c59b7f2fc1deb421">More...</a><br /></td></tr>
<tr class="separator:a2e01999bc0c176e9c59b7f2fc1deb421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cc24906f31d2740bb1d63641b145b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ae0cc24906f31d2740bb1d63641b145b4">get_func_mm_tree</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem.html">Item</a> *predicand, <a class="el" href="classItem__func.html">Item_func</a> *cond_func, <a class="el" href="classItem.html">Item</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> inv)</td></tr>
<tr class="memdesc:ae0cc24906f31d2740bb1d63641b145b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a SEL_TREE for a simple predicate.  <a href="#ae0cc24906f31d2740bb1d63641b145b4">More...</a><br /></td></tr>
<tr class="separator:ae0cc24906f31d2740bb1d63641b145b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43ebaaa0db7742de389c2a3c62ff242"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ab43ebaaa0db7742de389c2a3c62ff242">get_full_func_mm_tree</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classItem.html">Item</a> *predicand, <a class="el" href="classItem__func.html">Item_func</a> *op, <a class="el" href="classItem.html">Item</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> inv)</td></tr>
<tr class="separator:ab43ebaaa0db7742de389c2a3c62ff242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1955be20a1086f373696f62c9327e49f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a1955be20a1086f373696f62c9327e49f">is_spatial_operator</a> (<a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a> op_type)</td></tr>
<tr class="memdesc:a1955be20a1086f373696f62c9327e49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a comparison operator is a spatial comparison operator, i.e.  <a href="#a1955be20a1086f373696f62c9327e49f">More...</a><br /></td></tr>
<tr class="separator:a1955be20a1086f373696f62c9327e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9b192831fd24e2550f50ee812b587"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a75d9b192831fd24e2550f50ee812b587">comparable_in_index</a> (<a class="el" href="classItem.html">Item</a> *cond_func, const <a class="el" href="classField.html">Field</a> *field, const <a class="el" href="classField.html#a1ccb308943bbfdb37fe6924f886b177c">Field::imagetype</a> itype, <a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a> comp_type, const <a class="el" href="classItem.html">Item</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a75d9b192831fd24e2550f50ee812b587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if 'value' is comparable to 'field' when setting up range access for predicate "field OP value".  <a href="#a75d9b192831fd24e2550f50ee812b587">More...</a><br /></td></tr>
<tr class="separator:a75d9b192831fd24e2550f50ee812b587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db4fd8bb7e54c3fb5dc145fe2719d36"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a1db4fd8bb7e54c3fb5dc145fe2719d36">save_value_and_handle_conversion</a> (<a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> **tree, <a class="el" href="classItem.html">Item</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>, const <a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a> comp_op, <a class="el" href="classField.html">Field</a> *field, const char **impossible_cond_cause, <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *memroot)</td></tr>
<tr class="memdesc:a1db4fd8bb7e54c3fb5dc145fe2719d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves 'value' in 'field' and handles potential type conversion problems.  <a href="#a1db4fd8bb7e54c3fb5dc145fe2719d36">More...</a><br /></td></tr>
<tr class="separator:a1db4fd8bb7e54c3fb5dc145fe2719d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1a7bbde03e1dc98267e04bebda8d1f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#aac1a7bbde03e1dc98267e04bebda8d1f">debug_print_tree</a> (<a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *origin)</td></tr>
<tr class="memdesc:aac1a7bbde03e1dc98267e04bebda8d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function to print out a SEL_ROOT and everything it points to, recursively.  <a href="#aac1a7bbde03e1dc98267e04bebda8d1f">More...</a><br /></td></tr>
<tr class="separator:aac1a7bbde03e1dc98267e04bebda8d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b3f278f380f6fbfd13c08cc9f6cec0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a89b3f278f380f6fbfd13c08cc9f6cec0">remove_nonrange_trees</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *tree)</td></tr>
<tr class="separator:a89b3f278f380f6fbfd13c08cc9f6cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7929992d6af54c371f5624327b23dd11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a7929992d6af54c371f5624327b23dd11">and_all_keys</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#a39586bf0934bc10a56cedbf340aded85">key1</a>, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#af8cb0fe63d8fb11a50d3dc772d004576">key2</a>)</td></tr>
<tr class="memdesc:a7929992d6af54c371f5624327b23dd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">And key trees where key1-&gt;part &lt; key2-&gt;part.  <a href="#a7929992d6af54c371f5624327b23dd11">More...</a><br /></td></tr>
<tr class="separator:a7929992d6af54c371f5624327b23dd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62de66e843445493f777a1592230690d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a62de66e843445493f777a1592230690d">left_rotate</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> **root, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *leaf)</td></tr>
<tr class="separator:a62de66e843445493f777a1592230690d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11696d64d61757bbabf475f4f4c8fd6d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a11696d64d61757bbabf475f4f4c8fd6d">right_rotate</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> **root, <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *leaf)</td></tr>
<tr class="separator:a11696d64d61757bbabf475f4f4c8fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ea32d16c9be6a5d4695ccb2f2ae3d5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a06ea32d16c9be6a5d4695ccb2f2ae3d5">count_key_part_usage</a> (const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *root, const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="suite__stubs_8h.html#ad287d8e71b971be7d1c8998b3284340c">std::set</a>&lt; const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&gt; *seen)</td></tr>
<tr class="memdesc:a06ea32d16c9be6a5d4695ccb2f2ae3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count how many times SEL_ARG graph "root" refers to its part "key" via transitive closure.  <a href="#a06ea32d16c9be6a5d4695ccb2f2ae3d5">More...</a><br /></td></tr>
<tr class="separator:a06ea32d16c9be6a5d4695ccb2f2ae3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0299894fff346d1c2d57e611ccd36ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ac0299894fff346d1c2d57e611ccd36ac">sel_arg_range_seq_init</a> (void *init_param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>)</td></tr>
<tr class="separator:ac0299894fff346d1c2d57e611ccd36ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8977d6e31a7ed4a62377ed8155e7a1b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ac8977d6e31a7ed4a62377ed8155e7a1b">sel_arg_range_seq_next</a> (<a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> rseq, <a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *<a class="el" href="structrange.html">range</a>)</td></tr>
<tr class="separator:ac8977d6e31a7ed4a62377ed8155e7a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6951da91ab95fcb95a2f88f7a3750163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a6951da91ab95fcb95a2f88f7a3750163">quick_range_seq_init</a> (void *init_param, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>)</td></tr>
<tr class="separator:a6951da91ab95fcb95a2f88f7a3750163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e69f3a3005d77d7e779e5326e56ec26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a0e69f3a3005d77d7e779e5326e56ec26">quick_range_seq_next</a> (<a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> rseq, <a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *<a class="el" href="structrange.html">range</a>)</td></tr>
<tr class="separator:a0e69f3a3005d77d7e779e5326e56ec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808a4405bccb243b1b7feb2d87d2be94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a808a4405bccb243b1b7feb2d87d2be94">get_field_keypart</a> (<a class="el" href="classKEY.html">KEY</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr class="separator:a808a4405bccb243b1b7feb2d87d2be94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947f90164eb1325ad49bdaef45ca2e41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a947f90164eb1325ad49bdaef45ca2e41">get_index_range_tree</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *range_tree, <a class="el" href="classPARAM.html">PARAM</a> *param)</td></tr>
<tr class="separator:a947f90164eb1325ad49bdaef45ca2e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482997c73c12ea0d3bf7ccf4fd82f31d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a482997c73c12ea0d3bf7ccf4fd82f31d">get_sel_root_for_keypart</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_part_num, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *index_range_tree, <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> **cur_range)</td></tr>
<tr class="separator:a482997c73c12ea0d3bf7ccf4fd82f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bf46f319cec04d6286cbff6ea04b6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ab7bf46f319cec04d6286cbff6ea04b6e">check_key_infix</a> (<a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *index_range_tree, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *first_non_group_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *min_max_arg_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *last_part, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *key_infix_len, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> **first_non_infix_part, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *infix_factor, <a class="el" href="classKEY.html">KEY</a> *index_info)</td></tr>
<tr class="separator:ab7bf46f319cec04d6286cbff6ea04b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bbd1e321ad04b016e5d7899d0994b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a30bbd1e321ad04b016e5d7899d0994b6">check_group_min_max_predicates</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem__field.html">Item_field</a> *min_max_arg_item, <a class="el" href="classField.html#a1ccb308943bbfdb37fe6924f886b177c">Field::imagetype</a> image_type)</td></tr>
<tr class="separator:a30bbd1e321ad04b016e5d7899d0994b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182cb951715af58e530f3ad35c998073"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a182cb951715af58e530f3ad35c998073">min_max_inspect_cond_for_fields</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem__field.html">Item_field</a> *min_max_arg_item, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *min_max_arg_present, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *non_min_max_arg_present)</td></tr>
<tr class="memdesc:a182cb951715af58e530f3ad35c998073"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function detects the presents of MIN/MAX field along with at least one non MIN/MAX field participation in the given condition.  <a href="#a182cb951715af58e530f3ad35c998073">More...</a><br /></td></tr>
<tr class="separator:a182cb951715af58e530f3ad35c998073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635a31f7377b79911f9ecb6fdcdfead9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a635a31f7377b79911f9ecb6fdcdfead9">cost_group_min_max</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> used_key_parts, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> group_key_parts, <a class="el" href="classSEL__TREE.html">SEL_TREE</a> *range_tree, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> quick_prefix_records, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> have_min, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> have_max, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> infix_factor, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost_est, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *records)</td></tr>
<tr class="separator:a635a31f7377b79911f9ecb6fdcdfead9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79074a6b3633acac4d49713b9507c440"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a79074a6b3633acac4d49713b9507c440">util_min_max_inspect_item</a> (<a class="el" href="classItem.html">Item</a> *item_field, <a class="el" href="classItem__field.html">Item_field</a> *min_max_arg_item, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *min_max_arg_present, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *non_min_max_arg_present)</td></tr>
<tr class="memdesc:a79074a6b3633acac4d49713b9507c440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used by min_max_inspect_cond_for_fields() for comparing FILED item with given MIN/MAX item and setting appropriate out paramater.  <a href="#a79074a6b3633acac4d49713b9507c440">More...</a><br /></td></tr>
<tr class="separator:a79074a6b3633acac4d49713b9507c440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9dd7639ed35c43aa529ae90af97c37"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a4b9dd7639ed35c43aa529ae90af97c37">index_next_different</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_index_scan, <a class="el" href="classhandler.html">handler</a> *file, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *group_prefix, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> group_prefix_len, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> group_key_parts)</td></tr>
<tr class="memdesc:a4b9dd7639ed35c43aa529ae90af97c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next different key value by skiping all the rows with the same key value.  <a href="#a4b9dd7639ed35c43aa529ae90af97c37">More...</a><br /></td></tr>
<tr class="separator:a4b9dd7639ed35c43aa529ae90af97c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6fab11ee823dd54e74fc273bc377d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a9a6fab11ee823dd54e74fc273bc377d9">get_search_mode</a> (<a class="el" href="classQUICK__RANGE.html">QUICK_RANGE</a> *cur_range, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_asc, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_min)</td></tr>
<tr class="memdesc:a9a6fab11ee823dd54e74fc273bc377d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns search mode that needs to be used to read the next record.  <a href="#a9a6fab11ee823dd54e74fc273bc377d9">More...</a><br /></td></tr>
<tr class="separator:a9a6fab11ee823dd54e74fc273bc377d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87986de660c724bd87e8cfe2d175105"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#ab87986de660c724bd87e8cfe2d175105">cost_skip_scan</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> distinct_key_parts, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> quick_prefix_records, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost_est, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *records, <a class="el" href="classItem.html">Item</a> *where_cond, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *trace_idx)</td></tr>
<tr class="memdesc:ab87986de660c724bd87e8cfe2d175105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cost of a QUICK_SKIP_SCAN_SELECT for a particular index.  <a href="#ab87986de660c724bd87e8cfe2d175105">More...</a><br /></td></tr>
<tr class="separator:ab87986de660c724bd87e8cfe2d175105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846a12904abc8fe6ad893c27f60aaf84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a846a12904abc8fe6ad893c27f60aaf84">print_key_value</a> (<a class="el" href="classString.html">String</a> *out, const <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:a846a12904abc8fe6ad893c27f60aaf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a key to a string.  <a href="#a846a12904abc8fe6ad893c27f60aaf84">More...</a><br /></td></tr>
<tr class="separator:a846a12904abc8fe6ad893c27f60aaf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4190059a204a4657aeb6a5eeed6d31"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#abd4190059a204a4657aeb6a5eeed6d31">print_multiple_key_values</a> (<a class="el" href="structKEY__PART.html">KEY_PART</a> *key_part, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> used_length)</td></tr>
<tr class="separator:abd4190059a204a4657aeb6a5eeed6d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0364f2f9281e7223d4c0a0bd3c6c61f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a0364f2f9281e7223d4c0a0bd3c6c61f1">is_null_string</a> [2] = {1, 0}</td></tr>
<tr class="separator:a0364f2f9281e7223d4c0a0bd3c6c61f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116e635d42e4e76445a547592558c13b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a116e635d42e4e76445a547592558c13b">null_root</a></td></tr>
<tr class="separator:a116e635d42e4e76445a547592558c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2623dc51e33a5c2ecd4ffbe75c8393"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__range_8cc.html#a6a2623dc51e33a5c2ecd4ffbe75c8393">null_element</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="memdesc:a6a2623dc51e33a5c2ecd4ffbe75c8393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared sentinel node for all trees.  <a href="#a6a2623dc51e33a5c2ecd4ffbe75c8393">More...</a><br /></td></tr>
<tr class="separator:a6a2623dc51e33a5c2ecd4ffbe75c8393"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a48a58d73bd51e6ab6e0006f4f8c17b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a58d73bd51e6ab6e0006f4f8c17b21">&#9670;&nbsp;</a></span>OPT_RANGE_CC_INCLUDED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPT_RANGE_CC_INCLUDED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a31273d0cbf966c8485f717409a8a5d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31273d0cbf966c8485f717409a8a5d80">&#9670;&nbsp;</a></span>mark_full_part_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mark_full_part_func) (<a class="el" href="classpartition__info.html">partition_info</a> *, <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3042889cd636db269b9a985349692808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3042889cd636db269b9a985349692808">&#9670;&nbsp;</a></span>all_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> all_same </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>sa1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>sa2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to compare two SEL_ROOTs. </p>

</div>
</div>
<a id="a7929992d6af54c371f5624327b23dd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7929992d6af54c371f5624327b23dd11">&#9670;&nbsp;</a></span>and_all_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a>* and_all_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And key trees where key1-&gt;part &lt; key2-&gt;part. </p>
<p>key2 will be connected to every key in key1, and thus have its use_count incremented many times. The returned node will not have its use_count increased; you are supposed to do that yourself when you connect it to a root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Range analysis context (needed to track if we have allocated too many SEL_ARGs) </td></tr>
    <tr><td class="paramname">key1</td><td>Root of first tree to AND together </td></tr>
    <tr><td class="paramname">key2</td><td>Root of second tree to AND together </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Root of (key1 AND key2) </dd></dl>

</div>
</div>
<a id="a893e7206b4761fe56129c8a15e5f9a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893e7206b4761fe56129c8a15e5f9a1e">&#9670;&nbsp;</a></span>append_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>min_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>max_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append range info for a key part to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>String the range info is appended to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_part</td><td>Indexed column used in a range select </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_key</td><td>Key tuple describing lower bound of range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_key</td><td>Key tuple describing upper bound of range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Key range flags defining what min_key and max_key represent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>my_base.h </dd></dl>

</div>
</div>
<a id="a2d5581e347723def9c345a37feea4cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5581e347723def9c345a37feea4cb5">&#9670;&nbsp;</a></span>append_range_all_keyparts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void append_range_all_keyparts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpt__trace__array.html">Opt_trace_array</a> *&#160;</td>
          <td class="paramname"><em>range_trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>range_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>range_so_far</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>keypart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>print_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse an R-B tree of range conditions and append all ranges for this keypart and consecutive keyparts to range_trace (if non-NULL) or to range_string (if range_trace is NULL). </p>
<p>See description of R-B trees/SEL_ARG for details on how ranges are linked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_trace</td><td>Optimizer trace array ranges are appended to </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_string</td><td>The string where range predicates are appended when the last keypart has been reached. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_so_far</td><td>String containing ranges for keyparts prior to this keypart. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keypart</td><td>The R-B tree containing intervals for this keypart. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_parts</td><td>Index components description, used when adding information to the optimizer trace </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">print_full</td><td>Whether or not ranges on unusable keyparts should be printed. Useful for debugging.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function mimics the behavior of sel_arg_range_seq_next() </dd></dl>

</div>
</div>
<a id="a30bbd1e321ad04b016e5d7899d0994b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bbd1e321ad04b016e5d7899d0994b6">&#9670;&nbsp;</a></span>check_group_min_max_predicates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_group_min_max_predicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>min_max_arg_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html#a1ccb308943bbfdb37fe6924f886b177c">Field::imagetype</a>&#160;</td>
          <td class="paramname"><em>image_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7bf46f319cec04d6286cbff6ea04b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bf46f319cec04d6286cbff6ea04b6e">&#9670;&nbsp;</a></span>check_key_infix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_key_infix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>index_range_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>first_non_group_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>min_max_arg_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>last_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>key_infix_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> **&#160;</td>
          <td class="paramname"><em>first_non_infix_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>infix_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>index_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb98e1671535d148565357347c3783e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb98e1671535d148565357347c3783e4">&#9670;&nbsp;</a></span>check_quick_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> check_quick_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>index_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>update_tbl_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>mrr_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75d9b192831fd24e2550f50ee812b587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d9b192831fd24e2550f50ee812b587">&#9670;&nbsp;</a></span>comparable_in_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> comparable_in_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html#a1ccb308943bbfdb37fe6924f886b177c">Field::imagetype</a>&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a>&#160;</td>
          <td class="paramname"><em>comp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if 'value' is comparable to 'field' when setting up range access for predicate "field OP value". </p>
<p>'field' is a field in the table being optimized for while 'value' is whatever 'field' is compared to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond_func</td><td>the predicate item that compares 'field' with 'value' </td></tr>
    <tr><td class="paramname">field</td><td>field in the predicate </td></tr>
    <tr><td class="paramname">itype</td><td>itMBR if indexed field is spatial, itRAW otherwise </td></tr>
    <tr><td class="paramname">comp_type</td><td>comparator for the predicate </td></tr>
    <tr><td class="paramname">value</td><td>whatever 'field' is compared to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 'field' and 'value' are comparable, false otherwise </dd></dl>

</div>
</div>
<a id="a635a31f7377b79911f9ecb6fdcdfead9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635a31f7377b79911f9ecb6fdcdfead9">&#9670;&nbsp;</a></span>cost_group_min_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cost_group_min_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>used_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>group_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>range_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>quick_prefix_records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>have_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>have_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>infix_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost_est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab87986de660c724bd87e8cfe2d175105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87986de660c724bd87e8cfe2d175105">&#9670;&nbsp;</a></span>cost_skip_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cost_skip_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>distinct_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>quick_prefix_records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost_est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>where_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the cost of a QUICK_SKIP_SCAN_SELECT for a particular index. </p>
<p>SYNOPSIS cost_skip_scan() table [in] The table being accessed key [in] The index used to access the table distinct_key_parts [in] Number of key_parts used to get distinct prefix quick_prefix_records [in] Number of records processed by prefix ranges cost_est [out] The cost to retrieve rows via this quick select records [out] The number of rows retrieved where_cond [in] WHERE condition trace_idx [in] optimizer_trace object</p>
<p>DESCRIPTION This method computes the access cost of a TRP_SKIP_SCAN instance and the number of rows returned.</p>
<p>NOTES</p>
<p>To estimate the size of the groups to read, index statistics from rec_per_key is used. Each equality range decreases number of the groups to read. The total number of processed records from all the groups will be quick_prefix_records if there are equality ranges else it will be the entire table. Number of distinct group is calculated by dividing the number of processed record by the number keys in a group.</p>
<p>Number of processed records is calculated using following formula:</p>
<p>records = number_of_distinct_groups * records_per_group * filtering_effect</p>
<p>where filtering_effect is filtering effect of the range condition.</p>
<p>RETURN None </p>

</div>
</div>
<a id="a06ea32d16c9be6a5d4695ccb2f2ae3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ea32d16c9be6a5d4695ccb2f2ae3d5">&#9670;&nbsp;</a></span>count_key_part_usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> count_key_part_usage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="suite__stubs_8h.html#ad287d8e71b971be7d1c8998b3284340c">std::set</a>&lt; const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&gt; *&#160;</td>
          <td class="paramname"><em>seen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count how many times SEL_ARG graph "root" refers to its part "key" via transitive closure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>An RB-Root node in a SEL_ARG graph. </td></tr>
    <tr><td class="paramname">key</td><td>Another RB-Root node in that SEL_ARG graph. </td></tr>
    <tr><td class="paramname">seen</td><td>Which SEL_ARGs we have already seen in this traversal. Used for deduplication, so that we only count each SEL_ARG once.</td></tr>
  </table>
  </dd>
</dl>
<p>The passed "root" node may refer to "key" node via root-&gt;next_key_part, root-&gt;next-&gt;n</p>
<p>This function counts how many times the node "key" is referred (via SEL_ARG::next_key_part) by</p><ul>
<li>intervals of RB-tree pointed by "root",</li>
<li>intervals of RB-trees that are pointed by SEL_ARG::next_key_part from intervals of RB-tree pointed by "root",</li>
<li>and so on.</li>
</ul>
<p>Here is an example (horizontal links represent next_key_part pointers, vertical links - next/prev prev pointers): </p><pre class="fragment">   +----+               $
   |root|-----------------+
   +----+               $ |
     |                  $ |
     |                  $ |
   +----+       +---+   $ |     +---+    Here the return value
   |    |- ... -|   |---$-+--+-&gt;|key|    will be 4.
   +----+       +---+   $ |  |  +---+
     |                  $ |  |
    ...                 $ |  |
     |                  $ |  |
   +----+   +---+       $ |  |
   |    |---|   |---------+  |
   +----+   +---+       $    |
     |        |         $    |
    ...     +---+       $    |
            |   |------------+
            +---+       $
</pre> <dl class="section return"><dt>Returns</dt><dd>Number of links to "key" from nodes reachable from "root". </dd></dl>

</div>
</div>
<a id="a2da6bd9f46445f5df7680d53eae02c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da6bd9f46445f5df7680d53eae02c2d">&#9670;&nbsp;</a></span>create_partition_index_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> create_partition_index_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *&#160;</td>
          <td class="paramname"><em>prune_par</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a546821bae2ba36fe0dbaf13805c92283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546821bae2ba36fe0dbaf13805c92283">&#9670;&nbsp;</a></span>dbug_print_segment_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dbug_print_segment_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fa435670d43a8cc3e765f38af61a7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa435670d43a8cc3e765f38af61a7cb">&#9670;&nbsp;</a></span>dbug_print_singlepoint_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dbug_print_singlepoint_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e08efb70763e7a550e705f68a8c9a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e08efb70763e7a550e705f68a8c9a5a">&#9670;&nbsp;</a></span>dbug_print_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dbug_print_tree </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tree_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the ranges in a SEL_TREE to debug log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree_name</td><td>Descriptive name of the tree </td></tr>
    <tr><td class="paramname">tree</td><td>The SEL_TREE that will be printed to debug log </td></tr>
    <tr><td class="paramname">param</td><td>PARAM from test_quick_select </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac1a7bbde03e1dc98267e04bebda8d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1a7bbde03e1dc98267e04bebda8d1f">&#9670;&nbsp;</a></span>debug_print_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void debug_print_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debugging function to print out a SEL_ROOT and everything it points to, recursively. </p>
<p>Used only when tracking bugs in the range optimizer (for printf debugging); will not normally have any calls to it. </p>

</div>
</div>
<a id="aeed8f2b0f9b3d632731afc604f37c03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed8f2b0f9b3d632731afc604f37c03d">&#9670;&nbsp;</a></span>eq_ranges_exceeds_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> eq_ranges_exceeds_limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>keypart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the R-B range tree for this and later keyparts to see if there are at least as many equality ranges as defined by the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">keypart</td><td>The R-B tree of ranges for a given keypart. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">count</td><td>The number of equality ranges found so far </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">limit</td><td>The number of ranges</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if limit &gt; 0 and 'limit' or more equality ranges have been found in the range R-B trees </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa92be7be6edb8ebe31ab2903e7257c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92be7be6edb8ebe31ab2903e7257c79">&#9670;&nbsp;</a></span>eq_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> eq_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if two trees are equal, recursively (not necessarily the same elements, but in terms of structure and values in each leaf). </p>
<p>NOTE: The demand for the same structure means that some trees that are equivalent could be deemed inequal by this function, depending on insertion order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First tree to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second tree to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff they are equivalent. </dd></dl>

</div>
</div>
<a id="a91f38837d8f139f9553b71c8d6d492cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f38837d8f139f9553b71c8d6d492cc">&#9670;&nbsp;</a></span>eq_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> eq_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3725471638750b5017897fd71a32a575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3725471638750b5017897fd71a32a575">&#9670;&nbsp;</a></span>fields_ok_for_partition_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> fields_ok_for_partition_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>pfield</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a010a983bb12da1780e10d707fafaa5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010a983bb12da1780e10d707fafaa5b2">&#9670;&nbsp;</a></span>fill_used_fields_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int fill_used_fields_bitmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a8dbea68d528123dd3f10384ce0130a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8dbea68d528123dd3f10384ce0130a">&#9670;&nbsp;</a></span>find_intersect_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void find_intersect_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort indexes in an order that is likely to be a good index merge intersection order. </p>
<p>After running this function, [start, ..., end-1] is ordered according to this strategy:</p>
<p>1) Minimize the number of indexes that must be used in the intersection. I.e., the index covering most fields not already covered by other indexes earlier in the sort order is picked first. 2) When multiple indexes cover equally many uncovered fields, the index with lowest E(Number of rows) is chosen.</p>
<p>Note that all permutations of index ordering are not tested, so this function may not find the optimal order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start</td><td>Pointer to the start of indexes that may be used in index merge intersection </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>Pointer past the last index that may be used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">param</td><td>Parameter from test_quick_select function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa69fc213bb823da25e9b51d0e054d2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69fc213bb823da25e9b51d0e054d2c1">&#9670;&nbsp;</a></span>find_used_partitions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int find_used_partitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *&#160;</td>
          <td class="paramname"><em>ppar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key_tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a280aa4c1bf551a67e531a0f61fd4252b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280aa4c1bf551a67e531a0f61fd4252b">&#9670;&nbsp;</a></span>find_used_partitions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int find_used_partitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *&#160;</td>
          <td class="paramname"><em>ppar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">SEL_ROOT::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>key_tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eb1881381b1c7c7774824113a3ac7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb1881381b1c7c7774824113a3ac7bb">&#9670;&nbsp;</a></span>find_used_partitions_imerge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int find_used_partitions_imerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *&#160;</td>
          <td class="paramname"><em>ppar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> *&#160;</td>
          <td class="paramname"><em>imerge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a699991dd9161a9c78b9fc53218df6117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699991dd9161a9c78b9fc53218df6117">&#9670;&nbsp;</a></span>find_used_partitions_imerge_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int find_used_partitions_imerge_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *&#160;</td>
          <td class="paramname"><em>ppar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>merges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d8d0b6f805cb5ea9095f6c3c61cb9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8d0b6f805cb5ea9095f6c3c61cb9c5">&#9670;&nbsp;</a></span>get_best_disjunct_quick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTABLE__READ__PLAN.html">TABLE_READ_PLAN</a> * get_best_disjunct_quick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> *&#160;</td>
          <td class="paramname"><em>imerge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost_est</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11b351f367cda631b09d7f5f25517633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b351f367cda631b09d7f5f25517633">&#9670;&nbsp;</a></span>get_best_group_min_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTRP__GROUP__MIN__MAX.html">TRP_GROUP_MIN_MAX</a> * get_best_group_min_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost_est</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if this access method is applicable to a GROUP query with MIN/MAX functions, and if so, construct a new TRP object. </p>
<p>DESCRIPTION Test whether a query can be computed via a QUICK_GROUP_MIN_MAX_SELECT. Queries computable via a QUICK_GROUP_MIN_MAX_SELECT must satisfy the following conditions: A) Table T has at least one compound index I of the form: I = &lt;A_1, ...,A_k, [B_1,..., B_m], C, [D_1,...,D_n]&gt; B) Query conditions: B0. Q is over a single table T. B1. The attributes referenced by Q are a subset of the attributes of I. B2. All attributes QA in Q can be divided into 3 overlapping groups:</p><ul>
<li>SA = {S_1, ..., S_l, [C]} - from the SELECT clause, where C is referenced by any number of MIN and/or MAX functions if present.</li>
<li>WA = {W_1, ..., W_p} - from the WHERE clause</li>
<li>GA = &lt;G_1, ..., G_k&gt; - from the GROUP BY clause (if any) = SA - if Q is a DISTINCT query (based on the equivalence of DISTINCT and GROUP queries.</li>
<li>NGA = QA - (GA union C) = {NG_1, ..., NG_m} - the ones not in GROUP BY and not referenced by MIN/MAX functions. with the following properties specified below. B3. If Q has a GROUP BY WITH ROLLUP clause the access method is not applicable.</li>
</ul>
<p>SA1. There is at most one attribute in SA referenced by any number of MIN and/or MAX functions which, which if present, is denoted as C. SA2. The position of the C attribute in the index is after the last A_k. SA3. The attribute C can be referenced in the WHERE clause only in predicates of the forms:</p><ul>
<li>(C {&lt; | &lt;= | &gt; | &gt;= | =} const)</li>
<li>(const {&lt; | &lt;= | &gt; | &gt;= | =} C)</li>
<li>(C between const_i and const_j)</li>
<li>C IS NULL</li>
<li>C IS NOT NULL</li>
<li>C != const SA4. If Q has a GROUP BY clause, there are no other aggregate functions except MIN and MAX. For queries with DISTINCT, aggregate functions are allowed. SA5. The select list in DISTINCT queries should not contain expressions. SA6. Clustered index can not be used by GROUP_MIN_MAX quick select for AGG_FUNC(DISTINCT ...) optimization because cursor position is never stored after a unique key lookup in the clustered index and furhter index_next/prev calls can not be used. So loose index scan optimization can not be used in this case. SA7. If Q has both AGG_FUNC(DISTINCT ...) and MIN/MAX() functions then this access method is not used. For above queries MIN/MAX() aggregation has to be done at nested_loops_join (end_send_group). But with current design MIN/MAX() is always set as part of loose index scan. Because of this mismatch MIN() and MAX() values will be set incorrectly. For such queries to work we need a new interface for loose index scan. This new interface should only fetch records with min and max values and let end_send_group to do aggregation. Until then do not use loose_index_scan. GA1. If Q has a GROUP BY clause, then GA is a prefix of I. That is, if G_i = A_j =&gt; i = j. GA2. If Q has a DISTINCT clause, then there is a permutation of SA that forms a prefix of I. This permutation is used as the GROUP clause when the DISTINCT query is converted to a GROUP query. GA3. The attributes in GA may participate in arbitrary predicates, divided into two groups:</li>
<li>RNG(G_1,...,G_q ; where q &lt;= k) is a range condition over the attributes of a prefix of GA</li>
<li>PA(G_i1,...G_iq) is an arbitrary predicate over an arbitrary subset of GA. Since P is applied to only GROUP attributes it filters some groups, and thus can be applied after the grouping. GA4. There are no expressions among G_i, just direct column references. NGA1.If in the index I there is a gap between the last GROUP attribute G_k, and the MIN/MAX attribute C, then NGA must consist of exactly the index attributes that constitute the gap. As a result there is a permutation of NGA, BA=&lt;B_1,...,B_m&gt;, that coincides with the gap in the index. NGA2.If BA &lt;&gt; {}, then the WHERE clause must contain a conjunction EQ of equality conditions for all NG_i of the form (NG_i = const) or (const = NG_i), such that each NG_i is referenced in exactly one conjunct. Informally, the predicates provide constants to fill the gap in the index. WA1. There are no other attributes in the WHERE clause except the ones referenced in predicates RNG, PA, PC, EQ defined above. Therefore WA is subset of (GA union NGA union C) for GA,NGA,C that pass the above tests. By transitivity then it also follows that each WA_i participates in the index I (if this was already tested for GA, NGA and C). WA2. If there is a predicate on C, then it must be in conjunction to all predicates on all earlier keyparts in I.</li>
</ul>
<p>C) Overall query form: SELECT EXPR([A_1,...,A_k], [B_1,...,B_m], [MIN(C)], [MAX(C)]) FROM T WHERE [RNG(A_1,...,A_p ; where p &lt;= k)] [AND EQ(B_1,...,B_m)] [AND PC(C)] [AND PA(A_i1,...,A_iq)] GROUP BY A_1,...,A_k [HAVING PH(A_1, ..., B_1,..., C)] where EXPR(...) is an arbitrary expression over some or all SELECT fields, or: SELECT DISTINCT A_i1,...,A_ik FROM T WHERE [RNG(A_1,...,A_p ; where p &lt;= k)] [AND PA(A_i1,...,A_iq)];</p>
<p>NOTES If the current query satisfies the conditions above, and if (mem_root! = NULL), then the function constructs and returns a new TRP object, that is later used to construct a new QUICK_GROUP_MIN_MAX_SELECT. If (mem_root == NULL), then the function only tests whether the current query satisfies the conditions above, and, if so, sets is_applicable = true.</p>
<p>Queries with DISTINCT for which index access can be used are transformed into equivalent group-by queries of the form:</p>
<p>SELECT A_1,...,A_k FROM T WHERE [RNG(A_1,...,A_p ; where p &lt;= k)] [AND PA(A_i1,...,A_iq)] GROUP BY A_1,...,A_k;</p>
<p>The group-by list is a permutation of the select attributes, according to their order in the index.</p>
<p>TODO</p><ul>
<li>What happens if the query groups by the MIN/MAX field, and there is no other field as in: "select min(a) from t1 group by a" ?</li>
<li>We assume that the general correctness of the GROUP-BY query was checked before this point. Is this correct, or do we have to check it completely?</li>
<li>Lift the limitation in condition (B3), that is, make this access method applicable to ROLLUP queries.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameter from test_quick_select </td></tr>
    <tr><td class="paramname">tree</td><td>Range tree generated by get_mm_tree </td></tr>
    <tr><td class="paramname">cost_est</td><td>Best cost so far (=table/index scan time) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table read plan </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>Loose index scan not applicable or mem_root == NULL </td></tr>
    <tr><td class="paramname">!NULL</td><td>Loose index scan table read plan </td></tr>
  </table>
  </dd>
</dl>
<p>Test (Part of WA2): Skip loose index scan on disjunctive WHERE clause which results in null tree or merge tree.</p>
<p>The tree structure contains multiple disjoint trees. This happens when the WHERE clause can't be represented in a single range tree due to the disjunctive nature of it but there exists indexes to perform index merge scan.</p>
<p>Skip loose index scan if min_max attribute is present along with at least one other attribute in the WHERE cluse when the tree is null. There is no range tree if WHERE condition can't be represented in a single range tree and index merge is not possible.</p>
<p>Test Part of WA2:If there are conditions on a column C participating in MIN/MAX, those conditions must be conjunctions to all earlier keyparts. Otherwise, Loose Index Scan cannot be used.</p>

</div>
</div>
<a id="a50d7cfb69a4d25d3fd93c5b6ffdc1d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d7cfb69a4d25d3fd93c5b6ffdc1d71">&#9670;&nbsp;</a></span>get_best_ror_intersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTRP__ROR__INTERSECT.html">TRP_ROR_INTERSECT</a> * get_best_ror_intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost_est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>force_index_merge_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97bb90d8507b92983f1347fbe0a1c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bb90d8507b92983f1347fbe0a1c5ce">&#9670;&nbsp;</a></span>get_best_skip_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTRP__SKIP__SCAN.html">TRP_SKIP_SCAN</a> * get_best_skip_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>force_skip_scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if skip scan is applicable and if so, construct a new TRP object. </p>
<p>DESCRIPTION Test whether a query can be computed via a QUICK_SKIP_SCAN_SELECT. The overall query form should look like this:</p>
<p>SELECT A_1,...,A_k, B_1,...,B_m, C FROM T WHERE EQ(A_1,...,A_k) AND RNG(C);</p>
<p>Queries computable via a QUICK_SKIP_SCAN_SELECT must satisfy the following conditions:</p>
<p>A) Table T has at least one compound index I of the form: I = &lt;A_1,...,A_k, B_1,..., B_m, C ,[D_1,...,D_n]&gt; Keyparts A and D may be empty, but B and C must be non-empty. B) Only one table referenced. C) Cannot have group by/select distinct D) Query must reference fields in the index only. E) The predicates on A_1...A_k must be equality predicates and they need to be constants. This includes the 'IN' operator. F) The query must be a conjunctive query. In other words, it is a AND of ORs: (COND1(kp1) OR COND2(kp1)) AND (COND1(kp2) OR ...) AND ... See get_sel_arg_for_keypart for details. G) There must be a range condition on C. H) Conditions on D columns are allowed. Conditions on D must be in conjunction with range condition on C.</p>
<p>NOTES If the current query satisfies the conditions above, and if (mem_root! = NULL), then the function constructs and returns a new TRP object, that is later used to construct a new QUICK_SKIP_SCAN_SELECT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameter from test_quick_select </td></tr>
    <tr><td class="paramname">tree</td><td>Range tree generated by get_mm_tree </td></tr>
    <tr><td class="paramname">force_skip_scan</td><td>TRUE if skip scan is forced by optimizer hint</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL,if</td><td>skip index scan not applicable, otherwise skip index scan table read plan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a808a4405bccb243b1b7feb2d87d2be94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808a4405bccb243b1b7feb2d87d2be94">&#9670;&nbsp;</a></span>get_field_keypart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> get_field_keypart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab43ebaaa0db7742de389c2a3c62ff242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43ebaaa0db7742de389c2a3c62ff242">&#9670;&nbsp;</a></span>get_full_func_mm_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a>* get_full_func_mm_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>predicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0cc24906f31d2740bb1d63641b145b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cc24906f31d2740bb1d63641b145b4">&#9670;&nbsp;</a></span>get_func_mm_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a>* get_func_mm_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>predicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>cond_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a SEL_TREE for a simple predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>PARAM from test_quick_select </td></tr>
    <tr><td class="paramname">predicand</td><td>field in the predicate </td></tr>
    <tr><td class="paramname">cond_func</td><td>item for the predicate </td></tr>
    <tr><td class="paramname">value</td><td>constant in the predicate </td></tr>
    <tr><td class="paramname">inv</td><td>true &lt;&gt; NOT cond_func is considered (makes sense only when cond_func is BETWEEN or IN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the built tree.</dd></dl>

</div>
</div>
<a id="a7bed05e54a1d07dc170fb669e289e6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bed05e54a1d07dc170fb669e289e6e3">&#9670;&nbsp;</a></span>get_func_mm_tree_from_in_predicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a>* get_func_mm_tree_from_in_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>predicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func__in.html">Item_func_in</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_negated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to build a SEL_TREE from an &lt;in predicate&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Information on 'just about everything'. </td></tr>
    <tr><td class="paramname">predicand</td><td>The &lt;in predicate's&gt; predicand, i.e. the left-hand side of the &lt;in predicate&gt; expression. </td></tr>
    <tr><td class="paramname">op</td><td>The 'in' operator itself. </td></tr>
    <tr><td class="paramname">is_negated</td><td>If true, the operator is NOT IN, otherwise IN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e01999bc0c176e9c59b7f2fc1deb421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e01999bc0c176e9c59b7f2fc1deb421">&#9670;&nbsp;</a></span>get_func_mm_tree_from_json_overlaps_contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a>* get_func_mm_tree_from_json_overlaps_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>predicand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to build a SEL_TREE from a JSON_OVERLAPS or JSON_CONTAINS functions. </p>
<pre class="fragment">  This function builds SEL_TREE out of JSON_OEVRLAPS() of form:
    JSON_OVERLAPS(typed_array_field, "[&lt;val&gt;,...,&lt;val&gt;]")
    JSON_OVERLAPS("[&lt;val&gt;,...,&lt;val&gt;]", typed_array_field)
    JSON_CONTAINS(typed_array_field, "[&lt;val&gt;,...,&lt;val&gt;]")
  where
    typed_array_field is a field which has multi-valued index defined on it
    &lt;val&gt;             each value in the array is coercible to the array's
                      type
  These conditions are pre-checked in substitute_gc().
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Information on 'just about everything'. </td></tr>
    <tr><td class="paramname">predicand</td><td>the typed array JSON_CONTAIN's argument </td></tr>
    <tr><td class="paramname">op</td><td>The 'JSON_OVERLAPS' operator itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL constructed SEL_TREE NULL in case of any error </dd></dl>

</div>
</div>
<a id="a947f90164eb1325ad49bdaef45ca2e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947f90164eb1325ad49bdaef45ca2e41">&#9670;&nbsp;</a></span>get_index_range_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> * get_index_range_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>range_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9fd6e560182dc2b565b22a73683e42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fd6e560182dc2b565b22a73683e42b">&#9670;&nbsp;</a></span>get_key_scans_params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTRP__RANGE.html">TRP_RANGE</a> * get_key_scans_params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>index_read_must_be_used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>update_tbl_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost_est</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No cost calculation when index dive is skipped. </p>

</div>
</div>
<a id="a4ba5f75a44faef3952ccd9a16bdb22e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba5f75a44faef3952ccd9a16bdb22e6">&#9670;&nbsp;</a></span>get_mm_leaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> * get_mm_leaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae4601556a9f3b9bc8c9f2ecdf4f36ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4601556a9f3b9bc8c9f2ecdf4f36ef">&#9670;&nbsp;</a></span>get_mm_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> * get_mm_parts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>cond_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29173f455b1a2cee8c79b993058a89b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29173f455b1a2cee8c79b993058a89b9">&#9670;&nbsp;</a></span>get_mm_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> * get_mm_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Range Analysis Module, which finds range access alternatives applicable to single or multi-index (UNION) access. </p>
<p>The function does not calculate or care about the cost of the different alternatives.</p>
<p>get_mm_tree() employs a relaxed boolean algebra where the solution may be bigger than what the rules of boolean algebra accept. In other words, get_mm_tree() may return range access plans that will read more rows than the input conditions dictate. In it's simplest form, consider a condition on two fields indexed by two different indexes:</p>
<p>"WHERE fld1 &gt; 'x' AND fld2 &gt; 'y'"</p>
<p>In this case, there are two single-index range access alternatives. No matter which access path is chosen, rows that are not in the result set may be read.</p>
<p>In the case above, get_mm_tree() will create range access alternatives for both indexes, so boolean algebra is still correct. In other cases, however, the conditions are too complex to be used without relaxing the rules. This typically happens when ORing a conjunction to a multi-index disjunctions (</p><dl class="section see"><dt>See also</dt><dd>e.g. imerge_list_or_tree()). When this happens, the range optimizer may choose to ignore conjunctions (any condition connected with AND). The effect of this is that the result includes a "bigger" solution than neccessary. This is OK since all conditions will be used as filters after row retrieval.</dd>
<dd>
SEL_TREE::keys and SEL_TREE::merges for details of how single and multi-index range access alternatives are stored. </dd></dl>

</div>
</div>
<a id="a35cb3a98c4f5d43d3f8f8dd1b4a34371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cb3a98c4f5d43d3f8f8dd1b4a34371">&#9670;&nbsp;</a></span>get_ne_mm_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a>* get_ne_mm_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>cond_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>lt_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>gt_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea015b4ee3ada5c982f7a7bbc8ba348a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea015b4ee3ada5c982f7a7bbc8ba348a">&#9670;&nbsp;</a></span>get_quick_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> get_quick_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQUICK__RANGE__SELECT.html">QUICK_RANGE_SELECT</a> *&#160;</td>
          <td class="paramname"><em>quick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>key_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>min_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>min_key_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>max_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>max_key_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>desc_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>num_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate key values for range select from given sel_arg tree. </p>
<p>SYNOPSIS get_quick_keys()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Range's param </td></tr>
    <tr><td class="paramname">quick</td><td>Quick range select to generate keys for </td></tr>
    <tr><td class="paramname">key</td><td>Generate key values for this key </td></tr>
    <tr><td class="paramname">key_tree</td><td>SEL_ARG tree </td></tr>
    <tr><td class="paramname">min_key</td><td>Min key buffer </td></tr>
    <tr><td class="paramname">min_key_flag</td><td>Min key's flags </td></tr>
    <tr><td class="paramname">max_key</td><td>Max key buffer </td></tr>
    <tr><td class="paramname">max_key_flag</td><td>Max key's flags </td></tr>
    <tr><td class="paramname">desc_flag</td><td>Desc flag of the first keypart </td></tr>
    <tr><td class="paramname">num_key_parts</td><td>Number of key parts that should be used for creating ranges (see get_quick_select() for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Fix this to get all possible sub_ranges</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true OOM false Ok </dd></dl>

</div>
</div>
<a id="a176db9ac71a1f3bbba91cb82dd02df0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176db9ac71a1f3bbba91cb82dd02df0a">&#9670;&nbsp;</a></span>get_quick_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQUICK__RANGE__SELECT.html">QUICK_RANGE_SELECT</a> * get_quick_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mrr_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>mrr_buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>num_key_parts</em> = <code><a class="el" href="sql__const_8h.html#ade6d024ebbd678a7e3e0347e05546ebf">MAX_REF_PARTS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a363e9fef2c372407f9a90478d2a295c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363e9fef2c372407f9a90478d2a295c9">&#9670;&nbsp;</a></span>get_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> get_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> **&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> **&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>root1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a6fab11ee823dd54e74fc273bc377d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6fab11ee823dd54e74fc273bc377d9">&#9670;&nbsp;</a></span>get_search_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> get_search_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQUICK__RANGE.html">QUICK_RANGE</a> *&#160;</td>
          <td class="paramname"><em>cur_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_asc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function returns search mode that needs to be used to read the next record. </p>
<p>It takes the type of the range, the key part's order (ascending or descending) and if the range is on MIN function or a MAX function to get the right search mode. For "MIN" functon:</p><ul>
<li>ASC keypart We need to<ol type="1">
<li>Read the first key that matches the range a) if a minimum value is not specified in the condition b) if it is a equality or is NULL condition</li>
<li>Read the first key after a range value if range is like "a &gt; 10"</li>
<li>Read the key that matches the condition or any key after the range value for any other condition</li>
</ol>
</li>
<li>DESC keypart We need to<ol type="1">
<li>Read the last value for the key prefix if there is no minimum range specified.</li>
<li>Read the first key that matches the range if it is a equality condition.</li>
<li>Read the first key before a range value if range is like "a &gt; 10"</li>
<li>Read the key that matches the prefix or any key before for any other condition For MAX function:</li>
</ol>
</li>
<li>ASC keypart We need to<ol type="1">
<li>Read the last value for the key prefix if there is no maximum range specified</li>
<li>Read the first key that matches the range if it is a equality condition</li>
</ol>
</li>
</ul>
<ol type="1">
<li>Read the first key before a range value if range is like "a &lt; 10"</li>
<li>Read the key that matches the condition or any key before the range value for any other condition</li>
</ol>
<ul>
<li>DESC keypart We need to</li>
</ul>
<ol type="1">
<li>Read the first key that matches the range a) if a minimum value is not specified in the condition b) if it is a equality</li>
<li>Read the first key after a range value if range is like "a &lt; 10"</li>
<li>Read the key that matches the prefix or any key after for any other condition</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur_range</td><td>pointer to QUICK_RANGE. </td></tr>
    <tr><td class="paramname">is_asc</td><td>TRUE if key part is ascending, FALSE otherwise. </td></tr>
    <tr><td class="paramname">is_min</td><td>TRUE if the range is on MIN function. FALSE for MAX function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>search mode </dd></dl>

</div>
</div>
<a id="a482997c73c12ea0d3bf7ccf4fd82f31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482997c73c12ea0d3bf7ccf4fd82f31d">&#9670;&nbsp;</a></span>get_sel_root_for_keypart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> get_sel_root_for_keypart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key_part_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>index_range_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> **&#160;</td>
          <td class="paramname"><em>cur_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the SEL_ARG tree for 'field' is identical for all ranges in 'keypart_tree'.</p>

</div>
</div>
<a id="a96986689be1db30f9bc4251538457c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96986689be1db30f9bc4251538457c84">&#9670;&nbsp;</a></span>imerge_list_and_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void imerge_list_and_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *&#160;</td>
          <td class="paramname"><em>im1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *&#160;</td>
          <td class="paramname"><em>im2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="affac3937238252019867106caab8574f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affac3937238252019867106caab8574f">&#9670;&nbsp;</a></span>imerge_list_or_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int imerge_list_or_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *&#160;</td>
          <td class="paramname"><em>im1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *&#160;</td>
          <td class="paramname"><em>im2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8c93a3b5e9eb9e5cc7578cee0e693d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c93a3b5e9eb9e5cc7578cee0e693d4">&#9670;&nbsp;</a></span>imerge_list_or_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> imerge_list_or_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classSEL__IMERGE.html">SEL_IMERGE</a> &gt; *&#160;</td>
          <td class="paramname"><em>im1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b9dd7639ed35c43aa529ae90af97c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9dd7639ed35c43aa529ae90af97c37">&#9670;&nbsp;</a></span>index_next_different()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int index_next_different </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_index_scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html">handler</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>group_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>group_prefix_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>group_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the next different key value by skiping all the rows with the same key value. </p>
<p>Implements a specialized loose index access method for queries containing aggregate functions with distinct of the form: SELECT <a href="DISTINCT a,...">SUM|COUNT|AVG</a> FROM t This method comes to replace the index scan + Unique class (distinct selection) for loose index scan that visits all the rows of a covering index instead of jumping in the begining of each group. TODO: Placeholder function. To be replaced by a handler API call</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_index_scan</td><td>hint to use index scan instead of random index read to find the next different value. </td></tr>
    <tr><td class="paramname">file</td><td>table handler </td></tr>
    <tr><td class="paramname">key_part</td><td>group key to compare </td></tr>
    <tr><td class="paramname">record</td><td>row data </td></tr>
    <tr><td class="paramname">group_prefix</td><td>current key prefix data </td></tr>
    <tr><td class="paramname">group_prefix_len</td><td>length of the current key prefix data </td></tr>
    <tr><td class="paramname">group_key_parts</td><td>number of the current key prefix columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">!0</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae07ba9a2a7d56bd5186585f8b857ae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07ba9a2a7d56bd5186585f8b857ae55">&#9670;&nbsp;</a></span>invert_max_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> invert_max_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>max_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function to invert max flags to min flags for DESC key parts. </p>
<p>It changes NEAR_MAX, NO_MAX_RANGE to NEAR_MIN, NO_MIN_RANGE appropriately </p>

</div>
</div>
<a id="a3f0f9ba3e66d3f5a4621012de5384474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0f9ba3e66d3f5a4621012de5384474">&#9670;&nbsp;</a></span>invert_min_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> invert_min_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>min_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function to invert min flags to max flags for DESC key parts. </p>
<p>It changes NEAR_MIN, NO_MIN_RANGE to NEAR_MAX, NO_MAX_RANGE appropriately </p>

</div>
</div>
<a id="ab2df6ecb32a7df75cf2c1f6eb27402ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2df6ecb32a7df75cf2c1f6eb27402ac">&#9670;&nbsp;</a></span>is_better_intersect_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_better_intersect_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *&#160;</td>
          <td class="paramname"><em>scan1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *&#160;</td>
          <td class="paramname"><em>scan2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two ROR_SCAN_INFO* by. </p>
<ol type="1">
<li>Number of fields in this index that are not already covered by other indexes earlier in the intersect ordering: descending</li>
<li>E(Number of records): ascending</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan1</td><td>first ror scan to compare </td></tr>
    <tr><td class="paramname">scan2</td><td>second ror scan to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if scan1 &gt; scan2, false otherwise </dd></dl>

</div>
</div>
<a id="a63f8d7333662a3737a4766d8b43f4a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f8d7333662a3737a4766d8b43f4a59">&#9670;&nbsp;</a></span>is_key_scan_ror()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_key_scan_ror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1955be20a1086f373696f62c9327e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1955be20a1086f373696f62c9327e49f">&#9670;&nbsp;</a></span>is_spatial_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_spatial_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a>&#160;</td>
          <td class="paramname"><em>op_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether a comparison operator is a spatial comparison operator, i.e. </p>
<p>Item_func::SP_*.</p>
<p>Used to check if range access using operator 'op_type' is applicable for a non-spatial index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op_type</td><td>The comparison operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 'op_type' is a spatial comparison operator, false otherwise. </dd></dl>

</div>
</div>
<a id="a5b1090a671b0743937464df15e7af0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1090a671b0743937464df15e7af0f7">&#9670;&nbsp;</a></span>key_and()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> * key_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5824e4b3ec752fdbff045f1651bc23f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5824e4b3ec752fdbff045f1651bc23f9">&#9670;&nbsp;</a></span>key_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> * key_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine two range expression under a common OR. </p>
<p>On a logical level, the transformation is key_or( expr1, expr2 ) =&gt; expr1 OR expr2.</p>
<p>Both expressions are assumed to be in the SEL_ARG format. In a logic sense, the format is reminiscent of DNF, since an expression such as the following</p>
<p>( 1 &lt; kp1 &lt; 10 AND p1 ) OR ( 10 &lt;= kp2 &lt; 20 AND p2 )</p>
<p>where there is a key consisting of keyparts ( kp1, kp2, ..., kpn ) and p1 and p2 are valid SEL_ARG expressions over keyparts kp2 ... kpn, is a valid SEL_ARG condition. The disjuncts appear ordered by the minimum endpoint of the first range and ranges must not overlap. It follows that they are also ordered by maximum endpoints. Thus</p>
<p>( 1 &lt; kp1 &lt;= 2 AND ( kp2 = 2 OR kp2 = 3 ) ) OR kp1 = 3</p>
<p>Is a a valid SER_ARG expression for a key of at least 2 keyparts.</p>
<p>For simplicity, we will assume that expr2 is a single range predicate, i.e. on the form ( a &lt; x &lt; b AND ... ). It is easy to generalize to a disjunction of several predicates by subsequently call key_or for each disjunct.</p>
<p>The algorithm iterates over each disjunct of expr1, and for each disjunct where the first keypart's range overlaps with the first keypart's range in expr2:</p>
<p>If the predicates are equal for the rest of the keyparts, or if there are no more, the range in expr2 has its endpoints copied in, and the SEL_ARG node in expr2 is deallocated. If more ranges became connected in expr1, the surplus is also dealocated. If they differ, two ranges are created.</p>
<ul>
<li>The range leading up to the overlap. Empty if endpoints are equal.</li>
<li>The overlapping sub-range. May be the entire range if they are equal.</li>
</ul>
<p>Finally, there may be one more range if expr2's first keypart's range has a greater maximum endpoint than the last range in expr1.</p>
<p>For the overlapping sub-range, we recursively call key_or. Thus in order to compute key_or of</p>
<p>(1) ( 1 &lt; kp1 &lt; 10 AND 1 &lt; kp2 &lt; 10 )</p>
<p>(2) ( 2 &lt; kp1 &lt; 20 AND 4 &lt; kp2 &lt; 20 )</p>
<p>We create the ranges 1 &lt; kp &lt;= 2, 2 &lt; kp1 &lt; 10, 10 &lt;= kp1 &lt; 20. For the first one, we simply hook on the condition for the second keypart from (1) : 1 &lt; kp2 &lt; 10. For the second range 2 &lt; kp1 &lt; 10, key_or( 1 &lt; kp2 &lt; 10, 4 &lt; kp2 &lt; 20 ) is called, yielding 1 &lt; kp2 &lt; 20. For the last range, we reuse the range 4 &lt; kp2 &lt; 20 from (2) for the second keypart. The result is thus</p>
<p>( 1 &lt; kp1 &lt;= 2 AND 1 &lt; kp2 &lt; 10 ) OR ( 2 &lt; kp1 &lt; 10 AND 1 &lt; kp2 &lt; 20 ) OR ( 10 &lt;= kp1 &lt; 20 AND 4 &lt; kp2 &lt; 20 )</p>
<p>key_or() does not modify key1 nor key2 if they are in use by other roots (although typical use is that key1 has been disconnected from its root and thus can be modified in-place). Thus, it does not change their use_count.</p>
<p>The returned node will not have its use_count increased; you are supposed to do that yourself when you connect it to a root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>PARAM from test_quick_select </td></tr>
    <tr><td class="paramname">key1</td><td>Root of RB-tree of SEL_ARGs to be ORed with key2 </td></tr>
    <tr><td class="paramname">key2</td><td>Root of RB-tree of SEL_ARGs to be ORed with key1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62de66e843445493f777a1592230690d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62de66e843445493f777a1592230690d">&#9670;&nbsp;</a></span>left_rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void left_rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> **&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8adb2f8d23dc7cffe127d85c789f32b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adb2f8d23dc7cffe127d85c789f32b4">&#9670;&nbsp;</a></span>make_ror_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a>* make_ror_scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>sel_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c2fd4c62c8dd42cb77eb8f491d927fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2fd4c62c8dd42cb77eb8f491d927fe">&#9670;&nbsp;</a></span>mark_all_partitions_as_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mark_all_partitions_as_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpartition__info.html">partition_info</a> *&#160;</td>
          <td class="paramname"><em>part_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaab940e5edf5ad57bd223d2b54bb3bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab940e5edf5ad57bd223d2b54bb3bd6">&#9670;&nbsp;</a></span>mark_full_partition_used_no_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mark_full_partition_used_no_parts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpartition__info.html">partition_info</a> *&#160;</td>
          <td class="paramname"><em>part_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td>
          <td class="paramname"><em>part_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5d0d59fc26e3b27a6c278fc92783c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d0d59fc26e3b27a6c278fc92783c40">&#9670;&nbsp;</a></span>mark_full_partition_used_with_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mark_full_partition_used_with_parts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpartition__info.html">partition_info</a> *&#160;</td>
          <td class="paramname"><em>part_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td>
          <td class="paramname"><em>part_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a182cb951715af58e530f3ad35c998073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182cb951715af58e530f3ad35c998073">&#9670;&nbsp;</a></span>min_max_inspect_cond_for_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> min_max_inspect_cond_for_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>min_max_arg_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>min_max_arg_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>non_min_max_arg_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function detects the presents of MIN/MAX field along with at least one non MIN/MAX field participation in the given condition. </p>
<p>Subqueries inspection is skipped as of now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>tree (or subtree) describing all or part of the WHERE clause being analyzed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">min_max_arg_item</td><td>The field referenced by the MIN/MAX function(s). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_max_arg_present</td><td>This out parameter is set to true if MIN/MAX argument is present in cond. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">non_min_max_arg_present</td><td>This out parameter is set to true if any field item other than MIN/MAX argument is present in cond.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if both MIN/MAX field and non MIN/MAX field is present in cond. FALSE o/w.</dd></dl>

</div>
</div>
<a id="a83c7b1ee258895ae45aac66b7b0694d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c7b1ee258895ae45aac66b7b0694d4">&#9670;&nbsp;</a></span>null_part_in_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> null_part_in_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca88a04f4ff1e7872ac2cb12e4e788f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca88a04f4ff1e7872ac2cb12e4e788f6">&#9670;&nbsp;</a></span>null_sel_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> null_sel_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html#ab2c33faad20fa0700f23ed800de66cc8a8067b6c2ad537845bd370b4f2f935d61">SEL_TREE::IMPOSSIBLE</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&amp;&#160;</td>
          <td class="paramname"><em>null_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a846a12904abc8fe6ad893c27f60aaf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846a12904abc8fe6ad893c27f60aaf84">&#9670;&nbsp;</a></span>print_key_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a key to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>String the key is appended to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_part</td><td>Index components description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4190059a204a4657aeb6a5eeed6d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4190059a204a4657aeb6a5eeed6d31">&#9670;&nbsp;</a></span>print_multiple_key_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_multiple_key_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>used_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf3758ade4da5caec2cf836f2a9c1fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3758ade4da5caec2cf836f2a9c1fc0">&#9670;&nbsp;</a></span>print_partitioning_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_partitioning_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>parts_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20771d29be8493ceb9b1a945447f227e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20771d29be8493ceb9b1a945447f227e">&#9670;&nbsp;</a></span>print_quick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_quick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQUICK__SELECT__I.html">QUICK_SELECT_I</a> *&#160;</td>
          <td class="paramname"><em>quick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *&#160;</td>
          <td class="paramname"><em>needed_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07c6cc52dd0e8774c3bac0fd6f410449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c6cc52dd0e8774c3bac0fd6f410449">&#9670;&nbsp;</a></span>print_ror_scans_arr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_ror_scans_arr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e37a03a5e54507e76618e1852ae80cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e37a03a5e54507e76618e1852ae80cb">&#9670;&nbsp;</a></span>print_sel_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_sel_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *&#160;</td>
          <td class="paramname"><em>tree_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb6a9896a05b5655d18cb659fd5a94ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6a9896a05b5655d18cb659fd5a94ee">&#9670;&nbsp;</a></span>print_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tree_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>print_full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb637143f6e8ecfd3980c474ed0a19e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb637143f6e8ecfd3980c474ed0a19e9">&#9670;&nbsp;</a></span>prune_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> prune_partitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>pprune_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform partition pruning for a given table and condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table</td><td>Table to perform partition pruning for </td></tr>
    <tr><td class="paramname">pprune_cond</td><td>Condition to use for partition pruning</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that lock_partitions are setup when it is invoked. The function analyzes the condition, finds partitions that need to be used to retrieve the records that match the condition, and marks them as used by setting appropriate bit in part_info-&gt;read_partitions In the worst case all partitions are marked as used. If the table is not yet locked, it will also unset bits in part_info-&gt;lock_partitions that is not set in read_partitions.</dd></dl>
<p>This function returns promptly if called for non-partitioned table.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6951da91ab95fcb95a2f88f7a3750163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6951da91ab95fcb95a2f88f7a3750163">&#9670;&nbsp;</a></span>quick_range_seq_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> quick_range_seq_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e69f3a3005d77d7e779e5326e56ec26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e69f3a3005d77d7e779e5326e56ec26">&#9670;&nbsp;</a></span>quick_range_seq_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> quick_range_seq_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td>
          <td class="paramname"><em>rseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad63b16fee3e1922af5fac2f2bd772cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad63b16fee3e1922af5fac2f2bd772cc">&#9670;&nbsp;</a></span>range_optimizer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void range_optimizer_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global destruction of the null_element. Call on server stop. </p>

</div>
</div>
<a id="aeb7a6e279a9ab1ac304d1d45395defae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7a6e279a9ab1ac304d1d45395defae">&#9670;&nbsp;</a></span>range_optimizer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void range_optimizer_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global initialization of the null_element. Call on server start. </p>

</div>
</div>
<a id="aecdf9c54f6992af88f15c49339b0017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdf9c54f6992af88f15c49339b0017e">&#9670;&nbsp;</a></span>rb_delete_fixup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__ARG.html">SEL_ARG</a> * rb_delete_fixup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89b3f278f380f6fbfd13c08cc9f6cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b3f278f380f6fbfd13c08cc9f6cec0">&#9670;&nbsp;</a></span>remove_nonrange_trees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> remove_nonrange_trees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11696d64d61757bbabf475f4f4c8fd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11696d64d61757bbabf475f4f4c8fd6d">&#9670;&nbsp;</a></span>right_rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void right_rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> **&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21d856a220b2d2c3d92f78576ced002b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d856a220b2d2c3d92f78576ced002b">&#9670;&nbsp;</a></span>ror_intersect_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ror_intersect_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *&#160;</td>
          <td class="paramname"><em>ror_scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_cpk_scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58b38a3a876e53eaa2c7746adb0fa504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b38a3a876e53eaa2c7746adb0fa504">&#9670;&nbsp;</a></span>ror_intersect_cpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ror_intersect_cpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1026dc9ddebaab0b7266b80356971f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1026dc9ddebaab0b7266b80356971f67">&#9670;&nbsp;</a></span>ror_intersect_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a>* ror_intersect_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPARAM.html">PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbbfc5ac90fd28228bd029625ecdb1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbfc5ac90fd28228bd029625ecdb1ee">&#9670;&nbsp;</a></span>ror_scan_selectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ror_scan_selectivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structROR__INTERSECT__INFO.html">ROR_INTERSECT_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structROR__SCAN__INFO.html">ROR_SCAN_INFO</a> *&#160;</td>
          <td class="paramname"><em>scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>key values tuple, used to store both min_range.key and max_range.key. This function is only called for equality ranges; open ranges (e.g. "min_value &lt; X &lt; max_value") cannot be used for rowid ordered retrieval, so in this function we know that min_range.key == max_range.key</p>

</div>
</div>
<a id="a1db4fd8bb7e54c3fb5dc145fe2719d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db4fd8bb7e54c3fb5dc145fe2719d36">&#9670;&nbsp;</a></span>save_value_and_handle_conversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> save_value_and_handle_conversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> **&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItem__func.html#a44783465b41db99f2cff936cb7b6e70b">Item_func::Functype</a>&#160;</td>
          <td class="paramname"><em>comp_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>impossible_cond_cause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>memroot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves 'value' in 'field' and handles potential type conversion problems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tree</td><td>The SEL_ROOT leaf under construction. If an always false predicate is found it is modified to point to a SEL_ROOT with type == SEL_ROOT::Type::IMPOSSIBLE. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value</td><td>The Item that contains a value that shall be stored in 'field'. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_op</td><td>Comparison operator: &gt;, &gt;=, &lt;=&gt; etc. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">field</td><td>The field that 'value' is stored into. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">impossible_cond_cause</td><td>Set to a descriptive string if an impossible condition is found. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memroot</td><td>Memroot for creation of new SEL_ARG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if saving went fine and it makes sense to continue optimizing for this predicate. </td></tr>
    <tr><td class="paramname">true</td><td>if always true/false predicate was found, in which case 'tree' has been modified to reflect this: NULL pointer if always true, SEL_ARG with type IMPOSSIBLE if always false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af37fba8cff839033fc317d7465a6a42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37fba8cff839033fc317d7465a6a42e">&#9670;&nbsp;</a></span>sel_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> * sel_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new key test to a key when scanning through all keys This will never be called for same key parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>Old root of key </td></tr>
    <tr><td class="paramname">key2</td><td>Element to insert (must be a single element) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New root of key </dd></dl>

</div>
</div>
<a id="ac0299894fff346d1c2d57e611ccd36ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0299894fff346d1c2d57e611ccd36ac">&#9670;&nbsp;</a></span>sel_arg_range_seq_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> sel_arg_range_seq_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8977d6e31a7ed4a62377ed8155e7a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8977d6e31a7ed4a62377ed8155e7a1b">&#9670;&nbsp;</a></span>sel_arg_range_seq_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> sel_arg_range_seq_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td>
          <td class="paramname"><em>rseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96a3ff13290057561329a1183ab81bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a3ff13290057561329a1183ab81bd6">&#9670;&nbsp;</a></span>sel_cmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sel_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>a_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a33a5e996e7a90acefb8b1c0bea47e365">uint8</a>&#160;</td>
          <td class="paramname"><em>b_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0700b2184f75d76b03a8c7ead06b1c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0700b2184f75d76b03a8c7ead06b1c1f">&#9670;&nbsp;</a></span>sel_trees_can_be_ored()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sel_trees_can_be_ored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a532bf40caeeb95011cab7d39764af9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532bf40caeeb95011cab7d39764af9dd">&#9670;&nbsp;</a></span>store_key_image_to_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void store_key_image_to_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ad516f1cd6d8ddf7575ec2ef90f7a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad516f1cd6d8ddf7575ec2ef90f7a37">&#9670;&nbsp;</a></span>store_selargs_to_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void store_selargs_to_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPART__PRUNE__PARAM.html">PART_PRUNE_PARAM</a> *&#160;</td>
          <td class="paramname"><em>ppar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec989f01a2d6048771d5a1b61e4d073a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec989f01a2d6048771d5a1b61e4d073a">&#9670;&nbsp;</a></span>test_quick_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_quick_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a>&#160;</td>
          <td class="paramname"><em>keys_to_use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>prev_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>force_quick_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="key__spec_8h.html#ad747dc49681b256d83aa9a9e35375ded">enum_order</a>&#160;</td>
          <td class="paramname"><em>interesting_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQEP__shared__owner.html">QEP_shared_owner</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *&#160;</td>
          <td class="paramname"><em>needed_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQUICK__SELECT__I.html">QUICK_SELECT_I</a> **&#160;</td>
          <td class="paramname"><em>quick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_table_scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b6b3303913305304906f5dca70b4b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6b3303913305304906f5dca70b4b10">&#9670;&nbsp;</a></span>test_rb_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int test_rb_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedb1c2f0d47e65dfe761d1d4703f30de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb1c2f0d47e65dfe761d1d4703f30de">&#9670;&nbsp;</a></span>tree_and()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> * tree_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ba049d2bba21bc7a0694b23ca5ba1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba049d2bba21bc7a0694b23ca5ba1da">&#9670;&nbsp;</a></span>tree_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSEL__TREE.html">SEL_TREE</a> * tree_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__TREE.html">SEL_TREE</a> *&#160;</td>
          <td class="paramname"><em>tree2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79074a6b3633acac4d49713b9507c440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79074a6b3633acac4d49713b9507c440">&#9670;&nbsp;</a></span>util_min_max_inspect_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void util_min_max_inspect_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>min_max_arg_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>min_max_arg_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>non_min_max_arg_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function used by min_max_inspect_cond_for_fields() for comparing FILED item with given MIN/MAX item and setting appropriate out paramater. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">item_field</td><td>Item field for comparison. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">min_max_arg_item</td><td>The field referenced by the MIN/MAX function(s). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_max_arg_present</td><td>This out parameter is set to true if MIN/MAX argument is present in cond. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">non_min_max_arg_present</td><td>This out parameter is set to true if any field item other than MIN/MAX argument is present in cond. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7177124b48026b67e3fe1b0e79345ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7177124b48026b67e3fe1b0e79345ba2">&#9670;&nbsp;</a></span>warn_index_not_applicable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void warn_index_not_applicable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If EXPLAIN or if the &ndash;safe-updates option is enabled, add a warning that the index cannot be used for range access due to either type conversion or different collations on the field used for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>PARAM from test_quick_select </td></tr>
    <tr><td class="paramname">key_num</td><td>Key number </td></tr>
    <tr><td class="paramname">field</td><td>Field in the predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0364f2f9281e7223d4c0a0bd3c6c61f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0364f2f9281e7223d4c0a0bd3c6c61f1">&#9670;&nbsp;</a></span>is_null_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> is_null_string[2] = {1, 0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a2623dc51e33a5c2ecd4ffbe75c8393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2623dc51e33a5c2ecd4ffbe75c8393">&#9670;&nbsp;</a></span>null_element</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSEL__ARG.html">SEL_ARG</a>* null_element = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared sentinel node for all trees. </p>
<p>Initialized by range_optimizer_init(), destroyed by range_optimizer_free(); </p>

</div>
</div>
<a id="a116e635d42e4e76445a547592558c13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116e635d42e4e76445a547592558c13b">&#9670;&nbsp;</a></span>null_root</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> null_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5bd71961b401a432086d0fb290a87f3f.html">sql</a></li><li class="navelem"><a class="el" href="opt__range_8cc.html">opt_range.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
