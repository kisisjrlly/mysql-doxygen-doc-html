<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: log_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structlog__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structlog__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">log_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Redo log - single data structure with state of the redo log system.  
 <a href="structlog__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="log0types_8h_source.html">log0types.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa36178a39193339ae5cb96be4dcd2cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa36178a39193339ae5cb96be4dcd2cfc">m_disable</a></td></tr>
<tr class="memdesc:aa36178a39193339ae5cb96be4dcd2cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if redo logging is disabled.  <a href="#aa36178a39193339ae5cb96be4dcd2cfc">More...</a><br /></td></tr>
<tr class="separator:aa36178a39193339ae5cb96be4dcd2cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb456c4ab1524d24e8a258ee27e046f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a9eb456c4ab1524d24e8a258ee27e046f">m_crash_unsafe</a></td></tr>
<tr class="memdesc:a9eb456c4ab1524d24e8a258ee27e046f"><td class="mdescLeft">&#160;</td><td class="mdescRight">true, if server is not recoverable.  <a href="#a9eb456c4ab1524d24e8a258ee27e046f">More...</a><br /></td></tr>
<tr class="separator:a9eb456c4ab1524d24e8a258ee27e046f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2fe8916f029e6749fdc11369c875aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3b2fe8916f029e6749fdc11369c875aa">m_first_file_lsn</a></td></tr>
<tr class="memdesc:a3b2fe8916f029e6749fdc11369c875aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">start LSN of first redo log file.  <a href="#a3b2fe8916f029e6749fdc11369c875aa">More...</a><br /></td></tr>
<tr class="separator:a3b2fe8916f029e6749fdc11369c875aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Users writing to log buffer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a299b04dc56085293d2305a9877180362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a299b04dc56085293d2305a9877180362">sn_lock_event</a></td></tr>
<tr class="memdesc:a299b04dc56085293d2305a9877180362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event used for locking sn.  <a href="#a299b04dc56085293d2305a9877180362">More...</a><br /></td></tr>
<tr class="separator:a299b04dc56085293d2305a9877180362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b34ce638948350a6a05bf01e06976ea"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__psi__abi__rwlock.html#gaed6f27d4e7ccbaf85f850a72d6ac03c0">PSI_rwlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a8b34ce638948350a6a05bf01e06976ea">pfs_psi</a></td></tr>
<tr class="memdesc:a8b34ce638948350a6a05bf01e06976ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The instrumentation hook.  <a href="#a8b34ce638948350a6a05bf01e06976ea">More...</a><br /></td></tr>
<tr class="separator:a8b34ce638948350a6a05bf01e06976ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206251ce25625b0205d3950f9977745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ae206251ce25625b0205d3950f9977745">sn_lock_inst</a></td></tr>
<tr class="memdesc:ae206251ce25625b0205d3950f9977745"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rw_lock instance only for the debug info list.  <a href="#ae206251ce25625b0205d3950f9977745">More...</a><br /></td></tr>
<tr class="separator:ae206251ce25625b0205d3950f9977745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1286ead9c1a609bf48d74d55b97dbff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a1286ead9c1a609bf48d74d55b97dbff3">sn</a></td></tr>
<tr class="memdesc:a1286ead9c1a609bf48d74d55b97dbff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current sn value.  <a href="#a1286ead9c1a609bf48d74d55b97dbff3">More...</a><br /></td></tr>
<tr class="separator:a1286ead9c1a609bf48d74d55b97dbff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec8391de916e4e99c6f0ba54155b240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3ec8391de916e4e99c6f0ba54155b240">sn_locked</a></td></tr>
<tr class="memdesc:a3ec8391de916e4e99c6f0ba54155b240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended sn value while x-locked.  <a href="#a3ec8391de916e4e99c6f0ba54155b240">More...</a><br /></td></tr>
<tr class="separator:a3ec8391de916e4e99c6f0ba54155b240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03b3462e3a7d756a336874046455e37"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ad03b3462e3a7d756a336874046455e37">sn_x_lock_mutex</a></td></tr>
<tr class="memdesc:ad03b3462e3a7d756a336874046455e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which can be used for x-lock sn value.  <a href="#ad03b3462e3a7d756a336874046455e37">More...</a><br /></td></tr>
<tr class="separator:ad03b3462e3a7d756a336874046455e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dda509bce7dc8ef313f58424b639f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt; <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, <a class="el" href="os0file_8h.html#a893c38aa3aedd6efa1439b5ec00213f9">OS_FILE_LOG_BLOCK_SIZE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a2dda509bce7dc8ef313f58424b639f9c">buf</a></td></tr>
<tr class="memdesc:a2dda509bce7dc8ef313f58424b639f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding after the _sn to avoid false sharing issues for constants below (due to changes of sn).  <a href="#a2dda509bce7dc8ef313f58424b639f9c">More...</a><br /></td></tr>
<tr class="separator:a2dda509bce7dc8ef313f58424b639f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3174a2151ee9f35c716eb6781f8594e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3174a2151ee9f35c716eb6781f8594e0">buf_size_sn</a></td></tr>
<tr class="memdesc:a3174a2151ee9f35c716eb6781f8594e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the log buffer expressed in number of data bytes, that is excluding bytes for headers and footers of log blocks.  <a href="#a3174a2151ee9f35c716eb6781f8594e0">More...</a><br /></td></tr>
<tr class="separator:a3174a2151ee9f35c716eb6781f8594e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43957d37df1079a214194e10b9ce54a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ad43957d37df1079a214194e10b9ce54a">buf_size</a></td></tr>
<tr class="memdesc:ad43957d37df1079a214194e10b9ce54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the log buffer expressed in number of total bytes, that is including bytes for headers and footers of log blocks.  <a href="#ad43957d37df1079a214194e10b9ce54a">More...</a><br /></td></tr>
<tr class="separator:ad43957d37df1079a214194e10b9ce54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfd700a83392ade91b3cde44ec92e96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLink__buf.html">Link_buf</a>&lt; <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aebfd700a83392ade91b3cde44ec92e96">recent_written</a></td></tr>
<tr class="memdesc:aebfd700a83392ade91b3cde44ec92e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recent written buffer.  <a href="#aebfd700a83392ade91b3cde44ec92e96">More...</a><br /></td></tr>
<tr class="separator:aebfd700a83392ade91b3cde44ec92e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5543171f2fc4be5bb7f1c5b7a76efeb3"><td class="memItemLeft" align="right" valign="top">std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a5543171f2fc4be5bb7f1c5b7a76efeb3">writer_threads_paused</a></td></tr>
<tr class="memdesc:a5543171f2fc4be5bb7f1c5b7a76efeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for pausing the log writer threads.  <a href="#a5543171f2fc4be5bb7f1c5b7a76efeb3">More...</a><br /></td></tr>
<tr class="separator:a5543171f2fc4be5bb7f1c5b7a76efeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1d8d6d3f43c7b9e5071ef6eb58853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a75e1d8d6d3f43c7b9e5071ef6eb58853">current_ready_waiting_lsn</a></td></tr>
<tr class="memdesc:a75e1d8d6d3f43c7b9e5071ef6eb58853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some threads waiting for the ready for write lsn by closer_event.  <a href="#a75e1d8d6d3f43c7b9e5071ef6eb58853">More...</a><br /></td></tr>
<tr class="separator:a75e1d8d6d3f43c7b9e5071ef6eb58853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac533ce8887732178b8863fc49186f1"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3ac533ce8887732178b8863fc49186f1">current_ready_waiting_sig_count</a></td></tr>
<tr class="memdesc:a3ac533ce8887732178b8863fc49186f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">current_ready_waiting_lsn is waited using this sig_count.  <a href="#a3ac533ce8887732178b8863fc49186f1">More...</a><br /></td></tr>
<tr class="separator:a3ac533ce8887732178b8863fc49186f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af629cb14bdcce47d7b1aab7f3b512c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLink__buf.html">Link_buf</a>&lt; <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#af629cb14bdcce47d7b1aab7f3b512c68">recent_closed</a></td></tr>
<tr class="memdesc:af629cb14bdcce47d7b1aab7f3b512c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recent closed buffer.  <a href="#af629cb14bdcce47d7b1aab7f3b512c68">More...</a><br /></td></tr>
<tr class="separator:af629cb14bdcce47d7b1aab7f3b512c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Users &lt;=&gt; writer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a528838ad52c9d7b435b3daf69ed1d514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a528838ad52c9d7b435b3daf69ed1d514">buf_limit_sn</a></td></tr>
<tr class="memdesc:a528838ad52c9d7b435b3daf69ed1d514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum sn up to which there is free space in both the log buffer and the log files.  <a href="#a528838ad52c9d7b435b3daf69ed1d514">More...</a><br /></td></tr>
<tr class="separator:a528838ad52c9d7b435b3daf69ed1d514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af668ea03e6b8ce2ca9bc85f3026be301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#af668ea03e6b8ce2ca9bc85f3026be301">write_lsn</a></td></tr>
<tr class="memdesc:af668ea03e6b8ce2ca9bc85f3026be301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Up to this lsn, data has been written to disk (fsync not required).  <a href="#af668ea03e6b8ce2ca9bc85f3026be301">More...</a><br /></td></tr>
<tr class="separator:af668ea03e6b8ce2ca9bc85f3026be301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac3a11f2ff78528a4c65d98bbf77ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aeac3a11f2ff78528a4c65d98bbf77ee2">write_events</a></td></tr>
<tr class="memdesc:aeac3a11f2ff78528a4c65d98bbf77ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned pointer to array with events, which are used for notifications sent from the log write notifier thread to user threads.  <a href="#aeac3a11f2ff78528a4c65d98bbf77ee2">More...</a><br /></td></tr>
<tr class="separator:aeac3a11f2ff78528a4c65d98bbf77ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55a0e623dc8a13b61afbfdc812dcfce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#af55a0e623dc8a13b61afbfdc812dcfce">write_events_size</a></td></tr>
<tr class="memdesc:af55a0e623dc8a13b61afbfdc812dcfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries in the array with writer_events.  <a href="#af55a0e623dc8a13b61afbfdc812dcfce">More...</a><br /></td></tr>
<tr class="separator:af55a0e623dc8a13b61afbfdc812dcfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ed59d33529fbbe21b6497e8f02e979"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a27ed59d33529fbbe21b6497e8f02e979">write_to_file_requests_total</a></td></tr>
<tr class="memdesc:a27ed59d33529fbbe21b6497e8f02e979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approx.  <a href="#a27ed59d33529fbbe21b6497e8f02e979">More...</a><br /></td></tr>
<tr class="separator:a27ed59d33529fbbe21b6497e8f02e979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45d55b7f54c2a2c170f4dd1b1509805"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ae45d55b7f54c2a2c170f4dd1b1509805">write_to_file_requests_interval</a></td></tr>
<tr class="memdesc:ae45d55b7f54c2a2c170f4dd1b1509805"><td class="mdescLeft">&#160;</td><td class="mdescRight">How often redo write/flush is requested in average.  <a href="#ae45d55b7f54c2a2c170f4dd1b1509805">More...</a><br /></td></tr>
<tr class="separator:ae45d55b7f54c2a2c170f4dd1b1509805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Users &lt;=&gt; flusher</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This padding is probably not needed, left for convenience. </p>
</div></td></tr>
<tr class="memitem:aa695ec86ef978a60b4d6a2c388e330e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa695ec86ef978a60b4d6a2c388e330e5">flush_events</a></td></tr>
<tr class="memdesc:aa695ec86ef978a60b4d6a2c388e330e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned pointer to array with events, which are used for notifications sent from the log flush notifier thread to user threads.  <a href="#aa695ec86ef978a60b4d6a2c388e330e5">More...</a><br /></td></tr>
<tr class="separator:aa695ec86ef978a60b4d6a2c388e330e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f550296c4fa1d14f25f42abb9bad1dd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a9f550296c4fa1d14f25f42abb9bad1dd">flush_events_size</a></td></tr>
<tr class="memdesc:a9f550296c4fa1d14f25f42abb9bad1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries in the array with events.  <a href="#a9f550296c4fa1d14f25f42abb9bad1dd">More...</a><br /></td></tr>
<tr class="separator:a9f550296c4fa1d14f25f42abb9bad1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f3b7405baa60d905b3af75b139ff75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ab4f3b7405baa60d905b3af75b139ff75">old_flush_event</a></td></tr>
<tr class="memdesc:ab4f3b7405baa60d905b3af75b139ff75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is in the reset state when a flush is running; a thread should wait for this without owning any of redo mutexes, but NOTE that to reset this event, the thread MUST own the writer_mutex.  <a href="#ab4f3b7405baa60d905b3af75b139ff75">More...</a><br /></td></tr>
<tr class="separator:ab4f3b7405baa60d905b3af75b139ff75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1896732495682b34be952a8bf127a6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ab1896732495682b34be952a8bf127a6c">flushed_to_disk_lsn</a></td></tr>
<tr class="memdesc:ab1896732495682b34be952a8bf127a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding before the frequently updated flushed_to_disk_lsn.  <a href="#ab1896732495682b34be952a8bf127a6c">More...</a><br /></td></tr>
<tr class="separator:ab1896732495682b34be952a8bf127a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Log flusher thread</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Padding after the frequently updated flushed_to_disk_lsn. </p>
</div></td></tr>
<tr class="memitem:a35dbb4ebc32e3aa50a3d98bb09b7b4ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#a2a792b6cf082b0096ebeeb4edb8d071b">Log_clock_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a35dbb4ebc32e3aa50a3d98bb09b7b4ba">last_flush_start_time</a></td></tr>
<tr class="memdesc:a35dbb4ebc32e3aa50a3d98bb09b7b4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last flush start time.  <a href="#a35dbb4ebc32e3aa50a3d98bb09b7b4ba">More...</a><br /></td></tr>
<tr class="separator:a35dbb4ebc32e3aa50a3d98bb09b7b4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aee16938973ac92a483f8fc14d45312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#a2a792b6cf082b0096ebeeb4edb8d071b">Log_clock_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a7aee16938973ac92a483f8fc14d45312">last_flush_end_time</a></td></tr>
<tr class="memdesc:a7aee16938973ac92a483f8fc14d45312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last flush end time.  <a href="#a7aee16938973ac92a483f8fc14d45312">More...</a><br /></td></tr>
<tr class="separator:a7aee16938973ac92a483f8fc14d45312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0555399c6850f5c0611f5a5f65e0ffc9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a0555399c6850f5c0611f5a5f65e0ffc9">flush_avg_time</a></td></tr>
<tr class="memdesc:a0555399c6850f5c0611f5a5f65e0ffc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushing average time (in microseconds).  <a href="#a0555399c6850f5c0611f5a5f65e0ffc9">More...</a><br /></td></tr>
<tr class="separator:a0555399c6850f5c0611f5a5f65e0ffc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99bda3234f5226036df827a1128c75d"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ae99bda3234f5226036df827a1128c75d">flusher_mutex</a></td></tr>
<tr class="memdesc:ae99bda3234f5226036df827a1128c75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which can be used to pause log flusher thread.  <a href="#ae99bda3234f5226036df827a1128c75d">More...</a><br /></td></tr>
<tr class="separator:ae99bda3234f5226036df827a1128c75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf91f78c5fdbc0e1c11382f994f21f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a0bf91f78c5fdbc0e1c11382f994f21f7">flusher_event</a></td></tr>
<tr class="separator:a0bf91f78c5fdbc0e1c11382f994f21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Log writer thread</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Padding to avoid any dependency between the log flusher and the log writer threads. </p>
</div></td></tr>
<tr class="memitem:aaf99047ab3ebec7da5624a714811e91d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aaf99047ab3ebec7da5624a714811e91d">files_space_id</a></td></tr>
<tr class="memdesc:aaf99047ab3ebec7da5624a714811e91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space id for pages with log blocks.  <a href="#aaf99047ab3ebec7da5624a714811e91d">More...</a><br /></td></tr>
<tr class="separator:aaf99047ab3ebec7da5624a714811e91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648337f379d4952738e78dcd48ab66f6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a648337f379d4952738e78dcd48ab66f6">write_ahead_buf_size</a></td></tr>
<tr class="memdesc:a648337f379d4952738e78dcd48ab66f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of buffer used for the write-ahead (in bytes).  <a href="#a648337f379d4952738e78dcd48ab66f6">More...</a><br /></td></tr>
<tr class="separator:a648337f379d4952738e78dcd48ab66f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60f009f700f6ace386dc2643049ac53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt; <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, 64 *1024 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ad60f009f700f6ace386dc2643049ac53">write_ahead_buf</a></td></tr>
<tr class="memdesc:ad60f009f700f6ace386dc2643049ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned pointer to buffer used for the write-ahead.  <a href="#ad60f009f700f6ace386dc2643049ac53">More...</a><br /></td></tr>
<tr class="separator:ad60f009f700f6ace386dc2643049ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b25b19107e8166327797e15b19296bb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a8b25b19107e8166327797e15b19296bb">write_ahead_end_offset</a></td></tr>
<tr class="memdesc:a8b25b19107e8166327797e15b19296bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Up to this file offset in the log files, the write-ahead has been done or is not required (for any other reason).  <a href="#a8b25b19107e8166327797e15b19296bb">More...</a><br /></td></tr>
<tr class="separator:a8b25b19107e8166327797e15b19296bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1a99822c69919bc22e64411e794896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt; <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, <a class="el" href="os0file_8h.html#a893c38aa3aedd6efa1439b5ec00213f9">OS_FILE_LOG_BLOCK_SIZE</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aac1a99822c69919bc22e64411e794896">file_header_bufs</a></td></tr>
<tr class="memdesc:aac1a99822c69919bc22e64411e794896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned buffers for file headers.  <a href="#aac1a99822c69919bc22e64411e794896">More...</a><br /></td></tr>
<tr class="separator:aac1a99822c69919bc22e64411e794896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb404bcfe8ee5896d8f7498f729ddc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a4bb404bcfe8ee5896d8f7498f729ddc3">current_file_lsn</a></td></tr>
<tr class="memdesc:a4bb404bcfe8ee5896d8f7498f729ddc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some lsn value within the current log file.  <a href="#a4bb404bcfe8ee5896d8f7498f729ddc3">More...</a><br /></td></tr>
<tr class="separator:a4bb404bcfe8ee5896d8f7498f729ddc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3185b476e6f9356fb728add0d71483d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#af3185b476e6f9356fb728add0d71483d">current_file_real_offset</a></td></tr>
<tr class="memdesc:af3185b476e6f9356fb728add0d71483d"><td class="mdescLeft">&#160;</td><td class="mdescRight">File offset for the current_file_lsn.  <a href="#af3185b476e6f9356fb728add0d71483d">More...</a><br /></td></tr>
<tr class="separator:af3185b476e6f9356fb728add0d71483d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b83426b5d6cb024618798c118f6fd7e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a5b83426b5d6cb024618798c118f6fd7e">current_file_end_offset</a></td></tr>
<tr class="memdesc:a5b83426b5d6cb024618798c118f6fd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Up to this file offset we are within the same current log file.  <a href="#a5b83426b5d6cb024618798c118f6fd7e">More...</a><br /></td></tr>
<tr class="separator:a5b83426b5d6cb024618798c118f6fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4836e06f7b854699a9e9069276a5bd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aec4836e06f7b854699a9e9069276a5bd">n_log_ios</a></td></tr>
<tr class="memdesc:aec4836e06f7b854699a9e9069276a5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of performed IO operations (only for printing stats).  <a href="#aec4836e06f7b854699a9e9069276a5bd">More...</a><br /></td></tr>
<tr class="separator:aec4836e06f7b854699a9e9069276a5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676c27f3447f0ca2200910b2fcb685ab"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a676c27f3447f0ca2200910b2fcb685ab">file_size</a></td></tr>
<tr class="memdesc:a676c27f3447f0ca2200910b2fcb685ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of each single log file (expressed in bytes, including file header).  <a href="#a676c27f3447f0ca2200910b2fcb685ab">More...</a><br /></td></tr>
<tr class="separator:a676c27f3447f0ca2200910b2fcb685ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cc058c43c380505372b56a8d5c3584"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a51cc058c43c380505372b56a8d5c3584">n_files</a></td></tr>
<tr class="memdesc:a51cc058c43c380505372b56a8d5c3584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of log files.  <a href="#a51cc058c43c380505372b56a8d5c3584">More...</a><br /></td></tr>
<tr class="separator:a51cc058c43c380505372b56a8d5c3584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a55937cf39deb4fec71ee17dc01dac"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa4a55937cf39deb4fec71ee17dc01dac">files_real_capacity</a></td></tr>
<tr class="memdesc:aa4a55937cf39deb4fec71ee17dc01dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total capacity of all the log files (file_size * n_files), including headers of the log files.  <a href="#aa4a55937cf39deb4fec71ee17dc01dac">More...</a><br /></td></tr>
<tr class="separator:aa4a55937cf39deb4fec71ee17dc01dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa424c9dc0cad641d6797d5b3da7e5f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa424c9dc0cad641d6797d5b3da7e5f77">lsn_capacity_for_writer</a></td></tr>
<tr class="memdesc:aa424c9dc0cad641d6797d5b3da7e5f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity of redo log files for log writer thread.  <a href="#aa424c9dc0cad641d6797d5b3da7e5f77">More...</a><br /></td></tr>
<tr class="separator:aa424c9dc0cad641d6797d5b3da7e5f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597698c22182786bd0ce9beda45db0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa597698c22182786bd0ce9beda45db0a">extra_margin</a></td></tr>
<tr class="memdesc:aa597698c22182786bd0ce9beda45db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this margin is being used, the log writer decides to increase the concurrency_margin to stop new incoming mini-transactions earlier, on bigger margin.  <a href="#aa597698c22182786bd0ce9beda45db0a">More...</a><br /></td></tr>
<tr class="separator:aa597698c22182786bd0ce9beda45db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4c98e542f18c163eafd42d1d3bd8f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a4d4c98e542f18c163eafd42d1d3bd8f0">concurrency_margin_ok</a></td></tr>
<tr class="memdesc:a4d4c98e542f18c163eafd42d1d3bd8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we haven't increased the concurrency_margin since we entered (lsn_capacity_for_margin_inc..lsn_capacity_for_writer] range.  <a href="#a4d4c98e542f18c163eafd42d1d3bd8f0">More...</a><br /></td></tr>
<tr class="separator:a4d4c98e542f18c163eafd42d1d3bd8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056afb4316d4a206059deab9e3204fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a056afb4316d4a206059deab9e3204fae">max_concurrency_margin</a></td></tr>
<tr class="memdesc:a056afb4316d4a206059deab9e3204fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed concurrency_margin.  <a href="#a056afb4316d4a206059deab9e3204fae">More...</a><br /></td></tr>
<tr class="separator:a056afb4316d4a206059deab9e3204fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28574eb32c721766f0af258175b7e9f"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa28574eb32c721766f0af258175b7e9f">writer_mutex</a></td></tr>
<tr class="memdesc:aa28574eb32c721766f0af258175b7e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which can be used to pause log writer thread.  <a href="#aa28574eb32c721766f0af258175b7e9f">More...</a><br /></td></tr>
<tr class="separator:aa28574eb32c721766f0af258175b7e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ab7c03a202c13da983928f806c34cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a66ab7c03a202c13da983928f806c34cd">writer_event</a></td></tr>
<tr class="separator:a66ab7c03a202c13da983928f806c34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Log closer thread</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Padding after section for the log writer thread, to avoid any dependency between the log writer and the log closer threads. </p>
</div></td></tr>
<tr class="memitem:ad2e87f825f77ed27a6451ea96d95efc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ad2e87f825f77ed27a6451ea96d95efc5">closer_event</a></td></tr>
<tr class="memdesc:ad2e87f825f77ed27a6451ea96d95efc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event used by the log closer thread to wait for tasks.  <a href="#ad2e87f825f77ed27a6451ea96d95efc5">More...</a><br /></td></tr>
<tr class="separator:ad2e87f825f77ed27a6451ea96d95efc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad7f3593dd5965a0957392b313e1c09"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a4ad7f3593dd5965a0957392b313e1c09">closer_mutex</a></td></tr>
<tr class="memdesc:a4ad7f3593dd5965a0957392b313e1c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which can be used to pause log closer thread.  <a href="#a4ad7f3593dd5965a0957392b313e1c09">More...</a><br /></td></tr>
<tr class="separator:a4ad7f3593dd5965a0957392b313e1c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Log flusher &lt;=&gt; flush_notifier</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Padding after the log closer thread and before the memory used for communication between the log flusher and notifier threads. </p>
</div></td></tr>
<tr class="memitem:a894d83bbf13543fa188e2c2deb35cbb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a894d83bbf13543fa188e2c2deb35cbb4">flush_notifier_event</a></td></tr>
<tr class="memdesc:a894d83bbf13543fa188e2c2deb35cbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event used by the log flusher thread to notify the log flush notifier thread, that it should proceed with notifying user threads waiting for the advanced flushed_to_disk_lsn (because it has been advanced).  <a href="#a894d83bbf13543fa188e2c2deb35cbb4">More...</a><br /></td></tr>
<tr class="separator:a894d83bbf13543fa188e2c2deb35cbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3fde39d05c04c89af518929ad7f4e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a75c3fde39d05c04c89af518929ad7f4e">current_flush_sig_count</a></td></tr>
<tr class="memdesc:a75c3fde39d05c04c89af518929ad7f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next flushed_to_disk_lsn can be waited using this sig_count.  <a href="#a75c3fde39d05c04c89af518929ad7f4e">More...</a><br /></td></tr>
<tr class="separator:a75c3fde39d05c04c89af518929ad7f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2932c566700d53de92be23e14f26272"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ab2932c566700d53de92be23e14f26272">flush_notifier_mutex</a></td></tr>
<tr class="memdesc:ab2932c566700d53de92be23e14f26272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which can be used to pause log flush notifier thread.  <a href="#ab2932c566700d53de92be23e14f26272">More...</a><br /></td></tr>
<tr class="separator:ab2932c566700d53de92be23e14f26272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Log writer &lt;=&gt; write_notifier</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Padding. </p>
</div></td></tr>
<tr class="memitem:ab5102c6bba6aa4c0f624ae09886c7b7a"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ab5102c6bba6aa4c0f624ae09886c7b7a">write_notifier_mutex</a></td></tr>
<tr class="memdesc:ab5102c6bba6aa4c0f624ae09886c7b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which can be used to pause log write notifier thread.  <a href="#ab5102c6bba6aa4c0f624ae09886c7b7a">More...</a><br /></td></tr>
<tr class="separator:ab5102c6bba6aa4c0f624ae09886c7b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848d08aad642a3aa1982f287039fec0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a848d08aad642a3aa1982f287039fec0d">write_notifier_event</a></td></tr>
<tr class="memdesc:a848d08aad642a3aa1982f287039fec0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event used by the log writer thread to notify the log write notifier thread, that it should proceed with notifying user threads waiting for the advanced write_lsn (because it has been advanced).  <a href="#a848d08aad642a3aa1982f287039fec0d">More...</a><br /></td></tr>
<tr class="separator:a848d08aad642a3aa1982f287039fec0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Maintenance</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a4887251dacf38a068ca05958a5a53f10"><td class="memItemLeft" align="right" valign="top">std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a4887251dacf38a068ca05958a5a53f10">should_stop_threads</a></td></tr>
<tr class="memdesc:a4887251dacf38a068ca05958a5a53f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for stopping the log background threads.  <a href="#a4887251dacf38a068ca05958a5a53f10">More...</a><br /></td></tr>
<tr class="separator:a4887251dacf38a068ca05958a5a53f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73337c783bf59a76f532aad9c782430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ae73337c783bf59a76f532aad9c782430">writer_threads_resume_event</a></td></tr>
<tr class="memdesc:ae73337c783bf59a76f532aad9c782430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event used for pausing the log writer threads.  <a href="#ae73337c783bf59a76f532aad9c782430">More...</a><br /></td></tr>
<tr class="separator:ae73337c783bf59a76f532aad9c782430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56918f4f2fb6b0069fdefa49fedd6038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a56918f4f2fb6b0069fdefa49fedd6038">write_notifier_resume_lsn</a></td></tr>
<tr class="memdesc:a56918f4f2fb6b0069fdefa49fedd6038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for resuming write notifier thread.  <a href="#a56918f4f2fb6b0069fdefa49fedd6038">More...</a><br /></td></tr>
<tr class="separator:a56918f4f2fb6b0069fdefa49fedd6038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79252f8511723a2d9b9faba9d05a7c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a79252f8511723a2d9b9faba9d05a7c3f">flush_notifier_resume_lsn</a></td></tr>
<tr class="memdesc:a79252f8511723a2d9b9faba9d05a7c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for resuming flush notifier thread.  <a href="#a79252f8511723a2d9b9faba9d05a7c3f">More...</a><br /></td></tr>
<tr class="separator:a79252f8511723a2d9b9faba9d05a7c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f01e8f1f1c55a37a802e9d27170eb30"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a1f01e8f1f1c55a37a802e9d27170eb30">n_log_ios_old</a></td></tr>
<tr class="memdesc:a1f01e8f1f1c55a37a802e9d27170eb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of total I/O operations performed when we printed the statistics last time.  <a href="#a1f01e8f1f1c55a37a802e9d27170eb30">More...</a><br /></td></tr>
<tr class="separator:a1f01e8f1f1c55a37a802e9d27170eb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7470f7b80408ac90097ff0c204a7c90"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ae7470f7b80408ac90097ff0c204a7c90">last_printout_time</a></td></tr>
<tr class="memdesc:ae7470f7b80408ac90097ff0c204a7c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wall time when we printed the statistics last time.  <a href="#ae7470f7b80408ac90097ff0c204a7c90">More...</a><br /></td></tr>
<tr class="separator:ae7470f7b80408ac90097ff0c204a7c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recovery</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a07d3b53fb38cb6cc99c7f0b8df19cebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a07d3b53fb38cb6cc99c7f0b8df19cebe">recovered_lsn</a></td></tr>
<tr class="memdesc:a07d3b53fb38cb6cc99c7f0b8df19cebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lsn from which recovery has been started.  <a href="#a07d3b53fb38cb6cc99c7f0b8df19cebe">More...</a><br /></td></tr>
<tr class="separator:a07d3b53fb38cb6cc99c7f0b8df19cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701ef5735c4da29c8bae05d543b10dd7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a701ef5735c4da29c8bae05d543b10dd7">format</a></td></tr>
<tr class="memdesc:a701ef5735c4da29c8bae05d543b10dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format of the redo log: e.g., LOG_HEADER_FORMAT_CURRENT.  <a href="#a701ef5735c4da29c8bae05d543b10dd7">More...</a><br /></td></tr>
<tr class="separator:a701ef5735c4da29c8bae05d543b10dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8089bb98990000aafcb08c3e815e400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#a38cdfe9c2edc7a86a726c941f4c40bf8">log_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ab8089bb98990000aafcb08c3e815e400">state</a></td></tr>
<tr class="memdesc:ab8089bb98990000aafcb08c3e815e400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corruption status.  <a href="#ab8089bb98990000aafcb08c3e815e400">More...</a><br /></td></tr>
<tr class="separator:ab8089bb98990000aafcb08c3e815e400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7e91e0b7f67171d0e35194a3c34705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a9e7e91e0b7f67171d0e35194a3c34705">scanned_lsn</a></td></tr>
<tr class="memdesc:a9e7e91e0b7f67171d0e35194a3c34705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used only in recovery: recovery scan succeeded up to this lsn.  <a href="#a9e7e91e0b7f67171d0e35194a3c34705">More...</a><br /></td></tr>
<tr class="separator:a9e7e91e0b7f67171d0e35194a3c34705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647eb60a7e40004df4c202b1dc6f0490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a647eb60a7e40004df4c202b1dc6f0490">disable_redo_writes</a></td></tr>
<tr class="memdesc:a647eb60a7e40004df4c202b1dc6f0490"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this is set, writing to the redo log should be disabled.  <a href="#a647eb60a7e40004df4c202b1dc6f0490">More...</a><br /></td></tr>
<tr class="separator:a647eb60a7e40004df4c202b1dc6f0490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690cf2e6d00e93a4a4eed613f1653f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a690cf2e6d00e93a4a4eed613f1653f77">first_block_is_correct_for_lsn</a></td></tr>
<tr class="memdesc:a690cf2e6d00e93a4a4eed613f1653f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEBUG only - if we copied or initialized the first block in buffer, this is set to lsn for which we did that.  <a href="#a690cf2e6d00e93a4a4eed613f1653f77">More...</a><br /></td></tr>
<tr class="separator:a690cf2e6d00e93a4a4eed613f1653f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fields protected by the log_limits mutex.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Related to free space in the redo log. </p>
</div></td></tr>
<tr class="memitem:a1b88a61b7b922137401f28aee96ab3f8"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a1b88a61b7b922137401f28aee96ab3f8">limits_mutex</a></td></tr>
<tr class="memdesc:a1b88a61b7b922137401f28aee96ab3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which protects fields: available_for_checkpoint_lsn, requested_checkpoint_lsn.  <a href="#a1b88a61b7b922137401f28aee96ab3f8">More...</a><br /></td></tr>
<tr class="separator:a1b88a61b7b922137401f28aee96ab3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb18e55e4a89144d6bc68a1a71ac350f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aeb18e55e4a89144d6bc68a1a71ac350f">available_for_checkpoint_lsn</a></td></tr>
<tr class="memdesc:aeb18e55e4a89144d6bc68a1a71ac350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A new checkpoint could be written for this lsn value.  <a href="#aeb18e55e4a89144d6bc68a1a71ac350f">More...</a><br /></td></tr>
<tr class="separator:aeb18e55e4a89144d6bc68a1a71ac350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4fcc19e1730b46e8bb45fadd1a3119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a7d4fcc19e1730b46e8bb45fadd1a3119">requested_checkpoint_lsn</a></td></tr>
<tr class="memdesc:a7d4fcc19e1730b46e8bb45fadd1a3119"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this is larger than the latest checkpoint, the log checkpointer thread will be forced to write a new checkpoint (unless the new latest checkpoint lsn would still be smaller than this value).  <a href="#a7d4fcc19e1730b46e8bb45fadd1a3119">More...</a><br /></td></tr>
<tr class="separator:a7d4fcc19e1730b46e8bb45fadd1a3119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b52f2529bfc6a7974e523a17df86559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a0b52f2529bfc6a7974e523a17df86559">dict_max_allowed_checkpoint_lsn</a></td></tr>
<tr class="memdesc:a0b52f2529bfc6a7974e523a17df86559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum lsn allowed for checkpoint by dict_persist or zero.  <a href="#a0b52f2529bfc6a7974e523a17df86559">More...</a><br /></td></tr>
<tr class="separator:a0b52f2529bfc6a7974e523a17df86559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b506fd03fc45c00191b051c838dbf1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a1b506fd03fc45c00191b051c838dbf1e">periodical_checkpoints_enabled</a></td></tr>
<tr class="memdesc:a1b506fd03fc45c00191b051c838dbf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If should perform checkpoints every innodb_log_checkpoint_every ms.  <a href="#a1b506fd03fc45c00191b051c838dbf1e">More...</a><br /></td></tr>
<tr class="separator:a1b506fd03fc45c00191b051c838dbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824293f4ce603643c1a07ac7f55d4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ad824293f4ce603643c1a07ac7f55d4ea">free_check_limit_sn</a></td></tr>
<tr class="memdesc:ad824293f4ce603643c1a07ac7f55d4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum sn up to which there is free space in the redo log.  <a href="#ad824293f4ce603643c1a07ac7f55d4ea">More...</a><br /></td></tr>
<tr class="separator:ad824293f4ce603643c1a07ac7f55d4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50243d29b71a2fe13c25b63c1370c87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a50243d29b71a2fe13c25b63c1370c87b">concurrency_margin</a></td></tr>
<tr class="memdesc:a50243d29b71a2fe13c25b63c1370c87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Margin used in calculation of.  <a href="#a50243d29b71a2fe13c25b63c1370c87b">More...</a><br /></td></tr>
<tr class="separator:a50243d29b71a2fe13c25b63c1370c87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab25985c47d257257496b083b5c4dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#adab25985c47d257257496b083b5c4dd5">dict_persist_margin</a></td></tr>
<tr class="memdesc:adab25985c47d257257496b083b5c4dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Margin used in calculation of.  <a href="#adab25985c47d257257496b083b5c4dd5">More...</a><br /></td></tr>
<tr class="separator:adab25985c47d257257496b083b5c4dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Log checkpointer thread</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a3aa380c42873f3e3920965137f757973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3aa380c42873f3e3920965137f757973">checkpointer_event</a></td></tr>
<tr class="memdesc:a3aa380c42873f3e3920965137f757973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event used by the log checkpointer thread to wait for requests.  <a href="#a3aa380c42873f3e3920965137f757973">More...</a><br /></td></tr>
<tr class="separator:a3aa380c42873f3e3920965137f757973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f68c0842b2702e9272d97fb59bfd2"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a2d5f68c0842b2702e9272d97fb59bfd2">checkpointer_mutex</a></td></tr>
<tr class="memdesc:a2d5f68c0842b2702e9272d97fb59bfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex which can be used to pause log checkpointer thread.  <a href="#a2d5f68c0842b2702e9272d97fb59bfd2">More...</a><br /></td></tr>
<tr class="separator:a2d5f68c0842b2702e9272d97fb59bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca6b9944c4e4e330e3b9c317ac98ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a9ca6b9944c4e4e330e3b9c317ac98ee5">last_checkpoint_lsn</a></td></tr>
<tr class="memdesc:a9ca6b9944c4e4e330e3b9c317ac98ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latest checkpoint lsn.  <a href="#a9ca6b9944c4e4e330e3b9c317ac98ee5">More...</a><br /></td></tr>
<tr class="separator:a9ca6b9944c4e4e330e3b9c317ac98ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ab668ea71b294ac6dac122f32476cd"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="log0types_8h.html#a0639412909d27380307488ac5cd2af5e">checkpoint_no_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a37ab668ea71b294ac6dac122f32476cd">next_checkpoint_no</a></td></tr>
<tr class="memdesc:a37ab668ea71b294ac6dac122f32476cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next checkpoint number.  <a href="#a37ab668ea71b294ac6dac122f32476cd">More...</a><br /></td></tr>
<tr class="separator:a37ab668ea71b294ac6dac122f32476cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b64271bb7dd4ca8904c73b4f09b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#a2a792b6cf082b0096ebeeb4edb8d071b">Log_clock_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a008b64271bb7dd4ca8904c73b4f09b28">last_checkpoint_time</a></td></tr>
<tr class="memdesc:a008b64271bb7dd4ca8904c73b4f09b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latest checkpoint wall time.  <a href="#a008b64271bb7dd4ca8904c73b4f09b28">More...</a><br /></td></tr>
<tr class="separator:a008b64271bb7dd4ca8904c73b4f09b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac051e7dc3a2a142769e5a1aa848001ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt; <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, <a class="el" href="os0file_8h.html#a893c38aa3aedd6efa1439b5ec00213f9">OS_FILE_LOG_BLOCK_SIZE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ac051e7dc3a2a142769e5a1aa848001ba">checkpoint_buf</a></td></tr>
<tr class="memdesc:ac051e7dc3a2a142769e5a1aa848001ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned buffer used for writing a checkpoint header.  <a href="#ac051e7dc3a2a142769e5a1aa848001ba">More...</a><br /></td></tr>
<tr class="separator:ac051e7dc3a2a142769e5a1aa848001ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fields considered constant, updated when log system</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>is initialized (log_sys_init()) and not assigned to particular log thread. </p>
</div></td></tr>
<tr class="memitem:a07e03b38bcb0a37475e82cfc5c6fd5ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a07e03b38bcb0a37475e82cfc5c6fd5ca">lsn_capacity_for_free_check</a></td></tr>
<tr class="memdesc:a07e03b38bcb0a37475e82cfc5c6fd5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity of the log files available for log_free_check().  <a href="#a07e03b38bcb0a37475e82cfc5c6fd5ca">More...</a><br /></td></tr>
<tr class="separator:a07e03b38bcb0a37475e82cfc5c6fd5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe510eb5b0126ae44184fde9ddde5eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#afe510eb5b0126ae44184fde9ddde5eed">lsn_real_capacity</a></td></tr>
<tr class="memdesc:afe510eb5b0126ae44184fde9ddde5eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity of log files excluding headers of the log files.  <a href="#afe510eb5b0126ae44184fde9ddde5eed">More...</a><br /></td></tr>
<tr class="separator:afe510eb5b0126ae44184fde9ddde5eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508fcd6f26bca33415f08e5868b2c4ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a508fcd6f26bca33415f08e5868b2c4ee">max_modified_age_async</a></td></tr>
<tr class="memdesc:a508fcd6f26bca33415f08e5868b2c4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the oldest dirty page age exceeds this value, we start an asynchronous preflush of dirty pages.  <a href="#a508fcd6f26bca33415f08e5868b2c4ee">More...</a><br /></td></tr>
<tr class="separator:a508fcd6f26bca33415f08e5868b2c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34eabc85eb4e135f48864703a45f61e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa34eabc85eb4e135f48864703a45f61e">max_modified_age_sync</a></td></tr>
<tr class="memdesc:aa34eabc85eb4e135f48864703a45f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the oldest dirty page age exceeds this value, we start a synchronous flush of dirty pages.  <a href="#aa34eabc85eb4e135f48864703a45f61e">More...</a><br /></td></tr>
<tr class="separator:aa34eabc85eb4e135f48864703a45f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3cb67692ef173533a0da3103f330fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3d3cb67692ef173533a0da3103f330fd">max_checkpoint_age_async</a></td></tr>
<tr class="memdesc:a3d3cb67692ef173533a0da3103f330fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">When checkpoint age exceeds this value, we write checkpoints if lag between oldest_lsn and checkpoint_lsn exceeds max_checkpoint_lag.  <a href="#a3d3cb67692ef173533a0da3103f330fd">More...</a><br /></td></tr>
<tr class="separator:a3d3cb67692ef173533a0da3103f330fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Redo log - single data structure with state of the redo log system. </p>
<p>In future, one could consider splitting this to multiple data structures. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="aeb18e55e4a89144d6bc68a1a71ac350f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb18e55e4a89144d6bc68a1a71ac350f">&#9670;&nbsp;</a></span>available_for_checkpoint_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::available_for_checkpoint_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A new checkpoint could be written for this lsn value. </p>
<p>Up to this lsn value, all dirty pages have been added to flush lists and flushed. Updated in the log checkpointer thread by takingminimum oldest_modification out of the last dirty pages from each flush list. However it will not be bigger than the current value of log.buf_dirty_pages_added_up_to_lsn. Read by: user threads when requesting fuzzy checkpoint Read by: log_print() (printing status of redo) Updated by: log_checkpointer Protected by: limits_mutex. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_available_for_checkpoint_lsn">subsect_redo_log_available_for_checkpoint_lsn</a> </dd></dl>

</div>
</div>
<a id="a2dda509bce7dc8ef313f58424b639f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dda509bce7dc8ef313f58424b639f9c">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt;<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, <a class="el" href="os0file_8h.html#a893c38aa3aedd6efa1439b5ec00213f9">OS_FILE_LOG_BLOCK_SIZE</a>&gt; log_t::buf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Padding after the _sn to avoid false sharing issues for constants below (due to changes of sn). </p>
<p>Pointer to the log buffer, aligned up to OS_FILE_LOG_BLOCK_SIZE. The alignment is to ensure that buffer parts specified for file IO write operations will be aligned to sector size, which is required e.g. on Windows when doing unbuffered file access. Protected by: locking sn not to add. </p>

</div>
</div>
<a id="a528838ad52c9d7b435b3daf69ed1d514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528838ad52c9d7b435b3daf69ed1d514">&#9670;&nbsp;</a></span>buf_limit_sn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a> log_t::buf_limit_sn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum sn up to which there is free space in both the log buffer and the log files. </p>
<p>This is limitation for the end of any write to the log buffer. Threads, which are limited need to wait, and possibly they hold latches of dirty pages making a deadlock possible. Protected by: writer_mutex (writes). </p>

</div>
</div>
<a id="ad43957d37df1079a214194e10b9ce54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43957d37df1079a214194e10b9ce54a">&#9670;&nbsp;</a></span>buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t log_t::buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the log buffer expressed in number of total bytes, that is including bytes for headers and footers of log blocks. </p>

</div>
</div>
<a id="a3174a2151ee9f35c716eb6781f8594e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3174a2151ee9f35c716eb6781f8594e0">&#9670;&nbsp;</a></span>buf_size_sn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a> log_t::buf_size_sn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the log buffer expressed in number of data bytes, that is excluding bytes for headers and footers of log blocks. </p>

</div>
</div>
<a id="ac051e7dc3a2a142769e5a1aa848001ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac051e7dc3a2a142769e5a1aa848001ba">&#9670;&nbsp;</a></span>checkpoint_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt;<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, <a class="el" href="os0file_8h.html#a893c38aa3aedd6efa1439b5ec00213f9">OS_FILE_LOG_BLOCK_SIZE</a>&gt; log_t::checkpoint_buf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned buffer used for writing a checkpoint header. </p>
<p>It is aligned similarly to log.buf. Used by (private): log_checkpointer, recovery code </p>

</div>
</div>
<a id="a3aa380c42873f3e3920965137f757973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa380c42873f3e3920965137f757973">&#9670;&nbsp;</a></span>checkpointer_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::checkpointer_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event used by the log checkpointer thread to wait for requests. </p>

</div>
</div>
<a id="a2d5f68c0842b2702e9272d97fb59bfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5f68c0842b2702e9272d97fb59bfd2">&#9670;&nbsp;</a></span>checkpointer_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::checkpointer_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which can be used to pause log checkpointer thread. </p>
<p>This is used by log_position_lock() together with log_buffer_x_lock(), to pause any changes to current_lsn or last_checkpoint_lsn. </p>

</div>
</div>
<a id="ad2e87f825f77ed27a6451ea96d95efc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e87f825f77ed27a6451ea96d95efc5">&#9670;&nbsp;</a></span>closer_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::closer_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event used by the log closer thread to wait for tasks. </p>

</div>
</div>
<a id="a4ad7f3593dd5965a0957392b313e1c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad7f3593dd5965a0957392b313e1c09">&#9670;&nbsp;</a></span>closer_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::closer_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which can be used to pause log closer thread. </p>

</div>
</div>
<a id="a50243d29b71a2fe13c25b63c1370c87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50243d29b71a2fe13c25b63c1370c87b">&#9670;&nbsp;</a></span>concurrency_margin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a> log_t::concurrency_margin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Margin used in calculation of. </p>
<dl class="section see"><dt>See also</dt><dd>free_check_limit_sn. Read by: page_cleaners, log_checkpointer Updated by: log_writer Protected by (updates only): limits_mutex. </dd></dl>

</div>
</div>
<a id="a4d4c98e542f18c163eafd42d1d3bd8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4c98e542f18c163eafd42d1d3bd8f0">&#9670;&nbsp;</a></span>concurrency_margin_ok</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> log_t::concurrency_margin_ok</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if we haven't increased the concurrency_margin since we entered (lsn_capacity_for_margin_inc..lsn_capacity_for_writer] range. </p>
<p>This allows to increase the margin only once per issue and wait until the issue becomes resolved, still having an option to increase margin even more, if new issue comes later. </p>

</div>
</div>
<a id="a5b83426b5d6cb024618798c118f6fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b83426b5d6cb024618798c118f6fd7e">&#9670;&nbsp;</a></span>current_file_end_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t log_t::current_file_end_offset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Up to this file offset we are within the same current log file. </p>

</div>
</div>
<a id="a4bb404bcfe8ee5896d8f7498f729ddc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb404bcfe8ee5896d8f7498f729ddc3">&#9670;&nbsp;</a></span>current_file_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::current_file_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some lsn value within the current log file. </p>

</div>
</div>
<a id="af3185b476e6f9356fb728add0d71483d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3185b476e6f9356fb728add0d71483d">&#9670;&nbsp;</a></span>current_file_real_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t log_t::current_file_real_offset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File offset for the current_file_lsn. </p>

</div>
</div>
<a id="a75c3fde39d05c04c89af518929ad7f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c3fde39d05c04c89af518929ad7f4e">&#9670;&nbsp;</a></span>current_flush_sig_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t log_t::current_flush_sig_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The next flushed_to_disk_lsn can be waited using this sig_count. </p>

</div>
</div>
<a id="a75e1d8d6d3f43c7b9e5071ef6eb58853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e1d8d6d3f43c7b9e5071ef6eb58853">&#9670;&nbsp;</a></span>current_ready_waiting_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::current_ready_waiting_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some threads waiting for the ready for write lsn by closer_event. </p>

</div>
</div>
<a id="a3ac533ce8887732178b8863fc49186f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac533ce8887732178b8863fc49186f1">&#9670;&nbsp;</a></span>current_ready_waiting_sig_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t log_t::current_ready_waiting_sig_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>current_ready_waiting_lsn is waited using this sig_count. </p>

</div>
</div>
<a id="a0b52f2529bfc6a7974e523a17df86559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b52f2529bfc6a7974e523a17df86559">&#9670;&nbsp;</a></span>dict_max_allowed_checkpoint_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::dict_max_allowed_checkpoint_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum lsn allowed for checkpoint by dict_persist or zero. </p>
<p>This will be set by dict_persist_to_dd_table_buffer(), which should be always called before really making a checkpoint. If non-zero, up to this lsn value, dynamic metadata changes have been written back to mysql.innodb_dynamic_metadata under dict_persist-&gt;mutex protection. All dynamic metadata changes after this lsn have to be kept in redo logs, but not discarded. If zero, just ignore it. Updated by: DD (when persisting dynamic meta data) Updated by: log_checkpointer (reset when checkpoint is written) Protected by: limits_mutex. </p>

</div>
</div>
<a id="adab25985c47d257257496b083b5c4dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab25985c47d257257496b083b5c4dd5">&#9670;&nbsp;</a></span>dict_persist_margin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a> log_t::dict_persist_margin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Margin used in calculation of. </p>
<dl class="section see"><dt>See also</dt><dd>free_check_limit_sn. Read by: page_cleaners, log_checkpointer Updated by: DD Protected by (updates only): limits_mutex. </dd></dl>

</div>
</div>
<a id="a647eb60a7e40004df4c202b1dc6f0490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647eb60a7e40004df4c202b1dc6f0490">&#9670;&nbsp;</a></span>disable_redo_writes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> log_t::disable_redo_writes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When this is set, writing to the redo log should be disabled. </p>
<p>We check for this in functions that write to the redo log. </p>

</div>
</div>
<a id="aa597698c22182786bd0ce9beda45db0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa597698c22182786bd0ce9beda45db0a">&#9670;&nbsp;</a></span>extra_margin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::extra_margin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When this margin is being used, the log writer decides to increase the concurrency_margin to stop new incoming mini-transactions earlier, on bigger margin. </p>
<p>This is used to provide adaptive concurrency margin calculation, which we need because we might have unlimited thread concurrency setting or we could miss some log_free_check() calls. It is just best effort to help getting out of the troubles. </p>

</div>
</div>
<a id="aac1a99822c69919bc22e64411e794896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1a99822c69919bc22e64411e794896">&#9670;&nbsp;</a></span>file_header_bufs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt;<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, <a class="el" href="os0file_8h.html#a893c38aa3aedd6efa1439b5ec00213f9">OS_FILE_LOG_BLOCK_SIZE</a>&gt;* log_t::file_header_bufs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned buffers for file headers. </p>

</div>
</div>
<a id="a676c27f3447f0ca2200910b2fcb685ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676c27f3447f0ca2200910b2fcb685ab">&#9670;&nbsp;</a></span>file_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t log_t::file_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of each single log file (expressed in bytes, including file header). </p>

</div>
</div>
<a id="aa4a55937cf39deb4fec71ee17dc01dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a55937cf39deb4fec71ee17dc01dac">&#9670;&nbsp;</a></span>files_real_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t log_t::files_real_capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total capacity of all the log files (file_size * n_files), including headers of the log files. </p>

</div>
</div>
<a id="aaf99047ab3ebec7da5624a714811e91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf99047ab3ebec7da5624a714811e91d">&#9670;&nbsp;</a></span>files_space_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> log_t::files_space_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Space id for pages with log blocks. </p>

</div>
</div>
<a id="a690cf2e6d00e93a4a4eed613f1653f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690cf2e6d00e93a4a4eed613f1653f77">&#9670;&nbsp;</a></span>first_block_is_correct_for_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::first_block_is_correct_for_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEBUG only - if we copied or initialized the first block in buffer, this is set to lsn for which we did that. </p>
<p>We later ensure that we start the redo log at the same lsn. Else it is zero and we would crash when trying to start redo then. </p>

</div>
</div>
<a id="a0555399c6850f5c0611f5a5f65e0ffc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0555399c6850f5c0611f5a5f65e0ffc9">&#9670;&nbsp;</a></span>flush_avg_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double log_t::flush_avg_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushing average time (in microseconds). </p>

</div>
</div>
<a id="aa695ec86ef978a60b4d6a2c388e330e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa695ec86ef978a60b4d6a2c388e330e5">&#9670;&nbsp;</a></span>flush_events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>* log_t::flush_events</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned pointer to array with events, which are used for notifications sent from the log flush notifier thread to user threads. </p>
<p>The notifications are sent when flushed_to_disk_lsn is advanced. User threads wait for flushed_to_disk_lsn &gt;= lsn, for some lsn. Log flusher advances the flushed_to_disk_lsn and notifies the log flush notifier, which notifies all users interested in nearby lsn values (lsn belonging to the same log block). Note that false wake-ups are possible, in which case user threads simply retry waiting. </p>

</div>
</div>
<a id="a9f550296c4fa1d14f25f42abb9bad1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f550296c4fa1d14f25f42abb9bad1dd">&#9670;&nbsp;</a></span>flush_events_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t log_t::flush_events_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of entries in the array with events. </p>

</div>
</div>
<a id="a894d83bbf13543fa188e2c2deb35cbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894d83bbf13543fa188e2c2deb35cbb4">&#9670;&nbsp;</a></span>flush_notifier_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::flush_notifier_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event used by the log flusher thread to notify the log flush notifier thread, that it should proceed with notifying user threads waiting for the advanced flushed_to_disk_lsn (because it has been advanced). </p>

</div>
</div>
<a id="ab2932c566700d53de92be23e14f26272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2932c566700d53de92be23e14f26272">&#9670;&nbsp;</a></span>flush_notifier_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::flush_notifier_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which can be used to pause log flush notifier thread. </p>

</div>
</div>
<a id="a79252f8511723a2d9b9faba9d05a7c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79252f8511723a2d9b9faba9d05a7c3f">&#9670;&nbsp;</a></span>flush_notifier_resume_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a> log_t::flush_notifier_resume_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for resuming flush notifier thread. </p>

</div>
</div>
<a id="ab1896732495682b34be952a8bf127a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1896732495682b34be952a8bf127a6c">&#9670;&nbsp;</a></span>flushed_to_disk_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a> log_t::flushed_to_disk_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Padding before the frequently updated flushed_to_disk_lsn. </p>
<p>Up to this lsn data has been flushed to disk (fsynced). </p>

</div>
</div>
<a id="a0bf91f78c5fdbc0e1c11382f994f21f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf91f78c5fdbc0e1c11382f994f21f7">&#9670;&nbsp;</a></span>flusher_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::flusher_event</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae99bda3234f5226036df827a1128c75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99bda3234f5226036df827a1128c75d">&#9670;&nbsp;</a></span>flusher_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::flusher_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which can be used to pause log flusher thread. </p>

</div>
</div>
<a id="a701ef5735c4da29c8bae05d543b10dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701ef5735c4da29c8bae05d543b10dd7">&#9670;&nbsp;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t log_t::format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format of the redo log: e.g., LOG_HEADER_FORMAT_CURRENT. </p>

</div>
</div>
<a id="ad824293f4ce603643c1a07ac7f55d4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad824293f4ce603643c1a07ac7f55d4ea">&#9670;&nbsp;</a></span>free_check_limit_sn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a> log_t::free_check_limit_sn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum sn up to which there is free space in the redo log. </p>
<p>Threads check this limit and compare to current log.sn, when they are outside mini-transactions and hold no latches. The formula used to compute the limitation takes into account maximum size of mtr and thread concurrency to include proper margins and avoid issues with race condition (in which all threads check the limitation and then all proceed with their mini-transactions). Also extra margin is there for dd table buffer cache (dict_persist_margin). Read by: user threads (log_free_check()) Updated by: log_checkpointer (after update of checkpoint_lsn) Updated by: log_writer (after increasing concurrency_margin) Updated by: DD (after update of dict_persist_margin) Protected by (updates only): limits_mutex. </p>

</div>
</div>
<a id="a9ca6b9944c4e4e330e3b9c317ac98ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca6b9944c4e4e330e3b9c317ac98ee5">&#9670;&nbsp;</a></span>last_checkpoint_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a> log_t::last_checkpoint_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Latest checkpoint lsn. </p>
<p>Read by: user threads, log_print (no protection) Read by: log_writer (under writer_mutex) Updated by: log_checkpointer (under both mutexes) Protected by (updates only): checkpointer_mutex + writer_mutex. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_last_checkpoint_lsn">log.last_checkpoint_lsn</a> </dd></dl>

</div>
</div>
<a id="a008b64271bb7dd4ca8904c73b4f09b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b64271bb7dd4ca8904c73b4f09b28">&#9670;&nbsp;</a></span>last_checkpoint_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#a2a792b6cf082b0096ebeeb4edb8d071b">Log_clock_point</a> log_t::last_checkpoint_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Latest checkpoint wall time. </p>
<p>Used by (private): log_checkpointer. </p>

</div>
</div>
<a id="a7aee16938973ac92a483f8fc14d45312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aee16938973ac92a483f8fc14d45312">&#9670;&nbsp;</a></span>last_flush_end_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#a2a792b6cf082b0096ebeeb4edb8d071b">Log_clock_point</a> log_t::last_flush_end_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Last flush end time. </p>
<p>Updated just after fsync is finished. If smaller than start time, then flush operation is pending. </p>

</div>
</div>
<a id="a35dbb4ebc32e3aa50a3d98bb09b7b4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dbb4ebc32e3aa50a3d98bb09b7b4ba">&#9670;&nbsp;</a></span>last_flush_start_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#a2a792b6cf082b0096ebeeb4edb8d071b">Log_clock_point</a> log_t::last_flush_start_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Last flush start time. </p>
<p>Updated just before fsync starts. </p>

</div>
</div>
<a id="ae7470f7b80408ac90097ff0c204a7c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7470f7b80408ac90097ff0c204a7c90">&#9670;&nbsp;</a></span>last_printout_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t log_t::last_printout_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wall time when we printed the statistics last time. </p>

</div>
</div>
<a id="a1b88a61b7b922137401f28aee96ab3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b88a61b7b922137401f28aee96ab3f8">&#9670;&nbsp;</a></span>limits_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::limits_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which protects fields: available_for_checkpoint_lsn, requested_checkpoint_lsn. </p>
<p>It also synchronizes updates of: free_check_limit_sn, concurrency_margin and dict_persist_margin. It also protects the srv_checkpoint_disabled (together with the checkpointer_mutex). </p>

</div>
</div>
<a id="a07e03b38bcb0a37475e82cfc5c6fd5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e03b38bcb0a37475e82cfc5c6fd5ca">&#9670;&nbsp;</a></span>lsn_capacity_for_free_check</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::lsn_capacity_for_free_check</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capacity of the log files available for log_free_check(). </p>

</div>
</div>
<a id="aa424c9dc0cad641d6797d5b3da7e5f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa424c9dc0cad641d6797d5b3da7e5f77">&#9670;&nbsp;</a></span>lsn_capacity_for_writer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::lsn_capacity_for_writer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capacity of redo log files for log writer thread. </p>
<p>The log writer does not to exceed this value. If space is not reclaimed after 1 sec wait, it writes only as much as can fit the free space or crashes if there is no free space at all (checkpoint did not advance for 1 sec). </p>

</div>
</div>
<a id="afe510eb5b0126ae44184fde9ddde5eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe510eb5b0126ae44184fde9ddde5eed">&#9670;&nbsp;</a></span>lsn_real_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::lsn_real_capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capacity of log files excluding headers of the log files. </p>
<p>If the checkpoint age exceeds this, it is a serious error, because in such case we have already overwritten redo log. </p>

</div>
</div>
<a id="a9eb456c4ab1524d24e8a258ee27e046f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb456c4ab1524d24e8a258ee27e046f">&#9670;&nbsp;</a></span>m_crash_unsafe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> log_t::m_crash_unsafe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true, if server is not recoverable. </p>
<p>Read and write with writer_mutex </p>

</div>
</div>
<a id="aa36178a39193339ae5cb96be4dcd2cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36178a39193339ae5cb96be4dcd2cfc">&#9670;&nbsp;</a></span>m_disable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> log_t::m_disable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true if redo logging is disabled. </p>
<p>Read and write with writer_mutex </p>

</div>
</div>
<a id="a3b2fe8916f029e6749fdc11369c875aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2fe8916f029e6749fdc11369c875aa">&#9670;&nbsp;</a></span>m_first_file_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::m_first_file_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>start LSN of first redo log file. </p>

</div>
</div>
<a id="a3d3cb67692ef173533a0da3103f330fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3cb67692ef173533a0da3103f330fd">&#9670;&nbsp;</a></span>max_checkpoint_age_async</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::max_checkpoint_age_async</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When checkpoint age exceeds this value, we write checkpoints if lag between oldest_lsn and checkpoint_lsn exceeds max_checkpoint_lag. </p>

</div>
</div>
<a id="a056afb4316d4a206059deab9e3204fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056afb4316d4a206059deab9e3204fae">&#9670;&nbsp;</a></span>max_concurrency_margin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::max_concurrency_margin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum allowed concurrency_margin. </p>
<p>We never set higher, even when we increase the concurrency_margin in the adaptive solution. </p>

</div>
</div>
<a id="a508fcd6f26bca33415f08e5868b2c4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508fcd6f26bca33415f08e5868b2c4ee">&#9670;&nbsp;</a></span>max_modified_age_async</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::max_modified_age_async</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When the oldest dirty page age exceeds this value, we start an asynchronous preflush of dirty pages. </p>

</div>
</div>
<a id="aa34eabc85eb4e135f48864703a45f61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34eabc85eb4e135f48864703a45f61e">&#9670;&nbsp;</a></span>max_modified_age_sync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::max_modified_age_sync</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When the oldest dirty page age exceeds this value, we start a synchronous flush of dirty pages. </p>

</div>
</div>
<a id="a51cc058c43c380505372b56a8d5c3584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cc058c43c380505372b56a8d5c3584">&#9670;&nbsp;</a></span>n_files</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t log_t::n_files</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of log files. </p>

</div>
</div>
<a id="aec4836e06f7b854699a9e9069276a5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4836e06f7b854699a9e9069276a5bd">&#9670;&nbsp;</a></span>n_log_ios</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t log_t::n_log_ios</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of performed IO operations (only for printing stats). </p>

</div>
</div>
<a id="a1f01e8f1f1c55a37a802e9d27170eb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f01e8f1f1c55a37a802e9d27170eb30">&#9670;&nbsp;</a></span>n_log_ios_old</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t log_t::n_log_ios_old</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of total I/O operations performed when we printed the statistics last time. </p>

</div>
</div>
<a id="a37ab668ea71b294ac6dac122f32476cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ab668ea71b294ac6dac122f32476cd">&#9670;&nbsp;</a></span>next_checkpoint_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="log0types_8h.html#a0639412909d27380307488ac5cd2af5e">checkpoint_no_t</a>&gt; log_t::next_checkpoint_no</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next checkpoint number. </p>
<p>Read by: log_get_last_block (no protection) Read by: log_writer (under writer_mutex) Updated by: log_checkpointer (under both mutexes) Protected by: checkpoint_mutex + writer_mutex. </p>

</div>
</div>
<a id="ab4f3b7405baa60d905b3af75b139ff75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f3b7405baa60d905b3af75b139ff75">&#9670;&nbsp;</a></span>old_flush_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::old_flush_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This event is in the reset state when a flush is running; a thread should wait for this without owning any of redo mutexes, but NOTE that to reset this event, the thread MUST own the writer_mutex. </p>

</div>
</div>
<a id="a1b506fd03fc45c00191b051c838dbf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b506fd03fc45c00191b051c838dbf1e">&#9670;&nbsp;</a></span>periodical_checkpoints_enabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> log_t::periodical_checkpoints_enabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If should perform checkpoints every innodb_log_checkpoint_every ms. </p>
<p>Disabled during startup / shutdown. Enabled in srv_start_threads. Updated by: starting thread (srv_start_threads) Read by: log_checkpointer </p>

</div>
</div>
<a id="a8b34ce638948350a6a05bf01e06976ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b34ce638948350a6a05bf01e06976ea">&#9670;&nbsp;</a></span>pfs_psi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__psi__abi__rwlock.html#gaed6f27d4e7ccbaf85f850a72d6ac03c0">PSI_rwlock</a>* log_t::pfs_psi</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The instrumentation hook. </p>

</div>
</div>
<a id="af629cb14bdcce47d7b1aab7f3b512c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af629cb14bdcce47d7b1aab7f3b512c68">&#9670;&nbsp;</a></span>recent_closed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLink__buf.html">Link_buf</a>&lt;<a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&gt; log_t::recent_closed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The recent closed buffer. </p>
<p>Protected by: locking sn not to add. </p>

</div>
</div>
<a id="aebfd700a83392ade91b3cde44ec92e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfd700a83392ade91b3cde44ec92e96">&#9670;&nbsp;</a></span>recent_written</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLink__buf.html">Link_buf</a>&lt;<a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&gt; log_t::recent_written</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The recent written buffer. </p>
<p>Protected by: locking sn not to add. </p>

</div>
</div>
<a id="a07d3b53fb38cb6cc99c7f0b8df19cebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d3b53fb38cb6cc99c7f0b8df19cebe">&#9670;&nbsp;</a></span>recovered_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::recovered_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lsn from which recovery has been started. </p>

</div>
</div>
<a id="a7d4fcc19e1730b46e8bb45fadd1a3119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4fcc19e1730b46e8bb45fadd1a3119">&#9670;&nbsp;</a></span>requested_checkpoint_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::requested_checkpoint_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When this is larger than the latest checkpoint, the log checkpointer thread will be forced to write a new checkpoint (unless the new latest checkpoint lsn would still be smaller than this value). </p>
<p>Read by: log_checkpointer Updated by: user threads (log_free_check() or for sharp checkpoint) Protected by: limits_mutex. </p>

</div>
</div>
<a id="a9e7e91e0b7f67171d0e35194a3c34705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7e91e0b7f67171d0e35194a3c34705">&#9670;&nbsp;</a></span>scanned_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_t::scanned_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used only in recovery: recovery scan succeeded up to this lsn. </p>

</div>
</div>
<a id="a4887251dacf38a068ca05958a5a53f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4887251dacf38a068ca05958a5a53f10">&#9670;&nbsp;</a></span>should_stop_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_bool log_t::should_stop_threads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for stopping the log background threads. </p>

</div>
</div>
<a id="a1286ead9c1a609bf48d74d55b97dbff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1286ead9c1a609bf48d74d55b97dbff3">&#9670;&nbsp;</a></span>sn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a> log_t::sn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current sn value. </p>
<p>Used to reserve space in the redo log, and used to acquire an exclusive access to the log buffer. Represents number of data bytes that have ever been reserved. Bytes of headers and footers of log blocks are not included. Its highest bit is used for locking the access to the log buffer. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_sn">log.sn</a> </dd></dl>

</div>
</div>
<a id="a299b04dc56085293d2305a9877180362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299b04dc56085293d2305a9877180362">&#9670;&nbsp;</a></span>sn_lock_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::sn_lock_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event used for locking sn. </p>

</div>
</div>
<a id="ae206251ce25625b0205d3950f9977745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae206251ce25625b0205d3950f9977745">&#9670;&nbsp;</a></span>sn_lock_inst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>* log_t::sn_lock_inst</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rw_lock instance only for the debug info list. </p>

</div>
</div>
<a id="a3ec8391de916e4e99c6f0ba54155b240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec8391de916e4e99c6f0ba54155b240">&#9670;&nbsp;</a></span>sn_locked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#abeeb3cbeac33a858af9c5b45f3937e0e">atomic_sn_t</a> log_t::sn_locked</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intended sn value while x-locked. </p>

</div>
</div>
<a id="ad03b3462e3a7d756a336874046455e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03b3462e3a7d756a336874046455e37">&#9670;&nbsp;</a></span>sn_x_lock_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::sn_x_lock_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which can be used for x-lock sn value. </p>

</div>
</div>
<a id="ab8089bb98990000aafcb08c3e815e400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8089bb98990000aafcb08c3e815e400">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#a38cdfe9c2edc7a86a726c941f4c40bf8">log_state_t</a> log_t::state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Corruption status. </p>

</div>
</div>
<a id="ad60f009f700f6ace386dc2643049ac53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60f009f700f6ace386dc2643049ac53">&#9670;&nbsp;</a></span>write_ahead_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer</a>&lt;<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>, 64 * 1024&gt; log_t::write_ahead_buf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned pointer to buffer used for the write-ahead. </p>
<p>It is aligned to system page size (why?) and is currently limited by constant 64KB. </p>

</div>
</div>
<a id="a648337f379d4952738e78dcd48ab66f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648337f379d4952738e78dcd48ab66f6">&#9670;&nbsp;</a></span>write_ahead_buf_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t log_t::write_ahead_buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of buffer used for the write-ahead (in bytes). </p>

</div>
</div>
<a id="a8b25b19107e8166327797e15b19296bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b25b19107e8166327797e15b19296bb">&#9670;&nbsp;</a></span>write_ahead_end_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t log_t::write_ahead_end_offset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Up to this file offset in the log files, the write-ahead has been done or is not required (for any other reason). </p>

</div>
</div>
<a id="aeac3a11f2ff78528a4c65d98bbf77ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac3a11f2ff78528a4c65d98bbf77ee2">&#9670;&nbsp;</a></span>write_events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>* log_t::write_events</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned pointer to array with events, which are used for notifications sent from the log write notifier thread to user threads. </p>
<p>The notifications are sent when write_lsn is advanced. User threads wait for write_lsn &gt;= lsn, for some lsn. Log writer advances the write_lsn and notifies the log write notifier, which notifies all users interested in nearby lsn values (lsn belonging to the same log block). Note that false wake-ups are possible, in which case user threads simply retry waiting. </p>

</div>
</div>
<a id="af55a0e623dc8a13b61afbfdc812dcfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55a0e623dc8a13b61afbfdc812dcfce">&#9670;&nbsp;</a></span>write_events_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t log_t::write_events_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of entries in the array with writer_events. </p>

</div>
</div>
<a id="af668ea03e6b8ce2ca9bc85f3026be301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af668ea03e6b8ce2ca9bc85f3026be301">&#9670;&nbsp;</a></span>write_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a> log_t::write_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Up to this lsn, data has been written to disk (fsync not required). </p>
<p>Protected by: writer_mutex (writes). </p>

</div>
</div>
<a id="a848d08aad642a3aa1982f287039fec0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848d08aad642a3aa1982f287039fec0d">&#9670;&nbsp;</a></span>write_notifier_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::write_notifier_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event used by the log writer thread to notify the log write notifier thread, that it should proceed with notifying user threads waiting for the advanced write_lsn (because it has been advanced). </p>

</div>
</div>
<a id="ab5102c6bba6aa4c0f624ae09886c7b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5102c6bba6aa4c0f624ae09886c7b7a">&#9670;&nbsp;</a></span>write_notifier_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::write_notifier_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which can be used to pause log write notifier thread. </p>

</div>
</div>
<a id="a56918f4f2fb6b0069fdefa49fedd6038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56918f4f2fb6b0069fdefa49fedd6038">&#9670;&nbsp;</a></span>write_notifier_resume_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa35035728b4eb2b9dbd8b2637fbc7822">atomic_lsn_t</a> log_t::write_notifier_resume_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for resuming write notifier thread. </p>

</div>
</div>
<a id="ae45d55b7f54c2a2c170f4dd1b1509805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45d55b7f54c2a2c170f4dd1b1509805">&#9670;&nbsp;</a></span>write_to_file_requests_interval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;uint64_t&gt; log_t::write_to_file_requests_interval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How often redo write/flush is requested in average. </p>
<p>Measures in microseconds. Log threads do not spin when the write/flush requests are not frequent. </p>

</div>
</div>
<a id="a27ed59d33529fbbe21b6497e8f02e979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ed59d33529fbbe21b6497e8f02e979">&#9670;&nbsp;</a></span>write_to_file_requests_total</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;uint64_t&gt; log_t::write_to_file_requests_total</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approx. </p>
<p>number of requests to write/flush redo since startup. </p>

</div>
</div>
<a id="a66ab7c03a202c13da983928f806c34cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ab7c03a202c13da983928f806c34cd">&#9670;&nbsp;</a></span>writer_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::writer_event</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa28574eb32c721766f0af258175b7e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28574eb32c721766f0af258175b7e9f">&#9670;&nbsp;</a></span>writer_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t log_t::writer_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex which can be used to pause log writer thread. </p>

</div>
</div>
<a id="a5543171f2fc4be5bb7f1c5b7a76efeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5543171f2fc4be5bb7f1c5b7a76efeb3">&#9670;&nbsp;</a></span>writer_threads_paused</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_bool log_t::writer_threads_paused</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for pausing the log writer threads. </p>
<p>When paused, each user thread should write log as in the former version. </p>

</div>
</div>
<a id="ae73337c783bf59a76f532aad9c782430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73337c783bf59a76f532aad9c782430">&#9670;&nbsp;</a></span>writer_threads_resume_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::writer_threads_resume_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event used for pausing the log writer threads. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>storage/innobase/include/<a class="el" href="log0types_8h_source.html">log0types.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structlog__t.html">log_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
