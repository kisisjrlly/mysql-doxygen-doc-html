<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: trx_lock_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structtrx__lock__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structtrx__lock__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">trx_lock_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Latching protocol for trx_lock_t::que_state.  
 <a href="structtrx__lock__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8b7f840c1deb4b3322a24bff1a9d11b8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a8b7f840c1deb4b3322a24bff1a9d11b8">n_active_thrs</a></td></tr>
<tr class="memdesc:a8b7f840c1deb4b3322a24bff1a9d11b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of active query threads  <a href="#a8b7f840c1deb4b3322a24bff1a9d11b8">More...</a><br /></td></tr>
<tr class="separator:a8b7f840c1deb4b3322a24bff1a9d11b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a11c3bcbef8f9f71497710587ba90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a34bba6fbd37f499f7874fc416547759f">trx_que_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a5b5a11c3bcbef8f9f71497710587ba90">que_state</a></td></tr>
<tr class="memdesc:a5b5a11c3bcbef8f9f71497710587ba90"><td class="mdescLeft">&#160;</td><td class="mdescRight">valid when trx-&gt;state == TRX_STATE_ACTIVE: TRX_QUE_RUNNING, TRX_QUE_LOCK_WAIT, ...  <a href="#a5b5a11c3bcbef8f9f71497710587ba90">More...</a><br /></td></tr>
<tr class="separator:a5b5a11c3bcbef8f9f71497710587ba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59226dd4afa12903c6be80f6588cd9ef"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a59226dd4afa12903c6be80f6588cd9ef">trx_locks_version</a></td></tr>
<tr class="memdesc:a59226dd4afa12903c6be80f6588cd9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incremented each time a lock is added or removed from the trx-&gt;lock.trx_locks, so that the thread which iterates over the list can spot a change if it occurred while it was reacquiring latches.  <a href="#a59226dd4afa12903c6be80f6588cd9ef">More...</a><br /></td></tr>
<tr class="separator:a59226dd4afa12903c6be80f6588cd9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ee2ac214b98e29698601177dbf3cd6"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="structtrx__t.html">trx_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a30ee2ac214b98e29698601177dbf3cd6">blocking_trx</a></td></tr>
<tr class="memdesc:a30ee2ac214b98e29698601177dbf3cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this transaction is waiting for a lock, then blocking_trx points to a transaction which holds a conflicting lock.  <a href="#a30ee2ac214b98e29698601177dbf3cd6">More...</a><br /></td></tr>
<tr class="separator:a30ee2ac214b98e29698601177dbf3cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc50f6732e67f6bbd1a1c19f03af6c"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="structlock__t.html">lock_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a44bc50f6732e67f6bbd1a1c19f03af6c">wait_lock</a></td></tr>
<tr class="memdesc:a44bc50f6732e67f6bbd1a1c19f03af6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock request of this transaction is waiting for.  <a href="#a44bc50f6732e67f6bbd1a1c19f03af6c">More...</a><br /></td></tr>
<tr class="separator:a44bc50f6732e67f6bbd1a1c19f03af6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe2615dace4086b723bd4646004402c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#adfe2615dace4086b723bd4646004402c">wait_lock_type</a></td></tr>
<tr class="memdesc:adfe2615dace4086b723bd4646004402c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the type of the most recent lock for which this trx had to wait.  <a href="#adfe2615dace4086b723bd4646004402c">More...</a><br /></td></tr>
<tr class="separator:adfe2615dace4086b723bd4646004402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe07936c64ae62254ce3e9ac845d0a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#abe07936c64ae62254ce3e9ac845d0a02">was_chosen_as_deadlock_victim</a></td></tr>
<tr class="memdesc:abe07936c64ae62254ce3e9ac845d0a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">when the transaction decides to wait for a lock, it sets this to false; if another transaction chooses this transaction as a victim in deadlock resolution, it sets this to true.  <a href="#abe07936c64ae62254ce3e9ac845d0a02">More...</a><br /></td></tr>
<tr class="separator:abe07936c64ae62254ce3e9ac845d0a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab2bc88e411af161ff3c1e447c30ae4"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a4ab2bc88e411af161ff3c1e447c30ae4">wait_started</a></td></tr>
<tr class="memdesc:a4ab2bc88e411af161ff3c1e447c30ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock wait started at this time.  <a href="#a4ab2bc88e411af161ff3c1e447c30ae4">More...</a><br /></td></tr>
<tr class="separator:a4ab2bc88e411af161ff3c1e447c30ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae4ec9c18be6c1f774472fae0bfbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#affae4ec9c18be6c1f774472fae0bfbc9">wait_thr</a></td></tr>
<tr class="memdesc:affae4ec9c18be6c1f774472fae0bfbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">query thread belonging to this trx that is in QUE_THR_LOCK_WAIT state.  <a href="#affae4ec9c18be6c1f774472fae0bfbc9">More...</a><br /></td></tr>
<tr class="separator:affae4ec9c18be6c1f774472fae0bfbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ab8b4add0aaff028acf918f8334a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0trx_8h.html#afaaac1afb77620ef89dbd971c181b04b">lock_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#ae2ab8b4add0aaff028acf918f8334a9e">rec_pool</a></td></tr>
<tr class="memdesc:ae2ab8b4add0aaff028acf918f8334a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-allocated record locks.  <a href="#ae2ab8b4add0aaff028acf918f8334a9e">More...</a><br /></td></tr>
<tr class="separator:ae2ab8b4add0aaff028acf918f8334a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ad4c453b000f28a03f561e5d531b14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0trx_8h.html#afaaac1afb77620ef89dbd971c181b04b">lock_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a78ad4c453b000f28a03f561e5d531b14">table_pool</a></td></tr>
<tr class="memdesc:a78ad4c453b000f28a03f561e5d531b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-allocated table locks.  <a href="#a78ad4c453b000f28a03f561e5d531b14">More...</a><br /></td></tr>
<tr class="separator:a78ad4c453b000f28a03f561e5d531b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecafab6cff6b97a66367feb5fa0b998"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a7ecafab6cff6b97a66367feb5fa0b998">rec_cached</a></td></tr>
<tr class="memdesc:a7ecafab6cff6b97a66367feb5fa0b998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next free record lock in pool.  <a href="#a7ecafab6cff6b97a66367feb5fa0b998">More...</a><br /></td></tr>
<tr class="separator:a7ecafab6cff6b97a66367feb5fa0b998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc47115095f89b26d9b3ed0a024d04d9"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#afc47115095f89b26d9b3ed0a024d04d9">table_cached</a></td></tr>
<tr class="memdesc:afc47115095f89b26d9b3ed0a024d04d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next free table lock in pool.  <a href="#afc47115095f89b26d9b3ed0a024d04d9">More...</a><br /></td></tr>
<tr class="separator:afc47115095f89b26d9b3ed0a024d04d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3a26f3c5dc889837e30b8bccd2f572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a2b3a26f3c5dc889837e30b8bccd2f572">lock_heap</a></td></tr>
<tr class="memdesc:a2b3a26f3c5dc889837e30b8bccd2f572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory heap for trx_locks.  <a href="#a2b3a26f3c5dc889837e30b8bccd2f572">More...</a><br /></td></tr>
<tr class="separator:a2b3a26f3c5dc889837e30b8bccd2f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4d09bc7b1ab30c068be9c870789a1d"><td class="memItemLeft" align="right" valign="top">trx_lock_list_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a3a4d09bc7b1ab30c068be9c870789a1d">trx_locks</a></td></tr>
<tr class="memdesc:a3a4d09bc7b1ab30c068be9c870789a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks requested by the transaction.  <a href="#a3a4d09bc7b1ab30c068be9c870789a1d">More...</a><br /></td></tr>
<tr class="separator:a3a4d09bc7b1ab30c068be9c870789a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8e3a71adc427f9e6b6d48feb999975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0trx_8h.html#afaaac1afb77620ef89dbd971c181b04b">lock_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#aba8e3a71adc427f9e6b6d48feb999975">table_locks</a></td></tr>
<tr class="memdesc:aba8e3a71adc427f9e6b6d48feb999975"><td class="mdescLeft">&#160;</td><td class="mdescRight">All table locks requested by this transaction, including AUTOINC locks.  <a href="#aba8e3a71adc427f9e6b6d48feb999975">More...</a><br /></td></tr>
<tr class="separator:aba8e3a71adc427f9e6b6d48feb999975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0a194559352f5ee17e901cb23545e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__vector__t.html">ib_vector_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#adb0a194559352f5ee17e901cb23545e2">autoinc_locks</a></td></tr>
<tr class="memdesc:adb0a194559352f5ee17e901cb23545e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTOINC locks held by this transaction.  <a href="#adb0a194559352f5ee17e901cb23545e2">More...</a><br /></td></tr>
<tr class="separator:adb0a194559352f5ee17e901cb23545e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282d12e7244c934015d3e515f6cdb0e5"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; ulint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a282d12e7244c934015d3e515f6cdb0e5">n_rec_locks</a></td></tr>
<tr class="memdesc:a282d12e7244c934015d3e515f6cdb0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rec locks in this trx.  <a href="#a282d12e7244c934015d3e515f6cdb0e5">More...</a><br /></td></tr>
<tr class="separator:a282d12e7244c934015d3e515f6cdb0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2045b09acdd16afe124784b7505ee6fd"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a2045b09acdd16afe124784b7505ee6fd">inherit_all</a></td></tr>
<tr class="memdesc:a2045b09acdd16afe124784b7505ee6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that every lock of this transaction placed on a record which is being purged should be inherited to the gap.  <a href="#a2045b09acdd16afe124784b7505ee6fd">More...</a><br /></td></tr>
<tr class="separator:a2045b09acdd16afe124784b7505ee6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef0c5b015cbdab070f3ecd71f4a2ad3"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a8ef0c5b015cbdab070f3ecd71f4a2ad3">schedule_weight</a></td></tr>
<tr class="memdesc:a8ef0c5b015cbdab070f3ecd71f4a2ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight of the waiting transaction used for scheduling.  <a href="#a8ef0c5b015cbdab070f3ecd71f4a2ad3">More...</a><br /></td></tr>
<tr class="separator:a8ef0c5b015cbdab070f3ecd71f4a2ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdbd90ac21c4ea933e01e835dfe27a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a5cdbd90ac21c4ea933e01e835dfe27a2">in_rollback</a></td></tr>
<tr class="memdesc:a5cdbd90ac21c4ea933e01e835dfe27a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a transaction is forced to rollback due to a deadlock check or by another high priority transaction this is true.  <a href="#a5cdbd90ac21c4ea933e01e835dfe27a2">More...</a><br /></td></tr>
<tr class="separator:a5cdbd90ac21c4ea933e01e835dfe27a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6d8a21a1999c8c7547dfd353a60483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a2e6d8a21a1999c8c7547dfd353a60483">start_stmt</a></td></tr>
<tr class="memdesc:a2e6d8a21a1999c8c7547dfd353a60483"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transaction called ha_innobase::start_stmt() to lock a table.  <a href="#a2e6d8a21a1999c8c7547dfd353a60483">More...</a><br /></td></tr>
<tr class="separator:a2e6d8a21a1999c8c7547dfd353a60483"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Latching protocol for trx_lock_t::que_state. </p>
<p>trx_lock_t::que_state captures the state of the query thread during the execution of a query. This is different from a transaction state. The query state of a transaction can be updated asynchronously by other threads. The other threads can be system threads, like the timeout monitor thread or user threads executing other queries. Another thing to be mindful of is that there is a delay between when a query thread is put into LOCK_WAIT state and before it actually starts waiting. Between these two events it is possible that the query thread is granted the lock it was waiting for, which implies that the state can be changed asynchronously.</p>
<p>All these operations take place within the context of locking. Therefore state changes within the locking code must latch the shard with the wait_lock and the trx-&gt;mutex when changing trx-&gt;lock.que_state to TRX_QUE_LOCK_WAIT or trx-&gt;lock.wait_lock to non-NULL but when the lock wait ends it is sufficient to only acquire the trx-&gt;mutex. To query the state either of the mutexes is sufficient within the locking code and no mutex is required when the query thread is no longer waiting. The locks and state of an active transaction. Protected by exclusive lock_sys latch or trx-&gt;mutex combined with shared lock_sys latch (unless stated otherwise for particular field). </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="adb0a194559352f5ee17e901cb23545e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0a194559352f5ee17e901cb23545e2">&#9670;&nbsp;</a></span>autoinc_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__vector__t.html">ib_vector_t</a>* trx_lock_t::autoinc_locks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AUTOINC locks held by this transaction. </p>
<p>Note that these are also in the lock list trx_locks and table_locks. This vector needs to be freed explicitly when the trx instance is destroyed. Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="a30ee2ac214b98e29698601177dbf3cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ee2ac214b98e29698601177dbf3cd6">&#9670;&nbsp;</a></span>blocking_trx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="structtrx__t.html">trx_t</a> *&gt; trx_lock_t::blocking_trx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this transaction is waiting for a lock, then blocking_trx points to a transaction which holds a conflicting lock. </p>
<p>It is possible that the transaction has trx-&gt;lock.wait_lock == nullptr, yet it has non-null value of trx-&gt;lock.blocking_trx. For example this can happen when we are in the process of moving locks from one heap_no to another. This however is always done while the lock_sys shards which contain the queues involved are latched and conceptually it is true that the blocking_trx is the one for which the transaction waits, even though temporarily there is no pointer to a particular WAITING lock object.</p>
<p>This field is changed from null to non-null, when holding this-&gt;mutex and mutex for lock_sys shard containing the new value of trx-&gt;lock.wait_lock. The field is changed from non-null to different non-null value, while holding mutex for lock_sys shard containing the trx-&gt;lock.wait_lock. The field is changed from non-null to null, while holding this-&gt;mutex, mutex for lock_sys shard containing the old value of trx-&gt;lock.wait_lock, before it was changed to null.</p>
<p>Readers might read it without any latch, but then they should validate the value, i.e. test if it is not-null, and points to a valid trx. To make any definite judgments one needs to latch the lock_sys shard containing the trx-&gt;lock.wait_lock. </p>

</div>
</div>
<a id="a5cdbd90ac21c4ea933e01e835dfe27a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdbd90ac21c4ea933e01e835dfe27a2">&#9670;&nbsp;</a></span>in_rollback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> trx_lock_t::in_rollback</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When a transaction is forced to rollback due to a deadlock check or by another high priority transaction this is true. </p>
<p>Used by debug checks in lock0lock.cc </p>

</div>
</div>
<a id="a2045b09acdd16afe124784b7505ee6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2045b09acdd16afe124784b7505ee6fd">&#9670;&nbsp;</a></span>inherit_all</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&gt; trx_lock_t::inherit_all</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to indicate that every lock of this transaction placed on a record which is being purged should be inherited to the gap. </p>
<p>Readers should hold a latch on the lock they'd like to learn about whether or not it should be inherited. Writers who want to set it to true, should hold a latch on the lock-sys queue they intend to add a lock to. Writers may set it to false at any time. </p>

</div>
</div>
<a id="a2b3a26f3c5dc889837e30b8bccd2f572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3a26f3c5dc889837e30b8bccd2f572">&#9670;&nbsp;</a></span>lock_heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a>* trx_lock_t::lock_heap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory heap for trx_locks. </p>
<p>Protected by trx-&gt;mutex </p>

</div>
</div>
<a id="a8b7f840c1deb4b3322a24bff1a9d11b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7f840c1deb4b3322a24bff1a9d11b8">&#9670;&nbsp;</a></span>n_active_thrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint trx_lock_t::n_active_thrs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of active query threads </p>

</div>
</div>
<a id="a282d12e7244c934015d3e515f6cdb0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282d12e7244c934015d3e515f6cdb0e5">&#9670;&nbsp;</a></span>n_rec_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;ulint&gt; trx_lock_t::n_rec_locks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of rec locks in this trx. </p>
<p>It is modified with shared lock_sys latch. It is read with exclusive lock_sys latch. </p>

</div>
</div>
<a id="a5b5a11c3bcbef8f9f71497710587ba90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5a11c3bcbef8f9f71497710587ba90">&#9670;&nbsp;</a></span>que_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a34bba6fbd37f499f7874fc416547759f">trx_que_t</a> trx_lock_t::que_state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>valid when trx-&gt;state == TRX_STATE_ACTIVE: TRX_QUE_RUNNING, TRX_QUE_LOCK_WAIT, ... </p>

</div>
</div>
<a id="a7ecafab6cff6b97a66367feb5fa0b998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecafab6cff6b97a66367feb5fa0b998">&#9670;&nbsp;</a></span>rec_cached</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint trx_lock_t::rec_cached</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next free record lock in pool. </p>
<p>Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="ae2ab8b4add0aaff028acf918f8334a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ab8b4add0aaff028acf918f8334a9e">&#9670;&nbsp;</a></span>rec_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0trx_8h.html#afaaac1afb77620ef89dbd971c181b04b">lock_pool_t</a> trx_lock_t::rec_pool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre-allocated record locks. </p>
<p>Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="a8ef0c5b015cbdab070f3ecd71f4a2ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef0c5b015cbdab070f3ecd71f4a2ad3">&#9670;&nbsp;</a></span>schedule_weight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a>&gt; trx_lock_t::schedule_weight</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weight of the waiting transaction used for scheduling. </p>
<p>The higher the weight the more we are willing to grant a lock to this transaction. Values are updated and read without any synchronization beyond that provided by atomics, as slightly stale values do not hurt correctness, just the performance. </p>

</div>
</div>
<a id="a2e6d8a21a1999c8c7547dfd353a60483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6d8a21a1999c8c7547dfd353a60483">&#9670;&nbsp;</a></span>start_stmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> trx_lock_t::start_stmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The transaction called ha_innobase::start_stmt() to lock a table. </p>
<p>Most likely a temporary table. </p>

</div>
</div>
<a id="afc47115095f89b26d9b3ed0a024d04d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc47115095f89b26d9b3ed0a024d04d9">&#9670;&nbsp;</a></span>table_cached</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint trx_lock_t::table_cached</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next free table lock in pool. </p>
<p>Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="aba8e3a71adc427f9e6b6d48feb999975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8e3a71adc427f9e6b6d48feb999975">&#9670;&nbsp;</a></span>table_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0trx_8h.html#afaaac1afb77620ef89dbd971c181b04b">lock_pool_t</a> trx_lock_t::table_locks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All table locks requested by this transaction, including AUTOINC locks. </p>
<p>Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="a78ad4c453b000f28a03f561e5d531b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ad4c453b000f28a03f561e5d531b14">&#9670;&nbsp;</a></span>table_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0trx_8h.html#afaaac1afb77620ef89dbd971c181b04b">lock_pool_t</a> trx_lock_t::table_pool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre-allocated table locks. </p>
<p>Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="a3a4d09bc7b1ab30c068be9c870789a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4d09bc7b1ab30c068be9c870789a1d">&#9670;&nbsp;</a></span>trx_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">trx_lock_list_t trx_lock_t::trx_locks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks requested by the transaction. </p>
<p>Modifications are protected by trx-&gt;mutex and shard of lock_sys mutex. Reads can be performed while holding trx-&gt;mutex or exclusive lock_sys latch. One can also check if this list is empty or not from the thread running this transaction without holding any latches, keeping in mind that other threads might modify the list in parallel (for example during implicit-to-explicit conversion, or when B-tree split or merge causes locks to be moved from one page to another) - we rely on assumption that such operations do not change the "emptiness" of the list and that one can check for emptiness in a safe manner (in current implementation length of the list is stored explicitly so one can read it without risking unsafe pointer operations) </p>

</div>
</div>
<a id="a59226dd4afa12903c6be80f6588cd9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59226dd4afa12903c6be80f6588cd9ef">&#9670;&nbsp;</a></span>trx_locks_version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t trx_lock_t::trx_locks_version</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incremented each time a lock is added or removed from the trx-&gt;lock.trx_locks, so that the thread which iterates over the list can spot a change if it occurred while it was reacquiring latches. </p>
<p>Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="a44bc50f6732e67f6bbd1a1c19f03af6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bc50f6732e67f6bbd1a1c19f03af6c">&#9670;&nbsp;</a></span>wait_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="structlock__t.html">lock_t</a> *&gt; trx_lock_t::wait_lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The lock request of this transaction is waiting for. </p>
<p>It might be NULL if the transaction is not currently waiting, or if the lock was temporarily removed during B-tree reorganization and will be recreated in a different queue. Such move is protected by latching the shards containing both queues, so the intermediate state should not be observed by readers who latch the old shard.</p>
<p>Changes from NULL to non-NULL while holding trx-&gt;mutex and latching the shard containing the new wait_lock value. Changes from non-NULL to NULL while latching the shard containing the old wait_lock value. Never changes from non-NULL to other non-NULL directly.</p>
<p>Readers should hold exclusive global latch on lock_sys, as in general they can't know what shard the lock belongs to before reading it. However, in debug assertions, where we strongly believe to know the value of this field in advance, we can:</p><ul>
<li>read without any latch if we believe the value should be NULL</li>
<li>read latching only the shard containing the wait_lock we expect </li>
</ul>

</div>
</div>
<a id="adfe2615dace4086b723bd4646004402c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe2615dace4086b723bd4646004402c">&#9670;&nbsp;</a></span>wait_lock_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t trx_lock_t::wait_lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the type of the most recent lock for which this trx had to wait. </p>
<p>Set to lock_get_type_low(wait_lock) together with wait_lock in lock_set_lock_and_trx_wait(). This field is not cleared when wait_lock is set to NULL during lock_reset_lock_and_trx_wait() as in lock_wait_suspend_thread() we are interested in reporting the last known value of this field via thd_wait_begin(). When a thread has to wait for a lock, it first releases lock-sys latch, and then calls lock_wait_suspend_thread() where among other things it tries to report statistic via thd_wait_begin() about the kind of lock (THD_WAIT_ROW_LOCK vs THD_WAIT_TABLE_LOCK) that caused the wait. But there is a possibility that before it gets to call thd_wait_begin() some other thread could latch lock-sys and grant the lock and call lock_reset_lock_and_trx_wait(). In other words: in case another thread was quick enough to grant the lock, we still would like to report the reason for attempting to sleep. Another common scenario of "setting trx-&gt;lock.wait_lock to NULL" is page reorganization: when we have to move records between pages, we also move locks, and when doing so, we temporarily remove the old waiting lock, and then add another one. For example look at lock_rec_move_low(). It first calls lock_reset_lock_and_trx_wait() which changes trx-&gt;lock.wait_lock to NULL, but then calls lock_rec_add_to_queue() -&gt; RecLock::create() -&gt; RecLock::lock_add() -&gt; lock_set_lock_and_trx_wait() to set it again to the new lock. This all happens while holding lock-sys latch, but we read wait_lock_type without this latch, so we should not clear the wait_lock_type simply because somebody changed wait_lock to NULL. Protected by trx-&gt;mutex. </p>

</div>
</div>
<a id="a4ab2bc88e411af161ff3c1e447c30ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab2bc88e411af161ff3c1e447c30ae4">&#9670;&nbsp;</a></span>wait_started</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t trx_lock_t::wait_started</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock wait started at this time. </p>
<p>Writes under shared lock_sys latch combined with trx-&gt;mutex. Reads require either trx-&gt;mutex or exclusive lock_sys latch. </p>

</div>
</div>
<a id="affae4ec9c18be6c1f774472fae0bfbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae4ec9c18be6c1f774472fae0bfbc9">&#9670;&nbsp;</a></span>wait_thr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* trx_lock_t::wait_thr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query thread belonging to this trx that is in QUE_THR_LOCK_WAIT state. </p>
<p>For threads suspended in a lock wait, this is protected by lock_sys latch for the wait_lock's shard. Otherwise, this may only be modified by the thread that is serving the running transaction. </p>

</div>
</div>
<a id="abe07936c64ae62254ce3e9ac845d0a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe07936c64ae62254ce3e9ac845d0a02">&#9670;&nbsp;</a></span>was_chosen_as_deadlock_victim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> trx_lock_t::was_chosen_as_deadlock_victim</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>when the transaction decides to wait for a lock, it sets this to false; if another transaction chooses this transaction as a victim in deadlock resolution, it sets this to true. </p>
<p>Protected by trx-&gt;mutex. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>storage/innobase/include/<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structtrx__lock__t.html">trx_lock_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
