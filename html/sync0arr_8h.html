<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/sync0arr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sync0arr_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sync0arr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The wait array used in synchronization primitives.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="os0thread_8h_source.html">os0thread.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;sync0arr.ic&quot;</code><br />
</div>
<p><a href="sync0arr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa380e8365c390a14ea167f5f2b700ad5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#aa380e8365c390a14ea167f5f2b700ad5">sync_array_get_and_reserve_cell</a> (void *object, ulint type, const char *file, ulint line, <a class="el" href="structsync__cell__t.html">sync_cell_t</a> **cell)</td></tr>
<tr class="memdesc:aa380e8365c390a14ea167f5f2b700ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instance of the sync wait array and reserve a wait array cell in the instance for waiting for an object.  <a href="#aa380e8365c390a14ea167f5f2b700ad5">More...</a><br /></td></tr>
<tr class="separator:aa380e8365c390a14ea167f5f2b700ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e825b4098aff570ae32597153887b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsync__cell__t.html">sync_cell_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a1e825b4098aff570ae32597153887b62">sync_array_reserve_cell</a> (<a class="el" href="structsync__array__t.html">sync_array_t</a> *arr, void *object, ulint type, const char *file, ulint line)</td></tr>
<tr class="memdesc:a1e825b4098aff570ae32597153887b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves a wait array cell for waiting for an object.  <a href="#a1e825b4098aff570ae32597153887b62">More...</a><br /></td></tr>
<tr class="separator:a1e825b4098aff570ae32597153887b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331319d9349145ecaf6c720de7161cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a331319d9349145ecaf6c720de7161cf9">sync_array_wait_event</a> (<a class="el" href="structsync__array__t.html">sync_array_t</a> *arr, <a class="el" href="structsync__cell__t.html">sync_cell_t</a> *&amp;cell)</td></tr>
<tr class="memdesc:a331319d9349145ecaf6c720de7161cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called when a thread starts to wait on a wait array cell.  <a href="#a331319d9349145ecaf6c720de7161cf9">More...</a><br /></td></tr>
<tr class="separator:a331319d9349145ecaf6c720de7161cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde5af977ed55e89ef5fc5a8f30b3d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#abde5af977ed55e89ef5fc5a8f30b3d64">sync_array_free_cell</a> (<a class="el" href="structsync__array__t.html">sync_array_t</a> *arr, <a class="el" href="structsync__cell__t.html">sync_cell_t</a> *&amp;cell)</td></tr>
<tr class="memdesc:abde5af977ed55e89ef5fc5a8f30b3d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the cell.  <a href="#abde5af977ed55e89ef5fc5a8f30b3d64">More...</a><br /></td></tr>
<tr class="separator:abde5af977ed55e89ef5fc5a8f30b3d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e79002d3a4df40c70a010737f61f54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a31e79002d3a4df40c70a010737f61f54">sync_array_object_signalled</a> ()</td></tr>
<tr class="memdesc:a31e79002d3a4df40c70a010737f61f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that one of the wait objects was signalled.  <a href="#a31e79002d3a4df40c70a010737f61f54">More...</a><br /></td></tr>
<tr class="separator:a31e79002d3a4df40c70a010737f61f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb529fea81df250284c0df753c7da9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#aedb529fea81df250284c0df753c7da9e">sync_arr_wake_threads_if_sema_free</a> ()</td></tr>
<tr class="memdesc:aedb529fea81df250284c0df753c7da9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the wakeup algorithm does not work perfectly at semaphore relases, this function will do the waking (see the comment in mutex_exit).  <a href="#aedb529fea81df250284c0df753c7da9e">More...</a><br /></td></tr>
<tr class="separator:aedb529fea81df250284c0df753c7da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af961f5593d1e14a973e4d34fdcd720c2"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#af961f5593d1e14a973e4d34fdcd720c2">sync_array_print_long_waits</a> (<a class="el" href="os0thread_8h.html#ab8ad022ed5dafb1f9defb66ac1b6a62a">os_thread_id_t</a> *waiter, const void **sema)</td></tr>
<tr class="memdesc:af961f5593d1e14a973e4d34fdcd720c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints warnings of long semaphore waits to stderr.  <a href="#af961f5593d1e14a973e4d34fdcd720c2">More...</a><br /></td></tr>
<tr class="separator:af961f5593d1e14a973e4d34fdcd720c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cace1b8c6619a9af08fd7f7688bfe00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a5cace1b8c6619a9af08fd7f7688bfe00">sync_array_print</a> (FILE *file)</td></tr>
<tr class="memdesc:a5cace1b8c6619a9af08fd7f7688bfe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of the wait array.  <a href="#a5cace1b8c6619a9af08fd7f7688bfe00">More...</a><br /></td></tr>
<tr class="separator:a5cace1b8c6619a9af08fd7f7688bfe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ca87b6076241cc30d2c579baa7f411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a01ca87b6076241cc30d2c579baa7f411">sync_array_init</a> (ulint n_threads)</td></tr>
<tr class="memdesc:a01ca87b6076241cc30d2c579baa7f411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the primary system wait array(s), they are protected by an OS mutex.  <a href="#a01ca87b6076241cc30d2c579baa7f411">More...</a><br /></td></tr>
<tr class="separator:a01ca87b6076241cc30d2c579baa7f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48d7b3aa019cea833f2a8fb64a3ff73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ab48d7b3aa019cea833f2a8fb64a3ff73">sync_array_close</a> ()</td></tr>
<tr class="memdesc:ab48d7b3aa019cea833f2a8fb64a3ff73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close sync array wait sub-system.  <a href="#ab48d7b3aa019cea833f2a8fb64a3ff73">More...</a><br /></td></tr>
<tr class="separator:ab48d7b3aa019cea833f2a8fb64a3ff73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe7fa3ce2ca2414865e6a229c01cfcb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#aefe7fa3ce2ca2414865e6a229c01cfcb">sync_array_get</a> ()</td></tr>
<tr class="memdesc:aefe7fa3ce2ca2414865e6a229c01cfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instance of the sync wait array.  <a href="#aefe7fa3ce2ca2414865e6a229c01cfcb">More...</a><br /></td></tr>
<tr class="separator:aefe7fa3ce2ca2414865e6a229c01cfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The wait array used in synchronization primitives. </p>
<p>Created 9/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aedb529fea81df250284c0df753c7da9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb529fea81df250284c0df753c7da9e">&#9670;&nbsp;</a></span>sync_arr_wake_threads_if_sema_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sync_arr_wake_threads_if_sema_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the wakeup algorithm does not work perfectly at semaphore relases, this function will do the waking (see the comment in mutex_exit). </p>
<p>This function should be called about every 1 second in the server.</p>
<p>This function should be called about every 1 second in the server.</p>
<p>Note that there's a race condition between this thread and mutex_exit changing the lock_word and calling signal_object, so sometimes this finds threads to wake up even when nothing has gone wrong. </p>

</div>
</div>
<a id="ab48d7b3aa019cea833f2a8fb64a3ff73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48d7b3aa019cea833f2a8fb64a3ff73">&#9670;&nbsp;</a></span>sync_array_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sync_array_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close sync array wait sub-system. </p>

</div>
</div>
<a id="abde5af977ed55e89ef5fc5a8f30b3d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde5af977ed55e89ef5fc5a8f30b3d64">&#9670;&nbsp;</a></span>sync_array_free_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sync_array_free_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsync__cell__t.html">sync_cell_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the cell. </p>
<p>NOTE! sync_array_wait_event frees the cell automatically! in: the reserved cell</p>
<p>NOTE! sync_array_wait_event frees the cell automatically! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
    <tr><td class="paramname">cell</td><td>in/out: the cell in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefe7fa3ce2ca2414865e6a229c01cfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe7fa3ce2ca2414865e6a229c01cfcb">&#9670;&nbsp;</a></span>sync_array_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structsync__array__t.html">sync_array_t</a>* sync_array_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an instance of the sync wait array. </p>

</div>
</div>
<a id="aa380e8365c390a14ea167f5f2b700ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa380e8365c390a14ea167f5f2b700ad5">&#9670;&nbsp;</a></span>sync_array_get_and_reserve_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structsync__array__t.html">sync_array_t</a>* sync_array_get_and_reserve_cell </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsync__cell__t.html">sync_cell_t</a> **&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an instance of the sync wait array and reserve a wait array cell in the instance for waiting for an object. </p>
<p>The event of the cell is reset to nonsignalled state. If reserving cell of the instance fails, try to get another new instance until we can reserve an empty cell of it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>pointer to the object to wait for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>lock request type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>file where requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>line where requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cell</td><td>the cell reserved, never NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sync array found, never NULL. </dd></dl>

</div>
</div>
<a id="a01ca87b6076241cc30d2c579baa7f411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ca87b6076241cc30d2c579baa7f411">&#9670;&nbsp;</a></span>sync_array_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sync_array_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the primary system wait array(s), they are protected by an OS mutex. </p>
<p>in: Number of slots to create </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_threads</td><td>in: Number of slots to create in all arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31e79002d3a4df40c70a010737f61f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e79002d3a4df40c70a010737f61f54">&#9670;&nbsp;</a></span>sync_array_object_signalled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sync_array_object_signalled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note that one of the wait objects was signalled. </p>
<p>Note that one of the wait objects was signalled. </p>

</div>
</div>
<a id="a5cace1b8c6619a9af08fd7f7688bfe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cace1b8c6619a9af08fd7f7688bfe00">&#9670;&nbsp;</a></span>sync_array_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sync_array_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of the wait array. </p>
<p>in: file where to print</p>
<p>Prints info of the wait array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in/out: Print to this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af961f5593d1e14a973e4d34fdcd720c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af961f5593d1e14a973e4d34fdcd720c2">&#9670;&nbsp;</a></span>sync_array_print_long_waits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool sync_array_print_long_waits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0thread_8h.html#ab8ad022ed5dafb1f9defb66ac1b6a62a">os_thread_id_t</a> *&#160;</td>
          <td class="paramname"><em>waiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>sema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints warnings of long semaphore waits to stderr. </p>
<dl class="section return"><dt>Returns</dt><dd>true if fatal semaphore wait threshold was exceeded out: longest-waited-for semaphore</dd>
<dd>
true if fatal semaphore wait threshold was exceeded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waiter</td><td>out: longest waiting thread </td></tr>
    <tr><td class="paramname">sema</td><td>out: longest-waited-for semaphore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e825b4098aff570ae32597153887b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e825b4098aff570ae32597153887b62">&#9670;&nbsp;</a></span>sync_array_reserve_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsync__cell__t.html">sync_cell_t</a>* sync_array_reserve_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves a wait array cell for waiting for an object. </p>
<p>The event of the cell is reset to nonsignalled state. in: line where requested</p>
<p>The event of the cell is reset to nonsignalled state. </p><dl class="section return"><dt>Returns</dt><dd>sync cell to wait on </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
    <tr><td class="paramname">object</td><td>in: pointer to the object to wait for </td></tr>
    <tr><td class="paramname">type</td><td>in: lock request type </td></tr>
    <tr><td class="paramname">file</td><td>in: file where requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a331319d9349145ecaf6c720de7161cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331319d9349145ecaf6c720de7161cf9">&#9670;&nbsp;</a></span>sync_array_wait_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sync_array_wait_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsync__cell__t.html">sync_cell_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called when a thread starts to wait on a wait array cell. </p>
<p>In the debug version this function checks if the wait for a semaphore will result in a deadlock, in which case prints info and asserts. in: the reserved cell</p>
<p>In the debug version this function checks if the wait for a semaphore will result in a deadlock, in which case prints info and asserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
    <tr><td class="paramname">cell</td><td>in: index of the reserved cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="sync0arr_8h.html">sync0arr.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
