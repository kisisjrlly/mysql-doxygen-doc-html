<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Gtid_state Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classGtid__state.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classGtid__state-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gtid_state Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the server's GTID state: the set of committed GTIDs, the set of lost gtids, the set of owned gtids, the owner of each owned gtid, and a Mutex_cond_array that protects updates to gtids of each SIDNO.  
 <a href="classGtid__state.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4e93b5ffa97a101e51aa722cf5f56ef3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a4e93b5ffa97a101e51aa722cf5f56ef3">Gtid_state</a> (<a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a> *_sid_lock, <a class="el" href="classSid__map.html">Sid_map</a> *_sid_map)</td></tr>
<tr class="memdesc:a4e93b5ffa97a101e51aa722cf5f56ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new Gtid_state object.  <a href="#a4e93b5ffa97a101e51aa722cf5f56ef3">More...</a><br /></td></tr>
<tr class="separator:a4e93b5ffa97a101e51aa722cf5f56ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bbafc9331c90395789157153fd3601"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a05bbafc9331c90395789157153fd3601">init</a> ()</td></tr>
<tr class="memdesc:a05bbafc9331c90395789157153fd3601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add @GLOBAL.SERVER_UUID to this binlog's Sid_map.  <a href="#a05bbafc9331c90395789157153fd3601">More...</a><br /></td></tr>
<tr class="separator:a05bbafc9331c90395789157153fd3601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad923504d43e3b912ab1aaad9bb65a8b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ad923504d43e3b912ab1aaad9bb65a8b7">clear</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ad923504d43e3b912ab1aaad9bb65a8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the state and persistor after RESET MASTER: remove all logged and lost gtids, but keep owned gtids as they are.  <a href="#ad923504d43e3b912ab1aaad9bb65a8b7">More...</a><br /></td></tr>
<tr class="separator:ad923504d43e3b912ab1aaad9bb65a8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85f3475832c5bab63b37c8f7fd65300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aa85f3475832c5bab63b37c8f7fd65300">is_executed</a> (const <a class="el" href="structGtid.html">Gtid</a> &amp;gtid) const</td></tr>
<tr class="memdesc:aa85f3475832c5bab63b37c8f7fd65300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given GTID is logged.  <a href="#aa85f3475832c5bab63b37c8f7fd65300">More...</a><br /></td></tr>
<tr class="separator:aa85f3475832c5bab63b37c8f7fd65300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a0e22e395f095aad358b1db91e170a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aa4a0e22e395f095aad358b1db91e170a">is_owned</a> (const <a class="el" href="structGtid.html">Gtid</a> &amp;gtid) const</td></tr>
<tr class="memdesc:aa4a0e22e395f095aad358b1db91e170a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if GTID is owned, otherwise returns 0.  <a href="#aa4a0e22e395f095aad358b1db91e170a">More...</a><br /></td></tr>
<tr class="separator:aa4a0e22e395f095aad358b1db91e170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bedc53a5eed5898822ede2a9d5214d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a3bedc53a5eed5898822ede2a9d5214d6">acquire_ownership</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="structGtid.html">Gtid</a> &amp;gtid)</td></tr>
<tr class="memdesc:a3bedc53a5eed5898822ede2a9d5214d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires ownership of the given GTID, on behalf of the given thread.  <a href="#a3bedc53a5eed5898822ede2a9d5214d6">More...</a><br /></td></tr>
<tr class="separator:a3bedc53a5eed5898822ede2a9d5214d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa3ed5a9b5fc7d0a4ad5492b657b790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a9fa3ed5a9b5fc7d0a4ad5492b657b790">update_commit_group</a> (<a class="el" href="classTHD.html">THD</a> *first_thd)</td></tr>
<tr class="memdesc:a9fa3ed5a9b5fc7d0a4ad5492b657b790"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates both the THD and the Gtid_state to reflect that the transaction set of transactions has ended, and it does this for the whole commit group (by following the thd-&gt;next_to_commit pointer).  <a href="#a9fa3ed5a9b5fc7d0a4ad5492b657b790">More...</a><br /></td></tr>
<tr class="separator:a9fa3ed5a9b5fc7d0a4ad5492b657b790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4c103d1209489a7b7e0d179d654faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#adc4c103d1209489a7b7e0d179d654faf">update_on_commit</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:adc4c103d1209489a7b7e0d179d654faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the GTID owned by thread from owned GTIDs, stating that thd-&gt;owned_gtid was committed.  <a href="#adc4c103d1209489a7b7e0d179d654faf">More...</a><br /></td></tr>
<tr class="separator:adc4c103d1209489a7b7e0d179d654faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dacb8e665689ad80e4541cea325897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a82dacb8e665689ad80e4541cea325897">update_on_rollback</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a82dacb8e665689ad80e4541cea325897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the state after the given thread has rollbacked.  <a href="#a82dacb8e665689ad80e4541cea325897">More...</a><br /></td></tr>
<tr class="separator:a82dacb8e665689ad80e4541cea325897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e259736e00e4fa5835ec9cdd34dc0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a7e259736e00e4fa5835ec9cdd34dc0ba">acquire_anonymous_ownership</a> ()</td></tr>
<tr class="memdesc:a7e259736e00e4fa5835ec9cdd34dc0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire anonymous ownership.  <a href="#a7e259736e00e4fa5835ec9cdd34dc0ba">More...</a><br /></td></tr>
<tr class="separator:a7e259736e00e4fa5835ec9cdd34dc0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf31ed3dbdbab7cf4ce39de1ca51bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aedf31ed3dbdbab7cf4ce39de1ca51bee">release_anonymous_ownership</a> ()</td></tr>
<tr class="memdesc:aedf31ed3dbdbab7cf4ce39de1ca51bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release anonymous ownership.  <a href="#aedf31ed3dbdbab7cf4ce39de1ca51bee">More...</a><br /></td></tr>
<tr class="separator:aedf31ed3dbdbab7cf4ce39de1ca51bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1612d90e7c0a0f6fec94b9a05e12fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ae1612d90e7c0a0f6fec94b9a05e12fbf">get_anonymous_ownership_count</a> ()</td></tr>
<tr class="memdesc:ae1612d90e7c0a0f6fec94b9a05e12fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of clients that hold anonymous ownership.  <a href="#ae1612d90e7c0a0f6fec94b9a05e12fbf">More...</a><br /></td></tr>
<tr class="separator:ae1612d90e7c0a0f6fec94b9a05e12fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda6d7defb7e4a1477c7a33ce8ee1263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#abda6d7defb7e4a1477c7a33ce8ee1263">begin_automatic_gtid_violating_transaction</a> ()</td></tr>
<tr class="memdesc:abda6d7defb7e4a1477c7a33ce8ee1263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the global counter when starting a GTID-violating transaction having GTID_NEXT=AUTOMATIC.  <a href="#abda6d7defb7e4a1477c7a33ce8ee1263">More...</a><br /></td></tr>
<tr class="separator:abda6d7defb7e4a1477c7a33ce8ee1263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138d09ad92a3df53b57f065b6535d7a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a138d09ad92a3df53b57f065b6535d7a0">end_automatic_gtid_violating_transaction</a> ()</td></tr>
<tr class="memdesc:a138d09ad92a3df53b57f065b6535d7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the global counter when ending a GTID-violating transaction having GTID_NEXT=AUTOMATIC.  <a href="#a138d09ad92a3df53b57f065b6535d7a0">More...</a><br /></td></tr>
<tr class="separator:a138d09ad92a3df53b57f065b6535d7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954b493111b1b2a7ad049db64eefe050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a954b493111b1b2a7ad049db64eefe050">get_automatic_gtid_violating_transaction_count</a> ()</td></tr>
<tr class="memdesc:a954b493111b1b2a7ad049db64eefe050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of ongoing GTID-violating transactions having GTID_NEXT=AUTOMATIC.  <a href="#a954b493111b1b2a7ad049db64eefe050">More...</a><br /></td></tr>
<tr class="separator:a954b493111b1b2a7ad049db64eefe050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315fbccbb1afe3414b5ef732027d2af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a315fbccbb1afe3414b5ef732027d2af6">begin_anonymous_gtid_violating_transaction</a> ()</td></tr>
<tr class="memdesc:a315fbccbb1afe3414b5ef732027d2af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the global counter when starting a GTID-violating transaction having GTID_NEXT=ANONYMOUS.  <a href="#a315fbccbb1afe3414b5ef732027d2af6">More...</a><br /></td></tr>
<tr class="separator:a315fbccbb1afe3414b5ef732027d2af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56fbf5a2c062a5b2db3eab4444c2f2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ad56fbf5a2c062a5b2db3eab4444c2f2f">end_anonymous_gtid_violating_transaction</a> ()</td></tr>
<tr class="memdesc:ad56fbf5a2c062a5b2db3eab4444c2f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the global counter when ending a GTID-violating transaction having GTID_NEXT=ANONYMOUS.  <a href="#ad56fbf5a2c062a5b2db3eab4444c2f2f">More...</a><br /></td></tr>
<tr class="separator:ad56fbf5a2c062a5b2db3eab4444c2f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e16543dafff485d212b494adb5dffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ab9e16543dafff485d212b494adb5dffb">end_gtid_violating_transaction</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="separator:ab9e16543dafff485d212b494adb5dffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77271375b558d3f23317b10752fec8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a77271375b558d3f23317b10752fec8bd">get_anonymous_gtid_violating_transaction_count</a> ()</td></tr>
<tr class="memdesc:a77271375b558d3f23317b10752fec8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of ongoing GTID-violating transactions having GTID_NEXT=AUTOMATIC.  <a href="#a77271375b558d3f23317b10752fec8bd">More...</a><br /></td></tr>
<tr class="separator:a77271375b558d3f23317b10752fec8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24be6529374d7badb7cd17e330ac840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#af24be6529374d7badb7cd17e330ac840">begin_gtid_wait</a> ()</td></tr>
<tr class="memdesc:af24be6529374d7badb7cd17e330ac840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the global counter when starting a call to WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS.  <a href="#af24be6529374d7badb7cd17e330ac840">More...</a><br /></td></tr>
<tr class="separator:af24be6529374d7badb7cd17e330ac840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b849b9b07629619b77882ddb5fde5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a4b849b9b07629619b77882ddb5fde5ac">end_gtid_wait</a> ()</td></tr>
<tr class="memdesc:a4b849b9b07629619b77882ddb5fde5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the global counter when ending a call to WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS.  <a href="#a4b849b9b07629619b77882ddb5fde5ac">More...</a><br /></td></tr>
<tr class="separator:a4b849b9b07629619b77882ddb5fde5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59586299cdb464b0378338eba646fb9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a59586299cdb464b0378338eba646fb9c">get_gtid_wait_count</a> ()</td></tr>
<tr class="memdesc:a59586299cdb464b0378338eba646fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of clients that have an ongoing call to WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS.  <a href="#a59586299cdb464b0378338eba646fb9c">More...</a><br /></td></tr>
<tr class="separator:a59586299cdb464b0378338eba646fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58b3ccada19a67f2b8b5f690d08a309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ad58b3ccada19a67f2b8b5f690d08a309">get_last_executed_gno</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno) const</td></tr>
<tr class="memdesc:ad58b3ccada19a67f2b8b5f690d08a309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last executed GNO for a given SIDNO, e.g.  <a href="#ad58b3ccada19a67f2b8b5f690d08a309">More...</a><br /></td></tr>
<tr class="separator:ad58b3ccada19a67f2b8b5f690d08a309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dc1e07ba3548a2b460f6c8a40abb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a56dc1e07ba3548a2b460f6c8a40abb70">generate_automatic_gtid</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> specified_sidno=0, <a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a> specified_gno=0, <a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> *locked_sidno=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:a56dc1e07ba3548a2b460f6c8a40abb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the GTID (or ANONYMOUS, if GTID_MODE = OFF or OFF_PERMISSIVE) for the THD, and acquires ownership.  <a href="#a56dc1e07ba3548a2b460f6c8a40abb70">More...</a><br /></td></tr>
<tr class="separator:a56dc1e07ba3548a2b460f6c8a40abb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d84b821f0021c098306971c6cc75a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ac3d84b821f0021c098306971c6cc75a6">lock_sidno</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno)</td></tr>
<tr class="memdesc:ac3d84b821f0021c098306971c6cc75a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a mutex for the given SIDNO.  <a href="#ac3d84b821f0021c098306971c6cc75a6">More...</a><br /></td></tr>
<tr class="separator:ac3d84b821f0021c098306971c6cc75a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28f4660564a239c4e538b86dce1f832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aa28f4660564a239c4e538b86dce1f832">unlock_sidno</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno)</td></tr>
<tr class="memdesc:aa28f4660564a239c4e538b86dce1f832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks a mutex for the given SIDNO.  <a href="#aa28f4660564a239c4e538b86dce1f832">More...</a><br /></td></tr>
<tr class="separator:aa28f4660564a239c4e538b86dce1f832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e2deb3fdc80fcb1931bc422f8382ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ae8e2deb3fdc80fcb1931bc422f8382ad">broadcast_sidno</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno)</td></tr>
<tr class="memdesc:ae8e2deb3fdc80fcb1931bc422f8382ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts updates for the given SIDNO.  <a href="#ae8e2deb3fdc80fcb1931bc422f8382ad">More...</a><br /></td></tr>
<tr class="separator:ae8e2deb3fdc80fcb1931bc422f8382ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3acb3b64327c2a5ce389a04a8ba026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a9a3acb3b64327c2a5ce389a04a8ba026">assert_sidno_lock_owner</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno)</td></tr>
<tr class="memdesc:a9a3acb3b64327c2a5ce389a04a8ba026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that we own the given SIDNO.  <a href="#a9a3acb3b64327c2a5ce389a04a8ba026">More...</a><br /></td></tr>
<tr class="separator:a9a3acb3b64327c2a5ce389a04a8ba026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05b5e777f238bb2b73e4b6af4666041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aa05b5e777f238bb2b73e4b6af4666041">wait_for_sidno</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno, struct timespec *<a class="el" href="memcached_8c.html#ae7fce3cf8e64856257530444179867fd">abstime</a>)</td></tr>
<tr class="memdesc:aa05b5e777f238bb2b73e4b6af4666041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a signal on the given SIDNO.  <a href="#aa05b5e777f238bb2b73e4b6af4666041">More...</a><br /></td></tr>
<tr class="separator:aa05b5e777f238bb2b73e4b6af4666041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7defb862a2a1ab4ebc1e90dfc7b78ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a7defb862a2a1ab4ebc1e90dfc7b78ecd">wait_for_gtid</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="structGtid.html">Gtid</a> &amp;gtid, struct timespec *<a class="el" href="memcached_8c.html#ae7fce3cf8e64856257530444179867fd">abstime</a>=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:a7defb862a2a1ab4ebc1e90dfc7b78ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is only a shorthand for wait_for_sidno, which contains additional debug printouts and assertions for the case when the caller waits for one specific GTID.  <a href="#a7defb862a2a1ab4ebc1e90dfc7b78ecd">More...</a><br /></td></tr>
<tr class="separator:a7defb862a2a1ab4ebc1e90dfc7b78ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99ab163cd352da46f80df24f8589bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ac99ab163cd352da46f80df24f8589bd4">wait_for_gtid_set</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classGtid__set.html">Gtid_set</a> *gtid_set, double timeout)</td></tr>
<tr class="memdesc:ac99ab163cd352da46f80df24f8589bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the given Gtid_set is included in @GLOBAL.GTID_EXECUTED.  <a href="#ac99ab163cd352da46f80df24f8589bd4">More...</a><br /></td></tr>
<tr class="separator:ac99ab163cd352da46f80df24f8589bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774c7aef129010303e01c1be2b588814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a774c7aef129010303e01c1be2b588814">lock_sidnos</a> (const <a class="el" href="classGtid__set.html">Gtid_set</a> *<a class="el" href="suite__stubs_8h.html#ad287d8e71b971be7d1c8998b3284340c">set</a>)</td></tr>
<tr class="memdesc:a774c7aef129010303e01c1be2b588814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks one mutex for each SIDNO where the given Gtid_set has at least one GTID.  <a href="#a774c7aef129010303e01c1be2b588814">More...</a><br /></td></tr>
<tr class="separator:a774c7aef129010303e01c1be2b588814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df515758938a44f381c98813130cb94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a1df515758938a44f381c98813130cb94">unlock_sidnos</a> (const <a class="el" href="classGtid__set.html">Gtid_set</a> *<a class="el" href="suite__stubs_8h.html#ad287d8e71b971be7d1c8998b3284340c">set</a>)</td></tr>
<tr class="memdesc:a1df515758938a44f381c98813130cb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the mutex for each SIDNO where the given Gtid_set has at least one GTID.  <a href="#a1df515758938a44f381c98813130cb94">More...</a><br /></td></tr>
<tr class="separator:a1df515758938a44f381c98813130cb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf75c15c777ea5fc24e6bb6c3874974e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#acf75c15c777ea5fc24e6bb6c3874974e">broadcast_sidnos</a> (const <a class="el" href="classGtid__set.html">Gtid_set</a> *<a class="el" href="suite__stubs_8h.html#ad287d8e71b971be7d1c8998b3284340c">set</a>)</td></tr>
<tr class="memdesc:acf75c15c777ea5fc24e6bb6c3874974e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the condition variable for each SIDNO where the given Gtid_set has at least one GTID.  <a href="#acf75c15c777ea5fc24e6bb6c3874974e">More...</a><br /></td></tr>
<tr class="separator:acf75c15c777ea5fc24e6bb6c3874974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c05e7cfec3de4245fbbb515ad253630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a2c05e7cfec3de4245fbbb515ad253630">ensure_sidno</a> ()</td></tr>
<tr class="memdesc:a2c05e7cfec3de4245fbbb515ad253630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that owned_gtids, executed_gtids, lost_gtids, gtids_only_in_table, previous_gtids_logged and sid_locks have room for at least as many SIDNOs as sid_map.  <a href="#a2c05e7cfec3de4245fbbb515ad253630">More...</a><br /></td></tr>
<tr class="separator:a2c05e7cfec3de4245fbbb515ad253630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6cda798c0e3aa17239230dba017e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a6f6cda798c0e3aa17239230dba017e13">add_lost_gtids</a> (<a class="el" href="classGtid__set.html">Gtid_set</a> *gtid_set, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> starts_with_plus)</td></tr>
<tr class="memdesc:a6f6cda798c0e3aa17239230dba017e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given Gtid_set to lost_gtids and executed_gtids.  <a href="#a6f6cda798c0e3aa17239230dba017e13">More...</a><br /></td></tr>
<tr class="separator:a6f6cda798c0e3aa17239230dba017e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae65b973f8fc7b10045407988e5951e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aae65b973f8fc7b10045407988e5951e7">update_prev_gtids</a> (<a class="el" href="classGtid__set.html">Gtid_set</a> *write_gtid_set)</td></tr>
<tr class="memdesc:aae65b973f8fc7b10045407988e5951e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates previously logged GTID set before writing to table.  <a href="#aae65b973f8fc7b10045407988e5951e7">More...</a><br /></td></tr>
<tr class="separator:aae65b973f8fc7b10045407988e5951e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e9415e3475938795b264b39e067765"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a15e9415e3475938795b264b39e067765">get_lost_gtids</a> () const</td></tr>
<tr class="memdesc:a15e9415e3475938795b264b39e067765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the Gtid_set that contains the lost gtids.  <a href="#a15e9415e3475938795b264b39e067765">More...</a><br /></td></tr>
<tr class="separator:a15e9415e3475938795b264b39e067765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe87f89a8f7034cc51af9ea19a8f3efb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#abe87f89a8f7034cc51af9ea19a8f3efb">get_executed_gtids</a> () const</td></tr>
<tr class="separator:abe87f89a8f7034cc51af9ea19a8f3efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09ed411b9de30e97c099ef09e60a7ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ac09ed411b9de30e97c099ef09e60a7ee">get_gtids_only_in_table</a> () const</td></tr>
<tr class="separator:ac09ed411b9de30e97c099ef09e60a7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b781dbfe578099fc96958f14a39041"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a08b781dbfe578099fc96958f14a39041">get_previous_gtids_logged</a> () const</td></tr>
<tr class="separator:a08b781dbfe578099fc96958f14a39041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0fc358faed4567b7b4f6c71d0f7b5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOwned__gtids.html">Owned_gtids</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#add0fc358faed4567b7b4f6c71d0f7b5d">get_owned_gtids</a> () const</td></tr>
<tr class="memdesc:add0fc358faed4567b7b4f6c71d0f7b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the Owned_gtids that contains the owned gtids.  <a href="#add0fc358faed4567b7b4f6c71d0f7b5d">More...</a><br /></td></tr>
<tr class="separator:add0fc358faed4567b7b4f6c71d0f7b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f262cfcb2e7cad774b61db9ecccde1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a56f262cfcb2e7cad774b61db9ecccde1">get_server_sidno</a> () const</td></tr>
<tr class="memdesc:a56f262cfcb2e7cad774b61db9ecccde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the server's SID's SIDNO.  <a href="#a56f262cfcb2e7cad774b61db9ecccde1">More...</a><br /></td></tr>
<tr class="separator:a56f262cfcb2e7cad774b61db9ecccde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e47d659119962deb56ee07632ed6634"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="rpl__gtid_8h.html#ada65b12e73ca5b310f33aea1537852e6">rpl_sid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a0e47d659119962deb56ee07632ed6634">get_server_sid</a> () const</td></tr>
<tr class="memdesc:a0e47d659119962deb56ee07632ed6634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the server's SID.  <a href="#a0e47d659119962deb56ee07632ed6634">More...</a><br /></td></tr>
<tr class="separator:a0e47d659119962deb56ee07632ed6634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19fcbc6a9a1f112c4452d170ac28e05"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ad19fcbc6a9a1f112c4452d170ac28e05">get_max_string_length</a> () const</td></tr>
<tr class="memdesc:ad19fcbc6a9a1f112c4452d170ac28e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug only: Returns an upper bound on the length of the string generated by to_string(), not counting '\0'.  <a href="#ad19fcbc6a9a1f112c4452d170ac28e05">More...</a><br /></td></tr>
<tr class="separator:ad19fcbc6a9a1f112c4452d170ac28e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c0cb53ce52933aa88ffcfb7601a0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aa80c0cb53ce52933aa88ffcfb7601a0b">to_string</a> (char *buf) const</td></tr>
<tr class="memdesc:aa80c0cb53ce52933aa88ffcfb7601a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug only: Generate a string in the given buffer and return the length.  <a href="#aa80c0cb53ce52933aa88ffcfb7601a0b">More...</a><br /></td></tr>
<tr class="separator:aa80c0cb53ce52933aa88ffcfb7601a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153260b2d824f4253a176f3a0504de1d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a153260b2d824f4253a176f3a0504de1d">to_string</a> () const</td></tr>
<tr class="memdesc:a153260b2d824f4253a176f3a0504de1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug only: return a newly allocated string, or NULL on out-of-memory.  <a href="#a153260b2d824f4253a176f3a0504de1d">More...</a><br /></td></tr>
<tr class="separator:a153260b2d824f4253a176f3a0504de1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2735f6ca673acb5c382acb3bf1fef6ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a2735f6ca673acb5c382acb3bf1fef6ef">print</a> () const</td></tr>
<tr class="memdesc:a2735f6ca673acb5c382acb3bf1fef6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug only: print this Gtid_state to stdout.  <a href="#a2735f6ca673acb5c382acb3bf1fef6ef">More...</a><br /></td></tr>
<tr class="separator:a2735f6ca673acb5c382acb3bf1fef6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3eee2f214aabcf44b769f69c50c0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a9c3eee2f214aabcf44b769f69c50c0eb">dbug_print</a> (const char *text=&quot;&quot;) const</td></tr>
<tr class="memdesc:a9c3eee2f214aabcf44b769f69c50c0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this Gtid_state to the trace file if debug is enabled; no-op otherwise.  <a href="#a9c3eee2f214aabcf44b769f69c50c0eb">More...</a><br /></td></tr>
<tr class="separator:a9c3eee2f214aabcf44b769f69c50c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74cd18a8d4033037b733d8ed586b01a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ae74cd18a8d4033037b733d8ed586b01a">save</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ae74cd18a8d4033037b733d8ed586b01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save gtid owned by the thd into executed_gtids variable and gtid_executed table.  <a href="#ae74cd18a8d4033037b733d8ed586b01a">More...</a><br /></td></tr>
<tr class="separator:ae74cd18a8d4033037b733d8ed586b01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f5c2e657b33be09503d912a30092e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ab2f5c2e657b33be09503d912a30092e9">save</a> (const <a class="el" href="classGtid__set.html">Gtid_set</a> *gtid_set)</td></tr>
<tr class="memdesc:ab2f5c2e657b33be09503d912a30092e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the gtid set into table.  <a href="#ab2f5c2e657b33be09503d912a30092e9">More...</a><br /></td></tr>
<tr class="separator:ab2f5c2e657b33be09503d912a30092e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4800a14127212d869d511e56aaaf1132"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a4800a14127212d869d511e56aaaf1132">save_gtids_of_last_binlog_into_table</a> ()</td></tr>
<tr class="memdesc:a4800a14127212d869d511e56aaaf1132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the set of gtids logged in the last binlog into gtid_executed table.  <a href="#a4800a14127212d869d511e56aaaf1132">More...</a><br /></td></tr>
<tr class="separator:a4800a14127212d869d511e56aaaf1132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fe208121f5e1de1f180f10558d8fec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a66fe208121f5e1de1f180f10558d8fec">read_gtid_executed_from_table</a> ()</td></tr>
<tr class="memdesc:a66fe208121f5e1de1f180f10558d8fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch gtids from gtid_executed table and store them into gtid_executed set.  <a href="#a66fe208121f5e1de1f180f10558d8fec">More...</a><br /></td></tr>
<tr class="separator:a66fe208121f5e1de1f180f10558d8fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a0566657e636fb597085ca0ec87a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a731a0566657e636fb597085ca0ec87a4">compress</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a731a0566657e636fb597085ca0ec87a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the gtid_executed table, read each row by the PK(sid, gno_start) in increasing order, compress the first consecutive gtids range (delete consecutive gtids from the second consecutive gtid, then update the first gtid) within a single transaction.  <a href="#a731a0566657e636fb597085ca0ec87a4">More...</a><br /></td></tr>
<tr class="separator:a731a0566657e636fb597085ca0ec87a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bbf73574f8b6718905cc703bae77a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a06bbf73574f8b6718905cc703bae77a5">warn_or_err_on_modify_gtid_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table)</td></tr>
<tr class="memdesc:a06bbf73574f8b6718905cc703bae77a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a warning to client if user is modifying the gtid_executed table explicitly by a non-XA transaction.  <a href="#a06bbf73574f8b6718905cc703bae77a5">More...</a><br /></td></tr>
<tr class="separator:a06bbf73574f8b6718905cc703bae77a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a834c19de33b53993f367e4d433c6b1dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a834c19de33b53993f367e4d433c6b1dd">get_automatic_gno</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno) const</td></tr>
<tr class="memdesc:a834c19de33b53993f367e4d433c6b1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the next available GNO.  <a href="#a834c19de33b53993f367e4d433c6b1dd">More...</a><br /></td></tr>
<tr class="separator:a834c19de33b53993f367e4d433c6b1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe96d7ec53c01672ce9327338f77362e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#afe96d7ec53c01672ce9327338f77362e">update_gtids_impl</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_commit)</td></tr>
<tr class="memdesc:afe96d7ec53c01672ce9327338f77362e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the GTID owned by thread from owned GTIDs.  <a href="#afe96d7ec53c01672ce9327338f77362e">More...</a><br /></td></tr>
<tr class="separator:afe96d7ec53c01672ce9327338f77362e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b126ade3f5c4aa0c67b449a4c1fe04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a51b126ade3f5c4aa0c67b449a4c1fe04">unlock_owned_sidnos</a> (const <a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a51b126ade3f5c4aa0c67b449a4c1fe04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock all SIDNOs owned by the given THD.  <a href="#a51b126ade3f5c4aa0c67b449a4c1fe04">More...</a><br /></td></tr>
<tr class="separator:a51b126ade3f5c4aa0c67b449a4c1fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a493352772ccc8ff9eda15bbb9ccc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a16a493352772ccc8ff9eda15bbb9ccc1">broadcast_owned_sidnos</a> (const <a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a16a493352772ccc8ff9eda15bbb9ccc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast the condition for all SIDNOs owned by the given THD.  <a href="#a16a493352772ccc8ff9eda15bbb9ccc1">More...</a><br /></td></tr>
<tr class="separator:a16a493352772ccc8ff9eda15bbb9ccc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f1a9fe30a114f0ba3c639ef2d6f1fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a04f1a9fe30a114f0ba3c639ef2d6f1fe">update_gtids_impl_check_skip_gtid_rollback</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a04f1a9fe30a114f0ba3c639ef2d6f1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by unit tests that need to access private members.  <a href="#a04f1a9fe30a114f0ba3c639ef2d6f1fe">More...</a><br /></td></tr>
<tr class="separator:a04f1a9fe30a114f0ba3c639ef2d6f1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123a3eeb97946be67d03d3a3d29fb892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a123a3eeb97946be67d03d3a3d29fb892">update_gtids_impl_do_nothing</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a123a3eeb97946be67d03d3a3d29fb892"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a sub task of update_gtids_impl responsible only to handle the case of a thread that owns nothing and does not violate GTID consistency.  <a href="#a123a3eeb97946be67d03d3a3d29fb892">More...</a><br /></td></tr>
<tr class="separator:a123a3eeb97946be67d03d3a3d29fb892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae801543d487e9d1cd8b45c4bafd15f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ae801543d487e9d1cd8b45c4bafd15f2b">update_gtids_impl_begin</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ae801543d487e9d1cd8b45c4bafd15f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a sub task of update_gtids_impl responsible only to evaluate if the thread is committing in the middle of a statement by checking THD's is_commit_in_middle_of_statement flag.  <a href="#ae801543d487e9d1cd8b45c4bafd15f2b">More...</a><br /></td></tr>
<tr class="separator:ae801543d487e9d1cd8b45c4bafd15f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac482f7d8c431a1ffcf91ba2240ce1bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ac482f7d8c431a1ffcf91ba2240ce1bd9">update_gtids_impl_own_gtid_set</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_commit)</td></tr>
<tr class="memdesc:ac482f7d8c431a1ffcf91ba2240ce1bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the case that the thread own a set of GTIDs.  <a href="#ac482f7d8c431a1ffcf91ba2240ce1bd9">More...</a><br /></td></tr>
<tr class="separator:ac482f7d8c431a1ffcf91ba2240ce1bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd70f1d9d3bedf31701b850560c21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a41bd70f1d9d3bedf31701b850560c21a">update_gtids_impl_lock_sidno</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno)</td></tr>
<tr class="memdesc:a41bd70f1d9d3bedf31701b850560c21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a given sidno of a transaction being updated.  <a href="#a41bd70f1d9d3bedf31701b850560c21a">More...</a><br /></td></tr>
<tr class="separator:a41bd70f1d9d3bedf31701b850560c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf3da7b283c5e4f957b0a097cfa9461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#adcf3da7b283c5e4f957b0a097cfa9461">update_gtids_impl_lock_sidnos</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:adcf3da7b283c5e4f957b0a097cfa9461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the sidnos of all the GTIDs of the commit group starting on the transaction passed as parameter.  <a href="#adcf3da7b283c5e4f957b0a097cfa9461">More...</a><br /></td></tr>
<tr class="separator:adcf3da7b283c5e4f957b0a097cfa9461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892f19be4d9aa82bccf5ce3bbf244db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a892f19be4d9aa82bccf5ce3bbf244db5">update_gtids_impl_own_gtid</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_commit)</td></tr>
<tr class="memdesc:a892f19be4d9aa82bccf5ce3bbf244db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the case that the thread own a single non-anonymous GTID.  <a href="#a892f19be4d9aa82bccf5ce3bbf244db5">More...</a><br /></td></tr>
<tr class="separator:a892f19be4d9aa82bccf5ce3bbf244db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5849e78a72e3276e48946297ba91b9b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a5849e78a72e3276e48946297ba91b9b9">update_gtids_impl_broadcast_and_unlock_sidno</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno)</td></tr>
<tr class="memdesc:a5849e78a72e3276e48946297ba91b9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a given sidno after broadcasting its changes.  <a href="#a5849e78a72e3276e48946297ba91b9b9">More...</a><br /></td></tr>
<tr class="separator:a5849e78a72e3276e48946297ba91b9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac142b9b61fc6ef3bb6c1d0deed1cece4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ac142b9b61fc6ef3bb6c1d0deed1cece4">update_gtids_impl_broadcast_and_unlock_sidnos</a> ()</td></tr>
<tr class="memdesc:ac142b9b61fc6ef3bb6c1d0deed1cece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks all locked sidnos after broadcasting their changes.  <a href="#ac142b9b61fc6ef3bb6c1d0deed1cece4">More...</a><br /></td></tr>
<tr class="separator:ac142b9b61fc6ef3bb6c1d0deed1cece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de5a744c4735befe5a440257006bf3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a7de5a744c4735befe5a440257006bf3c">update_gtids_impl_own_anonymous</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *more_trx)</td></tr>
<tr class="memdesc:a7de5a744c4735befe5a440257006bf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the case that the thread owns ANONYMOUS GTID.  <a href="#a7de5a744c4735befe5a440257006bf3c">More...</a><br /></td></tr>
<tr class="separator:a7de5a744c4735befe5a440257006bf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403af04576d1b7c78ddddbc099b3e2fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a403af04576d1b7c78ddddbc099b3e2fa">update_gtids_impl_own_nothing</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a403af04576d1b7c78ddddbc099b3e2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the case that the thread owns nothing.  <a href="#a403af04576d1b7c78ddddbc099b3e2fa">More...</a><br /></td></tr>
<tr class="separator:a403af04576d1b7c78ddddbc099b3e2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6505eb2482989c9074ed47eb83682a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ae6505eb2482989c9074ed47eb83682a2">update_gtids_impl_end</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> more_trx)</td></tr>
<tr class="memdesc:ae6505eb2482989c9074ed47eb83682a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the final part of update_gtids_impl.  <a href="#ae6505eb2482989c9074ed47eb83682a2">More...</a><br /></td></tr>
<tr class="separator:ae6505eb2482989c9074ed47eb83682a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c074cdb57f251a5cac72d93fe6082d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a7c074cdb57f251a5cac72d93fe6082d7">ensure_commit_group_sidnos</a> (<a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> sidno)</td></tr>
<tr class="memdesc:a7c074cdb57f251a5cac72d93fe6082d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that commit_group_sidnos have room for the SIDNO passed as parameter.  <a href="#a7c074cdb57f251a5cac72d93fe6082d7">More...</a><br /></td></tr>
<tr class="separator:a7c074cdb57f251a5cac72d93fe6082d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a43df262dbde2521ed215d00a0a166903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a43df262dbde2521ed215d00a0a166903">next_free_gno</a></td></tr>
<tr class="memdesc:a43df262dbde2521ed215d00a0a166903"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next_free_gno variable will be set with the supposed next free GNO every time a new GNO is delivered automatically or when a transaction is rolled back, releasing a GNO smaller than the last one delivered.  <a href="#a43df262dbde2521ed215d00a0a166903">More...</a><br /></td></tr>
<tr class="separator:a43df262dbde2521ed215d00a0a166903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65439378e7e1cfe8cd7c6ff4ed749ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ab65439378e7e1cfe8cd7c6ff4ed749ce">sid_lock</a></td></tr>
<tr class="memdesc:ab65439378e7e1cfe8cd7c6ff4ed749ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write lock that protects updates to the number of SIDs.  <a href="#ab65439378e7e1cfe8cd7c6ff4ed749ce">More...</a><br /></td></tr>
<tr class="separator:ab65439378e7e1cfe8cd7c6ff4ed749ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46186a7ce7f287ac71a6f9d114091b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSid__map.html">Sid_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a46186a7ce7f287ac71a6f9d114091b22">sid_map</a></td></tr>
<tr class="memdesc:a46186a7ce7f287ac71a6f9d114091b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Sid_map used by this Gtid_state.  <a href="#a46186a7ce7f287ac71a6f9d114091b22">More...</a><br /></td></tr>
<tr class="separator:a46186a7ce7f287ac71a6f9d114091b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e38e036ea2abc473c4d916d20e7a44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMutex__cond__array.html">Mutex_cond_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a5e38e036ea2abc473c4d916d20e7a44e">sid_locks</a></td></tr>
<tr class="memdesc:a5e38e036ea2abc473c4d916d20e7a44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains one mutex/cond pair for every SIDNO.  <a href="#a5e38e036ea2abc473c4d916d20e7a44e">More...</a><br /></td></tr>
<tr class="separator:a5e38e036ea2abc473c4d916d20e7a44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5125d8c4aa10b0459c67ab418ba7b38e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtid__set.html">Gtid_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a5125d8c4aa10b0459c67ab418ba7b38e">lost_gtids</a></td></tr>
<tr class="memdesc:a5125d8c4aa10b0459c67ab418ba7b38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of GTIDs that existed in some previously purged binary log.  <a href="#a5125d8c4aa10b0459c67ab418ba7b38e">More...</a><br /></td></tr>
<tr class="separator:a5125d8c4aa10b0459c67ab418ba7b38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869b9354d10defd652545378de658703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtid__set.html">Gtid_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a869b9354d10defd652545378de658703">executed_gtids</a></td></tr>
<tr class="separator:a869b9354d10defd652545378de658703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833b5a205bee7d8307ee3978062f5d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtid__set.html">Gtid_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a833b5a205bee7d8307ee3978062f5d31">gtids_only_in_table</a></td></tr>
<tr class="separator:a833b5a205bee7d8307ee3978062f5d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6945ba776f950c749a8f51838351a4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtid__set.html">Gtid_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a6945ba776f950c749a8f51838351a4db">previous_gtids_logged</a></td></tr>
<tr class="separator:a6945ba776f950c749a8f51838351a4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55048f7fef8e7c66c310a5acc9cd8043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOwned__gtids.html">Owned_gtids</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a55048f7fef8e7c66c310a5acc9cd8043">owned_gtids</a></td></tr>
<tr class="memdesc:a55048f7fef8e7c66c310a5acc9cd8043"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of GTIDs that are owned by some thread.  <a href="#a55048f7fef8e7c66c310a5acc9cd8043">More...</a><br /></td></tr>
<tr class="separator:a55048f7fef8e7c66c310a5acc9cd8043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f4a1252fe66bab3757c7e6fc8e335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a348f4a1252fe66bab3757c7e6fc8e335">server_sidno</a></td></tr>
<tr class="memdesc:a348f4a1252fe66bab3757c7e6fc8e335"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SIDNO for this server.  <a href="#a348f4a1252fe66bab3757c7e6fc8e335">More...</a><br /></td></tr>
<tr class="separator:a348f4a1252fe66bab3757c7e6fc8e335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47df73991055f5575a521ebc7df78c21"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#a47df73991055f5575a521ebc7df78c21">atomic_anonymous_gtid_count</a> {0}</td></tr>
<tr class="memdesc:a47df73991055f5575a521ebc7df78c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of anonymous transactions owned by any client.  <a href="#a47df73991055f5575a521ebc7df78c21">More...</a><br /></td></tr>
<tr class="separator:a47df73991055f5575a521ebc7df78c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28466e26df247b9b7cff0867284ad51"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ad28466e26df247b9b7cff0867284ad51">atomic_automatic_gtid_violation_count</a> {0}</td></tr>
<tr class="memdesc:ad28466e26df247b9b7cff0867284ad51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of GTID-violating transactions that use GTID_NEXT=AUTOMATIC.  <a href="#ad28466e26df247b9b7cff0867284ad51">More...</a><br /></td></tr>
<tr class="separator:ad28466e26df247b9b7cff0867284ad51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada44923f630f3a6855bbbf804464b2c6"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ada44923f630f3a6855bbbf804464b2c6">atomic_anonymous_gtid_violation_count</a> {0}</td></tr>
<tr class="memdesc:ada44923f630f3a6855bbbf804464b2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of GTID-violating transactions that use GTID_NEXT=AUTOMATIC.  <a href="#ada44923f630f3a6855bbbf804464b2c6">More...</a><br /></td></tr>
<tr class="separator:ada44923f630f3a6855bbbf804464b2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e4d53f6233ffc24f67a25d16ac46de"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#ad3e4d53f6233ffc24f67a25d16ac46de">atomic_gtid_wait_count</a> {0}</td></tr>
<tr class="memdesc:ad3e4d53f6233ffc24f67a25d16ac46de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of clients that are executing WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS.  <a href="#ad3e4d53f6233ffc24f67a25d16ac46de">More...</a><br /></td></tr>
<tr class="separator:ad3e4d53f6233ffc24f67a25d16ac46de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8edc31eba8d09e32193d53442463277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPrealloced__array.html">Prealloced_array</a>&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtid__state.html#aa8edc31eba8d09e32193d53442463277">commit_group_sidnos</a></td></tr>
<tr class="memdesc:aa8edc31eba8d09e32193d53442463277"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array is used by Gtid_state_update_gtids_impl* functions.  <a href="#aa8edc31eba8d09e32193d53442463277">More...</a><br /></td></tr>
<tr class="separator:aa8edc31eba8d09e32193d53442463277"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the server's GTID state: the set of committed GTIDs, the set of lost gtids, the set of owned gtids, the owner of each owned gtid, and a Mutex_cond_array that protects updates to gtids of each SIDNO. </p>
<p>Locking:</p>
<p>This data structure has a read-write lock that protects the number of SIDNOs, and a Mutex_cond_array that contains one mutex per SIDNO. The rwlock is always the global_sid_lock.</p>
<p>Access methods generally assert that the caller already holds the appropriate lock:</p>
<ul>
<li>before accessing any global data, hold at least the rdlock.</li>
<li>before accessing a specific SIDNO in a Gtid_set or Owned_gtids (e.g., calling Gtid_set::_add_gtid(Gtid)), hold either the rdlock and the SIDNO's mutex lock; or the wrlock. If you need to hold multiple mutexes, they must be acquired in order of increasing SIDNO.</li>
<li>before starting an operation that needs to access all SIDs (e.g. Gtid_set::to_string()), hold the wrlock.</li>
</ul>
<p>The access type (read/write) does not matter; the write lock only implies that the entire data structure is locked whereas the read lock implies that everything except SID-specific data is locked. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4e93b5ffa97a101e51aa722cf5f56ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e93b5ffa97a101e51aa722cf5f56ef3">&#9670;&nbsp;</a></span>Gtid_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gtid_state::Gtid_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a> *&#160;</td>
          <td class="paramname"><em>_sid_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSid__map.html">Sid_map</a> *&#160;</td>
          <td class="paramname"><em>_sid_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new Gtid_state object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_sid_lock</td><td>Read-write lock that protects updates to the number of SIDs. </td></tr>
    <tr><td class="paramname">_sid_map</td><td>Sid_map used by this Gtid_state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7e259736e00e4fa5835ec9cdd34dc0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e259736e00e4fa5835ec9cdd34dc0ba">&#9670;&nbsp;</a></span>acquire_anonymous_ownership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::acquire_anonymous_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire anonymous ownership. </p>
<p>The caller must hold either sid_lock.rdlock or sid_lock.wrlock. (The caller must have taken the lock and checked that gtid_mode!=ON before calling this function, or else the gtid_mode could have changed to ON by a concurrent SET GTID_MODE.) </p>

</div>
</div>
<a id="a3bedc53a5eed5898822ede2a9d5214d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bedc53a5eed5898822ede2a9d5214d6">&#9670;&nbsp;</a></span>acquire_ownership()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a> Gtid_state::acquire_ownership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGtid.html">Gtid</a> &amp;&#160;</td>
          <td class="paramname"><em>gtid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires ownership of the given GTID, on behalf of the given thread. </p>
<p>The caller must lock the SIDNO before invoking this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread that will own the GTID. </td></tr>
    <tr><td class="paramname">gtid</td><td>The Gtid to acquire ownership of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a6f6cda798c0e3aa17239230dba017e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6cda798c0e3aa17239230dba017e13">&#9670;&nbsp;</a></span>add_lost_gtids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a> Gtid_state::add_lost_gtids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>starts_with_plus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given Gtid_set to lost_gtids and executed_gtids. </p>
<p>lost_gtids must be a subset of executed_gtids. purged_gtid and executed_gtid sets are appened with the argument set provided the latter is disjoint with gtid_executed owned_gtids.</p>
<p>Requires that the caller holds global_sid_lock.wrlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gtid_set</td><td>The gtid_set to add. If the gtid_set does not start with a plus sign (starts_with_plus is false), @GLOBAL.GTID_PURGED will be removed from the gtid_set. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">starts_with_plus</td><td>If true, the gtid_set passed is required to be disjoint from @GLOBAL.GTID_PURGED; if false, the gtid_set passed is required to be a superset of @GLOBAL.GTID_PURGED. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a9a3acb3b64327c2a5ce389a04a8ba026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3acb3b64327c2a5ce389a04a8ba026">&#9670;&nbsp;</a></span>assert_sidno_lock_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::assert_sidno_lock_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that we own the given SIDNO. </p>

</div>
</div>
<a id="a315fbccbb1afe3414b5ef732027d2af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315fbccbb1afe3414b5ef732027d2af6">&#9670;&nbsp;</a></span>begin_anonymous_gtid_violating_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::begin_anonymous_gtid_violating_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the global counter when starting a GTID-violating transaction having GTID_NEXT=ANONYMOUS. </p>

</div>
</div>
<a id="abda6d7defb7e4a1477c7a33ce8ee1263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda6d7defb7e4a1477c7a33ce8ee1263">&#9670;&nbsp;</a></span>begin_automatic_gtid_violating_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::begin_automatic_gtid_violating_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the global counter when starting a GTID-violating transaction having GTID_NEXT=AUTOMATIC. </p>

</div>
</div>
<a id="af24be6529374d7badb7cd17e330ac840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24be6529374d7badb7cd17e330ac840">&#9670;&nbsp;</a></span>begin_gtid_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::begin_gtid_wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the global counter when starting a call to WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS. </p>

</div>
</div>
<a id="a16a493352772ccc8ff9eda15bbb9ccc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a493352772ccc8ff9eda15bbb9ccc1">&#9670;&nbsp;</a></span>broadcast_owned_sidnos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::broadcast_owned_sidnos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast the condition for all SIDNOs owned by the given THD. </p>

</div>
</div>
<a id="ae8e2deb3fdc80fcb1931bc422f8382ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e2deb3fdc80fcb1931bc422f8382ad">&#9670;&nbsp;</a></span>broadcast_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::broadcast_sidno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts updates for the given SIDNO. </p>

</div>
</div>
<a id="acf75c15c777ea5fc24e6bb6c3874974e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf75c15c777ea5fc24e6bb6c3874974e">&#9670;&nbsp;</a></span>broadcast_sidnos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::broadcast_sidnos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the condition variable for each SIDNO where the given Gtid_set has at least one GTID. </p>

</div>
</div>
<a id="ad923504d43e3b912ab1aaad9bb65a8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad923504d43e3b912ab1aaad9bb65a8b7">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the state and persistor after RESET MASTER: remove all logged and lost gtids, but keep owned gtids as they are. </p>
<p>The caller must hold the write lock on sid_lock before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread requesting to reset the persistor</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">-1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a731a0566657e636fb597085ca0ec87a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731a0566657e636fb597085ca0ec87a4">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress the gtid_executed table, read each row by the PK(sid, gno_start) in increasing order, compress the first consecutive gtids range (delete consecutive gtids from the second consecutive gtid, then update the first gtid) within a single transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread requesting to compress the table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>The table was not found. </td></tr>
    <tr><td class="paramname">-1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c3eee2f214aabcf44b769f69c50c0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3eee2f214aabcf44b769f69c50c0eb">&#9670;&nbsp;</a></span>dbug_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::dbug_print </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print this Gtid_state to the trace file if debug is enabled; no-op otherwise. </p>

</div>
</div>
<a id="ad56fbf5a2c062a5b2db3eab4444c2f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56fbf5a2c062a5b2db3eab4444c2f2f">&#9670;&nbsp;</a></span>end_anonymous_gtid_violating_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::end_anonymous_gtid_violating_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease the global counter when ending a GTID-violating transaction having GTID_NEXT=ANONYMOUS. </p>

</div>
</div>
<a id="a138d09ad92a3df53b57f065b6535d7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138d09ad92a3df53b57f065b6535d7a0">&#9670;&nbsp;</a></span>end_automatic_gtid_violating_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::end_automatic_gtid_violating_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease the global counter when ending a GTID-violating transaction having GTID_NEXT=AUTOMATIC. </p>

</div>
</div>
<a id="ab9e16543dafff485d212b494adb5dffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e16543dafff485d212b494adb5dffb">&#9670;&nbsp;</a></span>end_gtid_violating_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::end_gtid_violating_transaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b849b9b07629619b77882ddb5fde5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b849b9b07629619b77882ddb5fde5ac">&#9670;&nbsp;</a></span>end_gtid_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::end_gtid_wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease the global counter when ending a call to WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS. </p>

</div>
</div>
<a id="a7c074cdb57f251a5cac72d93fe6082d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c074cdb57f251a5cac72d93fe6082d7">&#9670;&nbsp;</a></span>ensure_commit_group_sidnos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a> Gtid_state::ensure_commit_group_sidnos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that commit_group_sidnos have room for the SIDNO passed as parameter. </p>
<p>This function must only be called in one place: Gtid_state::ensure_sidno().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The SIDNO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a2c05e7cfec3de4245fbbb515ad253630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c05e7cfec3de4245fbbb515ad253630">&#9670;&nbsp;</a></span>ensure_sidno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a> Gtid_state::ensure_sidno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that owned_gtids, executed_gtids, lost_gtids, gtids_only_in_table, previous_gtids_logged and sid_locks have room for at least as many SIDNOs as sid_map. </p>
<p>This function must only be called in one place: Sid_map::add_sid().</p>
<p>Requires that the write lock on sid_locks is held. If any object needs to be resized, then the lock will be temporarily upgraded to a write lock and then degraded to a read lock again; there will be a short period when the lock is not held at all.</p>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a56dc1e07ba3548a2b460f6c8a40abb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dc1e07ba3548a2b460f6c8a40abb70">&#9670;&nbsp;</a></span>generate_automatic_gtid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a> Gtid_state::generate_automatic_gtid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>specified_sidno</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a>&#160;</td>
          <td class="paramname"><em>specified_gno</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> *&#160;</td>
          <td class="paramname"><em>locked_sidno</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the GTID (or ANONYMOUS, if GTID_MODE = OFF or OFF_PERMISSIVE) for the THD, and acquires ownership. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">specified_sidno</td><td>Externaly generated sidno. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">specified_gno</td><td>Externaly generated gno. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">locked_sidno</td><td>This parameter should be used when there is a need of generating many GTIDs without having to acquire/release a sidno_lock many times. The caller must hold global_sid_lock and unlock the locked_sidno after invocation when locked_sidno &gt; 0 if locked_sidno!=NULL. The caller must not hold global_sid_lock when locked_sidno==NULL. See comments on function code to more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_ERROR. Error can happen in case of out of memory or if the range of GNOs was exhausted. </dd></dl>

</div>
</div>
<a id="a77271375b558d3f23317b10752fec8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77271375b558d3f23317b10752fec8bd">&#9670;&nbsp;</a></span>get_anonymous_gtid_violating_transaction_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> Gtid_state::get_anonymous_gtid_violating_transaction_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of ongoing GTID-violating transactions having GTID_NEXT=AUTOMATIC. </p>

</div>
</div>
<a id="ae1612d90e7c0a0f6fec94b9a05e12fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1612d90e7c0a0f6fec94b9a05e12fbf">&#9670;&nbsp;</a></span>get_anonymous_ownership_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> Gtid_state::get_anonymous_ownership_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of clients that hold anonymous ownership. </p>

</div>
</div>
<a id="a834c19de33b53993f367e4d433c6b1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834c19de33b53993f367e4d433c6b1dd">&#9670;&nbsp;</a></span>get_automatic_gno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a> Gtid_state::get_automatic_gno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the next available GNO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The GTID's SIDNO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>The range of GNOs was exhausted (i.e., more than 1&lt;&lt;63-1 GTIDs with the same UUID have been generated). </td></tr>
    <tr><td class="paramname">&gt;0</td><td>The GNO for the GTID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a954b493111b1b2a7ad049db64eefe050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954b493111b1b2a7ad049db64eefe050">&#9670;&nbsp;</a></span>get_automatic_gtid_violating_transaction_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> Gtid_state::get_automatic_gtid_violating_transaction_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of ongoing GTID-violating transactions having GTID_NEXT=AUTOMATIC. </p>

</div>
</div>
<a id="abe87f89a8f7034cc51af9ea19a8f3efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe87f89a8f7034cc51af9ea19a8f3efb">&#9670;&nbsp;</a></span>get_executed_gtids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtid__set.html">Gtid_set</a>* Gtid_state::get_executed_gtids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59586299cdb464b0378338eba646fb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59586299cdb464b0378338eba646fb9c">&#9670;&nbsp;</a></span>get_gtid_wait_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a> Gtid_state::get_gtid_wait_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of clients that have an ongoing call to WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS. </p>

</div>
</div>
<a id="ac09ed411b9de30e97c099ef09e60a7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09ed411b9de30e97c099ef09e60a7ee">&#9670;&nbsp;</a></span>get_gtids_only_in_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtid__set.html">Gtid_set</a>* Gtid_state::get_gtids_only_in_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad58b3ccada19a67f2b8b5f690d08a309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58b3ccada19a67f2b8b5f690d08a309">&#9670;&nbsp;</a></span>get_last_executed_gno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a> Gtid_state::get_last_executed_gno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the last executed GNO for a given SIDNO, e.g. </p>
<p>for the following set: UUID:1-10, UUID:12, UUID:15-20 20 will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The GTID's SIDNO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>GNO or 0 if set is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15e9415e3475938795b264b39e067765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e9415e3475938795b264b39e067765">&#9670;&nbsp;</a></span>get_lost_gtids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtid__set.html">Gtid_set</a>* Gtid_state::get_lost_gtids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the Gtid_set that contains the lost gtids. </p>

</div>
</div>
<a id="ad19fcbc6a9a1f112c4452d170ac28e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19fcbc6a9a1f112c4452d170ac28e05">&#9670;&nbsp;</a></span>get_max_string_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Gtid_state::get_max_string_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debug only: Returns an upper bound on the length of the string generated by to_string(), not counting '\0'. </p>
<p>The actual length may be shorter. </p>

</div>
</div>
<a id="add0fc358faed4567b7b4f6c71d0f7b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0fc358faed4567b7b4f6c71d0f7b5d">&#9670;&nbsp;</a></span>get_owned_gtids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOwned__gtids.html">Owned_gtids</a>* Gtid_state::get_owned_gtids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the Owned_gtids that contains the owned gtids. </p>

</div>
</div>
<a id="a08b781dbfe578099fc96958f14a39041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b781dbfe578099fc96958f14a39041">&#9670;&nbsp;</a></span>get_previous_gtids_logged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtid__set.html">Gtid_set</a>* Gtid_state::get_previous_gtids_logged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e47d659119962deb56ee07632ed6634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e47d659119962deb56ee07632ed6634">&#9670;&nbsp;</a></span>get_server_sid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="rpl__gtid_8h.html#ada65b12e73ca5b310f33aea1537852e6">rpl_sid</a>&amp; Gtid_state::get_server_sid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the server's SID. </p>

</div>
</div>
<a id="a56f262cfcb2e7cad774b61db9ecccde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f262cfcb2e7cad774b61db9ecccde1">&#9670;&nbsp;</a></span>get_server_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> Gtid_state::get_server_sidno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the server's SID's SIDNO. </p>

</div>
</div>
<a id="a05bbafc9331c90395789157153fd3601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bbafc9331c90395789157153fd3601">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add @GLOBAL.SERVER_UUID to this binlog's Sid_map. </p>
<p>This can't be done in the constructor because the constructor is invoked at server startup before SERVER_UUID is initialized.</p>
<p>The caller must hold the read lock or write lock on sid_locks before invoking this function.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">1</td><td>Error (out of memory or IO error). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa85f3475832c5bab63b37c8f7fd65300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85f3475832c5bab63b37c8f7fd65300">&#9670;&nbsp;</a></span>is_executed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::is_executed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGtid.html">Gtid</a> &amp;&#160;</td>
          <td class="paramname"><em>gtid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given GTID is logged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gtid</td><td>The Gtid to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The gtid is logged in the binary log. </td></tr>
    <tr><td class="paramname">false</td><td>The gtid is not logged in the binary log. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4a0e22e395f095aad358b1db91e170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a0e22e395f095aad358b1db91e170a">&#9670;&nbsp;</a></span>is_owned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::is_owned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGtid.html">Gtid</a> &amp;&#160;</td>
          <td class="paramname"><em>gtid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if GTID is owned, otherwise returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gtid</td><td>The Gtid to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if some thread owns the gtid, false if the gtid is not owned </dd></dl>

</div>
</div>
<a id="ac3d84b821f0021c098306971c6cc75a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d84b821f0021c098306971c6cc75a6">&#9670;&nbsp;</a></span>lock_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::lock_sidno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks a mutex for the given SIDNO. </p>

</div>
</div>
<a id="a774c7aef129010303e01c1be2b588814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774c7aef129010303e01c1be2b588814">&#9670;&nbsp;</a></span>lock_sidnos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::lock_sidnos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks one mutex for each SIDNO where the given Gtid_set has at least one GTID. </p>
<p>Locks are acquired in order of increasing SIDNO. </p>

</div>
</div>
<a id="a2735f6ca673acb5c382acb3bf1fef6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2735f6ca673acb5c382acb3bf1fef6ef">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debug only: print this Gtid_state to stdout. </p>

</div>
</div>
<a id="a66fe208121f5e1de1f180f10558d8fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fe208121f5e1de1f180f10558d8fec">&#9670;&nbsp;</a></span>read_gtid_executed_from_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::read_gtid_executed_from_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch gtids from gtid_executed table and store them into gtid_executed set. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>The table was not found. </td></tr>
    <tr><td class="paramname">-1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedf31ed3dbdbab7cf4ce39de1ca51bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf31ed3dbdbab7cf4ce39de1ca51bee">&#9670;&nbsp;</a></span>release_anonymous_ownership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::release_anonymous_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release anonymous ownership. </p>

</div>
</div>
<a id="ae74cd18a8d4033037b733d8ed586b01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74cd18a8d4033037b733d8ed586b01a">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save gtid owned by the thd into executed_gtids variable and gtid_executed table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session to commit </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2f5c2e657b33be09503d912a30092e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f5c2e657b33be09503d912a30092e9">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the gtid set into table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gtid_set</td><td>contains a set of gtid, which holds the sidno and the gno.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4800a14127212d869d511e56aaaf1132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4800a14127212d869d511e56aaaf1132">&#9670;&nbsp;</a></span>save_gtids_of_last_binlog_into_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::save_gtids_of_last_binlog_into_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the set of gtids logged in the last binlog into gtid_executed table. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa80c0cb53ce52933aa88ffcfb7601a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c0cb53ce52933aa88ffcfb7601a0b">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::to_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debug only: Generate a string in the given buffer and return the length. </p>

</div>
</div>
<a id="a153260b2d824f4253a176f3a0504de1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153260b2d824f4253a176f3a0504de1d">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Gtid_state::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debug only: return a newly allocated string, or NULL on out-of-memory. </p>

</div>
</div>
<a id="a51b126ade3f5c4aa0c67b449a4c1fe04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b126ade3f5c4aa0c67b449a4c1fe04">&#9670;&nbsp;</a></span>unlock_owned_sidnos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::unlock_owned_sidnos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock all SIDNOs owned by the given THD. </p>

</div>
</div>
<a id="aa28f4660564a239c4e538b86dce1f832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28f4660564a239c4e538b86dce1f832">&#9670;&nbsp;</a></span>unlock_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::unlock_sidno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks a mutex for the given SIDNO. </p>

</div>
</div>
<a id="a1df515758938a44f381c98813130cb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df515758938a44f381c98813130cb94">&#9670;&nbsp;</a></span>unlock_sidnos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::unlock_sidnos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks the mutex for each SIDNO where the given Gtid_set has at least one GTID. </p>

</div>
</div>
<a id="a9fa3ed5a9b5fc7d0a4ad5492b657b790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa3ed5a9b5fc7d0a4ad5492b657b790">&#9670;&nbsp;</a></span>update_commit_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_commit_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>first_thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates both the THD and the Gtid_state to reflect that the transaction set of transactions has ended, and it does this for the whole commit group (by following the thd-&gt;next_to_commit pointer). </p>
<p>It will:</p>
<ul>
<li>Clean up the thread state when a thread owned GTIDs is empty.</li>
<li>Release ownership of all GTIDs owned by the THDs. This removes the GTIDs from Owned_gtids and clears the ownership status in the THDs object.</li>
<li>Add the owned GTIDs to executed_gtids when the thread is committing.</li>
<li>Decrease counters of GTID-violating transactions.</li>
<li>Send a broadcast on the condition variable for every sidno for which we released ownership.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_thd</td><td>The first thread of the group commit that needs GTIDs to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe96d7ec53c01672ce9327338f77362e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe96d7ec53c01672ce9327338f77362e">&#9670;&nbsp;</a></span>update_gtids_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the GTID owned by thread from owned GTIDs. </p>
<p>This will:</p>
<ul>
<li>Clean up the thread state if the thread owned GTIDs is empty.</li>
<li>Release ownership of all GTIDs owned by the THD. This removes the GTID from Owned_gtids and clears the ownership status in the THD object.</li>
<li>Add the owned GTID to executed_gtids if the is_commit flag is set.</li>
<li>Decrease counters of GTID-violating transactions.</li>
<li>Send a broadcast on the condition variable for every sidno for which we released ownership.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread for which owned gtids are updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_commit</td><td>If true, the update is for a commit (not a rollback). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae801543d487e9d1cd8b45c4bafd15f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae801543d487e9d1cd8b45c4bafd15f2b">&#9670;&nbsp;</a></span>update_gtids_impl_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::update_gtids_impl_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a sub task of update_gtids_impl responsible only to evaluate if the thread is committing in the middle of a statement by checking THD's is_commit_in_middle_of_statement flag. </p>
<p>This flag is true for anonymous transactions, when the 'transaction' has been split into multiple transactions in the binlog, and the present transaction is not the last one.</p>
<p>This means two things:</p>
<ul>
<li>We should not release anonymous ownership in case gtid_next=anonymous. If we did, it would be possible for user to set GTID_MODE=ON from a concurrent transaction, making it impossible to commit the current transaction.</li>
<li>We should not decrease the counters for GTID-violating statements. If we did, it would be possible for a concurrent client to set ENFORCE_GTID_CONSISTENCY=ON despite there is an ongoing transaction that violates GTID consistency.</li>
</ul>
<p>The flag is set in two cases:</p>
<ol type="1">
<li><p class="startli">We are committing the statement cache when there are more changes in the transaction cache.</p>
<p class="startli">This happens either because a single statement in the beginning of a transaction updates both transactional and non-transactional tables, or because we are committing a non-transactional update in the middle of a transaction when binlog_direct_non_transactional_updates=1.</p>
<p class="startli">In this case, the flag is set further down in this function.</p>
</li>
<li><p class="startli">The statement is one of the special statements that may generate multiple transactions: CREATE...SELECT, DROP TABLE, DROP DATABASE. See comment for THD::owned_gtid in sql/sql_class.h.</p>
<p class="startli">In this case, the THD::is_commit_in_middle_of_statement flag is set by the caller and the flag becomes true here.</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of thread's is_commit_in_middle_of_statement flag. </dd></dl>

</div>
</div>
<a id="a5849e78a72e3276e48946297ba91b9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5849e78a72e3276e48946297ba91b9b9">&#9670;&nbsp;</a></span>update_gtids_impl_broadcast_and_unlock_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_broadcast_and_unlock_sidno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock a given sidno after broadcasting its changes. </p>
<p>This is a sub task of update_gtids_impl responsible only to unlock the sidno of the GTID being updated after broadcasting its changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sidno</td><td>- The sidno to be broadcasted and unlocked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac142b9b61fc6ef3bb6c1d0deed1cece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac142b9b61fc6ef3bb6c1d0deed1cece4">&#9670;&nbsp;</a></span>update_gtids_impl_broadcast_and_unlock_sidnos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_broadcast_and_unlock_sidnos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks all locked sidnos after broadcasting their changes. </p>
<p>This is a sub task of update_commit_group responsible only to unlock the sidno(s) of the GTID(s) being updated after broadcasting their changes. </p>

</div>
</div>
<a id="a04f1a9fe30a114f0ba3c639ef2d6f1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f1a9fe30a114f0ba3c639ef2d6f1fe">&#9670;&nbsp;</a></span>update_gtids_impl_check_skip_gtid_rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::update_gtids_impl_check_skip_gtid_rollback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by unit tests that need to access private members. </p>
<p>This is a sub task of update_on_rollback responsible only to handle the case of a thread that needs to skip GTID operations when it has "failed to commit".</p>
<p>Administrative commands [CHECK|REPAIR|OPTIMIZE|ANALYZE] TABLE are written to the binary log even when they fail. When the commands fail, they will call update_on_rollback; later they will write the binary log. But we must not do any of the things in update_gtids_impl if we are going to write the binary log. So these statements set the skip_gtid_rollback flag, which tells update_on_rollback to return early. When the statements are written to the binary log they will call update_on_commit as usual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread to be evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The transaction should skip the rollback, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a123a3eeb97946be67d03d3a3d29fb892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123a3eeb97946be67d03d3a3d29fb892">&#9670;&nbsp;</a></span>update_gtids_impl_do_nothing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::update_gtids_impl_do_nothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a sub task of update_gtids_impl responsible only to handle the case of a thread that owns nothing and does not violate GTID consistency. </p>
<p>If the THD does not own anything, there is nothing to do, so we can do an early return of the update process. Except if there is a GTID consistency violation; then we need to decrease the counter, so then we can continue executing inside update_gtids_impl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread to be evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The transaction can be skipped because it owns nothing and does not violate GTID consistency, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6505eb2482989c9074ed47eb83682a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6505eb2482989c9074ed47eb83682a2">&#9670;&nbsp;</a></span>update_gtids_impl_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>more_trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the final part of update_gtids_impl. </p>
<p>This is a sub task of update_gtids_impl responsible only to handle the call to end_gtid_violating_transaction function when there is no more transactions split after the current transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread for which owned GTID is updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">more_trx</td><td>- This is the value returned from Gtid_state::update_gtids_impl_begin and can be changed for transactions owning anonymous GTID at Gtid_state::update_gtids_impl_own_anonymous. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41bd70f1d9d3bedf31701b850560c21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd70f1d9d3bedf31701b850560c21a">&#9670;&nbsp;</a></span>update_gtids_impl_lock_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_lock_sidno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock a given sidno of a transaction being updated. </p>
<p>This is a sub task of update_gtids_impl responsible only to lock the sidno of the GTID being updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sidno</td><td>- The sidno to be locked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcf3da7b283c5e4f957b0a097cfa9461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf3da7b283c5e4f957b0a097cfa9461">&#9670;&nbsp;</a></span>update_gtids_impl_lock_sidnos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_lock_sidnos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the sidnos of all the GTIDs of the commit group starting on the transaction passed as parameter. </p>
<p>This is a sub task of update_commit_group responsible only to lock the sidno(s) of the GTID(s) being updated.</p>
<p>The function should follow thd-&gt;next_to_commit to lock all sidnos of all transactions being updated in a group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread that owns the GTID(s) to be updated or leader of the commit group in the case of a commit group update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7de5a744c4735befe5a440257006bf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de5a744c4735befe5a440257006bf3c">&#9670;&nbsp;</a></span>update_gtids_impl_own_anonymous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_own_anonymous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>more_trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the case that the thread owns ANONYMOUS GTID. </p>
<p>This is a sub task of update_gtids_impl responsible only to handle the case of a thread with an ANONYMOUS GTID being updated.</p>
<ul>
<li>Release ownership of the anonymous GTID owned by the THD and clears the ownership status in the THD object.</li>
<li>Decrease counters of GTID-violating transactions.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread to be updated that owns anonymous GTID. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">more_trx</td><td>- If the 'transaction' has been split into multiple transactions in the binlog. This is firstly assigned with the return of Gtid_state::update_gtids_impl_begin function, and its value can be set to true when Gtid_state::update_gtids_impl_anonymous_gtid detects more content on the transaction cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a892f19be4d9aa82bccf5ce3bbf244db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892f19be4d9aa82bccf5ce3bbf244db5">&#9670;&nbsp;</a></span>update_gtids_impl_own_gtid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_own_gtid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the case that the thread own a single non-anonymous GTID. </p>
<p>This is a sub task of update_gtids_impl responsible only to handle the case of a thread with a single non-anonymous GTID being updated either for commit or rollback.</p>
<ul>
<li>Release ownership of the GTID owned by the THD. This removes the GTID from Owned_gtids and clears the ownership status in the THD object.</li>
<li>Add the owned GTID to executed_gtids if the is_commit flag is set.</li>
<li>Send a broadcast on the condition variable for the sidno which we released ownership.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread to be updated that owns single non-anonymous GTID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_commit</td><td>- If the thread is being updated by a commit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac482f7d8c431a1ffcf91ba2240ce1bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac482f7d8c431a1ffcf91ba2240ce1bd9">&#9670;&nbsp;</a></span>update_gtids_impl_own_gtid_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_own_gtid_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the case that the thread own a set of GTIDs. </p>
<p>This is a sub task of update_gtids_impl responsible only to handle the case of a thread with a set of GTIDs being updated.</p>
<ul>
<li>Release ownership of the GTIDs owned by the THD. This removes the GTID from Owned_gtids and clears the ownership status in the THD object.</li>
<li>Add the owned GTIDs to executed_gtids if the is_commit flag is set.</li>
<li>Send a broadcast on the condition variable for the sidno which we released ownership.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread for which owned GTID set should be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_commit</td><td>- If the thread is being updated by a commit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a403af04576d1b7c78ddddbc099b3e2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403af04576d1b7c78ddddbc099b3e2fa">&#9670;&nbsp;</a></span>update_gtids_impl_own_nothing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_gtids_impl_own_nothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the case that the thread owns nothing. </p>
<p>This is a sub task of update_gtids_impl responsible only to handle the case of a thread that owns nothing being updated.</p>
<p>There are two cases when this happens:</p><ul>
<li>Normally, it is a rollback of an automatic transaction, so the is_commit is false and gtid_next=automatic.</li>
<li>There is also a corner case. This case may happen for a transaction that uses GTID_NEXT=AUTOMATIC, and violates GTID_CONSISTENCY, and commits changes to the database, but does not write to the binary log, so that no GTID is generated. An example is CREATE TEMPORARY TABLE inside a transaction when binlog_format=row. Despite the thread does not own anything, the GTID consistency violation makes it necessary to call end_gtid_violating_transaction. Therefore MYSQL_BIN_LOG::gtid_end_transaction will call gtid_state-&gt;update_on_commit in this case, and subsequently we will reach this case.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- Thread to be updated that owns anonymous GTID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc4c103d1209489a7b7e0d179d654faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4c103d1209489a7b7e0d179d654faf">&#9670;&nbsp;</a></span>update_on_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_on_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the GTID owned by thread from owned GTIDs, stating that thd-&gt;owned_gtid was committed. </p>
<p>This will:</p><ul>
<li>remove owned GTID from owned_gtids;</li>
<li>remove all owned GTIDS from thd-&gt;owned_gtid and thd-&gt;owned_gtid_set;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread for which owned gtids are updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82dacb8e665689ad80e4541cea325897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dacb8e665689ad80e4541cea325897">&#9670;&nbsp;</a></span>update_on_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_on_rollback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the state after the given thread has rollbacked. </p>
<p>This will:</p><ul>
<li>release ownership of all GTIDs owned by the THD;</li>
<li>remove owned GTID from owned_gtids;</li>
<li>remove all owned GTIDS from thd-&gt;owned_gtid and thd-&gt;owned_gtid_set;</li>
<li>send a broadcast on the condition variable for every sidno for which we released ownership.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread for which owned gtids are updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae65b973f8fc7b10045407988e5951e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae65b973f8fc7b10045407988e5951e7">&#9670;&nbsp;</a></span>update_prev_gtids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_state::update_prev_gtids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>write_gtid_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates previously logged GTID set before writing to table. </p>

</div>
</div>
<a id="a7defb862a2a1ab4ebc1e90dfc7b78ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7defb862a2a1ab4ebc1e90dfc7b78ecd">&#9670;&nbsp;</a></span>wait_for_gtid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::wait_for_gtid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGtid.html">Gtid</a> &amp;&#160;</td>
          <td class="paramname"><em>gtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is only a shorthand for wait_for_sidno, which contains additional debug printouts and assertions for the case when the caller waits for one specific GTID. </p>

</div>
</div>
<a id="ac99ab163cd352da46f80df24f8589bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99ab163cd352da46f80df24f8589bd4">&#9670;&nbsp;</a></span>wait_for_gtid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::wait_for_gtid_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the given Gtid_set is included in @GLOBAL.GTID_EXECUTED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The calling thread. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gtid_set</td><td>Gtid_set to wait for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The maximum number of milliseconds that the function should wait, or 0 to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure: either timeout or thread was killed. If thread was killed, the error has been generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa05b5e777f238bb2b73e4b6af4666041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05b5e777f238bb2b73e4b6af4666041">&#9670;&nbsp;</a></span>wait_for_sidno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gtid_state::wait_for_sidno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a>&#160;</td>
          <td class="paramname"><em>sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a signal on the given SIDNO. </p>
<p>NOTE: This releases a lock!</p>
<p>This requires that the caller holds a read lock on sid_lock. It will release the lock before waiting; neither global_sid_lock nor the mutex lock on SIDNO will not be held when this function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>THD object of the caller. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sidno</td><td>Sidno to wait for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abstime</td><td>The absolute point in time when the wait times out and stops, or NULL to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure: either timeout or thread was killed. If thread was killed, the error has been generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06bbf73574f8b6718905cc703bae77a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bbf73574f8b6718905cc703bae77a5">&#9670;&nbsp;</a></span>warn_or_err_on_modify_gtid_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_state::warn_or_err_on_modify_gtid_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a warning to client if user is modifying the gtid_executed table explicitly by a non-XA transaction. </p>
<p>Push an error to client if user is modifying it explicitly by a XA transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread requesting to access the table </td></tr>
    <tr><td class="paramname">table</td><td>The table is being accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>No warning or error was pushed to the client. </td></tr>
    <tr><td class="paramname">1</td><td>Push a warning to client. </td></tr>
    <tr><td class="paramname">2</td><td>Push an error to client. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a47df73991055f5575a521ebc7df78c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47df73991055f5575a521ebc7df78c21">&#9670;&nbsp;</a></span>atomic_anonymous_gtid_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&gt; Gtid_state::atomic_anonymous_gtid_count {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of anonymous transactions owned by any client. </p>

</div>
</div>
<a id="ada44923f630f3a6855bbbf804464b2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada44923f630f3a6855bbbf804464b2c6">&#9670;&nbsp;</a></span>atomic_anonymous_gtid_violation_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&gt; Gtid_state::atomic_anonymous_gtid_violation_count {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of GTID-violating transactions that use GTID_NEXT=AUTOMATIC. </p>

</div>
</div>
<a id="ad28466e26df247b9b7cff0867284ad51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28466e26df247b9b7cff0867284ad51">&#9670;&nbsp;</a></span>atomic_automatic_gtid_violation_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&gt; Gtid_state::atomic_automatic_gtid_violation_count {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of GTID-violating transactions that use GTID_NEXT=AUTOMATIC. </p>

</div>
</div>
<a id="ad3e4d53f6233ffc24f67a25d16ac46de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e4d53f6233ffc24f67a25d16ac46de">&#9670;&nbsp;</a></span>atomic_gtid_wait_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="my__inttypes_8h.html#ab7903878916593daecbeb95b98115ab0">int32</a>&gt; Gtid_state::atomic_gtid_wait_count {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of clients that are executing WAIT_FOR_EXECUTED_GTID_SET or WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS. </p>

</div>
</div>
<a id="aa8edc31eba8d09e32193d53442463277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8edc31eba8d09e32193d53442463277">&#9670;&nbsp;</a></span>commit_group_sidnos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPrealloced__array.html">Prealloced_array</a>&lt;<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, 8&gt; Gtid_state::commit_group_sidnos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This array is used by Gtid_state_update_gtids_impl* functions. </p>
<p>The array items (one per sidno of the sid_map) will be set as true for each sidno that requires to be locked when updating a set of GTIDs (at Gtid_set::update_gtids_impl_lock_sidnos).</p>
<p>The array items will be set false at Gtid_set::update_gtids_impl_broadcast_and_unlock_sidnos.</p>
<p>It is used to so that lock, unlock, and broadcast operations are only called once per sidno per commit group, instead of once per transaction.</p>
<p>Its access is protected by:</p><ul>
<li>global_sid_lock-&gt;wrlock when growing and cleaning up;</li>
<li>MYSQL_BIN_LOG::LOCK_commit when setting true/false on array items. </li>
</ul>

</div>
</div>
<a id="a869b9354d10defd652545378de658703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869b9354d10defd652545378de658703">&#9670;&nbsp;</a></span>executed_gtids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtid__set.html">Gtid_set</a> Gtid_state::executed_gtids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a833b5a205bee7d8307ee3978062f5d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833b5a205bee7d8307ee3978062f5d31">&#9670;&nbsp;</a></span>gtids_only_in_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtid__set.html">Gtid_set</a> Gtid_state::gtids_only_in_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5125d8c4aa10b0459c67ab418ba7b38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5125d8c4aa10b0459c67ab418ba7b38e">&#9670;&nbsp;</a></span>lost_gtids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtid__set.html">Gtid_set</a> Gtid_state::lost_gtids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of GTIDs that existed in some previously purged binary log. </p>
<p>This is always a subset of executed_gtids. </p>

</div>
</div>
<a id="a43df262dbde2521ed215d00a0a166903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43df262dbde2521ed215d00a0a166903">&#9670;&nbsp;</a></span>next_free_gno</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a74378e47532331d3ac920082cf954668">rpl_gno</a> Gtid_state::next_free_gno</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next_free_gno variable will be set with the supposed next free GNO every time a new GNO is delivered automatically or when a transaction is rolled back, releasing a GNO smaller than the last one delivered. </p>
<p>It was introduced in an optimization of Gtid_state::get_automatic_gno and Gtid_state::generate_automatic_gtid functions.</p>
<p>Locking scheme</p>
<p>This variable can be read and modified in four places:</p><ul>
<li>During server startup, holding global_sid_lock.wrlock;</li>
<li>By a client thread holding global_sid_lock.wrlock (doing a RESET MASTER);</li>
<li>By a client thread calling MYSQL_BIN_LOG::write_transaction function (often the group commit FLUSH stage leader). It will call Gtid_state::generate_automatic_gtid, that will acquire global_sid_lock.rdlock and lock_sidno(get_server_sidno()) when getting a new automatically generated GTID;</li>
<li>By a client thread rolling back, holding global_sid_lock.rdlock and lock_sidno(get_server_sidno()). </li>
</ul>

</div>
</div>
<a id="a55048f7fef8e7c66c310a5acc9cd8043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55048f7fef8e7c66c310a5acc9cd8043">&#9670;&nbsp;</a></span>owned_gtids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOwned__gtids.html">Owned_gtids</a> Gtid_state::owned_gtids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of GTIDs that are owned by some thread. </p>

</div>
</div>
<a id="a6945ba776f950c749a8f51838351a4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6945ba776f950c749a8f51838351a4db">&#9670;&nbsp;</a></span>previous_gtids_logged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtid__set.html">Gtid_set</a> Gtid_state::previous_gtids_logged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a348f4a1252fe66bab3757c7e6fc8e335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348f4a1252fe66bab3757c7e6fc8e335">&#9670;&nbsp;</a></span>server_sidno</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a4873b950f954adcfa36c1665428ce3ff">rpl_sidno</a> Gtid_state::server_sidno</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SIDNO for this server. </p>

</div>
</div>
<a id="ab65439378e7e1cfe8cd7c6ff4ed749ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65439378e7e1cfe8cd7c6ff4ed749ce">&#9670;&nbsp;</a></span>sid_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a>* Gtid_state::sid_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-write lock that protects updates to the number of SIDs. </p>

</div>
</div>
<a id="a5e38e036ea2abc473c4d916d20e7a44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e38e036ea2abc473c4d916d20e7a44e">&#9670;&nbsp;</a></span>sid_locks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMutex__cond__array.html">Mutex_cond_array</a> Gtid_state::sid_locks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains one mutex/cond pair for every SIDNO. </p>

</div>
</div>
<a id="a46186a7ce7f287ac71a6f9d114091b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46186a7ce7f287ac71a6f9d114091b22">&#9670;&nbsp;</a></span>sid_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSid__map.html">Sid_map</a>* Gtid_state::sid_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Sid_map used by this Gtid_state. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a></li>
<li>sql/<a class="el" href="rpl__gtid__state_8cc.html">rpl_gtid_state.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classGtid__state.html">Gtid_state</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
