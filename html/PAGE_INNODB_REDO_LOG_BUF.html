<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Redo log buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PAGE_INNODB_REDO_LOG_BUF.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Redo log buffer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When mtr commits, data has to be moved from internal buffer of the mtr to the redo log buffer.</p>
<p>For a better concurrency, procedure for writing to the log buffer consists of following steps:</p><ol type="1">
<li><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_buf_reserve">Reservation of space in the redo</a></li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_buf_write">Copying data to the reserved space</a></li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_buf_add_links_to_recent_written">Adding links to the</a></li>
</ol>
<p>Afterwards pages modified during the mtr, need to be added to flush lists. Because there is no longer a mutex protecting order in which dirty pages are added to flush lists, additional mechanism is required to ensure that lsn available for checkpoint is determined properly. Hence the procedure consists of following steps:</p><ol type="1">
<li><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_mark_dirty_pages">Marking pages as dirty</a></li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_add_dirty_pages">Adding dirty pages to flush lists</a></li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_add_link_to_recent_closed">Adding link to the log recent</a></li>
</ol>
<h1><a class="anchor" id="sect_redo_log_buf_reserve"></a>
Reservation of space in the redo</h1>
<p>Range of lsn values is reserved for a provided number of data bytes. The reserved range will directly address space for the data in both the log buffer and the log files.</p>
<p>Procedure used to reserve the range of lsn values:</p>
<ol type="1">
<li>Acquiring shared access to the redo log (through sharded rw_lock)</li>
<li><p class="startli">Increase the global number of reserved data bytes (<a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_sn">log.sn</a>) by number of data bytes we need to write.</p>
<p class="startli">This is performed by an atomic fetch_add operation: </p><pre class="fragment"> start_sn = log.sn.fetch_add(len)
 end_sn = start_sn + len
</pre><p class="startli">where <em>len</em> is number of data bytes we need to write.</p>
<p class="startli">Then range of sn values is translated to range of lsn values: </p><pre class="fragment"> start_lsn = log_translate_sn_to_lsn(start_sn)
 end_lsn = log_translate_sn_to_lsn(end_sn)
</pre><p class="startli">The required translations are performed by simple calculations, because: </p><pre class="fragment"> lsn = sn / LOG_BLOCK_DATA_SIZE * OS_FILE_LOG_BLOCK_SIZE
         + sn % LOG_BLOCK_DATA_SIZE
         + LOG_BLOCK_HDR_SIZE
</pre></li>
<li><p class="startli">Wait until the reserved range corresponds to free space in the log buffer.</p>
<p class="startli">In this step we could be forced to wait for the <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_writer">log writer thread</a>, which reclaims space in the log buffer by writing data to system buffers.</p>
<p class="startli">The user thread waits until the reserved range of lsn values maps to free space in the log buffer, which is true when: </p><pre class="fragment">  end_lsn - log.write_lsn &lt;= log.buf_size
</pre><dl class="section remark"><dt>Remarks</dt><dd>The waiting is performed by a call to log_write_up_to(end_lsn - log.buf_size), which has a loop with short sleeps. We assume that it is unlikely that the waiting is actually needed. The <em>MONITOR_LOG_ON_BUFFER_SPACE</em>* counters track number of iterations spent in the waiting loop. If they are not nearby 0, DBA should try to increase the size of the log buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The log writer thread could be waiting on the write syscall, but it also could be waiting for other user threads, which need to complete writing their data to the log buffer for smaller sn values! Hopefully these user threads have not been scheduled out. If we controlled scheduling (e.g. if we have used fiber-based approach), we could avoid such problem.</dd></dl>
</li>
<li><p class="startli">Wait until the reserved range corresponds to free space in the log files.</p>
<p class="startli">In this step we could be forced to wait for page cleaner threads or the <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_checkpointer">log checkpointer thread</a> until it made a next checkpoint.</p>
<p class="startli">The user thread waits until the reserved range of lsn values maps to free space in the log files, which is true when: </p><pre class="fragment">  end_lsn - log.last_checkpoint_lsn &lt;= redo lsn capacity
</pre><dl class="section remark"><dt>Remarks</dt><dd>The waiting is performed by a loop with progressive sleeps. The <em>MONITOR_LOG_ON_FILE_SPACE</em>* counters track number of iterations spent in the waiting loop. If they are not nearby 0, DBA should try to use more page cleaner threads, increase size of the log files or ask for better storage device.</dd></dl>
<p>This mechanism could lead to a <b>deadlock</b>, because the user thread waiting during commit of mtr, keeps the dirty pages locked, which makes it impossible to flush them. Now, if these pages have very old modifications, it could be impossible to move checkpoint further without flushing them. In such case the log checkpointer thread will be unable to <a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_reclaim_space">reclaim space in the log files</a>.</p>
<p class="startli">To avoid such problems, user threads call log_free_check() from time to time, when they don't keep any latches. They try to do it at least every 4 modified pages and if they detected that there is not much free space in the log files, they wait until the free space is reclaimed (but without holding latches!).</p>
<dl class="section note"><dt>Note</dt><dd>Note that multiple user threads could check the free space without holding latches and then proceed with writes. Therefore this mechanism only works because the minimum required free space is based on assumptions:<ul>
<li>maximum number of such concurrent user threads is limited,</li>
<li>maximum size of write between two checks within a thread is limited.</li>
</ul>
</dd></dl>
<p>This mechanism does not provide safety when concurrency is not limited! In such case we only do the best effort but the deadlock is still possible in theory.</p>
</li>
</ol>
<dl class="section see"><dt>See also</dt><dd>log_buffer_reserve()</dd></dl>
<h1><a class="anchor" id="sect_redo_log_buf_write"></a>
Copying data to the reserved space</h1>
<p>After a range of lsn values has been reserved, the data is copied to the log buffer's fragment related to the range of lsn values.</p>
<p>The log buffer is a ring buffer, directly addressed by lsn values, which means that there is no need for shifting of data in the log buffer. Byte for a given lsn is stored at lsn modulo size of the buffer. It is then easier to reach higher concurrency with such the log buffer, because shifting would require an exclusive access.</p>
<dl class="section note"><dt>Note</dt><dd>However, when writing the wrapped fragment of the log buffer to disk, extra IO operation could happen (because we need to copy two disjoint areas of memory). First of all, it's a rare case so it shouldn't matter at all. Also note that the wrapped fragment results only in additional write to system buffer, so still number of real IO operations could stay the same.</dd></dl>
<p>Writes to different ranges of lsn values happen concurrently without any synchronization. Each user thread writes its own sequence of log records to the log buffer, copying them from the internal buffer of the mtr, leaving holes for headers and footers of consecutive log blocks.</p>
<dl class="section note"><dt>Note</dt><dd>There is some hidden synchronization when multiple user threads write to the same memory cache line. That happens when they write to the same 64 bytes, because they have reserved small consecutive ranges of lsn values. Fortunately each mtr takes in average more than few bytes, which limits number of such user threads that meet within a cache line.</dd></dl>
<p>When mtr_commit() finishes writing the group of log records, it is responsible for updating the <em>first_rec_group</em> field in the header of the block to which <em>end_lsn</em> belongs, unless it is the same block to which <em>start_lsn</em> belongs (in which case user ending at <em>start_lsn</em> is responsible for the update).</p>
<dl class="section see"><dt>See also</dt><dd>log_buffer_write()</dd></dl>
<h1><a class="anchor" id="sect_redo_log_buf_add_links_to_recent_written"></a>
Adding links to the</h1>
<p>recent written buffer</p>
<p>Fragment of the log buffer, which is close to current lsn, is very likely being written concurrently by multiple user threads. There is no restriction on order in which such concurrent writes might be finished. Each user thread which has finished writing, proceeds further without waiting for any other user threads.</p>
<p><div class="diagraph">
<img src="dia_user_thread_writes_to_buffer.png" />
<div class="caption">
One of many</div>
</div>
 concurrent writes"</p>
<dl class="section note"><dt>Note</dt><dd>Note that when a user thread has finished writing, still some other user threads could be writing their data for smaller lsn values. It is still fine, because it is the <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_writer">log writer thread</a> that needs to ensure, that it writes only complete fragments of the log buffer. For that we need information about the finished writes.</dd></dl>
<p>The log recent written buffer is responsible for tracking which of concurrent writes to the log buffer, have been finished. It allows the log writer thread to update <a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_ready_for_write_lsn">log.buf_ready_for_write_lsn</a>, which allows to find the next complete fragment of the log buffer to write. It is enough to track only recent writes, because we know that up to <em>log.buf_ready_for_write_lsn</em>, all writes have been finished. Hence this lsn value defines the beginning of lsn range represented by the recent written buffer in a given time. The recent written buffer is a ring buffer, directly addressed by lsn value. When there is no space in the buffer, user thread needs to wait.</p>
<dl class="section note"><dt>Note</dt><dd>Size of the log recent written buffer is limited, so concurrency might be limited if the recent written buffer is too small and user threads start to wait for each other then (indirectly by waiting for the space reclaimed in the recent written buffer by the log writer thread).</dd></dl>
<p>Let us describe the procedure used for adding the links.</p>
<p>Suppose, user thread has just written some of mtr's log records to a range of lsn values <em>tmp_start_lsn</em> .. <em>tmp_end_lsn</em>, then:</p>
<ol type="1">
<li><p class="startli">User thread waits for free space in the recent written buffer, until: </p><pre class="fragment"> tmp_end_lsn - log.buf_ready_for_write_lsn &lt;= S
</pre><p class="startli">where <em>S</em> is a number of slots in the log recent_written buffer.</p>
</li>
<li><p class="startli">User thread adds the link by setting value of slot for <em>tmp_start_lsn</em>: </p><pre class="fragment"> log.recent_written[tmp_start_lsn % S] = tmp_end_lsn
</pre><p class="startli">The value gives information about how much to advance lsn when traversing the link.</p>
<dl class="section note"><dt>Note</dt><dd>Note that possibly <em>tmp_end_lsn</em> &lt; <em>end_lsn</em>. In such case, next write of log records in the mtr will start at <em>tmp_end_lsn</em>. After all the log records are written, the <em>tmp_end_lsn</em> should become equal to the <em>end_lsn</em> of the reservation (we must not reserve more bytes than we write).</dd></dl>
<p>The log writer thread follows path created by the added links, updates <a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_ready_for_write_lsn">log.buf_ready_for_write_lsn</a> and clears the links, allowing to reuse them (for lsn larger by <em>S</em>).</p>
</li>
</ol>
<p>Before the link is added, release barrier is required, to avoid compile time or memory reordering of writes to the log buffer and the recent written buffer. It is extremely important to ensure, that write to the log buffer will precede write to the recent written buffer.</p>
<p>The same will apply to reads in the log writer thread, so then the log writer thread will be sure, that after reading the link from the recent written buffer it will read the proper data from the log buffer's fragment related to the link.</p>
<p>Copying data and adding links is performed in loop for consecutive log records within the group of log records in the mtr.</p>
<dl class="section note"><dt>Note</dt><dd>Note that until some user thread finished writing all the log records, any log records which have been written to the log buffer for larger lsn (by other user threads), cannot be written to disk. The log writer thread will stop at the missing links in the log recent written buffer and wait. It follows connected links only.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>log_buffer_write_completed()</dd></dl>
<h1><a class="anchor" id="sect_redo_log_mark_dirty_pages"></a>
Marking pages as dirty</h1>
<p>Range of lsn values <em>start_lsn</em> .. <em>end_lsn</em>, acquired during the reservation of space, represents the whole group of log records. It is used to mark all the pages in the mtr as dirty.</p>
<dl class="section note"><dt>Note</dt><dd>During recovery the whole mtr needs to be recovered or skipped at all. Hence we don't need more detailed ranges of lsn values when marking pages.</dd></dl>
<p>Each page modified in the mtr is locked and its <em>oldest_modification</em> is checked to see if this is the first modification or the page had already been modified when its modification in this mtr started.</p>
<p>Page, which was modified the first time, will have updated:</p><ul>
<li><em>oldest_modification</em> = <em>start_lsn</em>,</li>
<li><em>newest_modification</em> = <em>end_lsn</em>,</li>
</ul>
<p>and will be added to the flush list for corresponding buffer pool (buffer pools are sharded by page_id).</p>
<p>For other pages, only <em>newest_modification</em> field is updated (with <em>end_lsn</em>).</p>
<dl class="section note"><dt>Note</dt><dd>Note that some pages could already be modified earlier (in a previous mtr) and still unflushed. Such pages would have <em>oldest_modification</em> != 0 during this phase and they would belong already to flush lists. Hence it is enough to update their <em>newest_modification</em>.</dd></dl>
<h1><a class="anchor" id="sect_redo_log_add_dirty_pages"></a>
Adding dirty pages to flush lists</h1>
<p>After writes of all log records in a mtr_commit() have been finished, dirty pages have to be moved to flush lists. Hopefully, after some time the pages will become flushed and space in the log files could be reclaimed.</p>
<p>The procedure for adding pages to flush lists:</p>
<ol type="1">
<li><p class="startli">Wait for the recent closed buffer covering <em>end_lsn</em>.</p>
<p class="startli">Before moving the pages, user thread waits until there is free space for a link pointing from <em>start_lsn</em> to <em>end_lsn</em> in the recent closed buffer. The free space is available when: </p><pre class="fragment"> end_lsn - log.buf_dirty_pages_added_up_to_lsn &lt; L
</pre><p class="startli">where <em>L</em> is a number of slots in the log recent closed buffer.</p>
<p class="startli">This way we have guarantee, that the maximum delay in flush lists is limited by <em>L</em>. That's because we disallow adding dirty page with too high lsn value until pages with smaller lsn values (smaller by more than <em>L</em>), have been added!</p>
</li>
<li><p class="startli">Add the dirty pages to corresponding flush lists.</p>
<p class="startli">During this step pages are locked and marked as dirty as described in <a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_mark_dirty_pages">Marking pages as dirty</a>.</p>
<p class="startli">Multiple user threads could perform this step in any order of them. Hence order of dirty pages in a flush list, is not the same as order by their oldest modification lsn.</p>
<p class="startli"><div class="diagraph">
<img src="dia_relaxed_order_of_dirty_pages.png" />
<div class="caption">
Relaxed</div>
</div>
 order of dirty pages"</p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Note that still the <a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_dirty_pages_added_up_to_lsn">subsect_redo_log_buf_dirty_pages_added_up_to_lsn</a> cannot be advanced further than to <em>start_lsn</em>. That's because the link from <em>start_lsn</em> to <em>end_lsn</em>, has still not been added at this stage.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>log_buffer_write_completed_before_dirty_pages_added()</dd></dl>
<h1><a class="anchor" id="sect_redo_log_add_link_to_recent_closed"></a>
Adding link to the log recent</h1>
<p>closed buffer</p>
<p>After all the dirty pages have been added to flush lists, a link pointing from <em>start_lsn</em> to <em>end_lsn</em> is added to the log recent closed buffer.</p>
<p>This is performed by user thread, by setting value of slot for start_lsn: </p><pre class="fragment">    log.recent_closed[start_lsn % L] = end_lsn
</pre><p>where <em>L</em> is size of the log recent closed buffer. The value gives information about how much to advance lsn when traversing the link.</p>
<dl class="section see"><dt>See also</dt><dd>log_buffer_write_completed_and_dirty_pages_added()</dd></dl>
<p>After the link is added, the shared-access for log buffer is released. This possibly allows any thread waiting for an exclussive access to proceed.</p>
<h1><a class="anchor" id="sect_redo_log_reclaim_space"></a>
Reclaiming space in redo log</h1>
<p>Recall that recovery always starts at the last written checkpoint lsn. Therefore <a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_last_checkpoint_lsn">log.last_checkpoint_lsn</a> defines the beginning of the log files. Because size of the log files is fixed, it is easy to determine if a given range of lsn values corresponds to free space in the log files or not (in which case it would overwrite tail of the redo log for smaller lsns).</p>
<p>Space in the log files is reclaimed by writing a checkpoint for a higher lsn. This could be possible when more dirty pages have been flushed. The checkpoint cannot be written for higher lsn than the <em>oldest_modification</em> of any of the dirty pages (otherwise we would have lost modifications for that page in case of crash). It is <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_checkpointer">log checkpointer thread</a>, which calculates safe lsn for a next checkpoint (<a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_available_for_checkpoint_lsn">subsect_redo_log_available_for_checkpoint_lsn</a>) and writes the checkpoint. User threads doing writes to the log buffer, no longer hold mutex, which would disallow to determine such lsn and write checkpoint mean while.</p>
<p>Suppose user thread has just finished writing to the log buffer, and it is just before adding the corresponding dirty pages to flush lists, but suddenly became scheduled out. Now, the log checkpointer thread comes in and tries to determine lsn available for a next checkpoint. If we allowed the thread to take minimum <em>oldest_modification</em> of dirty pages in flush lists and write checkpoint at that lsn value, we would logically erase all log records for smaller lsn values. However the dirty pages, which the user thread was trying to add to flush lists, could have smaller value of <em>oldest_modification</em>. Then log records protecting the modifications would be logically erased and in case of crash we would not be able to recover the pages.</p>
<p>That's why we need to protect from doing checkpoint at such lsn value, which would logically erase the just written data to the redo log, until the related dirty pages have been added to flush lists.</p>
<p>When user thread has added all the dirty pages related to <em>start_lsn</em> .. <em>end_lsn</em>, it creates link in the log recent closed buffer, pointing from <em>start_lsn</em> to <em>end_lsn</em>. The log closer thread tracks the links in the recent closed buffer, clears the slots (so they could be safely reused) and updates the <a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_dirty_pages_added_up_to_lsn">subsect_redo_log_buf_dirty_pages_added_up_to_lsn</a>, reclaiming space in the recent closed buffer and potentially allowing to advance checkpoint further.</p>
<p>Order of pages added to flush lists became relaxed so we also cannot rely directly on the lsn of the earliest added page to a given flush list. It is not guaranteed that it has the minimum <em>oldest_modification</em> anymore. However it is guaranteed that it has <em>oldest_modification</em> not higher than the minimum by more than <em>L</em>. Hence we subtract <em>L</em> from its value and use that as lsn available for checkpoint according to the given flush list. For more details <a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_add_dirty_pages">read about adding dirty pages</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Note there are two reasons for which lsn available for checkpoint could be updated:<ul>
<li>because <a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_dirty_pages_added_up_to_lsn">subsect_redo_log_buf_dirty_pages_added_up_to_lsn</a> was updated,</li>
<li>because the earliest added dirty page in one of flush lists became flushed. </li>
</ul>
</dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_STORAGE.html">Data Storage</a></li><li class="navelem"><a class="el" href="PAGE_INNODB_REDO_LOG.html">Innodb redo log</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
