<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: ut_allocator&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classut__allocator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classut__allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ut_allocator&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allocator class for allocating memory from inside std::* containers.  
 <a href="classut__allocator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ut0new_8h_source.html">ut0new.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structut__allocator_1_1rebind.html">rebind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1b1afaf9e3252c27c34896f5d042d774"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a></td></tr>
<tr class="separator:a1b1afaf9e3252c27c34896f5d042d774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b8e96e2a0dede0c1b81d5b68b26707"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a></td></tr>
<tr class="separator:a81b8e96e2a0dede0c1b81d5b68b26707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae674ab1ecd66d7e8cc0d4cc4f67d6"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a9dae674ab1ecd66d7e8cc0d4cc4f67d6">reference</a></td></tr>
<tr class="separator:a9dae674ab1ecd66d7e8cc0d4cc4f67d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d7a333da9a5aa7aecfd7ddb3ab6127"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#ac3d7a333da9a5aa7aecfd7ddb3ab6127">const_reference</a></td></tr>
<tr class="separator:ac3d7a333da9a5aa7aecfd7ddb3ab6127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf547e014001affefc3c0afbabb5648b"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#aaf547e014001affefc3c0afbabb5648b">value_type</a></td></tr>
<tr class="separator:aaf547e014001affefc3c0afbabb5648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01fa7d46769e53e889e217e5b34e29f"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a></td></tr>
<tr class="separator:ad01fa7d46769e53e889e217e5b34e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9094bcb64a97b405ac2bb7ae96fa1227"><td class="memItemLeft" align="right" valign="top">typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a9094bcb64a97b405ac2bb7ae96fa1227">difference_type</a></td></tr>
<tr class="separator:a9094bcb64a97b405ac2bb7ae96fa1227"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe75fccdcc6b898576c0bb54916701ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#afe75fccdcc6b898576c0bb54916701ad">ut_allocator</a> (<a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>=<a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a>)</td></tr>
<tr class="memdesc:afe75fccdcc6b898576c0bb54916701ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#afe75fccdcc6b898576c0bb54916701ad">More...</a><br /></td></tr>
<tr class="separator:afe75fccdcc6b898576c0bb54916701ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc81adbe3ea23377d41b4d08b364a400"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:afc81adbe3ea23377d41b4d08b364a400"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classut__allocator.html#afc81adbe3ea23377d41b4d08b364a400">ut_allocator</a> (const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="unionU.html">U</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:afc81adbe3ea23377d41b4d08b364a400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from allocator of another type.  <a href="#afc81adbe3ea23377d41b4d08b364a400">More...</a><br /></td></tr>
<tr class="separator:afc81adbe3ea23377d41b4d08b364a400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3602a6cdc16ee328b82733459b9ae98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html">ut_allocator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a3602a6cdc16ee328b82733459b9ae98d">set_oom_not_fatal</a> ()</td></tr>
<tr class="memdesc:a3602a6cdc16ee328b82733459b9ae98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When out of memory (OOM) happens, report error and do not make it fatal.  <a href="#a3602a6cdc16ee328b82733459b9ae98d">More...</a><br /></td></tr>
<tr class="separator:a3602a6cdc16ee328b82733459b9ae98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a7d81e761e4bcac2331abfef22977c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#ae6a7d81e761e4bcac2331abfef22977c">is_oom_fatal</a> () const</td></tr>
<tr class="memdesc:ae6a7d81e761e4bcac2331abfef22977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if allocation failure is a fatal error.  <a href="#ae6a7d81e761e4bcac2331abfef22977c">More...</a><br /></td></tr>
<tr class="separator:ae6a7d81e761e4bcac2331abfef22977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edde033db2cf20d7fe5c0438468f818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a9edde033db2cf20d7fe5c0438468f818">get_mem_key</a> () const</td></tr>
<tr class="memdesc:a9edde033db2cf20d7fe5c0438468f818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the performance schema key to use for tracing allocations.  <a href="#a9edde033db2cf20d7fe5c0438468f818">More...</a><br /></td></tr>
<tr class="separator:a9edde033db2cf20d7fe5c0438468f818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf18053aaa34058bb0e671c476116d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a24bf18053aaa34058bb0e671c476116d">max_size</a> () const</td></tr>
<tr class="memdesc:a24bf18053aaa34058bb0e671c476116d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of objects that can be allocated by this allocator.  <a href="#a24bf18053aaa34058bb0e671c476116d">More...</a><br /></td></tr>
<tr class="separator:a24bf18053aaa34058bb0e671c476116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2d4eaf3f85a232337a6aeb5d2787f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a3f2d4eaf3f85a232337a6aeb5d2787f0">allocate</a> (<a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a> n_elements, <a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a> hint=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>, <a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>=<a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> set_to_zero=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> throw_on_error=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:a3f2d4eaf3f85a232337a6aeb5d2787f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of memory that can hold 'n_elements' objects of type 'T' and trace the allocation.  <a href="#a3f2d4eaf3f85a232337a6aeb5d2787f0">More...</a><br /></td></tr>
<tr class="separator:a3f2d4eaf3f85a232337a6aeb5d2787f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a76c66a11b452b134713185aa33c348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a8a76c66a11b452b134713185aa33c348">deallocate</a> (<a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> ptr, <a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a> n_elements=0)</td></tr>
<tr class="memdesc:a8a76c66a11b452b134713185aa33c348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory allocated by allocate() and trace the deallocation.  <a href="#a8a76c66a11b452b134713185aa33c348">More...</a><br /></td></tr>
<tr class="separator:a8a76c66a11b452b134713185aa33c348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece44e331d977f1139a6f6554567de1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#aece44e331d977f1139a6f6554567de1d">construct</a> (<a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> <a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>, const T &amp;val)</td></tr>
<tr class="memdesc:aece44e331d977f1139a6f6554567de1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of type 'T' using the value 'val' over the memory pointed by 'p'.  <a href="#aece44e331d977f1139a6f6554567de1d">More...</a><br /></td></tr>
<tr class="separator:aece44e331d977f1139a6f6554567de1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381c1c3d310a76a7dd0b3fe084375d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a381c1c3d310a76a7dd0b3fe084375d0c">destroy</a> (<a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> <a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>)</td></tr>
<tr class="memdesc:a381c1c3d310a76a7dd0b3fe084375d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an object pointed by 'p'.  <a href="#a381c1c3d310a76a7dd0b3fe084375d0c">More...</a><br /></td></tr>
<tr class="separator:a381c1c3d310a76a7dd0b3fe084375d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273918634da9d9a256884660024266c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a273918634da9d9a256884660024266c3">address</a> (<a class="el" href="classut__allocator.html#a9dae674ab1ecd66d7e8cc0d4cc4f67d6">reference</a> x) const</td></tr>
<tr class="memdesc:a273918634da9d9a256884660024266c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address of an object.  <a href="#a273918634da9d9a256884660024266c3">More...</a><br /></td></tr>
<tr class="separator:a273918634da9d9a256884660024266c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94f822fe1d5129d2fb5945379ae1bea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#af94f822fe1d5129d2fb5945379ae1bea">address</a> (<a class="el" href="classut__allocator.html#ac3d7a333da9a5aa7aecfd7ddb3ab6127">const_reference</a> x) const</td></tr>
<tr class="memdesc:af94f822fe1d5129d2fb5945379ae1bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address of a const object.  <a href="#af94f822fe1d5129d2fb5945379ae1bea">More...</a><br /></td></tr>
<tr class="separator:af94f822fe1d5129d2fb5945379ae1bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2de2e4a4615fd34a463915853ce0a1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#ad2de2e4a4615fd34a463915853ce0a1b">reallocate</a> (void *ptr, <a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a> n_elements, <a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:ad2de2e4a4615fd34a463915853ce0a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">realloc(3)-like method.  <a href="#ad2de2e4a4615fd34a463915853ce0a1b">More...</a><br /></td></tr>
<tr class="separator:ad2de2e4a4615fd34a463915853ce0a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ba0455630296e25d274f6c90790291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#ad8ba0455630296e25d274f6c90790291">new_array</a> (<a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a> n_elements, <a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:ad8ba0455630296e25d274f6c90790291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate, trace the allocation and construct 'n_elements' objects of type 'T'.  <a href="#ad8ba0455630296e25d274f6c90790291">More...</a><br /></td></tr>
<tr class="separator:ad8ba0455630296e25d274f6c90790291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd9421eae6c2c89bd5e99349c17918c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a3cd9421eae6c2c89bd5e99349c17918c">delete_array</a> (T *ptr)</td></tr>
<tr class="memdesc:a3cd9421eae6c2c89bd5e99349c17918c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy, deallocate and trace the deallocation of an array created by new_array().  <a href="#a3cd9421eae6c2c89bd5e99349c17918c">More...</a><br /></td></tr>
<tr class="separator:a3cd9421eae6c2c89bd5e99349c17918c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c12e2ea9c377f69cefbab47d1d4d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a22c12e2ea9c377f69cefbab47d1d4d24">allocate_large</a> (<a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a> n_elements, <a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *pfx)</td></tr>
<tr class="memdesc:a22c12e2ea9c377f69cefbab47d1d4d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a large chunk of memory that can hold 'n_elements' objects of type 'T' and trace the allocation.  <a href="#a22c12e2ea9c377f69cefbab47d1d4d24">More...</a><br /></td></tr>
<tr class="separator:a22c12e2ea9c377f69cefbab47d1d4d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9111018c07028343e80917545d3578d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#ac9111018c07028343e80917545d3578d">deallocate_large</a> (<a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> ptr, const <a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *pfx)</td></tr>
<tr class="memdesc:ac9111018c07028343e80917545d3578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory allocated by allocate_large() and trace the deallocation.  <a href="#ac9111018c07028343e80917545d3578d">More...</a><br /></td></tr>
<tr class="separator:ac9111018c07028343e80917545d3578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a31233ccc994ec2e94e781deed18bfd3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a31233ccc994ec2e94e781deed18bfd3f">n_elements_allocated</a> (<a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a> ptr)</td></tr>
<tr class="memdesc:a31233ccc994ec2e94e781deed18bfd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of a memory block allocated by new_array().  <a href="#a31233ccc994ec2e94e781deed18bfd3f">More...</a><br /></td></tr>
<tr class="separator:a31233ccc994ec2e94e781deed18bfd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2d6844434d15753dfa8920f69c1d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a7e2d6844434d15753dfa8920f69c1d8b">allocate_trace</a> (size_t size, <a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *pfx)</td></tr>
<tr class="memdesc:a7e2d6844434d15753dfa8920f69c1d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace a memory allocation.  <a href="#a7e2d6844434d15753dfa8920f69c1d8b">More...</a><br /></td></tr>
<tr class="separator:a7e2d6844434d15753dfa8920f69c1d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa83f13383ef79f6ea36d6da8b1188b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#afa83f13383ef79f6ea36d6da8b1188b8">deallocate_trace</a> (const <a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *pfx)</td></tr>
<tr class="memdesc:afa83f13383ef79f6ea36d6da8b1188b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace a memory deallocation.  <a href="#afa83f13383ef79f6ea36d6da8b1188b8">More...</a><br /></td></tr>
<tr class="separator:afa83f13383ef79f6ea36d6da8b1188b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7558479a06447a2998f4b3e175fa70d"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:af7558479a06447a2998f4b3e175fa70d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classut__allocator.html#af7558479a06447a2998f4b3e175fa70d">operator=</a> (const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="unionU.html">U</a> &gt; &amp;)</td></tr>
<tr class="separator:af7558479a06447a2998f4b3e175fa70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a871a6db262aff21f8ddb98398b0fdadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a871a6db262aff21f8ddb98398b0fdadd">m_key</a></td></tr>
<tr class="memdesc:a871a6db262aff21f8ddb98398b0fdadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance schema key.  <a href="#a871a6db262aff21f8ddb98398b0fdadd">More...</a><br /></td></tr>
<tr class="separator:a871a6db262aff21f8ddb98398b0fdadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6d7c0be9639c286460693c14adfb88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html#a9a6d7c0be9639c286460693c14adfb88">m_oom_fatal</a></td></tr>
<tr class="memdesc:a9a6d7c0be9639c286460693c14adfb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag to indicate whether out of memory (OOM) error is considered fatal.  <a href="#a9a6d7c0be9639c286460693c14adfb88">More...</a><br /></td></tr>
<tr class="separator:a9a6d7c0be9639c286460693c14adfb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class ut_allocator&lt; T &gt;</h3>

<p>Allocator class for allocating memory from inside std::* containers. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a81b8e96e2a0dede0c1b81d5b68b26707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b8e96e2a0dede0c1b81d5b68b26707">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3d7a333da9a5aa7aecfd7ddb3ab6127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d7a333da9a5aa7aecfd7ddb3ab6127">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html#ac3d7a333da9a5aa7aecfd7ddb3ab6127">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9094bcb64a97b405ac2bb7ae96fa1227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9094bcb64a97b405ac2bb7ae96fa1227">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ptrdiff_t <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html#a9094bcb64a97b405ac2bb7ae96fa1227">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b1afaf9e3252c27c34896f5d042d774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1afaf9e3252c27c34896f5d042d774">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dae674ab1ecd66d7e8cc0d4cc4f67d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dae674ab1ecd66d7e8cc0d4cc4f67d6">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html#a9dae674ab1ecd66d7e8cc0d4cc4f67d6">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad01fa7d46769e53e889e217e5b34e29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01fa7d46769e53e889e217e5b34e29f">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf547e014001affefc3c0afbabb5648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf547e014001affefc3c0afbabb5648b">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html#aaf547e014001affefc3c0afbabb5648b">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afe75fccdcc6b898576c0bb54916701ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe75fccdcc6b898576c0bb54916701ad">&#9670;&nbsp;</a></span>ut_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html">ut_allocator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>performance schema key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc81adbe3ea23377d41b4d08b364a400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc81adbe3ea23377d41b4d08b364a400">&#9670;&nbsp;</a></span>ut_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::<a class="el" href="classut__allocator.html">ut_allocator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="unionU.html">U</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from allocator of another type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the allocator to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a273918634da9d9a256884660024266c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273918634da9d9a256884660024266c3">&#9670;&nbsp;</a></span>address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#a9dae674ab1ecd66d7e8cc0d4cc4f67d6">reference</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the address of an object. </p>

</div>
</div>
<a id="af94f822fe1d5129d2fb5945379ae1bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94f822fe1d5129d2fb5945379ae1bea">&#9670;&nbsp;</a></span>address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#ac3d7a333da9a5aa7aecfd7ddb3ab6127">const_reference</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the address of a const object. </p>

</div>
</div>
<a id="a3f2d4eaf3f85a232337a6aeb5d2787f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2d4eaf3f85a232337a6aeb5d2787f0">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a>&#160;</td>
          <td class="paramname"><em>hint</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td>
          <td class="paramname"><em>key</em> = <code><a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>set_to_zero</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>throw_on_error</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a chunk of memory that can hold 'n_elements' objects of type 'T' and trace the allocation. </p>
<p>If the allocation fails this method may throw an exception. This is mandated by the standard and if it returns NULL instead, then STL containers that use it (e.g. std::vector) may get confused. After successful allocation the returned pointer must be passed to ut_allocator::deallocate() when no longer needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>pointer to a nearby memory location, unused by this implementation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>performance schema key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set_to_zero</td><td>if true, then the returned memory is initialized with 0x0 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">throw_on_error</td><td>if true, then exception is throw on allocation failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the allocated memory </dd></dl>

</div>
</div>
<a id="a22c12e2ea9c377f69cefbab47d1d4d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c12e2ea9c377f69cefbab47d1d4d24">&#9670;&nbsp;</a></span>allocate_large()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::allocate_large </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *&#160;</td>
          <td class="paramname"><em>pfx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a large chunk of memory that can hold 'n_elements' objects of type 'T' and trace the allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pfx</td><td>storage for the description of the allocated memory. The caller must provide space for this one and keep it until the memory is no longer needed and then pass it to deallocate_large(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the allocated memory or NULL </dd></dl>

</div>
</div>
<a id="a7e2d6844434d15753dfa8920f69c1d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2d6844434d15753dfa8920f69c1d8b">&#9670;&nbsp;</a></span>allocate_trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::allocate_trace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *&#160;</td>
          <td class="paramname"><em>pfx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace a memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes that were allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Performance Schema key </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pfx</td><td>placeholder to store the info which will be needed when freeing the memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aece44e331d977f1139a6f6554567de1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece44e331d977f1139a6f6554567de1d">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an object of type 'T' using the value 'val' over the memory pointed by 'p'. </p>

</div>
</div>
<a id="a8a76c66a11b452b134713185aa33c348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a76c66a11b452b134713185aa33c348">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a memory allocated by allocate() and trace the deallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>pointer to memory to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>number of elements allocated (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9111018c07028343e80917545d3578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9111018c07028343e80917545d3578d">&#9670;&nbsp;</a></span>deallocate_large()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::deallocate_large </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *&#160;</td>
          <td class="paramname"><em>pfx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a memory allocated by allocate_large() and trace the deallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>pointer to memory to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfx</td><td>descriptor of the memory, as returned by allocate_large(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa83f13383ef79f6ea36d6da8b1188b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa83f13383ef79f6ea36d6da8b1188b8">&#9670;&nbsp;</a></span>deallocate_trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::deallocate_trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a> *&#160;</td>
          <td class="paramname"><em>pfx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace a memory deallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pfx</td><td>info for the deallocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cd9421eae6c2c89bd5e99349c17918c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd9421eae6c2c89bd5e99349c17918c">&#9670;&nbsp;</a></span>delete_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::delete_array </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy, deallocate and trace the deallocation of an array created by new_array(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>pointer to the first object in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a381c1c3d310a76a7dd0b3fe084375d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381c1c3d310a76a7dd0b3fe084375d0c">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy an object pointed by 'p'. </p>

</div>
</div>
<a id="a9edde033db2cf20d7fe5c0438468f818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edde033db2cf20d7fe5c0438468f818">&#9670;&nbsp;</a></span>get_mem_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::get_mem_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the performance schema key to use for tracing allocations. </p>
<dl class="section return"><dt>Returns</dt><dd>performance schema key </dd></dl>

</div>
</div>
<a id="ae6a7d81e761e4bcac2331abfef22977c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a7d81e761e4bcac2331abfef22977c">&#9670;&nbsp;</a></span>is_oom_fatal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::is_oom_fatal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if allocation failure is a fatal error. </p>
<dl class="section return"><dt>Returns</dt><dd>true if allocation failure is fatal, false otherwise. </dd></dl>

</div>
</div>
<a id="a24bf18053aaa34058bb0e671c476116d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bf18053aaa34058bb0e671c476116d">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of objects that can be allocated by this allocator. </p>

</div>
</div>
<a id="a31233ccc994ec2e94e781deed18bfd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31233ccc994ec2e94e781deed18bfd3f">&#9670;&nbsp;</a></span>n_elements_allocated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::n_elements_allocated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#a81b8e96e2a0dede0c1b81d5b68b26707">const_pointer</a>&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the size of a memory block allocated by new_array(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer returned by new_array(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of memory block </dd></dl>

</div>
</div>
<a id="ad8ba0455630296e25d274f6c90790291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ba0455630296e25d274f6c90790291">&#9670;&nbsp;</a></span>new_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::new_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate, trace the allocation and construct 'n_elements' objects of type 'T'. </p>
<p>If the allocation fails or if some of the constructors throws an exception, then this method will return NULL. It does not throw exceptions. After successful completion the returned pointer must be passed to delete_array() when no longer needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>number of elements to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Performance schema key to allocate under </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first allocated object or NULL </dd></dl>

</div>
</div>
<a id="af7558479a06447a2998f4b3e175fa70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7558479a06447a2998f4b3e175fa70d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="unionU.html">U</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2de2e4a4615fd34a463915853ce0a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2de2e4a4615fd34a463915853ce0a1b">&#9670;&nbsp;</a></span>reallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html#a1b1afaf9e3252c27c34896f5d042d774">pointer</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::reallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classut__allocator.html#ad01fa7d46769e53e889e217e5b34e29f">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>realloc(3)-like method. </p>
<p>The passed in ptr must have been returned by allocate() and the pointer returned by this method must be passed to deallocate() when no longer needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>old pointer to reallocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>new number of elements to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Performance schema key to allocate under </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly allocated memory </dd></dl>

</div>
</div>
<a id="a3602a6cdc16ee328b82733459b9ae98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3602a6cdc16ee328b82733459b9ae98d">&#9670;&nbsp;</a></span>set_oom_not_fatal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html">ut_allocator</a>&amp; <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::set_oom_not_fatal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When out of memory (OOM) happens, report error and do not make it fatal. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the allocator. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a871a6db262aff21f8ddb98398b0fdadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871a6db262aff21f8ddb98398b0fdadd">&#9670;&nbsp;</a></span>m_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::m_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performance schema key. </p>

</div>
</div>
<a id="a9a6d7c0be9639c286460693c14adfb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6d7c0be9639c286460693c14adfb88">&#9670;&nbsp;</a></span>m_oom_fatal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt;::m_oom_fatal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A flag to indicate whether out of memory (OOM) error is considered fatal. </p>
<p>If true, it is fatal. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>storage/innobase/include/<a class="el" href="ut0new_8h_source.html">ut0new.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classut__allocator.html">ut_allocator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
