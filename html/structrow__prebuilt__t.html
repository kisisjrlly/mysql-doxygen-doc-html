<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: row_prebuilt_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structrow__prebuilt__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structrow__prebuilt__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">row_prebuilt_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A struct for (sometimes lazily) prebuilt structures in an Innobase table handle used within MySQL; these are used to save CPU time.  
 <a href="structrow__prebuilt__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrow__prebuilt__t_1_1row__is__reading__range__guard__t.html">row_is_reading_range_guard_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac2b2027e0ebc1de5d4d1d4c85ec90ffe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structrow__prebuilt__t.html#ac2b2027e0ebc1de5d4d1d4c85ec90ffea0472245d9ec4774acf79a72404a112fe">LOCK_PCUR</a>, 
<a class="el" href="structrow__prebuilt__t.html#ac2b2027e0ebc1de5d4d1d4c85ec90ffea8f5793157d7a1abdcb2e0ee2a066ad8f">LOCK_CLUST_PCUR</a>, 
<a class="el" href="structrow__prebuilt__t.html#ac2b2027e0ebc1de5d4d1d4c85ec90ffea6b4eac0f20f2925aefe876a0ef28bc3a">LOCK_COUNT</a>
 }</td></tr>
<tr class="separator:ac2b2027e0ebc1de5d4d1d4c85ec90ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a814aaed869d2837566608d19e792282a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a814aaed869d2837566608d19e792282a">is_reading_range</a> () const</td></tr>
<tr class="separator:a814aaed869d2837566608d19e792282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b8a8253f89dfc60a13fa38c11e3224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrow__prebuilt__t_1_1row__is__reading__range__guard__t.html">row_is_reading_range_guard_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ac9b8a8253f89dfc60a13fa38c11e3224">get_is_reading_range_guard</a> ()</td></tr>
<tr class="separator:ac9b8a8253f89dfc60a13fa38c11e3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3575fdf719e32dbff61fde9061d8ad94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3575fdf719e32dbff61fde9061d8ad94">get_lob_undo</a> ()</td></tr>
<tr class="separator:a3575fdf719e32dbff61fde9061d8ad94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6d4199f7e00754ecdf315dab81c0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1c6d4199f7e00754ecdf315dab81c0a9">lob_undo_reset</a> ()</td></tr>
<tr class="separator:a1c6d4199f7e00754ecdf315dab81c0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc498acabe15e1c9115ae5414ecdf2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#acbc498acabe15e1c9115ae5414ecdf2f">can_prefetch_records</a> () const</td></tr>
<tr class="memdesc:acbc498acabe15e1c9115ae5414ecdf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a record buffer or a prefetch cache be utilized for prefetching records in this scan?  <a href="#acbc498acabe15e1c9115ae5414ecdf2f">More...</a><br /></td></tr>
<tr class="separator:acbc498acabe15e1c9115ae5414ecdf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92235489f79f74ad55cd4d0f6051a34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a92235489f79f74ad55cd4d0f6051a34f">allow_duplicates</a> ()</td></tr>
<tr class="memdesc:a92235489f79f74ad55cd4d0f6051a34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the query is REPLACE or ON DUPLICATE KEY UPDATE in which case duplicate values should be allowed (and further processed) instead of causing an error.  <a href="#a92235489f79f74ad55cd4d0f6051a34f">More...</a><br /></td></tr>
<tr class="separator:a92235489f79f74ad55cd4d0f6051a34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5cce943b6a4e391ff798b06daa28bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aba5cce943b6a4e391ff798b06daa28bf">init_search_tuples_types</a> ()</td></tr>
<tr class="memdesc:aba5cce943b6a4e391ff798b06daa28bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes search_tuple and m_stop_tuple shape so they match the index.  <a href="#aba5cce943b6a4e391ff798b06daa28bf">More...</a><br /></td></tr>
<tr class="separator:aba5cce943b6a4e391ff798b06daa28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87f0f28e6b9c4a5e152eedf0e63bf1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad87f0f28e6b9c4a5e152eedf0e63bf1f">clear_search_tuples</a> ()</td></tr>
<tr class="memdesc:ad87f0f28e6b9c4a5e152eedf0e63bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets both search_tuple and m_stop_tuple.  <a href="#ad87f0f28e6b9c4a5e152eedf0e63bf1f">More...</a><br /></td></tr>
<tr class="separator:ad87f0f28e6b9c4a5e152eedf0e63bf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866bb5dd717dc6c08707b2d89dc29bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a866bb5dd717dc6c08707b2d89dc29bab">skip_concurrency_ticket</a> () const</td></tr>
<tr class="separator:a866bb5dd717dc6c08707b2d89dc29bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364e702884ced0c85208d86fc5182d14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a364e702884ced0c85208d86fc5182d14">row_prebuilt_t</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a364e702884ced0c85208d86fc5182d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is unsafe to copy this struct, and moving it would be non-trivial, because we want to keep in sync with row_is_reading_range_guard_t.  <a href="#a364e702884ced0c85208d86fc5182d14">More...</a><br /></td></tr>
<tr class="separator:a364e702884ced0c85208d86fc5182d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6af0040013c08cdc4ce6096ccc626ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa6af0040013c08cdc4ce6096ccc626ae">operator=</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> const &amp;)=delete</td></tr>
<tr class="separator:aa6af0040013c08cdc4ce6096ccc626ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1ea0c1c162aba499a9df70406da166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a5e1ea0c1c162aba499a9df70406da166">operator=</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a5e1ea0c1c162aba499a9df70406da166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ec4ec80586a68887a7447a7d8e4182"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a13ec4ec80586a68887a7447a7d8e4182">row_prebuilt_t</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a13ec4ec80586a68887a7447a7d8e4182"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad936db2921893119b95f7e33727f2d2a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad936db2921893119b95f7e33727f2d2a">magic_n</a></td></tr>
<tr class="memdesc:ad936db2921893119b95f7e33727f2d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this magic number is set to ROW_PREBUILT_ALLOCATED when created, or ROW_PREBUILT_FREED when the struct has been freed  <a href="#ad936db2921893119b95f7e33727f2d2a">More...</a><br /></td></tr>
<tr class="separator:ad936db2921893119b95f7e33727f2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c2a8205446e84d2e64f80088a7846c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a19c2a8205446e84d2e64f80088a7846c">table</a></td></tr>
<tr class="memdesc:a19c2a8205446e84d2e64f80088a7846c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innobase table handle.  <a href="#a19c2a8205446e84d2e64f80088a7846c">More...</a><br /></td></tr>
<tr class="separator:a19c2a8205446e84d2e64f80088a7846c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb88835f509e12ea05929f410f4df0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afeb88835f509e12ea05929f410f4df0a">index</a></td></tr>
<tr class="memdesc:afeb88835f509e12ea05929f410f4df0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">current index for a search, if any  <a href="#afeb88835f509e12ea05929f410f4df0a">More...</a><br /></td></tr>
<tr class="separator:afeb88835f509e12ea05929f410f4df0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa177d7d5264d91df66db86414dfa7da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa177d7d5264d91df66db86414dfa7da8">trx</a></td></tr>
<tr class="memdesc:aa177d7d5264d91df66db86414dfa7da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">current transaction handle  <a href="#aa177d7d5264d91df66db86414dfa7da8">More...</a><br /></td></tr>
<tr class="separator:aa177d7d5264d91df66db86414dfa7da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1004d8c54485ba370f756c48f26d93a7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1004d8c54485ba370f756c48f26d93a7">sql_stat_start</a>: 1</td></tr>
<tr class="memdesc:a1004d8c54485ba370f756c48f26d93a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE when we start processing of an SQL statement: we may have to set an intention lock on the table, create a consistent read view etc.  <a href="#a1004d8c54485ba370f756c48f26d93a7">More...</a><br /></td></tr>
<tr class="separator:a1004d8c54485ba370f756c48f26d93a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76361eda548fa2e2f8d80d66d08612"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#abd76361eda548fa2e2f8d80d66d08612">clust_index_was_generated</a>: 1</td></tr>
<tr class="memdesc:abd76361eda548fa2e2f8d80d66d08612"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the user did not define a primary key in MySQL, then Innobase automatically generated a clustered index where the ordering column is the row id: in this case this flag is set to TRUE  <a href="#abd76361eda548fa2e2f8d80d66d08612">More...</a><br /></td></tr>
<tr class="separator:abd76361eda548fa2e2f8d80d66d08612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59950f1aed60deccf5ba6a917afc357"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ac59950f1aed60deccf5ba6a917afc357">index_usable</a>: 1</td></tr>
<tr class="memdesc:ac59950f1aed60deccf5ba6a917afc357"><td class="mdescLeft">&#160;</td><td class="mdescRight">caches the value of index-&gt;is_usable(trx)  <a href="#ac59950f1aed60deccf5ba6a917afc357">More...</a><br /></td></tr>
<tr class="separator:ac59950f1aed60deccf5ba6a917afc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2406d22fe6361a563ec8b4e9b010287"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa2406d22fe6361a563ec8b4e9b010287">read_just_key</a>: 1</td></tr>
<tr class="memdesc:aa2406d22fe6361a563ec8b4e9b010287"><td class="mdescLeft">&#160;</td><td class="mdescRight">set to 1 when MySQL calls ha_innobase::extra with the argument HA_EXTRA_KEYREAD; it is enough to read just columns defined in the index (i.e., no read of the clustered index record necessary)  <a href="#aa2406d22fe6361a563ec8b4e9b010287">More...</a><br /></td></tr>
<tr class="separator:aa2406d22fe6361a563ec8b4e9b010287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0568bf55e0cd59e39cbf5264e0107a04"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0568bf55e0cd59e39cbf5264e0107a04">used_in_HANDLER</a>: 1</td></tr>
<tr class="memdesc:a0568bf55e0cd59e39cbf5264e0107a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if we have been using this handle in a MySQL HANDLER low level index cursor command: then we must store the pcur position even in a unique search from a clustered index, because HANDLER allows NEXT and PREV in such a situation.  <a href="#a0568bf55e0cd59e39cbf5264e0107a04">More...</a><br /></td></tr>
<tr class="separator:a0568bf55e0cd59e39cbf5264e0107a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6cf19178262078ea73dd92941a88ca"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afa6cf19178262078ea73dd92941a88ca">template_type</a>: 2</td></tr>
<tr class="memdesc:afa6cf19178262078ea73dd92941a88ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROW_MYSQL_WHOLE_ROW, ROW_MYSQL_REC_FIELDS, ROW_MYSQL_DUMMY_TEMPLATE, or ROW_MYSQL_NO_TEMPLATE.  <a href="#afa6cf19178262078ea73dd92941a88ca">More...</a><br /></td></tr>
<tr class="separator:afa6cf19178262078ea73dd92941a88ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551a6896bb6da7d979e6fb20decf18ba"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a551a6896bb6da7d979e6fb20decf18ba">n_template</a>: 10</td></tr>
<tr class="memdesc:a551a6896bb6da7d979e6fb20decf18ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements in the template  <a href="#a551a6896bb6da7d979e6fb20decf18ba">More...</a><br /></td></tr>
<tr class="separator:a551a6896bb6da7d979e6fb20decf18ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4218e8b9331e26a43e2507663d59bdc1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4218e8b9331e26a43e2507663d59bdc1">null_bitmap_len</a>: 10</td></tr>
<tr class="memdesc:a4218e8b9331e26a43e2507663d59bdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bytes in the SQL NULL bitmap at the start of a row in the MySQL format  <a href="#a4218e8b9331e26a43e2507663d59bdc1">More...</a><br /></td></tr>
<tr class="separator:a4218e8b9331e26a43e2507663d59bdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94506e9f10462650bfa377f9414cf7db"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a94506e9f10462650bfa377f9414cf7db">need_to_access_clustered</a>: 1</td></tr>
<tr class="memdesc:a94506e9f10462650bfa377f9414cf7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">if we are fetching columns through a secondary index and at least one column is not in the secondary index, then this is set to TRUE  <a href="#a94506e9f10462650bfa377f9414cf7db">More...</a><br /></td></tr>
<tr class="separator:a94506e9f10462650bfa377f9414cf7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666323e0b2127c47e743adf5ba2bef94"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a666323e0b2127c47e743adf5ba2bef94">templ_contains_blob</a>: 1</td></tr>
<tr class="memdesc:a666323e0b2127c47e743adf5ba2bef94"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if the template contains a column with DATA_LARGE_MTYPE( get_innobase_type_from_mysql_type()) is TRUE; not to be confused with InnoDB externally stored columns (VARCHAR can be off-page too)  <a href="#a666323e0b2127c47e743adf5ba2bef94">More...</a><br /></td></tr>
<tr class="separator:a666323e0b2127c47e743adf5ba2bef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4081417afcdbd59f9e107423a812e528"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4081417afcdbd59f9e107423a812e528">templ_contains_fixed_point</a>: 1</td></tr>
<tr class="memdesc:a4081417afcdbd59f9e107423a812e528"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if the template contains a column with DATA_POINT.  <a href="#a4081417afcdbd59f9e107423a812e528">More...</a><br /></td></tr>
<tr class="separator:a4081417afcdbd59f9e107423a812e528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53bf10140469ab155bace892faa519"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a5a53bf10140469ab155bace892faa519">on_duplicate_key_update</a>: 1</td></tr>
<tr class="memdesc:a5a53bf10140469ab155bace892faa519"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if extra(HA_EXTRA_INSERT_WITH_UPDATE) was requested, which happens when ON DUPLICATE KEY UPDATE clause is present, 0 otherwise  <a href="#a5a53bf10140469ab155bace892faa519">More...</a><br /></td></tr>
<tr class="separator:a5a53bf10140469ab155bace892faa519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201878b5e5c37cf830f1b18489f78393"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a201878b5e5c37cf830f1b18489f78393">replace</a>: 1</td></tr>
<tr class="memdesc:a201878b5e5c37cf830f1b18489f78393"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if extra(HA_EXTRA_WRITE_CAN_REPLACE) was requested, which happen when REPLACE is done instead of regular INSERT, 0 otherwise  <a href="#a201878b5e5c37cf830f1b18489f78393">More...</a><br /></td></tr>
<tr class="separator:a201878b5e5c37cf830f1b18489f78393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c5641e4244b609f7e89f11069239e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a25c5641e4244b609f7e89f11069239e5">mysql_template</a></td></tr>
<tr class="memdesc:a25c5641e4244b609f7e89f11069239e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">template used to transform rows fast between MySQL and Innobase formats; memory for this template is not allocated from 'heap'  <a href="#a25c5641e4244b609f7e89f11069239e5">More...</a><br /></td></tr>
<tr class="separator:a25c5641e4244b609f7e89f11069239e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1114f766781ead5174ff03d9bfcaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afa1114f766781ead5174ff03d9bfcaac">heap</a></td></tr>
<tr class="memdesc:afa1114f766781ead5174ff03d9bfcaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory heap from which these auxiliary structures are allocated when needed  <a href="#afa1114f766781ead5174ff03d9bfcaac">More...</a><br /></td></tr>
<tr class="separator:afa1114f766781ead5174ff03d9bfcaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6554190844ba613c0afafb9a47b23bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6554190844ba613c0afafb9a47b23bad">cursor_heap</a></td></tr>
<tr class="memdesc:a6554190844ba613c0afafb9a47b23bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory heap from which innodb_api_buf is allocated per session  <a href="#a6554190844ba613c0afafb9a47b23bad">More...</a><br /></td></tr>
<tr class="separator:a6554190844ba613c0afafb9a47b23bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c9cc595e33ade9ceeb4a1f14a9d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4d7c9cc595e33ade9ceeb4a1f14a9d76">ins_node</a></td></tr>
<tr class="memdesc:a4d7c9cc595e33ade9ceeb4a1f14a9d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innobase SQL insert node used to perform inserts to the table.  <a href="#a4d7c9cc595e33ade9ceeb4a1f14a9d76">More...</a><br /></td></tr>
<tr class="separator:a4d7c9cc595e33ade9ceeb4a1f14a9d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1085ad273bb47a95631ac73a16a9a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa1085ad273bb47a95631ac73a16a9a22">ins_upd_rec_buff</a></td></tr>
<tr class="memdesc:aa1085ad273bb47a95631ac73a16a9a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer for storing data converted to the Innobase format from the MySQL format  <a href="#aa1085ad273bb47a95631ac73a16a9a22">More...</a><br /></td></tr>
<tr class="separator:aa1085ad273bb47a95631ac73a16a9a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17529dba84ae95ff25d3288cd032a373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmulti__value__data.html">multi_value_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a17529dba84ae95ff25d3288cd032a373">mv_data</a></td></tr>
<tr class="separator:a17529dba84ae95ff25d3288cd032a373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b397e188f2d0d2ebc9af03578617d35"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1b397e188f2d0d2ebc9af03578617d35">default_rec</a></td></tr>
<tr class="memdesc:a1b397e188f2d0d2ebc9af03578617d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default values of all columns (a "default row") in MySQL format  <a href="#a1b397e188f2d0d2ebc9af03578617d35">More...</a><br /></td></tr>
<tr class="separator:a1b397e188f2d0d2ebc9af03578617d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23328500b0f9834d0baddce5d3bbbc48"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a23328500b0f9834d0baddce5d3bbbc48">hint_need_to_fetch_extra_cols</a></td></tr>
<tr class="memdesc:a23328500b0f9834d0baddce5d3bbbc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">normally this is set to 0; if this is set to ROW_RETRIEVE_PRIMARY_KEY, then we should at least retrieve all columns in the primary key; if this is set to ROW_RETRIEVE_ALL_COLS, then we must retrieve all columns in the key (if read_just_key == 1), or all columns in the table  <a href="#a23328500b0f9834d0baddce5d3bbbc48">More...</a><br /></td></tr>
<tr class="separator:a23328500b0f9834d0baddce5d3bbbc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f54b68eb4f1a5349eef999f88a9967f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0f54b68eb4f1a5349eef999f88a9967f">upd_node</a></td></tr>
<tr class="memdesc:a0f54b68eb4f1a5349eef999f88a9967f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innobase SQL update node used to perform updates and deletes.  <a href="#a0f54b68eb4f1a5349eef999f88a9967f">More...</a><br /></td></tr>
<tr class="separator:a0f54b68eb4f1a5349eef999f88a9967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0079ca440c8a887b00c656ca73c767c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0079ca440c8a887b00c656ca73c767c6">trx_id</a></td></tr>
<tr class="memdesc:a0079ca440c8a887b00c656ca73c767c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The table-&gt;def_trx_id when ins_graph was built.  <a href="#a0079ca440c8a887b00c656ca73c767c6">More...</a><br /></td></tr>
<tr class="separator:a0079ca440c8a887b00c656ca73c767c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46537393407eb4071c703343586d22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ae46537393407eb4071c703343586d22a">ins_graph</a></td></tr>
<tr class="memdesc:ae46537393407eb4071c703343586d22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innobase SQL query graph used in inserts.  <a href="#ae46537393407eb4071c703343586d22a">More...</a><br /></td></tr>
<tr class="separator:ae46537393407eb4071c703343586d22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3aca3ac08088406e83cd47adb824a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9a3aca3ac08088406e83cd47adb824a4">upd_graph</a></td></tr>
<tr class="memdesc:a9a3aca3ac08088406e83cd47adb824a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Innobase SQL query graph used in updates or deletes.  <a href="#a9a3aca3ac08088406e83cd47adb824a4">More...</a><br /></td></tr>
<tr class="separator:a9a3aca3ac08088406e83cd47adb824a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60da953051fdf0e7b7aefe39e1ed693a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a60da953051fdf0e7b7aefe39e1ed693a">pcur</a></td></tr>
<tr class="memdesc:a60da953051fdf0e7b7aefe39e1ed693a"><td class="mdescLeft">&#160;</td><td class="mdescRight">persistent cursor used in selects and updates  <a href="#a60da953051fdf0e7b7aefe39e1ed693a">More...</a><br /></td></tr>
<tr class="separator:a60da953051fdf0e7b7aefe39e1ed693a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db8627d81df1a7a0c08668e575457a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3db8627d81df1a7a0c08668e575457a8">clust_pcur</a></td></tr>
<tr class="memdesc:a3db8627d81df1a7a0c08668e575457a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">persistent cursor used in some selects and updates  <a href="#a3db8627d81df1a7a0c08668e575457a8">More...</a><br /></td></tr>
<tr class="separator:a3db8627d81df1a7a0c08668e575457a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3504add5a29b9352f5f7a70da89e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#affb3504add5a29b9352f5f7a70da89e9">sel_graph</a></td></tr>
<tr class="memdesc:affb3504add5a29b9352f5f7a70da89e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy query graph used in selects  <a href="#affb3504add5a29b9352f5f7a70da89e9">More...</a><br /></td></tr>
<tr class="separator:affb3504add5a29b9352f5f7a70da89e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2110e245f510fe5703437190bdf7c9e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a2110e245f510fe5703437190bdf7c9e1">search_tuple</a></td></tr>
<tr class="memdesc:a2110e245f510fe5703437190bdf7c9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">prebuilt dtuple used in selects  <a href="#a2110e245f510fe5703437190bdf7c9e1">More...</a><br /></td></tr>
<tr class="separator:a2110e245f510fe5703437190bdf7c9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aee3ea62900f0e551a8e8d0bb5bc2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9aee3ea62900f0e551a8e8d0bb5bc2b0">m_stop_tuple</a></td></tr>
<tr class="memdesc:a9aee3ea62900f0e551a8e8d0bb5bc2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">prebuilt dtuple used in selects where the end of range is known  <a href="#a9aee3ea62900f0e551a8e8d0bb5bc2b0">More...</a><br /></td></tr>
<tr class="separator:a9aee3ea62900f0e551a8e8d0bb5bc2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39ca1bc8d5bdac980014d4d9e50eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9b39ca1bc8d5bdac980014d4d9e50eaa">m_stop_tuple_found</a></td></tr>
<tr class="memdesc:a9b39ca1bc8d5bdac980014d4d9e50eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true in row_search_mvcc when a row matching exactly the length and value of stop_tuple was found, so that the next iteration of row_search_mvcc knows it can simply return DB_RECORD_NOT_FOUND.  <a href="#a9b39ca1bc8d5bdac980014d4d9e50eaa">More...</a><br /></td></tr>
<tr class="separator:a9b39ca1bc8d5bdac980014d4d9e50eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac44d559d12885d25cceeebba46c7e6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aac44d559d12885d25cceeebba46c7e6c">row_id</a> [<a class="el" href="data0type_8h.html#a7a1bf08468f4acdff62d24adee4063f0">DATA_ROW_ID_LEN</a>]</td></tr>
<tr class="memdesc:aac44d559d12885d25cceeebba46c7e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the clustered index was generated, the row id of the last row fetched is stored here  <a href="#aac44d559d12885d25cceeebba46c7e6c">More...</a><br /></td></tr>
<tr class="separator:aac44d559d12885d25cceeebba46c7e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1fb978fc37f85f0f278ec6c09180d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fts0fts_8h.html#a380910af8d69503a3e3dcbf6d809a3b6">doc_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a2ab1fb978fc37f85f0f278ec6c09180d">fts_doc_id</a></td></tr>
<tr class="separator:a2ab1fb978fc37f85f0f278ec6c09180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad849b52ec988d5c989838523993998aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad849b52ec988d5c989838523993998aa">clust_ref</a></td></tr>
<tr class="memdesc:ad849b52ec988d5c989838523993998aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">prebuilt dtuple used in sel/upd/del  <a href="#ad849b52ec988d5c989838523993998aa">More...</a><br /></td></tr>
<tr class="separator:ad849b52ec988d5c989838523993998aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba7f40688b0b0acd0e46ce459eb134"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a33ba7f40688b0b0acd0e46ce459eb134">select_lock_type</a></td></tr>
<tr class="memdesc:a33ba7f40688b0b0acd0e46ce459eb134"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOCK_NONE, LOCK_S, or LOCK_X.  <a href="#a33ba7f40688b0b0acd0e46ce459eb134">More...</a><br /></td></tr>
<tr class="separator:a33ba7f40688b0b0acd0e46ce459eb134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77438b16efa1512b2eadb5a973898b9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad77438b16efa1512b2eadb5a973898b9">select_mode</a></td></tr>
<tr class="memdesc:ad77438b16efa1512b2eadb5a973898b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT.  <a href="#ad77438b16efa1512b2eadb5a973898b9">More...</a><br /></td></tr>
<tr class="separator:ad77438b16efa1512b2eadb5a973898b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b853f8cb36486a637e6f58ad95b458c"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6b853f8cb36486a637e6f58ad95b458c">row_read_type</a></td></tr>
<tr class="memdesc:a6b853f8cb36486a637e6f58ad95b458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROW_READ_WITH_LOCKS if row locks should be the obtained for records under an UPDATE or DELETE cursor.  <a href="#a6b853f8cb36486a637e6f58ad95b458c">More...</a><br /></td></tr>
<tr class="separator:a6b853f8cb36486a637e6f58ad95b458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ac56d3509b816290c930c3f409442a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ae6ac56d3509b816290c930c3f409442a">new_rec_lock</a> [<a class="el" href="structrow__prebuilt__t.html#ac2b2027e0ebc1de5d4d1d4c85ec90ffea6b4eac0f20f2925aefe876a0ef28bc3a">LOCK_COUNT</a>]</td></tr>
<tr class="memdesc:ae6ac56d3509b816290c930c3f409442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">normally false; if session is using READ COMMITTED or READ UNCOMMITTED isolation level, set in row_search_for_mysql() if we set a new record lock on the secondary or clustered index; this is used in row_unlock_for_mysql() when releasing the lock under the cursor if we determine after retrieving the row that it does not need to be locked ('mini-rollback') [LOCK_PCUR] corresponds to pcur, the first index we looked up (can be secondary or clustered!)  <a href="#ae6ac56d3509b816290c930c3f409442a">More...</a><br /></td></tr>
<tr class="separator:ae6ac56d3509b816290c930c3f409442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2656fbd8b2cf6d356622f37bace7444a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a2656fbd8b2cf6d356622f37bace7444a">mysql_prefix_len</a></td></tr>
<tr class="memdesc:a2656fbd8b2cf6d356622f37bace7444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte offset of the end of the last requested column  <a href="#a2656fbd8b2cf6d356622f37bace7444a">More...</a><br /></td></tr>
<tr class="separator:a2656fbd8b2cf6d356622f37bace7444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930a910f8de38274b71e4dcc79888496"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a930a910f8de38274b71e4dcc79888496">mysql_row_len</a></td></tr>
<tr class="memdesc:a930a910f8de38274b71e4dcc79888496"><td class="mdescLeft">&#160;</td><td class="mdescRight">length in bytes of a row in the MySQL format  <a href="#a930a910f8de38274b71e4dcc79888496">More...</a><br /></td></tr>
<tr class="separator:a930a910f8de38274b71e4dcc79888496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9219653973849987e00efd71c57cd9b5"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9219653973849987e00efd71c57cd9b5">n_rows_fetched</a></td></tr>
<tr class="memdesc:a9219653973849987e00efd71c57cd9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows fetched after positioning the current cursor  <a href="#a9219653973849987e00efd71c57cd9b5">More...</a><br /></td></tr>
<tr class="separator:a9219653973849987e00efd71c57cd9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8befaa7c077a4d5a0c3e673b09c4c361"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a8befaa7c077a4d5a0c3e673b09c4c361">fetch_direction</a></td></tr>
<tr class="memdesc:a8befaa7c077a4d5a0c3e673b09c4c361"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROW_SEL_NEXT or ROW_SEL_PREV.  <a href="#a8befaa7c077a4d5a0c3e673b09c4c361">More...</a><br /></td></tr>
<tr class="separator:a8befaa7c077a4d5a0c3e673b09c4c361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1ab35f63cdb3d2b64bb81a0a12cf84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9f1ab35f63cdb3d2b64bb81a0a12cf84">fetch_cache</a> [<a class="el" href="row0mysql_8h.html#adbabec476ae3e4e35d865d8d4dafdb8c">MYSQL_FETCH_CACHE_SIZE</a>]</td></tr>
<tr class="memdesc:a9f1ab35f63cdb3d2b64bb81a0a12cf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">a cache for fetched rows if we fetch many rows from the same cursor: it saves CPU time to fetch them in a batch; we reserve mysql_row_len bytes for each such row; these pointers point 4 bytes past the allocated mem buf start, because there is a 4 byte magic number at the start and at the end  <a href="#a9f1ab35f63cdb3d2b64bb81a0a12cf84">More...</a><br /></td></tr>
<tr class="separator:a9f1ab35f63cdb3d2b64bb81a0a12cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b52068ec945cf852151523434a786a"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ab6b52068ec945cf852151523434a786a">keep_other_fields_on_keyread</a></td></tr>
<tr class="memdesc:ab6b52068ec945cf852151523434a786a"><td class="mdescLeft">&#160;</td><td class="mdescRight">when using fetch cache with HA_EXTRA_KEYREAD, don't overwrite other fields in mysql row row buffer.  <a href="#ab6b52068ec945cf852151523434a786a">More...</a><br /></td></tr>
<tr class="separator:ab6b52068ec945cf852151523434a786a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a497bcd529e69f9b9ca11de686cc72"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad1a497bcd529e69f9b9ca11de686cc72">fetch_cache_first</a></td></tr>
<tr class="memdesc:ad1a497bcd529e69f9b9ca11de686cc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of the first not yet fetched row in fetch_cache  <a href="#ad1a497bcd529e69f9b9ca11de686cc72">More...</a><br /></td></tr>
<tr class="separator:ad1a497bcd529e69f9b9ca11de686cc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f4db03c18e781fe73864afb32fd4a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a633f4db03c18e781fe73864afb32fd4a">n_fetch_cached</a></td></tr>
<tr class="memdesc:a633f4db03c18e781fe73864afb32fd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of not yet fetched rows in fetch_cache  <a href="#a633f4db03c18e781fe73864afb32fd4a">More...</a><br /></td></tr>
<tr class="separator:a633f4db03c18e781fe73864afb32fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2bf20a06ef44d9114b5a7667f028c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4b2bf20a06ef44d9114b5a7667f028c2">blob_heap</a></td></tr>
<tr class="memdesc:a4b2bf20a06ef44d9114b5a7667f028c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">in SELECTS BLOB fields are copied to this heap  <a href="#a4b2bf20a06ef44d9114b5a7667f028c2">More...</a><br /></td></tr>
<tr class="separator:a4b2bf20a06ef44d9114b5a7667f028c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f020430b4ec6fdd33b90bc1a811f6f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a7f020430b4ec6fdd33b90bc1a811f6f3">old_vers_heap</a></td></tr>
<tr class="memdesc:a7f020430b4ec6fdd33b90bc1a811f6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory heap where a previous version is built in consistent read  <a href="#a7f020430b4ec6fdd33b90bc1a811f6f3">More...</a><br /></td></tr>
<tr class="separator:a7f020430b4ec6fdd33b90bc1a811f6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0dfee13cc2dd7f8603d873d0155d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a7d0dfee13cc2dd7f8603d873d0155d41">in_fts_query</a></td></tr>
<tr class="memdesc:a7d0dfee13cc2dd7f8603d873d0155d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we are in a FTS query.  <a href="#a7d0dfee13cc2dd7f8603d873d0155d41">More...</a><br /></td></tr>
<tr class="separator:a7d0dfee13cc2dd7f8603d873d0155d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5941dae2c19607f27f16c94dad626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#af7f5941dae2c19607f27f16c94dad626">fts_doc_id_in_read_set</a></td></tr>
<tr class="memdesc:af7f5941dae2c19607f27f16c94dad626"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if table has externally defined FTS_DOC_ID coulmn.  <a href="#af7f5941dae2c19607f27f16c94dad626">More...</a><br /></td></tr>
<tr class="separator:af7f5941dae2c19607f27f16c94dad626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec305f742e5262b09eeaad0e64066d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aec305f742e5262b09eeaad0e64066d0c">autoinc_last_value</a></td></tr>
<tr class="memdesc:aec305f742e5262b09eeaad0e64066d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">last value of AUTO-INC interval  <a href="#aec305f742e5262b09eeaad0e64066d0c">More...</a><br /></td></tr>
<tr class="separator:aec305f742e5262b09eeaad0e64066d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646ec8dded9b73f2ed89f14177fbbcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6646ec8dded9b73f2ed89f14177fbbcd">autoinc_increment</a></td></tr>
<tr class="memdesc:a6646ec8dded9b73f2ed89f14177fbbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The increment step of the auto increment column.  <a href="#a6646ec8dded9b73f2ed89f14177fbbcd">More...</a><br /></td></tr>
<tr class="separator:a6646ec8dded9b73f2ed89f14177fbbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c818b53352ba1e88d517b9e2d74c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a38c818b53352ba1e88d517b9e2d74c44">autoinc_offset</a></td></tr>
<tr class="memdesc:a38c818b53352ba1e88d517b9e2d74c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset passed to get_auto_increment() by MySQL.  <a href="#a38c818b53352ba1e88d517b9e2d74c44">More...</a><br /></td></tr>
<tr class="separator:a38c818b53352ba1e88d517b9e2d74c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9ef76992b0b772c92df797bb0b1f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9f9ef76992b0b772c92df797bb0b1f01">autoinc_error</a></td></tr>
<tr class="memdesc:a9f9ef76992b0b772c92df797bb0b1f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual error code encountered while trying to init or read the autoinc value from the table.  <a href="#a9f9ef76992b0b772c92df797bb0b1f01">More...</a><br /></td></tr>
<tr class="separator:a9f9ef76992b0b772c92df797bb0b1f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04b6f41e35d2507a6c6e2581576c736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa04b6f41e35d2507a6c6e2581576c736">idx_cond</a></td></tr>
<tr class="memdesc:aa04b6f41e35d2507a6c6e2581576c736"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if index condition pushdown is used, false otherwise.  <a href="#aa04b6f41e35d2507a6c6e2581576c736">More...</a><br /></td></tr>
<tr class="separator:aa04b6f41e35d2507a6c6e2581576c736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a85744d402aac8d6bd38de0d637ef4d"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6a85744d402aac8d6bd38de0d637ef4d">idx_cond_n_cols</a></td></tr>
<tr class="memdesc:a6a85744d402aac8d6bd38de0d637ef4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of fields in idx_cond_cols.  <a href="#a6a85744d402aac8d6bd38de0d637ef4d">More...</a><br /></td></tr>
<tr class="separator:a6a85744d402aac8d6bd38de0d637ef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb2c828efad5ccf81c3165c79269f80"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3cb2c828efad5ccf81c3165c79269f80">innodb_api</a>: 1</td></tr>
<tr class="memdesc:a3cb2c828efad5ccf81c3165c79269f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether this is a InnoDB API query  <a href="#a3cb2c828efad5ccf81c3165c79269f80">More...</a><br /></td></tr>
<tr class="separator:a3cb2c828efad5ccf81c3165c79269f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace90681d96b49e946dcade7a36f935a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aace90681d96b49e946dcade7a36f935a">innodb_api_rec</a></td></tr>
<tr class="memdesc:aace90681d96b49e946dcade7a36f935a"><td class="mdescLeft">&#160;</td><td class="mdescRight">InnoDB API search result.  <a href="#aace90681d96b49e946dcade7a36f935a">More...</a><br /></td></tr>
<tr class="separator:aace90681d96b49e946dcade7a36f935a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dc0d652fc8519e1b8e6c8c82d42509"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ac5dc0d652fc8519e1b8e6c8c82d42509">innodb_api_buf</a></td></tr>
<tr class="memdesc:ac5dc0d652fc8519e1b8e6c8c82d42509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer holding copy of the physical Innodb API search record.  <a href="#ac5dc0d652fc8519e1b8e6c8c82d42509">More...</a><br /></td></tr>
<tr class="separator:ac5dc0d652fc8519e1b8e6c8c82d42509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cac51144487afc9db0e5d11239acc82"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3cac51144487afc9db0e5d11239acc82">innodb_api_rec_size</a></td></tr>
<tr class="memdesc:a3cac51144487afc9db0e5d11239acc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the Innodb API record.  <a href="#a3cac51144487afc9db0e5d11239acc82">More...</a><br /></td></tr>
<tr class="separator:a3cac51144487afc9db0e5d11239acc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbde6d071d3ef240bbaed7f13b35d578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gis0type_8h.html#a3c34e436e3573c4d314f2c70c4d99326">rtr_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#acbde6d071d3ef240bbaed7f13b35d578">rtr_info</a></td></tr>
<tr class="memdesc:acbde6d071d3ef240bbaed7f13b35d578"><td class="mdescLeft">&#160;</td><td class="mdescRight">R-tree Search Info.  <a href="#acbde6d071d3ef240bbaed7f13b35d578">More...</a><br /></td></tr>
<tr class="separator:acbde6d071d3ef240bbaed7f13b35d578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc0a986a1cfa9c1af8d0c881d326f4b"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#affc0a986a1cfa9c1af8d0c881d326f4b">magic_n2</a></td></tr>
<tr class="memdesc:affc0a986a1cfa9c1af8d0c881d326f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this should be the same as magic_n  <a href="#affc0a986a1cfa9c1af8d0c881d326f4b">More...</a><br /></td></tr>
<tr class="separator:affc0a986a1cfa9c1af8d0c881d326f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43240b420d9f085748947946f2393799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a43240b420d9f085748947946f2393799">ins_sel_stmt</a></td></tr>
<tr class="memdesc:a43240b420d9f085748947946f2393799"><td class="mdescLeft">&#160;</td><td class="mdescRight">if true then ins_sel_statement.  <a href="#a43240b420d9f085748947946f2393799">More...</a><br /></td></tr>
<tr class="separator:a43240b420d9f085748947946f2393799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1744b97833f84182ee4fce419c7d313e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinnodb__session__t.html">innodb_session_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1744b97833f84182ee4fce419c7d313e">session</a></td></tr>
<tr class="memdesc:a1744b97833f84182ee4fce419c7d313e"><td class="mdescLeft">&#160;</td><td class="mdescRight">InnoDB session handler.  <a href="#a1744b97833f84182ee4fce419c7d313e">More...</a><br /></td></tr>
<tr class="separator:a1744b97833f84182ee4fce419c7d313e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93437253882fa8d53a3b576a4633fc94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a93437253882fa8d53a3b576a4633fc94">srch_key_val1</a></td></tr>
<tr class="memdesc:a93437253882fa8d53a3b576a4633fc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer used in converting search key values from MySQL format to InnoDB format.  <a href="#a93437253882fa8d53a3b576a4633fc94">More...</a><br /></td></tr>
<tr class="separator:a93437253882fa8d53a3b576a4633fc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe59b7101e2d8df0b534618b591511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a05fe59b7101e2d8df0b534618b591511">srch_key_val2</a></td></tr>
<tr class="memdesc:a05fe59b7101e2d8df0b534618b591511"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer used in converting search key values from MySQL format to InnoDB format.  <a href="#a05fe59b7101e2d8df0b534618b591511">More...</a><br /></td></tr>
<tr class="separator:a05fe59b7101e2d8df0b534618b591511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd747a430fb3aa32a2db04cebf345b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aefd747a430fb3aa32a2db04cebf345b6">srch_key_val_len</a></td></tr>
<tr class="memdesc:aefd747a430fb3aa32a2db04cebf345b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of search key.  <a href="#aefd747a430fb3aa32a2db04cebf345b6">More...</a><br /></td></tr>
<tr class="separator:aefd747a430fb3aa32a2db04cebf345b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52df69f729020848513251fb4b80a8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a52df69f729020848513251fb4b80a8bd">m_no_prefetch</a></td></tr>
<tr class="memdesc:a52df69f729020848513251fb4b80a8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable prefetch.  <a href="#a52df69f729020848513251fb4b80a8bd">More...</a><br /></td></tr>
<tr class="separator:a52df69f729020848513251fb4b80a8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4c9ae8172b3f861eb0be68b1c47ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a7e4c9ae8172b3f861eb0be68b1c47ea4">no_read_locking</a></td></tr>
<tr class="memdesc:a7e4c9ae8172b3f861eb0be68b1c47ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">true, if server has called ha_extra(HA_EXTRA_NO_READ_LOCKING)  <a href="#a7e4c9ae8172b3f861eb0be68b1c47ea4">More...</a><br /></td></tr>
<tr class="separator:a7e4c9ae8172b3f861eb0be68b1c47ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f76320461a701fba502789894bf298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a33f76320461a701fba502789894bf298">no_autoinc_locking</a></td></tr>
<tr class="memdesc:a33f76320461a701fba502789894bf298"><td class="mdescLeft">&#160;</td><td class="mdescRight">true, if we were asked to skip AUTOINC locking for the table.  <a href="#a33f76320461a701fba502789894bf298">More...</a><br /></td></tr>
<tr class="separator:a33f76320461a701fba502789894bf298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0023b94f5a14f5412d5d6bfc17b1ebc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0023b94f5a14f5412d5d6bfc17b1ebc6">m_read_virtual_key</a></td></tr>
<tr class="memdesc:a0023b94f5a14f5412d5d6bfc17b1ebc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return materialized key for secondary index scan.  <a href="#a0023b94f5a14f5412d5d6bfc17b1ebc6">More...</a><br /></td></tr>
<tr class="separator:a0023b94f5a14f5412d5d6bfc17b1ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5cce8840b85e71067495da833ff57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aab5cce8840b85e71067495da833ff57e">m_temp_read_shared</a></td></tr>
<tr class="memdesc:aab5cce8840b85e71067495da833ff57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is a temporary(intrinsic) table read to keep the position for this MySQL TABLE object.  <a href="#aab5cce8840b85e71067495da833ff57e">More...</a><br /></td></tr>
<tr class="separator:aab5cce8840b85e71067495da833ff57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de8f1def7443aa6a94c903f7b24aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a57de8f1def7443aa6a94c903f7b24aa7">m_temp_tree_modified</a></td></tr>
<tr class="memdesc:a57de8f1def7443aa6a94c903f7b24aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether tree modifying operation happened on a temporary (intrinsic) table index tree.  <a href="#a57de8f1def7443aa6a94c903f7b24aa7">More...</a><br /></td></tr>
<tr class="separator:a57de8f1def7443aa6a94c903f7b24aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace40b23405c2228c6407cfce4b52806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aace40b23405c2228c6407cfce4b52806">m_mysql_table</a></td></tr>
<tr class="memdesc:aace40b23405c2228c6407cfce4b52806"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MySQL table object.  <a href="#aace40b23405c2228c6407cfce4b52806">More...</a><br /></td></tr>
<tr class="separator:aace40b23405c2228c6407cfce4b52806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c5191fecd39b05fc04e456c37f975b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classha__innobase.html">ha_innobase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a77c5191fecd39b05fc04e456c37f975b">m_mysql_handler</a></td></tr>
<tr class="memdesc:a77c5191fecd39b05fc04e456c37f975b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MySQL handler object.  <a href="#a77c5191fecd39b05fc04e456c37f975b">More...</a><br /></td></tr>
<tr class="separator:a77c5191fecd39b05fc04e456c37f975b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2065738ddab0fa703271b13a4ca646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1c2065738ddab0fa703271b13a4ca646">m_fts_limit</a></td></tr>
<tr class="memdesc:a1c2065738ddab0fa703271b13a4ca646"><td class="mdescLeft">&#160;</td><td class="mdescRight">limit value to avoid fts result overflow  <a href="#a1c2065738ddab0fa703271b13a4ca646">More...</a><br /></td></tr>
<tr class="separator:a1c2065738ddab0fa703271b13a4ca646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3028cf172035fc3ab1c4e5f74fda0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad3028cf172035fc3ab1c4e5f74fda0dd">m_end_range</a></td></tr>
<tr class="memdesc:ad3028cf172035fc3ab1c4e5f74fda0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if exceeded the end_range while filling the prefetch cache.  <a href="#ad3028cf172035fc3ab1c4e5f74fda0dd">More...</a><br /></td></tr>
<tr class="separator:ad3028cf172035fc3ab1c4e5f74fda0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fccb5d041d43311811a1709d0990098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6fccb5d041d43311811a1709d0990098">m_lob_undo</a></td></tr>
<tr class="memdesc:a6fccb5d041d43311811a1709d0990098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo information for LOB mvcc.  <a href="#a6fccb5d041d43311811a1709d0990098">More...</a><br /></td></tr>
<tr class="separator:a6fccb5d041d43311811a1709d0990098"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acb289fd0cfc819e10b769745a9c0f02d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#acb289fd0cfc819e10b769745a9c0f02d">init_tuple_types</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:acb289fd0cfc819e10b769745a9c0f02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for init_search_tuples_types() which prepares the shape of the tuple to match the index.  <a href="#acb289fd0cfc819e10b769745a9c0f02d">More...</a><br /></td></tr>
<tr class="separator:acb289fd0cfc819e10b769745a9c0f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4c89af37d9fae7808f7c368b649803db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4c89af37d9fae7808f7c368b649803db">m_is_reading_range</a></td></tr>
<tr class="memdesc:a4c89af37d9fae7808f7c368b649803db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true iff we are inside read_range_first() or read_range_next()  <a href="#a4c89af37d9fae7808f7c368b649803db">More...</a><br /></td></tr>
<tr class="separator:a4c89af37d9fae7808f7c368b649803db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct for (sometimes lazily) prebuilt structures in an Innobase table handle used within MySQL; these are used to save CPU time. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac2b2027e0ebc1de5d4d1d4c85ec90ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b2027e0ebc1de5d4d1d4c85ec90ffe">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac2b2027e0ebc1de5d4d1d4c85ec90ffea0472245d9ec4774acf79a72404a112fe"></a>LOCK_PCUR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac2b2027e0ebc1de5d4d1d4c85ec90ffea8f5793157d7a1abdcb2e0ee2a066ad8f"></a>LOCK_CLUST_PCUR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac2b2027e0ebc1de5d4d1d4c85ec90ffea6b4eac0f20f2925aefe876a0ef28bc3a"></a>LOCK_COUNT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a364e702884ced0c85208d86fc5182d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364e702884ced0c85208d86fc5182d14">&#9670;&nbsp;</a></span>row_prebuilt_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">row_prebuilt_t::row_prebuilt_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It is unsafe to copy this struct, and moving it would be non-trivial, because we want to keep in sync with row_is_reading_range_guard_t. </p>
<p>Therefore it is much safer/easier to just forbid such operations. </p>

</div>
</div>
<a id="a13ec4ec80586a68887a7447a7d8e4182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ec4ec80586a68887a7447a7d8e4182">&#9670;&nbsp;</a></span>row_prebuilt_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">row_prebuilt_t::row_prebuilt_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a92235489f79f74ad55cd4d0f6051a34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92235489f79f74ad55cd4d0f6051a34f">&#9670;&nbsp;</a></span>allow_duplicates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::allow_duplicates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the query is REPLACE or ON DUPLICATE KEY UPDATE in which case duplicate values should be allowed (and further processed) instead of causing an error. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff duplicated values should be allowed </dd></dl>

</div>
</div>
<a id="acbc498acabe15e1c9115ae5414ecdf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc498acabe15e1c9115ae5414ecdf2f">&#9670;&nbsp;</a></span>can_prefetch_records()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::can_prefetch_records </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can a record buffer or a prefetch cache be utilized for prefetching records in this scan? </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if records can be prefetched </td></tr>
    <tr><td class="paramname">false</td><td>if records cannot be prefetched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad87f0f28e6b9c4a5e152eedf0e63bf1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87f0f28e6b9c4a5e152eedf0e63bf1f">&#9670;&nbsp;</a></span>clear_search_tuples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void row_prebuilt_t::clear_search_tuples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets both search_tuple and m_stop_tuple. </p>

</div>
</div>
<a id="ac9b8a8253f89dfc60a13fa38c11e3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b8a8253f89dfc60a13fa38c11e3224">&#9670;&nbsp;</a></span>get_is_reading_range_guard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrow__prebuilt__t_1_1row__is__reading__range__guard__t.html">row_is_reading_range_guard_t</a> row_prebuilt_t::get_is_reading_range_guard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3575fdf719e32dbff61fde9061d8ad94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3575fdf719e32dbff61fde9061d8ad94">&#9670;&nbsp;</a></span>get_lob_undo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a>* row_prebuilt_t::get_lob_undo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba5cce943b6a4e391ff798b06daa28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5cce943b6a4e391ff798b06daa28bf">&#9670;&nbsp;</a></span>init_search_tuples_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void row_prebuilt_t::init_search_tuples_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes search_tuple and m_stop_tuple shape so they match the index. </p>

</div>
</div>
<a id="acb289fd0cfc819e10b769745a9c0f02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb289fd0cfc819e10b769745a9c0f02d">&#9670;&nbsp;</a></span>init_tuple_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void row_prebuilt_t::init_tuple_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function for init_search_tuples_types() which prepares the shape of the tuple to match the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>this-&gt;search_tuple or this-&gt;m_stop_tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a814aaed869d2837566608d19e792282a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814aaed869d2837566608d19e792282a">&#9670;&nbsp;</a></span>is_reading_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::is_reading_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c6d4199f7e00754ecdf315dab81c0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6d4199f7e00754ecdf315dab81c0a9">&#9670;&nbsp;</a></span>lob_undo_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void row_prebuilt_t::lob_undo_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6af0040013c08cdc4ce6096ccc626ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6af0040013c08cdc4ce6096ccc626ae">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a>&amp; row_prebuilt_t::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1ea0c1c162aba499a9df70406da166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1ea0c1c162aba499a9df70406da166">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a>&amp; row_prebuilt_t::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a866bb5dd717dc6c08707b2d89dc29bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866bb5dd717dc6c08707b2d89dc29bab">&#9670;&nbsp;</a></span>skip_concurrency_ticket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::skip_concurrency_ticket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true iff the operation can skip concurrency ticket. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9f9ef76992b0b772c92df797bb0b1f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9ef76992b0b772c92df797bb0b1f01">&#9670;&nbsp;</a></span>autoinc_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_prebuilt_t::autoinc_error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual error code encountered while trying to init or read the autoinc value from the table. </p>
<p>We store it here so that we can return it to MySQL </p>

</div>
</div>
<a id="a6646ec8dded9b73f2ed89f14177fbbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646ec8dded9b73f2ed89f14177fbbcd">&#9670;&nbsp;</a></span>autoinc_increment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> row_prebuilt_t::autoinc_increment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The increment step of the auto increment column. </p>
<p>Value must be greater than or equal to 1. Required to calculate the next value </p>

</div>
</div>
<a id="aec305f742e5262b09eeaad0e64066d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec305f742e5262b09eeaad0e64066d0c">&#9670;&nbsp;</a></span>autoinc_last_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> row_prebuilt_t::autoinc_last_value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>last value of AUTO-INC interval </p>

</div>
</div>
<a id="a38c818b53352ba1e88d517b9e2d74c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c818b53352ba1e88d517b9e2d74c44">&#9670;&nbsp;</a></span>autoinc_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> row_prebuilt_t::autoinc_offset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The offset passed to get_auto_increment() by MySQL. </p>
<p>Required to calculate the next value </p>

</div>
</div>
<a id="a4b2bf20a06ef44d9114b5a7667f028c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2bf20a06ef44d9114b5a7667f028c2">&#9670;&nbsp;</a></span>blob_heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a>* row_prebuilt_t::blob_heap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>in SELECTS BLOB fields are copied to this heap </p>

</div>
</div>
<a id="abd76361eda548fa2e2f8d80d66d08612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd76361eda548fa2e2f8d80d66d08612">&#9670;&nbsp;</a></span>clust_index_was_generated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::clust_index_was_generated</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the user did not define a primary key in MySQL, then Innobase automatically generated a clustered index where the ordering column is the row id: in this case this flag is set to TRUE </p>

</div>
</div>
<a id="a3db8627d81df1a7a0c08668e575457a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db8627d81df1a7a0c08668e575457a8">&#9670;&nbsp;</a></span>clust_pcur</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a>* row_prebuilt_t::clust_pcur</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>persistent cursor used in some selects and updates </p>

</div>
</div>
<a id="ad849b52ec988d5c989838523993998aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad849b52ec988d5c989838523993998aa">&#9670;&nbsp;</a></span>clust_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* row_prebuilt_t::clust_ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prebuilt dtuple used in sel/upd/del </p>

</div>
</div>
<a id="a6554190844ba613c0afafb9a47b23bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6554190844ba613c0afafb9a47b23bad">&#9670;&nbsp;</a></span>cursor_heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a>* row_prebuilt_t::cursor_heap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory heap from which innodb_api_buf is allocated per session </p>

</div>
</div>
<a id="a1b397e188f2d0d2ebc9af03578617d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b397e188f2d0d2ebc9af03578617d35">&#9670;&nbsp;</a></span>default_rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_prebuilt_t::default_rec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the default values of all columns (a "default row") in MySQL format </p>

</div>
</div>
<a id="a9f1ab35f63cdb3d2b64bb81a0a12cf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1ab35f63cdb3d2b64bb81a0a12cf84">&#9670;&nbsp;</a></span>fetch_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_prebuilt_t::fetch_cache[<a class="el" href="row0mysql_8h.html#adbabec476ae3e4e35d865d8d4dafdb8c">MYSQL_FETCH_CACHE_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a cache for fetched rows if we fetch many rows from the same cursor: it saves CPU time to fetch them in a batch; we reserve mysql_row_len bytes for each such row; these pointers point 4 bytes past the allocated mem buf start, because there is a 4 byte magic number at the start and at the end </p>

</div>
</div>
<a id="ad1a497bcd529e69f9b9ca11de686cc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a497bcd529e69f9b9ca11de686cc72">&#9670;&nbsp;</a></span>fetch_cache_first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::fetch_cache_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>position of the first not yet fetched row in fetch_cache </p>

</div>
</div>
<a id="a8befaa7c077a4d5a0c3e673b09c4c361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8befaa7c077a4d5a0c3e673b09c4c361">&#9670;&nbsp;</a></span>fetch_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::fetch_direction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ROW_SEL_NEXT or ROW_SEL_PREV. </p>

</div>
</div>
<a id="a2ab1fb978fc37f85f0f278ec6c09180d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab1fb978fc37f85f0f278ec6c09180d">&#9670;&nbsp;</a></span>fts_doc_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fts0fts_8h.html#a380910af8d69503a3e3dcbf6d809a3b6">doc_id_t</a> row_prebuilt_t::fts_doc_id</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7f5941dae2c19607f27f16c94dad626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5941dae2c19607f27f16c94dad626">&#9670;&nbsp;</a></span>fts_doc_id_in_read_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::fts_doc_id_in_read_set</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true if table has externally defined FTS_DOC_ID coulmn. </p>

</div>
</div>
<a id="afa1114f766781ead5174ff03d9bfcaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1114f766781ead5174ff03d9bfcaac">&#9670;&nbsp;</a></span>heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a>* row_prebuilt_t::heap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory heap from which these auxiliary structures are allocated when needed </p>

</div>
</div>
<a id="a23328500b0f9834d0baddce5d3bbbc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23328500b0f9834d0baddce5d3bbbc48">&#9670;&nbsp;</a></span>hint_need_to_fetch_extra_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::hint_need_to_fetch_extra_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>normally this is set to 0; if this is set to ROW_RETRIEVE_PRIMARY_KEY, then we should at least retrieve all columns in the primary key; if this is set to ROW_RETRIEVE_ALL_COLS, then we must retrieve all columns in the key (if read_just_key == 1), or all columns in the table </p>

</div>
</div>
<a id="aa04b6f41e35d2507a6c6e2581576c736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04b6f41e35d2507a6c6e2581576c736">&#9670;&nbsp;</a></span>idx_cond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::idx_cond</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if index condition pushdown is used, false otherwise. </p>

</div>
</div>
<a id="a6a85744d402aac8d6bd38de0d637ef4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a85744d402aac8d6bd38de0d637ef4d">&#9670;&nbsp;</a></span>idx_cond_n_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::idx_cond_n_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of fields in idx_cond_cols. </p>
<p>0 if and only if idx_cond == false. </p>

</div>
</div>
<a id="a7d0dfee13cc2dd7f8603d873d0155d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0dfee13cc2dd7f8603d873d0155d41">&#9670;&nbsp;</a></span>in_fts_query</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::in_fts_query</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether we are in a FTS query. </p>

</div>
</div>
<a id="afeb88835f509e12ea05929f410f4df0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb88835f509e12ea05929f410f4df0a">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* row_prebuilt_t::index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>current index for a search, if any </p>

</div>
</div>
<a id="ac59950f1aed60deccf5ba6a917afc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59950f1aed60deccf5ba6a917afc357">&#9670;&nbsp;</a></span>index_usable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::index_usable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>caches the value of index-&gt;is_usable(trx) </p>

</div>
</div>
<a id="a3cb2c828efad5ccf81c3165c79269f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb2c828efad5ccf81c3165c79269f80">&#9670;&nbsp;</a></span>innodb_api</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::innodb_api</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>whether this is a InnoDB API query </p>

</div>
</div>
<a id="ac5dc0d652fc8519e1b8e6c8c82d42509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5dc0d652fc8519e1b8e6c8c82d42509">&#9670;&nbsp;</a></span>innodb_api_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* row_prebuilt_t::innodb_api_buf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer holding copy of the physical Innodb API search record. </p>

</div>
</div>
<a id="aace90681d96b49e946dcade7a36f935a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace90681d96b49e946dcade7a36f935a">&#9670;&nbsp;</a></span>innodb_api_rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* row_prebuilt_t::innodb_api_rec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>InnoDB API search result. </p>

</div>
</div>
<a id="a3cac51144487afc9db0e5d11239acc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cac51144487afc9db0e5d11239acc82">&#9670;&nbsp;</a></span>innodb_api_rec_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::innodb_api_rec_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the Innodb API record. </p>

</div>
</div>
<a id="ae46537393407eb4071c703343586d22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46537393407eb4071c703343586d22a">&#9670;&nbsp;</a></span>ins_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::ins_graph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Innobase SQL query graph used in inserts. </p>
<p>Will be rebuilt on trx_id or n_indexes mismatch. </p>

</div>
</div>
<a id="a4d7c9cc595e33ade9ceeb4a1f14a9d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7c9cc595e33ade9ceeb4a1f14a9d76">&#9670;&nbsp;</a></span>ins_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structins__node__t.html">ins_node_t</a>* row_prebuilt_t::ins_node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Innobase SQL insert node used to perform inserts to the table. </p>

</div>
</div>
<a id="a43240b420d9f085748947946f2393799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43240b420d9f085748947946f2393799">&#9670;&nbsp;</a></span>ins_sel_stmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::ins_sel_stmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if true then ins_sel_statement. </p>

</div>
</div>
<a id="aa1085ad273bb47a95631ac73a16a9a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1085ad273bb47a95631ac73a16a9a22">&#9670;&nbsp;</a></span>ins_upd_rec_buff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_prebuilt_t::ins_upd_rec_buff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer for storing data converted to the Innobase format from the MySQL format </p>

</div>
</div>
<a id="ab6b52068ec945cf852151523434a786a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b52068ec945cf852151523434a786a">&#9670;&nbsp;</a></span>keep_other_fields_on_keyread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_prebuilt_t::keep_other_fields_on_keyread</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>when using fetch cache with HA_EXTRA_KEYREAD, don't overwrite other fields in mysql row row buffer. </p>

</div>
</div>
<a id="ad3028cf172035fc3ab1c4e5f74fda0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3028cf172035fc3ab1c4e5f74fda0dd">&#9670;&nbsp;</a></span>m_end_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::m_end_range</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if exceeded the end_range while filling the prefetch cache. </p>

</div>
</div>
<a id="a1c2065738ddab0fa703271b13a4ca646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2065738ddab0fa703271b13a4ca646">&#9670;&nbsp;</a></span>m_fts_limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> row_prebuilt_t::m_fts_limit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>limit value to avoid fts result overflow </p>

</div>
</div>
<a id="a4c89af37d9fae7808f7c368b649803db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c89af37d9fae7808f7c368b649803db">&#9670;&nbsp;</a></span>m_is_reading_range</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::m_is_reading_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set to true iff we are inside read_range_first() or read_range_next() </p>

</div>
</div>
<a id="a6fccb5d041d43311811a1709d0990098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fccb5d041d43311811a1709d0990098">&#9670;&nbsp;</a></span>m_lob_undo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> row_prebuilt_t::m_lob_undo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo information for LOB mvcc. </p>

</div>
</div>
<a id="a77c5191fecd39b05fc04e456c37f975b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c5191fecd39b05fc04e456c37f975b">&#9670;&nbsp;</a></span>m_mysql_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classha__innobase.html">ha_innobase</a>* row_prebuilt_t::m_mysql_handler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The MySQL handler object. </p>

</div>
</div>
<a id="aace40b23405c2228c6407cfce4b52806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace40b23405c2228c6407cfce4b52806">&#9670;&nbsp;</a></span>m_mysql_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* row_prebuilt_t::m_mysql_table</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The MySQL table object. </p>

</div>
</div>
<a id="a52df69f729020848513251fb4b80a8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52df69f729020848513251fb4b80a8bd">&#9670;&nbsp;</a></span>m_no_prefetch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::m_no_prefetch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable prefetch. </p>

</div>
</div>
<a id="a0023b94f5a14f5412d5d6bfc17b1ebc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0023b94f5a14f5412d5d6bfc17b1ebc6">&#9670;&nbsp;</a></span>m_read_virtual_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::m_read_virtual_key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return materialized key for secondary index scan. </p>

</div>
</div>
<a id="a9aee3ea62900f0e551a8e8d0bb5bc2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aee3ea62900f0e551a8e8d0bb5bc2b0">&#9670;&nbsp;</a></span>m_stop_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* row_prebuilt_t::m_stop_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prebuilt dtuple used in selects where the end of range is known </p>

</div>
</div>
<a id="a9b39ca1bc8d5bdac980014d4d9e50eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b39ca1bc8d5bdac980014d4d9e50eaa">&#9670;&nbsp;</a></span>m_stop_tuple_found</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::m_stop_tuple_found</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set to true in row_search_mvcc when a row matching exactly the length and value of stop_tuple was found, so that the next iteration of row_search_mvcc knows it can simply return DB_RECORD_NOT_FOUND. </p>
<p>If true, then for sure, at least one such matching row was seen. If false, it might be false negative, as not all control paths lead to setting this field to true in case a matching row is visited. </p>

</div>
</div>
<a id="aab5cce8840b85e71067495da833ff57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5cce8840b85e71067495da833ff57e">&#9670;&nbsp;</a></span>m_temp_read_shared</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::m_temp_read_shared</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this is a temporary(intrinsic) table read to keep the position for this MySQL TABLE object. </p>

</div>
</div>
<a id="a57de8f1def7443aa6a94c903f7b24aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57de8f1def7443aa6a94c903f7b24aa7">&#9670;&nbsp;</a></span>m_temp_tree_modified</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::m_temp_tree_modified</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether tree modifying operation happened on a temporary (intrinsic) table index tree. </p>
<p>In this case, it could be split, but no shrink. </p>

</div>
</div>
<a id="ad936db2921893119b95f7e33727f2d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad936db2921893119b95f7e33727f2d2a">&#9670;&nbsp;</a></span>magic_n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::magic_n</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this magic number is set to ROW_PREBUILT_ALLOCATED when created, or ROW_PREBUILT_FREED when the struct has been freed </p>

</div>
</div>
<a id="affc0a986a1cfa9c1af8d0c881d326f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc0a986a1cfa9c1af8d0c881d326f4b">&#9670;&nbsp;</a></span>magic_n2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::magic_n2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this should be the same as magic_n </p>

</div>
</div>
<a id="a17529dba84ae95ff25d3288cd032a373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17529dba84ae95ff25d3288cd032a373">&#9670;&nbsp;</a></span>mv_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmulti__value__data.html">multi_value_data</a>* row_prebuilt_t::mv_data</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2656fbd8b2cf6d356622f37bace7444a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2656fbd8b2cf6d356622f37bace7444a">&#9670;&nbsp;</a></span>mysql_prefix_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::mysql_prefix_len</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>byte offset of the end of the last requested column </p>

</div>
</div>
<a id="a930a910f8de38274b71e4dcc79888496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930a910f8de38274b71e4dcc79888496">&#9670;&nbsp;</a></span>mysql_row_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::mysql_row_len</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>length in bytes of a row in the MySQL format </p>

</div>
</div>
<a id="a25c5641e4244b609f7e89f11069239e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c5641e4244b609f7e89f11069239e5">&#9670;&nbsp;</a></span>mysql_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a>* row_prebuilt_t::mysql_template</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template used to transform rows fast between MySQL and Innobase formats; memory for this template is not allocated from 'heap' </p>

</div>
</div>
<a id="a633f4db03c18e781fe73864afb32fd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f4db03c18e781fe73864afb32fd4a">&#9670;&nbsp;</a></span>n_fetch_cached</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::n_fetch_cached</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of not yet fetched rows in fetch_cache </p>

</div>
</div>
<a id="a9219653973849987e00efd71c57cd9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9219653973849987e00efd71c57cd9b5">&#9670;&nbsp;</a></span>n_rows_fetched</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::n_rows_fetched</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of rows fetched after positioning the current cursor </p>

</div>
</div>
<a id="a551a6896bb6da7d979e6fb20decf18ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551a6896bb6da7d979e6fb20decf18ba">&#9670;&nbsp;</a></span>n_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::n_template</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of elements in the template </p>

</div>
</div>
<a id="a94506e9f10462650bfa377f9414cf7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94506e9f10462650bfa377f9414cf7db">&#9670;&nbsp;</a></span>need_to_access_clustered</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::need_to_access_clustered</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if we are fetching columns through a secondary index and at least one column is not in the secondary index, then this is set to TRUE </p>

</div>
</div>
<a id="ae6ac56d3509b816290c930c3f409442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ac56d3509b816290c930c3f409442a">&#9670;&nbsp;</a></span>new_rec_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::new_rec_lock[<a class="el" href="structrow__prebuilt__t.html#ac2b2027e0ebc1de5d4d1d4c85ec90ffea6b4eac0f20f2925aefe876a0ef28bc3a">LOCK_COUNT</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>normally false; if session is using READ COMMITTED or READ UNCOMMITTED isolation level, set in row_search_for_mysql() if we set a new record lock on the secondary or clustered index; this is used in row_unlock_for_mysql() when releasing the lock under the cursor if we determine after retrieving the row that it does not need to be locked ('mini-rollback') [LOCK_PCUR] corresponds to pcur, the first index we looked up (can be secondary or clustered!) </p>
<p>[LOCK_CLUST_PCUR] corresponds to clust_pcur, which if used at all, is always the clustered index.</p>
<p>The meaning of these booleans is: true = we've created a rec lock, which we might release as we "own" it false = we should not release any lock for this index as we either reused some existing lock, or there is some other reason, we should keep it </p>

</div>
</div>
<a id="a33f76320461a701fba502789894bf298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f76320461a701fba502789894bf298">&#9670;&nbsp;</a></span>no_autoinc_locking</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::no_autoinc_locking</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true, if we were asked to skip AUTOINC locking for the table. </p>

</div>
</div>
<a id="a7e4c9ae8172b3f861eb0be68b1c47ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4c9ae8172b3f861eb0be68b1c47ea4">&#9670;&nbsp;</a></span>no_read_locking</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_prebuilt_t::no_read_locking</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true, if server has called ha_extra(HA_EXTRA_NO_READ_LOCKING) </p>

</div>
</div>
<a id="a4218e8b9331e26a43e2507663d59bdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4218e8b9331e26a43e2507663d59bdc1">&#9670;&nbsp;</a></span>null_bitmap_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::null_bitmap_len</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of bytes in the SQL NULL bitmap at the start of a row in the MySQL format </p>

</div>
</div>
<a id="a7f020430b4ec6fdd33b90bc1a811f6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f020430b4ec6fdd33b90bc1a811f6f3">&#9670;&nbsp;</a></span>old_vers_heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a>* row_prebuilt_t::old_vers_heap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory heap where a previous version is built in consistent read </p>

</div>
</div>
<a id="a5a53bf10140469ab155bace892faa519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a53bf10140469ab155bace892faa519">&#9670;&nbsp;</a></span>on_duplicate_key_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::on_duplicate_key_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if extra(HA_EXTRA_INSERT_WITH_UPDATE) was requested, which happens when ON DUPLICATE KEY UPDATE clause is present, 0 otherwise </p>

</div>
</div>
<a id="a60da953051fdf0e7b7aefe39e1ed693a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60da953051fdf0e7b7aefe39e1ed693a">&#9670;&nbsp;</a></span>pcur</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a>* row_prebuilt_t::pcur</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>persistent cursor used in selects and updates </p>

</div>
</div>
<a id="aa2406d22fe6361a563ec8b4e9b010287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2406d22fe6361a563ec8b4e9b010287">&#9670;&nbsp;</a></span>read_just_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::read_just_key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set to 1 when MySQL calls ha_innobase::extra with the argument HA_EXTRA_KEYREAD; it is enough to read just columns defined in the index (i.e., no read of the clustered index record necessary) </p>

</div>
</div>
<a id="a201878b5e5c37cf830f1b18489f78393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201878b5e5c37cf830f1b18489f78393">&#9670;&nbsp;</a></span>replace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::replace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if extra(HA_EXTRA_WRITE_CAN_REPLACE) was requested, which happen when REPLACE is done instead of regular INSERT, 0 otherwise </p>

</div>
</div>
<a id="aac44d559d12885d25cceeebba46c7e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac44d559d12885d25cceeebba46c7e6c">&#9670;&nbsp;</a></span>row_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> row_prebuilt_t::row_id[<a class="el" href="data0type_8h.html#a7a1bf08468f4acdff62d24adee4063f0">DATA_ROW_ID_LEN</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the clustered index was generated, the row id of the last row fetched is stored here </p>

</div>
</div>
<a id="a6b853f8cb36486a637e6f58ad95b458c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b853f8cb36486a637e6f58ad95b458c">&#9670;&nbsp;</a></span>row_read_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::row_read_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ROW_READ_WITH_LOCKS if row locks should be the obtained for records under an UPDATE or DELETE cursor. </p>
<p>If trx_t::allow_semi_consistent() returns true, this can be set to ROW_READ_TRY_SEMI_CONSISTENT, so that if the row under an UPDATE or DELETE cursor was locked by another transaction, InnoDB will resort to reading the last committed value ('semi-consistent read'). Then, this field will be set to ROW_READ_DID_SEMI_CONSISTENT to indicate that. If the row does not match the WHERE condition, MySQL will invoke handler::unlock_row() to clear the flag back to ROW_READ_TRY_SEMI_CONSISTENT and to simply skip the row. If the row matches, the next call to row_search_for_mysql() will lock the row. This eliminates lock waits in some cases; note that this breaks serializability. </p>

</div>
</div>
<a id="acbde6d071d3ef240bbaed7f13b35d578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbde6d071d3ef240bbaed7f13b35d578">&#9670;&nbsp;</a></span>rtr_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gis0type_8h.html#a3c34e436e3573c4d314f2c70c4d99326">rtr_info_t</a>* row_prebuilt_t::rtr_info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R-tree Search Info. </p>

</div>
</div>
<a id="a2110e245f510fe5703437190bdf7c9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2110e245f510fe5703437190bdf7c9e1">&#9670;&nbsp;</a></span>search_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* row_prebuilt_t::search_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prebuilt dtuple used in selects </p>

</div>
</div>
<a id="affb3504add5a29b9352f5f7a70da89e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3504add5a29b9352f5f7a70da89e9">&#9670;&nbsp;</a></span>sel_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::sel_graph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dummy query graph used in selects </p>

</div>
</div>
<a id="a33ba7f40688b0b0acd0e46ce459eb134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ba7f40688b0b0acd0e46ce459eb134">&#9670;&nbsp;</a></span>select_lock_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::select_lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LOCK_NONE, LOCK_S, or LOCK_X. </p>

</div>
</div>
<a id="ad77438b16efa1512b2eadb5a973898b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77438b16efa1512b2eadb5a973898b9">&#9670;&nbsp;</a></span>select_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> row_prebuilt_t::select_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT. </p>

</div>
</div>
<a id="a1744b97833f84182ee4fce419c7d313e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1744b97833f84182ee4fce419c7d313e">&#9670;&nbsp;</a></span>session</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinnodb__session__t.html">innodb_session_t</a>* row_prebuilt_t::session</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>InnoDB session handler. </p>

</div>
</div>
<a id="a1004d8c54485ba370f756c48f26d93a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1004d8c54485ba370f756c48f26d93a7">&#9670;&nbsp;</a></span>sql_stat_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::sql_stat_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE when we start processing of an SQL statement: we may have to set an intention lock on the table, create a consistent read view etc. </p>

</div>
</div>
<a id="a93437253882fa8d53a3b576a4633fc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93437253882fa8d53a3b576a4633fc94">&#9670;&nbsp;</a></span>srch_key_val1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_prebuilt_t::srch_key_val1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer used in converting search key values from MySQL format to InnoDB format. </p>

</div>
</div>
<a id="a05fe59b7101e2d8df0b534618b591511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe59b7101e2d8df0b534618b591511">&#9670;&nbsp;</a></span>srch_key_val2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_prebuilt_t::srch_key_val2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer used in converting search key values from MySQL format to InnoDB format. </p>

</div>
</div>
<a id="aefd747a430fb3aa32a2db04cebf345b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd747a430fb3aa32a2db04cebf345b6">&#9670;&nbsp;</a></span>srch_key_val_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> row_prebuilt_t::srch_key_val_len</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of search key. </p>

</div>
</div>
<a id="a19c2a8205446e84d2e64f80088a7846c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c2a8205446e84d2e64f80088a7846c">&#9670;&nbsp;</a></span>table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__table__t.html">dict_table_t</a>* row_prebuilt_t::table</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Innobase table handle. </p>

</div>
</div>
<a id="a666323e0b2127c47e743adf5ba2bef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666323e0b2127c47e743adf5ba2bef94">&#9670;&nbsp;</a></span>templ_contains_blob</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::templ_contains_blob</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if the template contains a column with DATA_LARGE_MTYPE( get_innobase_type_from_mysql_type()) is TRUE; not to be confused with InnoDB externally stored columns (VARCHAR can be off-page too) </p>

</div>
</div>
<a id="a4081417afcdbd59f9e107423a812e528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4081417afcdbd59f9e107423a812e528">&#9670;&nbsp;</a></span>templ_contains_fixed_point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::templ_contains_fixed_point</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if the template contains a column with DATA_POINT. </p>
<p>Since InnoDB regards DATA_POINT as non-BLOB type, the templ_contains_blob can't tell us if there is DATA_POINT </p>

</div>
</div>
<a id="afa6cf19178262078ea73dd92941a88ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6cf19178262078ea73dd92941a88ca">&#9670;&nbsp;</a></span>template_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::template_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ROW_MYSQL_WHOLE_ROW, ROW_MYSQL_REC_FIELDS, ROW_MYSQL_DUMMY_TEMPLATE, or ROW_MYSQL_NO_TEMPLATE. </p>

</div>
</div>
<a id="aa177d7d5264d91df66db86414dfa7da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa177d7d5264d91df66db86414dfa7da8">&#9670;&nbsp;</a></span>trx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrx__t.html">trx_t</a>* row_prebuilt_t::trx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>current transaction handle </p>

</div>
</div>
<a id="a0079ca440c8a887b00c656ca73c767c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0079ca440c8a887b00c656ca73c767c6">&#9670;&nbsp;</a></span>trx_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> row_prebuilt_t::trx_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The table-&gt;def_trx_id when ins_graph was built. </p>

</div>
</div>
<a id="a9a3aca3ac08088406e83cd47adb824a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3aca3ac08088406e83cd47adb824a4">&#9670;&nbsp;</a></span>upd_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::upd_graph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Innobase SQL query graph used in updates or deletes. </p>

</div>
</div>
<a id="a0f54b68eb4f1a5349eef999f88a9967f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f54b68eb4f1a5349eef999f88a9967f">&#9670;&nbsp;</a></span>upd_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__node__t.html">upd_node_t</a>* row_prebuilt_t::upd_node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Innobase SQL update node used to perform updates and deletes. </p>

</div>
</div>
<a id="a0568bf55e0cd59e39cbf5264e0107a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0568bf55e0cd59e39cbf5264e0107a04">&#9670;&nbsp;</a></span>used_in_HANDLER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::used_in_HANDLER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if we have been using this handle in a MySQL HANDLER low level index cursor command: then we must store the pcur position even in a unique search from a clustered index, because HANDLER allows NEXT and PREV in such a situation. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>storage/innobase/include/<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a></li>
<li>storage/innobase/row/<a class="el" href="row0mysql_8cc.html">row0mysql.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
