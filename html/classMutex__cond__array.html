<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Mutex_cond_array Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classMutex__cond__array.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMutex__cond__array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mutex_cond_array Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a growable array where each element contains a mutex and a condition variable.  
 <a href="classMutex__cond__array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMutex__cond__array_1_1Mutex__cond.html">Mutex_cond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex/cond pair.  <a href="structMutex__cond__array_1_1Mutex__cond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7daf69af88f2693e9d8ba87a5fa59c2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a7daf69af88f2693e9d8ba87a5fa59c2b">Mutex_cond_array</a> (<a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a> *<a class="el" href="classMutex__cond__array.html#a2eca1ae4a6f8382bd8a7ecd6e4efa666">global_lock</a>)</td></tr>
<tr class="memdesc:a7daf69af88f2693e9d8ba87a5fa59c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Mutex_cond_array.  <a href="#a7daf69af88f2693e9d8ba87a5fa59c2b">More...</a><br /></td></tr>
<tr class="separator:a7daf69af88f2693e9d8ba87a5fa59c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd09088240c27e11c270c43ff6c212b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a9dd09088240c27e11c270c43ff6c212b">~Mutex_cond_array</a> ()</td></tr>
<tr class="memdesc:a9dd09088240c27e11c270c43ff6c212b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this object.  <a href="#a9dd09088240c27e11c270c43ff6c212b">More...</a><br /></td></tr>
<tr class="separator:a9dd09088240c27e11c270c43ff6c212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefa8a4be4f750ef387b6cdcae78f1da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#acefa8a4be4f750ef387b6cdcae78f1da">lock</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:acefa8a4be4f750ef387b6cdcae78f1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the n'th mutex.  <a href="#acefa8a4be4f750ef387b6cdcae78f1da">More...</a><br /></td></tr>
<tr class="separator:acefa8a4be4f750ef387b6cdcae78f1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d612110e1544c730ab0e9986f75762"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#ab2d612110e1544c730ab0e9986f75762">unlock</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:ab2d612110e1544c730ab0e9986f75762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the n'th mutex.  <a href="#ab2d612110e1544c730ab0e9986f75762">More...</a><br /></td></tr>
<tr class="separator:ab2d612110e1544c730ab0e9986f75762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814e7f07b28928ffe98a471581625775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a814e7f07b28928ffe98a471581625775">broadcast</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:a814e7f07b28928ffe98a471581625775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast the n'th condition.  <a href="#a814e7f07b28928ffe98a471581625775">More...</a><br /></td></tr>
<tr class="separator:a814e7f07b28928ffe98a471581625775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae15c5c36f1d88f44f8ec8672a827d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#aae15c5c36f1d88f44f8ec8672a827d22">assert_owner</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:aae15c5c36f1d88f44f8ec8672a827d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that this thread owns the n'th mutex.  <a href="#aae15c5c36f1d88f44f8ec8672a827d22">More...</a><br /></td></tr>
<tr class="separator:aae15c5c36f1d88f44f8ec8672a827d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944367c6618c3f1c766511fdfc10eff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a944367c6618c3f1c766511fdfc10eff8">assert_not_owner</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:a944367c6618c3f1c766511fdfc10eff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that this thread does not own the n'th mutex.  <a href="#a944367c6618c3f1c766511fdfc10eff8">More...</a><br /></td></tr>
<tr class="separator:a944367c6618c3f1c766511fdfc10eff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d35f8265bc0ba163ca0c6bb36ba96d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a3d35f8265bc0ba163ca0c6bb36ba96d9">wait</a> (const <a class="el" href="classTHD.html">THD</a> *thd, int sidno, struct timespec *<a class="el" href="memcached_8c.html#ae7fce3cf8e64856257530444179867fd">abstime</a>) const</td></tr>
<tr class="memdesc:a3d35f8265bc0ba163ca0c6bb36ba96d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for signal on the n'th condition variable.  <a href="#a3d35f8265bc0ba163ca0c6bb36ba96d9">More...</a><br /></td></tr>
<tr class="separator:a3d35f8265bc0ba163ca0c6bb36ba96d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21299141e0c3205b4ab6545621f9526e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a21299141e0c3205b4ab6545621f9526e">enter_cond</a> (<a class="el" href="classTHD.html">THD</a> *thd, int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, <a class="el" href="group__psi__abi__stage.html#ga289f44a2c863dbb41fafc7d299df4f69">PSI_stage_info</a> *stage, <a class="el" href="group__psi__abi__stage.html#ga289f44a2c863dbb41fafc7d299df4f69">PSI_stage_info</a> *old_stage) const</td></tr>
<tr class="memdesc:a21299141e0c3205b4ab6545621f9526e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute THD::enter_cond for the n'th condition variable.  <a href="#a21299141e0c3205b4ab6545621f9526e">More...</a><br /></td></tr>
<tr class="separator:a21299141e0c3205b4ab6545621f9526e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06799cb9027245967b4e372390a43514"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a06799cb9027245967b4e372390a43514">get_max_index</a> () const</td></tr>
<tr class="memdesc:a06799cb9027245967b4e372390a43514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest addressable index in this Mutex_cond_array.  <a href="#a06799cb9027245967b4e372390a43514">More...</a><br /></td></tr>
<tr class="separator:a06799cb9027245967b4e372390a43514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36690cb3001e20bc5900abce919ea4e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a36690cb3001e20bc5900abce919ea4e1">ensure_index</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a36690cb3001e20bc5900abce919ea4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grows the array so that the given index fits.  <a href="#a36690cb3001e20bc5900abce919ea4e1">More...</a><br /></td></tr>
<tr class="separator:a36690cb3001e20bc5900abce919ea4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a13250f45b65714b51b83d25656904aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a13250f45b65714b51b83d25656904aae">is_thd_killed</a> (const <a class="el" href="classTHD.html">THD</a> *thd) const</td></tr>
<tr class="memdesc:a13250f45b65714b51b83d25656904aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given THD is killed.  <a href="#a13250f45b65714b51b83d25656904aae">More...</a><br /></td></tr>
<tr class="separator:a13250f45b65714b51b83d25656904aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dd6a9a43ffefa153f2b7593ca66d7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMutex__cond__array_1_1Mutex__cond.html">Mutex_cond</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#aa5dd6a9a43ffefa153f2b7593ca66d7a">get_mutex_cond</a> (int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const</td></tr>
<tr class="memdesc:aa5dd6a9a43ffefa153f2b7593ca66d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Nth Mutex_cond object.  <a href="#aa5dd6a9a43ffefa153f2b7593ca66d7a">More...</a><br /></td></tr>
<tr class="separator:aa5dd6a9a43ffefa153f2b7593ca66d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2eca1ae4a6f8382bd8a7ecd6e4efa666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a2eca1ae4a6f8382bd8a7ecd6e4efa666">global_lock</a></td></tr>
<tr class="memdesc:a2eca1ae4a6f8382bd8a7ecd6e4efa666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write lock that protects updates to the number of elements.  <a href="#a2eca1ae4a6f8382bd8a7ecd6e4efa666">More...</a><br /></td></tr>
<tr class="separator:a2eca1ae4a6f8382bd8a7ecd6e4efa666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b15c36729d8595d6fc829c709cc814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPrealloced__array.html">Prealloced_array</a>&lt; <a class="el" href="structMutex__cond__array_1_1Mutex__cond.html">Mutex_cond</a> *, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__cond__array.html#a06b15c36729d8595d6fc829c709cc814">m_array</a></td></tr>
<tr class="separator:a06b15c36729d8595d6fc829c709cc814"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a growable array where each element contains a mutex and a condition variable. </p>
<p>Each element can be locked, unlocked, broadcast, or waited for, and it is possible to call "THD::enter_cond" for the condition. The allowed indexes range from 0, inclusive, to get_max_index(), inclusive. Initially there are zero elements (and get_max_index() returns -1); more elements can be allocated by calling ensure_index().</p>
<p>This data structure has a read-write lock that protects the number of elements. The lock is provided by the invoker of the constructor and it is generally the caller's responsibility to acquire the read lock. Access methods assert that the caller already holds the read (or write) lock. If a method of this class grows the number of elements, then the method temporarily upgrades this lock to a write lock and then degrades it to a read lock again; there will be a short period when the lock is not held at all. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7daf69af88f2693e9d8ba87a5fa59c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daf69af88f2693e9d8ba87a5fa59c2b">&#9670;&nbsp;</a></span>Mutex_cond_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mutex_cond_array::Mutex_cond_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a> *&#160;</td>
          <td class="paramname"><em>global_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Mutex_cond_array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_lock</td><td>Read-write lock that protects updates to the number of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dd09088240c27e11c270c43ff6c212b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd09088240c27e11c270c43ff6c212b">&#9670;&nbsp;</a></span>~Mutex_cond_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mutex_cond_array::~Mutex_cond_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy this object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a944367c6618c3f1c766511fdfc10eff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944367c6618c3f1c766511fdfc10eff8">&#9670;&nbsp;</a></span>assert_not_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_cond_array::assert_not_owner </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that this thread does not own the n'th mutex. </p>
<p>This is a no-op if DBUG_OFF is on. </p>

</div>
</div>
<a id="aae15c5c36f1d88f44f8ec8672a827d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae15c5c36f1d88f44f8ec8672a827d22">&#9670;&nbsp;</a></span>assert_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_cond_array::assert_owner </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that this thread owns the n'th mutex. </p>
<p>This is a no-op if DBUG_OFF is on. </p>

</div>
</div>
<a id="a814e7f07b28928ffe98a471581625775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814e7f07b28928ffe98a471581625775">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_cond_array::broadcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast the n'th condition. </p>

</div>
</div>
<a id="a36690cb3001e20bc5900abce919ea4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36690cb3001e20bc5900abce919ea4e1">&#9670;&nbsp;</a></span>ensure_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rpl__gtid_8h.html#a3cf0e1a495b2402d8e6aa88f870316d5">enum_return_status</a> Mutex_cond_array::ensure_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grows the array so that the given index fits. </p>
<p>If the array is grown, the global_lock is temporarily upgraded to a write lock and then degraded again; there will be a short period when the lock is not held at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_OK or RETURN_REPORTED_ERROR </dd></dl>

</div>
</div>
<a id="a21299141e0c3205b4ab6545621f9526e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21299141e0c3205b4ab6545621f9526e">&#9670;&nbsp;</a></span>enter_cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_cond_array::enter_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__stage.html#ga289f44a2c863dbb41fafc7d299df4f69">PSI_stage_info</a> *&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__stage.html#ga289f44a2c863dbb41fafc7d299df4f69">PSI_stage_info</a> *&#160;</td>
          <td class="paramname"><em>old_stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute THD::enter_cond for the n'th condition variable. </p>

</div>
</div>
<a id="a06799cb9027245967b4e372390a43514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06799cb9027245967b4e372390a43514">&#9670;&nbsp;</a></span>get_max_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Mutex_cond_array::get_max_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest addressable index in this Mutex_cond_array. </p>

</div>
</div>
<a id="aa5dd6a9a43ffefa153f2b7593ca66d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dd6a9a43ffefa153f2b7593ca66d7a">&#9670;&nbsp;</a></span>get_mutex_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMutex__cond__array_1_1Mutex__cond.html">Mutex_cond</a>* Mutex_cond_array::get_mutex_cond </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Nth Mutex_cond object. </p>

</div>
</div>
<a id="a13250f45b65714b51b83d25656904aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13250f45b65714b51b83d25656904aae">&#9670;&nbsp;</a></span>is_thd_killed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Mutex_cond_array::is_thd_killed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given THD is killed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>- The thread object </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- thread is killed false - thread not killed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acefa8a4be4f750ef387b6cdcae78f1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefa8a4be4f750ef387b6cdcae78f1da">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_cond_array::lock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the n'th mutex. </p>

</div>
</div>
<a id="ab2d612110e1544c730ab0e9986f75762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d612110e1544c730ab0e9986f75762">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mutex_cond_array::unlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock the n'th mutex. </p>

</div>
</div>
<a id="a3d35f8265bc0ba163ca0c6bb36ba96d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d35f8265bc0ba163ca0c6bb36ba96d9">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Mutex_cond_array::wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>abstime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for signal on the n'th condition variable. </p>
<p>The caller must hold the read lock or write lock on sid_lock, as well as the nth mutex lock, before invoking this function. The sid_lock will be released, whereas the mutex will be released during the wait and (atomically) re-acquired when the wait ends or the timeout is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>THD object for the calling thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sidno</td><td>Condition variable to wait for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abstime</td><td>The absolute point in time when the wait times out and stops, or NULL to wait indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure: either timeout or thread was killed. If thread was killed, the error has been generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2eca1ae4a6f8382bd8a7ecd6e4efa666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eca1ae4a6f8382bd8a7ecd6e4efa666">&#9670;&nbsp;</a></span>global_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCheckable__rwlock.html">Checkable_rwlock</a>* Mutex_cond_array::global_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-write lock that protects updates to the number of elements. </p>

</div>
</div>
<a id="a06b15c36729d8595d6fc829c709cc814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b15c36729d8595d6fc829c709cc814">&#9670;&nbsp;</a></span>m_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPrealloced__array.html">Prealloced_array</a>&lt;<a class="el" href="structMutex__cond__array_1_1Mutex__cond.html">Mutex_cond</a> *, 8&gt; Mutex_cond_array::m_array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a></li>
<li>sql/<a class="el" href="rpl__gtid__mutex__cond__array_8cc.html">rpl_gtid_mutex_cond_array.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMutex__cond__array.html">Mutex_cond_array</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
