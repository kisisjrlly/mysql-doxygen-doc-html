<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Query Planner</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Query__Planner.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Planner</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga42f852eb43f8bc7a538dad8571f9b36f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga42f852eb43f8bc7a538dad8571f9b36f">prev_record_reads</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> found_ref)</td></tr>
<tr class="separator:ga42f852eb43f8bc7a538dad8571f9b36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287945c7b5b4a7419bb032390c634fe5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga287945c7b5b4a7419bb032390c634fe5">trace_plan_prefix</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> excluded_tables)</td></tr>
<tr class="memdesc:ga287945c7b5b4a7419bb032390c634fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to write the current plan's prefix to the optimizer trace.  <a href="#ga287945c7b5b4a7419bb032390c634fe5">More...</a><br /></td></tr>
<tr class="separator:ga287945c7b5b4a7419bb032390c634fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f81044d8b2b8a2af2a3325bf58f6f69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga2f81044d8b2b8a2af2a3325bf58f6f69">max_part_bit</a> (<a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> bits)</td></tr>
<tr class="separator:ga2f81044d8b2b8a2af2a3325bf58f6f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527fc42447a50830258e011b46b18307"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga527fc42447a50830258e011b46b18307">cache_record_length</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx)</td></tr>
<tr class="separator:ga527fc42447a50830258e011b46b18307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df25f42d6f17d92ab9e15fef0b81447"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga9df25f42d6f17d92ab9e15fef0b81447">calculate_condition_filter</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *const tab, const <a class="el" href="classKey__use.html">Key_use</a> *const keyuse, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> used_tables, double fanout, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_join_buffering, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> write_to_trace, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> &amp;parent_trace)</td></tr>
<tr class="memdesc:ga9df25f42d6f17d92ab9e15fef0b81447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate 'Post read filtering' effect of JOIN::conds for table 'tab'.  <a href="#ga9df25f42d6f17d92ab9e15fef0b81447">More...</a><br /></td></tr>
<tr class="separator:ga9df25f42d6f17d92ab9e15fef0b81447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec27fb1ea26091c151bc56ae9f416b08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaec27fb1ea26091c151bc56ae9f416b08">get_bound_sj_equalities</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> not_available_tables)</td></tr>
<tr class="memdesc:gaec27fb1ea26091c151bc56ae9f416b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmap of bound semi-join equalities.  <a href="#gaec27fb1ea26091c151bc56ae9f416b08">More...</a><br /></td></tr>
<tr class="separator:gaec27fb1ea26091c151bc56ae9f416b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51edd4249ea43d69718f9754c9422fd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaf51edd4249ea43d69718f9754c9422fd">semijoin_order_allows_materialization</a> (const <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx)</td></tr>
<tr class="memdesc:gaf51edd4249ea43d69718f9754c9422fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a semijoin materialization strategy is allowed for the current (semi)join table order.  <a href="#gaf51edd4249ea43d69718f9754c9422fd">More...</a><br /></td></tr>
<tr class="separator:gaf51edd4249ea43d69718f9754c9422fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945145266f4a865c166692aea42818ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga945145266f4a865c166692aea42818ed">get_partial_join_cost</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_tables, double *cost_arg, double *rowcount_arg)</td></tr>
<tr class="memdesc:ga945145266f4a865c166692aea42818ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a cost of given partial join order.  <a href="#ga945145266f4a865c166692aea42818ed">More...</a><br /></td></tr>
<tr class="separator:ga945145266f4a865c166692aea42818ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632cc5e05186538f3f511bb4c83e413e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga632cc5e05186538f3f511bb4c83e413e">secondary_engine_handlerton</a> (const <a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga632cc5e05186538f3f511bb4c83e413e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the handlerton of the secondary engine that will execute the current statement, or nullptr if a secondary engine is not used.  <a href="#ga632cc5e05186538f3f511bb4c83e413e">More...</a><br /></td></tr>
<tr class="separator:ga632cc5e05186538f3f511bb4c83e413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff35c6524786dde2e2620b7d7ca7bee3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaff35c6524786dde2e2620b7d7ca7bee3">almost_equal</a> (double left, double right)</td></tr>
<tr class="memdesc:gaff35c6524786dde2e2620b7d7ca7bee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that compares two doubles and accept these as "almost equal" if they are within 10 percent of each other.  <a href="#gaff35c6524786dde2e2620b7d7ca7bee3">More...</a><br /></td></tr>
<tr class="separator:gaff35c6524786dde2e2620b7d7ca7bee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108167d5d39ff1eaf262c4ec13842dc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga108167d5d39ff1eaf262c4ec13842dc0">Optimize_table_order::Optimize_table_order</a> (<a class="el" href="classTHD.html">THD</a> *thd_arg, <a class="el" href="classJOIN.html">JOIN</a> *join_arg, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *sjm_nest_arg)</td></tr>
<tr class="separator:ga108167d5d39ff1eaf262c4ec13842dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ebacbc2e35461641062e9e848dd5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gae1ebacbc2e35461641062e9e848dd5c3">Optimize_table_order::find_best_ref</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, const <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, const double prefix_rowcount, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *found_condition, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *ref_depends_map, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *used_key_parts)</td></tr>
<tr class="memdesc:gae1ebacbc2e35461641062e9e848dd5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best index to do 'ref' access on for a table.  <a href="#gae1ebacbc2e35461641062e9e848dd5c3">More...</a><br /></td></tr>
<tr class="separator:gae1ebacbc2e35461641062e9e848dd5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98725464468dbad84a527a073f8f02e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gad98725464468dbad84a527a073f8f02e">Optimize_table_order::calculate_scan_cost</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, const <a class="el" href="classKey__use.html">Key_use</a> *best_ref, const double prefix_rowcount, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> found_condition, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> disable_jbuf, double *rows_after_filtering, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *trace_access_scan)</td></tr>
<tr class="memdesc:gad98725464468dbad84a527a073f8f02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of range/table/index scanning table 'tab'.  <a href="#gad98725464468dbad84a527a073f8f02e">More...</a><br /></td></tr>
<tr class="separator:gad98725464468dbad84a527a073f8f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc697b97e535ae45b31fc3e65b11ce5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaabc697b97e535ae45b31fc3e65b11ce5">Optimize_table_order::lateral_derived_cost</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, const double prefix_rowcount, const <a class="el" href="classCost__model__server.html">Cost_model_server</a> *cost_model)</td></tr>
<tr class="memdesc:gaabc697b97e535ae45b31fc3e65b11ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If table is a lateral derived table, calculates the "cost of
materialization", which is the cost of a single materialization (available in the DT's underlying JOIN final plan) multiplied by the number of rows output by the last-in-plan table which DT references (available in a POSITION structure).  <a href="#gaabc697b97e535ae45b31fc3e65b11ce5">More...</a><br /></td></tr>
<tr class="separator:gaabc697b97e535ae45b31fc3e65b11ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ba95bb78a84577fe7bd278558b5467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaf4ba95bb78a84577fe7bd278558b5467">Optimize_table_order::best_access_path</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, const <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> disable_jbuf, const double prefix_rowcount, <a class="el" href="structPOSITION.html">POSITION</a> *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)</td></tr>
<tr class="memdesc:gaf4ba95bb78a84577fe7bd278558b5467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best access path for an extension of a partial execution plan and add this path to the plan.  <a href="#gaf4ba95bb78a84577fe7bd278558b5467">More...</a><br /></td></tr>
<tr class="separator:gaf4ba95bb78a84577fe7bd278558b5467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0107529f7577410e85d151cd359778e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gac0107529f7577410e85d151cd359778e">Optimize_table_order::semijoin_loosescan_fill_driving_table_position</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *s, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, double prefix_rowcount, <a class="el" href="structPOSITION.html">POSITION</a> *loose_scan_pos)</td></tr>
<tr class="memdesc:gac0107529f7577410e85d151cd359778e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a POSITION object of the driving table of a semi-join LooseScan range, with the cheapest access path.  <a href="#gac0107529f7577410e85d151cd359778e">More...</a><br /></td></tr>
<tr class="separator:gac0107529f7577410e85d151cd359778e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4471d2dbc1e6a0c471c56c950ab7cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gad4471d2dbc1e6a0c471c56c950ab7cac">Join_tab_compare_default::operator()</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *jt1, const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *jt2) const</td></tr>
<tr class="memdesc:gad4471d2dbc1e6a0c471c56c950ab7cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Less than" comparison function object used to compare two JOIN_TAB objects based on a number of factors in this order:  <a href="#gad4471d2dbc1e6a0c471c56c950ab7cac">More...</a><br /></td></tr>
<tr class="separator:gad4471d2dbc1e6a0c471c56c950ab7cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf585184987b0097465505d600394b8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaf585184987b0097465505d600394b8f3">Optimize_table_order::choose_table_order</a> ()</td></tr>
<tr class="memdesc:gaf585184987b0097465505d600394b8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point to table join order optimization.  <a href="#gaf585184987b0097465505d600394b8f3">More...</a><br /></td></tr>
<tr class="separator:gaf585184987b0097465505d600394b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1345da559c5841bf89d657bf2348e230"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga1345da559c5841bf89d657bf2348e230">Optimize_table_order::determine_search_depth</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> table_count)</td></tr>
<tr class="memdesc:ga1345da559c5841bf89d657bf2348e230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heuristic procedure to automatically guess a reasonable degree of exhaustiveness for the greedy search procedure.  <a href="#ga1345da559c5841bf89d657bf2348e230">More...</a><br /></td></tr>
<tr class="separator:ga1345da559c5841bf89d657bf2348e230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4eb4a2a802676363d5079335af9106d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gae4eb4a2a802676363d5079335af9106d">Optimize_table_order::optimize_straight_join</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> join_tables)</td></tr>
<tr class="memdesc:gae4eb4a2a802676363d5079335af9106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the best ways to access the tables in a query without reordering them.  <a href="#gae4eb4a2a802676363d5079335af9106d">More...</a><br /></td></tr>
<tr class="separator:gae4eb4a2a802676363d5079335af9106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0e0e4bba8f362f8b3c60cfb2736559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga1d0e0e4bba8f362f8b3c60cfb2736559">Optimize_table_order::greedy_search</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables)</td></tr>
<tr class="memdesc:ga1d0e0e4bba8f362f8b3c60cfb2736559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a good, possibly optimal, query execution plan (QEP) by a greedy search.  <a href="#ga1d0e0e4bba8f362f8b3c60cfb2736559">More...</a><br /></td></tr>
<tr class="separator:ga1d0e0e4bba8f362f8b3c60cfb2736559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad856a4b4c374fe71361e146146544191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gad856a4b4c374fe71361e146146544191">Optimize_table_order::consider_plan</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *trace_obj)</td></tr>
<tr class="memdesc:gad856a4b4c374fe71361e146146544191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost calculation of another (partial-)QEP has been completed.  <a href="#gad856a4b4c374fe71361e146146544191">More...</a><br /></td></tr>
<tr class="separator:gad856a4b4c374fe71361e146146544191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86042675d8fc244c695f3cc7c8fb5937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga86042675d8fc244c695f3cc7c8fb5937">Optimize_table_order::best_extension_by_limited_search</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> current_search_depth)</td></tr>
<tr class="memdesc:ga86042675d8fc244c695f3cc7c8fb5937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a good, possibly optimal, query execution plan (QEP) by a possibly exhaustive search.  <a href="#ga86042675d8fc244c695f3cc7c8fb5937">More...</a><br /></td></tr>
<tr class="separator:ga86042675d8fc244c695f3cc7c8fb5937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f382d0c287b8181908ad9fcd58150aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga9f382d0c287b8181908ad9fcd58150aa">Optimize_table_order::eq_ref_extension_by_limited_search</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> current_search_depth)</td></tr>
<tr class="memdesc:ga9f382d0c287b8181908ad9fcd58150aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heuristic utility used by best_extension_by_limited_search().  <a href="#ga9f382d0c287b8181908ad9fcd58150aa">More...</a><br /></td></tr>
<tr class="separator:ga9f382d0c287b8181908ad9fcd58150aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba76f383cbe1dccc7c7a6facaf1fe6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaba76f383cbe1dccc7c7a6facaf1fe6b8">Optimize_table_order::fix_semijoin_strategies</a> ()</td></tr>
<tr class="memdesc:gaba76f383cbe1dccc7c7a6facaf1fe6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix semi-join strategies for the picked join order.  <a href="#gaba76f383cbe1dccc7c7a6facaf1fe6b8">More...</a><br /></td></tr>
<tr class="separator:gaba76f383cbe1dccc7c7a6facaf1fe6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40175e89a592caf0dce0b81876c820f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga40175e89a592caf0dce0b81876c820f1">Optimize_table_order::check_interleaving_with_nj</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *next_tab)</td></tr>
<tr class="memdesc:ga40175e89a592caf0dce0b81876c820f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check interleaving with an inner tables of an outer join for extension table.  <a href="#ga40175e89a592caf0dce0b81876c820f1">More...</a><br /></td></tr>
<tr class="separator:ga40175e89a592caf0dce0b81876c820f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3c9edffdbb4ac2a34132ab34c5e410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gace3c9edffdbb4ac2a34132ab34c5e410">Optimize_table_order::semijoin_firstmatch_loosescan_access_paths</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> first_tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> last_tab, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> loosescan, double *newcount, double *newcost)</td></tr>
<tr class="memdesc:gace3c9edffdbb4ac2a34132ab34c5e410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find best access paths for semi-join FirstMatch or LooseScan strategy and calculate rowcount and cost based on these.  <a href="#gace3c9edffdbb4ac2a34132ab34c5e410">More...</a><br /></td></tr>
<tr class="separator:gace3c9edffdbb4ac2a34132ab34c5e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32406fd2c6934703eddb9131f42b51cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga32406fd2c6934703eddb9131f42b51cc">Optimize_table_order::semijoin_mat_scan_access_paths</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> last_inner_tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> last_outer_tab, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *sjm_nest, double *newcount, double *newcost)</td></tr>
<tr class="memdesc:ga32406fd2c6934703eddb9131f42b51cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find best access paths for semi-join MaterializeScan strategy and calculate rowcount and cost based on these.  <a href="#ga32406fd2c6934703eddb9131f42b51cc">More...</a><br /></td></tr>
<tr class="separator:ga32406fd2c6934703eddb9131f42b51cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e9baa19f09976372ae2ed2c19d5a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gac0e9baa19f09976372ae2ed2c19d5a7d">Optimize_table_order::semijoin_mat_lookup_access_paths</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> last_inner, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *sjm_nest, double *newcount, double *newcost)</td></tr>
<tr class="memdesc:gac0e9baa19f09976372ae2ed2c19d5a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find best access paths for semi-join MaterializeLookup strategy.  <a href="#gac0e9baa19f09976372ae2ed2c19d5a7d">More...</a><br /></td></tr>
<tr class="separator:gac0e9baa19f09976372ae2ed2c19d5a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107b06a43541ee7398f271e802aaa27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga107b06a43541ee7398f271e802aaa27a">Optimize_table_order::semijoin_dupsweedout_access_paths</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> first_tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> last_tab, double *newcount, double *newcost)</td></tr>
<tr class="memdesc:ga107b06a43541ee7398f271e802aaa27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find best access paths for semi-join DuplicateWeedout strategy and calculate rowcount and cost based on these.  <a href="#ga107b06a43541ee7398f271e802aaa27a">More...</a><br /></td></tr>
<tr class="separator:ga107b06a43541ee7398f271e802aaa27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b405566e7d41dad0996e85d34b0ab06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#ga5b405566e7d41dad0996e85d34b0ab06">Optimize_table_order::advance_sj_state</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx)</td></tr>
<tr class="memdesc:ga5b405566e7d41dad0996e85d34b0ab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do semi-join optimization step after we've added a new tab to join prefix.  <a href="#ga5b405566e7d41dad0996e85d34b0ab06">More...</a><br /></td></tr>
<tr class="separator:ga5b405566e7d41dad0996e85d34b0ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa149d4e4ac91df26688a77c6f2a2c55d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Planner.html#gaa149d4e4ac91df26688a77c6f2a2c55d">Optimize_table_order::backout_nj_state</a> (const <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> remaining_tables, const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="memdesc:gaa149d4e4ac91df26688a77c6f2a2c55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested joins perspective: Remove the last table from the join order.  <a href="#gaa149d4e4ac91df26688a77c6f2a2c55d">More...</a><br /></td></tr>
<tr class="separator:gaa149d4e4ac91df26688a77c6f2a2c55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga108167d5d39ff1eaf262c4ec13842dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga108167d5d39ff1eaf262c4ec13842dc0">&#9670;&nbsp;</a></span>Optimize_table_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Optimize_table_order::Optimize_table_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sjm_nest_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5b405566e7d41dad0996e85d34b0ab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b405566e7d41dad0996e85d34b0ab06">&#9670;&nbsp;</a></span>advance_sj_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::advance_sj_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>new_join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do semi-join optimization step after we've added a new tab to join prefix. </p>
<p>This function cannot work with nested SJ nests, for two reasons: (a) QEP_TAB::emb_sj_nest points to the most inner SJ nest, and this function looks only at it, so misses to do any SJ strategy choice for outer nests (b) POSITION has only one set of SJ-info (e.g. first_firstmatch_table): so planning for two nested nests would require more info than we have. And indeed, SJ nests cannot be nested, because: (c) a SJ nest is not nested in another SJ or anti SJ nest (it would have been dissolved into the outer nest by simplify_joins()). (d) an anti SJ nest is not nested inside another SJ or anti SJ nest (this case is blocked by resolve_subquery()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>Tables not in the join prefix </td></tr>
    <tr><td class="paramname">new_join_tab</td><td>Join tab that we are adding to the join prefix </td></tr>
    <tr><td class="paramname">idx</td><td>Index in join-&gt;position storing this join tab (i.e. number of tables in the prefix)</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">Update semi-join optimization state after we've added another tab (table
and access method) to the join prefix.

The state is maintained in join-&gt;positions[#prefix_size]. Each of the
available strategies has its own state variables.

for each semi-join strategy
{
  update strategy's state variables;

  if (join prefix has all the tables that are needed to consider
      using this strategy for the semi-join(s))
  {
    calculate cost of using the strategy
    if ((this is the first strategy to handle the semi-join nest(s)  ||
        the cost is less than other strategies))
    {
</pre><p> Pick this strategy pos-&gt;sj_strategy= .. .. } } }</p>
<p>Most of the new state is saved in join-&gt;positions[idx] (and hence no undo is necessary).</p>
<p>See setup_semijoin_dups_elimination() for a description of what kinds of join prefixes each strategy can handle.</p>
<p>A note on access path, rowcount and cost estimates:</p><ul>
<li>best_extension_by_limited_search() performs <em>initial calculations</em> of access paths, rowcount and cost based on the operation being an inner join or an outer join operation. These estimates are saved in join-&gt;positions.</li>
<li>advance_sj_state() performs <em>intermediate calculations</em> based on the same table information, but for the supported semi-join strategies. The access path part of these calculations are not saved anywhere, but the rowcount and cost of the best semi-join strategy are saved in join-&gt;positions.</li>
<li>Because the semi-join access path information was not saved previously, fix_semijoin_strategies() must perform <em>final calculations</em> of access paths, rowcount and cost when saving the selected table order in join-&gt;best_positions. The results of the final calculations will be the same as the results of the "best" intermediate calculations. </li>
</ul>

</div>
</div>
<a id="gaff35c6524786dde2e2620b7d7ca7bee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff35c6524786dde2e2620b7d7ca7bee3">&#9670;&nbsp;</a></span>almost_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> almost_equal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that compares two doubles and accept these as "almost equal" if they are within 10 percent of each other. </p>
<p>Handling of exact 0.0 values: if one of the values are exactly 0.0, the other value must also be exactly 0.0 to be considered to be equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>First double number to compare </td></tr>
    <tr><td class="paramname">right</td><td>Second double number to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two numbers are almost equal, false otherwise. </dd></dl>

</div>
</div>
<a id="gaa149d4e4ac91df26688a77c6f2a2c55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa149d4e4ac91df26688a77c6f2a2c55d">&#9670;&nbsp;</a></span>backout_nj_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::backout_nj_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nested joins perspective: Remove the last table from the join order. </p>
<p>Remove the last table from the partial join order and update the nested joins counters and cur_embedding_map. It is ok to call this function for the first table in join order (for which check_interleaving_with_nj has not been called)</p>
<p>This function rolls back changes done by:</p><ul>
<li>check_interleaving_with_nj(): removes the last table from the partial join order and update the nested joins counters and cur_embedding_map. It is ok to call this for the first table in join order (for which check_interleaving_with_nj() has not been called).</li>
</ul>
<p>The algorithm is the reciprocal of check_interleaving_with_nj(), hence parent join nest nodes are updated only when the last table in its child node is removed. The ASCII graphic below will clarify.</p>
<p>A table nesting such as <code> t1 x [ ( t2 x t3 ) x ( t4 x t5 ) ] </code>is represented by the below join nest tree.</p>
<pre class="fragment">                   NJ1
                _/ /  \
              _/  /    NJ2
            _/   /     / \
           /    /     /   \
 t1 x [ (t2 x t3) x (t4 x t5) ]
</pre><p>At the point in time when check_interleaving_with_nj() adds the table t5 to the query execution plan, QEP, it also directs the node named NJ2 to mark the table as covered. NJ2 does so by incrementing its <code>counter</code> member. Since all of NJ2's tables are now covered by the QEP, the algorithm proceeds up the tree to NJ1, incrementing its counter as well. All join nests are now completely covered by the QEP.</p>
<p>backout_nj_state() does the above in reverse. As seen above, the node NJ1 contains the nodes t2, t3, and NJ2. Its counter being equal to 3 means that the plan covers t2, t3, and NJ2, <em>and</em> that the sub-plan (t4 x t5) completely covers NJ2. The removal of t5 from the partial plan will first decrement NJ2's counter to 1. It will then detect that NJ2 went from being completely to partially covered, and hence the algorithm must continue upwards to NJ1 and decrement its counter to 2. A subsequent removal of t4 will however not influence NJ1 since it did not un-cover the last table in NJ2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>remaining tables to optimize, must contain 'tab' </td></tr>
    <tr><td class="paramname">tab</td><td>join table to remove, assumed to be the last in current partial join order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4ba95bb78a84577fe7bd278558b5467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4ba95bb78a84577fe7bd278558b5467">&#9670;&nbsp;</a></span>best_access_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::best_access_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>disable_jbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>prefix_rowcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best access path for an extension of a partial execution plan and add this path to the plan. </p>
<p>The function finds the best access path to table 'tab' from the passed partial plan where an access path is the general term for any means to access the data in 'tab'. An access path may use either an index scan, a table scan, a range scan or ref access, whichever is cheaper. The input partial plan is passed via the array 'join-&gt;positions' of length 'idx'. The chosen access method for 'tab' and its cost is stored in 'join-&gt;positions[idx]'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>the table to be joined by the function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td>set of tables not included in the partial plan yet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>the index in join-&gt;position[] where 'tab' is added to the partial plan. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">disable_jbuf</td><td>true&lt;=&gt; Don't use join buffering </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prefix_rowcount</td><td>estimate for the number of records returned by the partial plan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Table access plan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86042675d8fc244c695f3cc7c8fb5937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86042675d8fc244c695f3cc7c8fb5937">&#9670;&nbsp;</a></span>best_extension_by_limited_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::best_extension_by_limited_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>current_search_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a good, possibly optimal, query execution plan (QEP) by a possibly exhaustive search. </p>
<p>The procedure searches for the optimal ordering of the query tables in set 'remaining_tables' of size N, and the corresponding optimal access paths to each table. The choice of a table order and an access path for each table constitutes a query execution plan (QEP) that fully specifies how to execute the query.</p>
<p>The maximal size of the found plan is controlled by the parameter 'search_depth'. When search_depth == N, the resulting plan is complete and can be used directly as a QEP. If search_depth &lt; N, the found plan consists of only some of the query tables. Such "partial" optimal plans are useful only as input to query optimization procedures, and cannot be used directly to execute a query.</p>
<p>The algorithm begins with an empty partial plan stored in 'join-&gt;positions' and a set of N tables - 'remaining_tables'. Each step of the algorithm evaluates the cost of the partial plan extended by all access plans for each of the relations in 'remaining_tables', expands the current partial plan with the access plan that results in lowest cost of the expanded partial plan, and removes the corresponding relation from 'remaining_tables'. The algorithm continues until it either constructs a complete optimal plan, or constructs an optimal plartial plan with size = search_depth.</p>
<p>The final optimal plan is stored in 'join-&gt;best_positions'. The corresponding cost of the optimal plan is in 'join-&gt;best_read'.</p>
<dl class="section note"><dt>Note</dt><dd>The procedure uses a recursive depth-first search where the depth of the recursion (and thus the exhaustiveness of the search) is controlled by the parameter 'search_depth'.</dd>
<dd>
The pseudocode below describes the algorithm of 'best_extension_by_limited_search'. The worst-case complexity of this algorithm is O(N*N^search_depth/search_depth). When serch_depth &gt;= N, then the complexity of greedy_search is O(N!).</dd>
<dd>
<code>best_extension_by_limited_search()</code> and <code>eq_ref_extension_by_limited_search()</code> are closely related to each other and intentionally implemented using the same pattern wherever possible. If a change/bug fix is done to either of these also consider if it is relevant for the other.</dd></dl>
<div class="fragment"><div class="line">procedure <a class="code" href="group__Query__Planner.html#ga86042675d8fc244c695f3cc7c8fb5937">best_extension_by_limited_search</a>(</div><div class="line">  pplan in,             <span class="comment">// in, partial plan of tables-joined-so-far</span></div><div class="line">  pplan_cost,           <span class="comment">// in, cost of pplan</span></div><div class="line">  remaining_tables,     <span class="comment">// in, set of tables not referenced in pplan</span></div><div class="line">  best_plan_so_far,     <span class="comment">// in/out, best plan found so far</span></div><div class="line">  best_plan_so_far_cost,<span class="comment">// in/out, cost of best_plan_so_far</span></div><div class="line">  <a class="code" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a>)         <span class="comment">// in, maximum size of the plans being considered</span></div><div class="line">{</div><div class="line">  <span class="keywordflow">for each</span> table T from remaining_tables</div><div class="line">  {</div><div class="line">    <span class="comment">// Calculate the cost of using table T as above</span></div><div class="line">    cost = complex-series-of-calculations;</div><div class="line"></div><div class="line">    <span class="comment">// Add the cost to the cost so far.</span></div><div class="line">    pplan_cost+= cost;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (pplan_cost &gt;= best_plan_so_far_cost)</div><div class="line">      <span class="comment">// pplan_cost already too great, stop search</span></div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    pplan= expand pplan by best_access_method;</div><div class="line">    remaining_tables= remaining_tables - table T;</div><div class="line">    <span class="keywordflow">if</span> (remaining_tables is not an empty <span class="keyword">set</span></div><div class="line">        and</div><div class="line">        <a class="code" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a> &gt; 1)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (table T is EQ_REF-joined)</div><div class="line">        eq_ref_eq_ref_extension_by_limited_search(</div><div class="line">                                         pplan, pplan_cost,</div><div class="line">                                         remaining_tables,</div><div class="line">                                         best_plan_so_far,</div><div class="line">                                         best_plan_so_far_cost,</div><div class="line">                                         <a class="code" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a> - 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Query__Planner.html#ga86042675d8fc244c695f3cc7c8fb5937">best_extension_by_limited_search</a>(pplan, pplan_cost,</div><div class="line">                                         remaining_tables,</div><div class="line">                                         best_plan_so_far,</div><div class="line">                                         best_plan_so_far_cost,</div><div class="line">                                         <a class="code" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a> - 1);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      best_plan_so_far_cost= pplan_cost;</div><div class="line">      best_plan_so_far= pplan;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arguments pplan, plan_cost, best_plan_so_far and best_plan_so_far_cost are actually found in the POSITION object.</dd>
<dd>
When 'best_extension_by_limited_search' is called for the first time, 'join-&gt;best_read' must be set to the largest possible value (e.g. DBL_MAX). The actual implementation provides a way to optionally use pruning heuristic (controlled by the parameter 'prune_level') to reduce the search space by skipping some partial plans.</dd>
<dd>
The parameter 'search_depth' provides control over the recursion depth, and thus the size of the resulting optimal plan.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>set of tables not included into the partial plan yet </td></tr>
    <tr><td class="paramname">idx</td><td>length of the partial QEP in 'join-&gt;positions'; since a depth-first search is used, also corresponds to the current depth of the search tree; also an index in the array 'join-&gt;best_ref'; </td></tr>
    <tr><td class="paramname">current_search_depth</td><td>maximum depth of recursion and thus size of the found optimal plan (0 &lt; current_search_depth &lt;= join-&gt;tables+1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>

</div>
</div>
<a id="ga527fc42447a50830258e011b46b18307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527fc42447a50830258e011b46b18307">&#9670;&nbsp;</a></span>cache_record_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cache_record_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9df25f42d6f17d92ab9e15fef0b81447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df25f42d6f17d92ab9e15fef0b81447">&#9670;&nbsp;</a></span>calculate_condition_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float calculate_condition_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *const&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKey__use.html">Key_use</a> *const&#160;</td>
          <td class="paramname"><em>keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>used_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fanout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_join_buffering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>write_to_trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate 'Post read filtering' effect of JOIN::conds for table 'tab'. </p>
<p>Only conditions that are not directly involved in the chosen access method shall be included in the calculation of this 'Post read filtering' effect.</p>
<p>The function first identifies fields that are directly used by the access method. This includes columns used by range and ref access types, and predicates on the identified columns (if any) will not be taken into account when the filtering effect is calculated.</p>
<p>The function will then calculate the filtering effect of any predicate that applies to 'tab' and is not depending on the columns used by the access method. The source of information with highest accuracy is always preferred and is as follows: 1) Row estimates from the range optimizer 2) Row estimates from index statistics (records per key) 3) Guesstimates</p>
<p>Thus, after identifying columns that are used by the access method, the function will look for rows estimates made by the range optimizer. If found, the estimates from the range optimizer are calculated into the filtering effect.</p>
<p>The function then goes through JOIN::conds to get estimates from any remaining predicate that applies to 'tab' and does not depend on any tables that come later in the join sequence. Predicates that depend on columns that are either used by the access method or used in the row estimate from the range optimizer will not be considered in this phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>The table condition filtering effect is calculated for </td></tr>
    <tr><td class="paramname">keyuse</td><td>Describes the 'ref' access method (if any) that is chosen </td></tr>
    <tr><td class="paramname">used_tables</td><td>Tables earlier in the join sequence than 'tab' </td></tr>
    <tr><td class="paramname">fanout</td><td>The number of rows read by the chosen access method for each row combination of previous tables </td></tr>
    <tr><td class="paramname">is_join_buffering</td><td>Whether or not condition filtering is about to be calculated for an access method using join buffering. </td></tr>
    <tr><td class="paramname">write_to_trace</td><td>Wheter we should print the filtering effect calculated by histogram statistics and the final aggregated filtering effect to optimizer trace. </td></tr>
    <tr><td class="paramname">parent_trace</td><td>The parent trace object where the final aggregated filtering effect will be printed if "write_to_trace" is set to true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 'post read filtering' effect (between 0 and 1) of JOIN::conds </dd></dl>

</div>
</div>
<a id="gad98725464468dbad84a527a073f8f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad98725464468dbad84a527a073f8f02e">&#9670;&nbsp;</a></span>calculate_scan_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Optimize_table_order::calculate_scan_cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>best_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>prefix_rowcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>found_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>disable_jbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rows_after_filtering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_access_scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the cost of range/table/index scanning table 'tab'. </p>
<p>Returns a hybrid scan cost number: the cost of fetching rows from the storage engine plus CPU cost during execution for evaluating the rows (estimate) that will be filtered out by predicates relevant to the table. The cost does not include the CPU cost during execution for rows that are not filtered out.</p>
<p>This hybrid cost is needed because if join buffering is used to reduce the number of scans, then the final cost depends on how many times the join buffer had to be filled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the table to be joined by the function </td></tr>
    <tr><td class="paramname">idx</td><td>the index in join-&gt;position[] where 'tab' is added to the partial plan. </td></tr>
    <tr><td class="paramname">best_ref</td><td>description of the best ref access method for 'tab' </td></tr>
    <tr><td class="paramname">prefix_rowcount</td><td>estimate for the number of records returned by the partial plan </td></tr>
    <tr><td class="paramname">found_condition</td><td>whether or not there exists a condition that filters away rows for this table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>find_best_ref() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">disable_jbuf</td><td>don't use join buffering if true </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rows_after_filtering</td><td>fanout of the access method after taking condition filtering into account </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trace_access_scan</td><td>The optimizer trace object info is appended to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cost of fetching rows from the storage engine plus CPU execution cost of the rows that are estimated to be filtered out by query conditions. </dd></dl>

</div>
</div>
<a id="ga40175e89a592caf0dce0b81876c820f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40175e89a592caf0dce0b81876c820f1">&#9670;&nbsp;</a></span>check_interleaving_with_nj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::check_interleaving_with_nj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check interleaving with an inner tables of an outer join for extension table. </p>
<p>Check if table tab can be added to current partial join order, and if yes, record that it has been added. This recording can be rolled back with backout_nj_state().</p>
<p>The function assumes that both current partial join order and its extension with tab are valid wrt table dependencies.</p>
<pre class="fragment">   IMPLEMENTATION
     LIMITATIONS ON JOIN ORDER
       The nested [outer] joins executioner algorithm imposes these
limitations on join order:
       1. "Outer tables first" -  any "outer" table must be before any
           corresponding "inner" table.
       2. "No interleaving" - tables inside a nested join must form a
continuous sequence in join order (i.e. the sequence must not be interrupted
by tables that are outside of this nested join).

       #1 is checked elsewhere, this function checks #2 provided that #1 has
       been already checked.

     WHY NEED NON-INTERLEAVING
       Consider an example:

         select * from t0 join t1 left join (t2 join t3) on cond1

       The join order "t1 t2 t0 t3" is invalid:

       table t0 is outside of the nested join, so WHERE condition for t0 is
       attached directly to t0 (without triggers, and it may be used to access
       t0). Applying WHERE(t0) to (t2,t0,t3) record is invalid as we may miss
       combinations of (t1, t2, t3) that satisfy condition cond1, and produce
a null-complemented (t1, t2.NULLs, t3.NULLs) row, which should not have been
produced.

       If table t0 is not between t2 and t3, the problem doesn't exist:
        If t0 is located after (t2,t3), WHERE(t0) is applied after nested join
         processing has finished.
        If t0 is located before (t2,t3), predicates like WHERE_cond(t0, t2)
are wrapped into condition triggers, which takes care of correct nested join
processing.

     HOW IT IS IMPLEMENTED
       The limitations on join order can be rephrased as follows: for valid
       join order one must be able to:
         1. write down the used tables in the join order on one line.
         2. for each nested join, put one '(' and one ')' on the said line
         3. write "LEFT JOIN" and "ON (...)" where appropriate
         4. get a query equivalent to the query we're trying to execute.

       Calls to check_interleaving_with_nj() are equivalent to writing the
       above described line from left to right.
       A single check_interleaving_with_nj(A,B) call is equivalent to writing
       table B and appropriate brackets on condition that table A and
       appropriate brackets is the last what was written. Graphically the
       transition is as follows:

                            +---- current position
                            |
           ... last_tab ))) | ( tab )  )..) | ...
                              X     Y   Z   |
                                            +- need to move to this
                                               position.

       Notes about the position:
         The caller guarantees that there is no more then one X-bracket by
         checking "!(remaining_tables &amp; s-&gt;dependent)" before calling this
         function. X-bracket may have a pair in Y-bracket.

       When "writing" we store/update this auxilary info about the current
       position:
        1. cur_embedding_map - bitmap of pairs of brackets (aka nested
           joins) we've opened but didn't close.
        2. {each NESTED_JOIN structure not simplified away}-&gt;counter - number
           of this nested join's children that have already been added to to
           the partial join order.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table we're going to extend the current partial join with</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Join order extended, nested joins info about current join order (see NOTE section) updated. </td></tr>
    <tr><td class="paramname">true</td><td>Requested join order extension not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf585184987b0097465505d600394b8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf585184987b0097465505d600394b8f3">&#9670;&nbsp;</a></span>choose_table_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::choose_table_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point to table join order optimization. </p>
<p>Selects and invokes a search strategy for an optimal query join order.</p>
<p>For further description, see class header and private function headers.</p>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error</dd></dl>
<p>The function checks user-configurable parameters that control the search strategy for an optimal plan, selects the search method and then invokes it. Each specific optimization procedure stores the final optimal plan in the array 'join-&gt;best_positions', and the cost of the plan in 'join-&gt;best_read'. The function can be invoked to produce a plan for all tables in the query (in this case, the const tables are usually filtered out), or it can be invoked to produce a plan for a materialization of a semijoin nest. Set a non-NULL emb_sjm_nest pointer when producing a plan for a semijoin nest to be materialized and a NULL pointer when producing a full query plan.</p>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>
<p>&lt; The tables involved in order selection </p>

</div>
</div>
<a id="gad856a4b4c374fe71361e146146544191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad856a4b4c374fe71361e146146544191">&#9670;&nbsp;</a></span>consider_plan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::consider_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost calculation of another (partial-)QEP has been completed. </p>
<p>If this is our 'best' plan explored so far, we record this query plan and its cost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>length of the partial QEP in 'join-&gt;positions'; also corresponds to the current depth of the search tree; also an index in the array 'join-&gt;best_ref'; </td></tr>
    <tr><td class="paramname">trace_obj</td><td>trace object where information is to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>

</div>
</div>
<a id="ga1345da559c5841bf89d657bf2348e230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1345da559c5841bf89d657bf2348e230">&#9670;&nbsp;</a></span>determine_search_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Optimize_table_order::determine_search_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>search_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>table_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Heuristic procedure to automatically guess a reasonable degree of exhaustiveness for the greedy search procedure. </p>
<p>The procedure estimates the optimization time and selects a search depth big enough to result in a near-optimal QEP, that doesn't take too long to find. If the number of tables in the query exceeds some constant, then search_depth is set to this constant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_depth</td><td>Search depth value specified. If zero, calculate a default value. </td></tr>
    <tr><td class="paramname">table_count</td><td>Number of tables to be optimized (excludes const tables)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is an extremely simplistic implementation that serves as a stub for a more advanced analysis of the join. Ideally the search depth should be determined by learning from previous query optimizations, because it will depend on the CPU power (and other factors).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer that specifies the search depth (and thus the exhaustiveness) of the depth-first search algorithm used by 'greedy_search'. </dd></dl>

</div>
</div>
<a id="ga9f382d0c287b8181908ad9fcd58150aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f382d0c287b8181908ad9fcd58150aa">&#9670;&nbsp;</a></span>eq_ref_extension_by_limited_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> Optimize_table_order::eq_ref_extension_by_limited_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>current_search_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Heuristic utility used by best_extension_by_limited_search(). </p>
<p>Adds EQ_REF-joined tables to the partial plan without extensive 'greedy' cost calculation.</p>
<p>When a table is joined by an unique key there is a 1::1 relation between the rows being joined. Assuming we have multiple such 1::1 (star-)joined relations in a sequence, without other join types inbetween. Then all of these 'eq_ref-joins' will be estimated to return the exact same number of rows and having identical 'cost' (or 'read_time').</p>
<p>This leads to that we can append such a contiguous sequence of eq_ref-joins to a partial plan in any order without affecting the total cost of the query plan. Exploring the different permutations of these eq_refs in the 'greedy' optimizations will simply be a waste of precious CPU cycles.</p>
<p>Once we have appended a single eq_ref-join to a partial plan, we may use eq_ref_extension_by_limited_search() to search 'remaining_tables' for more eq_refs which will form a contiguous set of eq_refs in the QEP.</p>
<p>Effectively, this chain of eq_refs will be handled as a single entity wrt. the full 'greedy' exploration of the possible join plans. This will reduce the 'N' in the O(N!) complexity of the full greedy search.</p>
<p>The algorithm start by already having a eq_ref joined table in position[idx-1] when called. It then search for more eq_ref-joinable 'remaining_tables' which are added directly to the partial QEP without further cost analysis. The algorithm continues until it either has constructed a complete plan, constructed a partial plan with size = search_depth, or could not find more eq_refs to append.</p>
<p>In the later case the algorithm continues into 'best_extension_by_limited_search' which does a 'greedy' search for the next table to add - Possibly with later eq_ref_extensions.</p>
<p>The final optimal plan is stored in 'join-&gt;best_positions'. The corresponding cost of the optimal plan is in 'join-&gt;best_read'.</p>
<dl class="section note"><dt>Note</dt><dd><code>best_extension_by_limited_search()</code> and <code>eq_ref_extension_by_limited_search()</code> are closely related to each other and intentionally implemented using the same pattern wherever possible. If a change/bug fix is done to either of these also consider if it is relevant for the other.</dd></dl>
<div class="fragment"><div class="line">procedure <a class="code" href="group__Query__Planner.html#ga9f382d0c287b8181908ad9fcd58150aa">eq_ref_extension_by_limited_search</a>(</div><div class="line">  pplan in,             <span class="comment">// in, partial plan of tables-joined-so-far</span></div><div class="line">  pplan_cost,           <span class="comment">// in, cost of pplan</span></div><div class="line">  remaining_tables,     <span class="comment">// in, set of tables not referenced in pplan</span></div><div class="line">  best_plan_so_far,     <span class="comment">// in/out, best plan found so far</span></div><div class="line">  best_plan_so_far_cost,<span class="comment">// in/out, cost of best_plan_so_far</span></div><div class="line">  <a class="code" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a>)         <span class="comment">// in, maximum size of the plans being considered</span></div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> <a class="code" href="namespacedblwr_1_1recv.html#a4d87e29e585a1f0ddb67f6f0b3b2d0ea">find</a> <span class="stringliteral">&#39;eq_ref&#39;</span> table T from remaining_tables</div><div class="line">  {</div><div class="line">    <span class="comment">// Calculate the cost of using table T as above</span></div><div class="line">    cost = complex-series-of-calculations;</div><div class="line"></div><div class="line">    <span class="comment">// Add the cost to the cost so far.</span></div><div class="line">    pplan_cost+= cost;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (pplan_cost &gt;= best_plan_so_far_cost)</div><div class="line">      <span class="comment">// pplan_cost already too great, stop search</span></div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    pplan= expand pplan by best_access_method;</div><div class="line">    remaining_tables= remaining_tables - table T;</div><div class="line">    <a class="code" href="group__Query__Planner.html#ga9f382d0c287b8181908ad9fcd58150aa">eq_ref_extension_by_limited_search</a>(pplan, pplan_cost,</div><div class="line">                                       remaining_tables,</div><div class="line">                                       best_plan_so_far,</div><div class="line">                                       best_plan_so_far_cost,</div><div class="line">                                       <a class="code" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a> - 1);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <a class="code" href="group__Query__Planner.html#ga86042675d8fc244c695f3cc7c8fb5937">best_extension_by_limited_search</a>(pplan, pplan_cost,</div><div class="line">                                     remaining_tables,</div><div class="line">                                     best_plan_so_far,</div><div class="line">                                     best_plan_so_far_cost,</div><div class="line">                                     <a class="code" href="classOptimize__table__order.html#ae42f93fe1a0474f0bbc25ddf8088faf9">search_depth</a> - 1);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The parameter 'search_depth' provides control over the recursion depth, and thus the size of the resulting optimal plan.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>set of tables not included into the partial plan yet </td></tr>
    <tr><td class="paramname">idx</td><td>length of the partial QEP in 'join-&gt;positions'; since a depth-first search is used, also corresponds to the current depth of the search tree; also an index in the array 'join-&gt;best_ref'; </td></tr>
    <tr><td class="paramname">current_search_depth</td><td>maximum depth of recursion and thus size of the found optimal plan (0 &lt; current_search_depth &lt;= join-&gt;tables+1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">'table_map'</td><td>Map of those tables appended to the EQ_REF-joined sequence </td></tr>
    <tr><td class="paramname">~(table_map)0</td><td>Fatal error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1ebacbc2e35461641062e9e848dd5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ebacbc2e35461641062e9e848dd5c3">&#9670;&nbsp;</a></span>find_best_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKey__use.html">Key_use</a> * Optimize_table_order::find_best_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>prefix_rowcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>found_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>ref_depend_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>used_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the best index to do 'ref' access on for a table. </p>
<p>The best index chosen using the following priority list 1) A clustered primary key with equality predicates on all keyparts is always chosen. 2) A non nullable unique index with equality predicates on all keyparts is preferred over a non-unique index, nullable unique index or unique index where there are some keyparts without equality predicates. 3) Otherwise, the index with best cost estimate is chosen.</p>
<p>As a side-effect, bound_keyparts/read_cost/fanout is set for the first Key_use of every considered key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>the table to be joined by the function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td>set of tables not included in the partial plan yet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>the index in join-&gt;position[] where 'tab' is added to the partial plan. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prefix_rowcount</td><td>estimate for the number of records returned by the partial plan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found_condition</td><td>whether or not there exists a condition that filters away rows for this table. Always true when the function finds a usable 'ref' access, but also if it finds a condition that is not usable by 'ref' access, e.g. is there is an index covering (a,b) and there is a condition only on 'b'. Note that all dependent tables for the condition in question must be in the plan prefix for this to be 'true'. Unmodified if no relevant condition is found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ref_depend_map</td><td>tables the best ref access depends on. Unmodified if no 'ref' access is found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">used_key_parts</td><td>Number of keyparts 'ref' access uses. Unmodified if no 'ref' access is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to Key_use for the index with best 'ref' access, NULL if no 'ref' access method is found. </dd></dl>

</div>
</div>
<a id="gaba76f383cbe1dccc7c7a6facaf1fe6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba76f383cbe1dccc7c7a6facaf1fe6b8">&#9670;&nbsp;</a></span>fix_semijoin_strategies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::fix_semijoin_strategies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix semi-join strategies for the picked join order. </p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>Fix semi-join strategies for the picked join order. This is a step that needs to be done right after we have fixed the join order. What we do here is switch join's semi-join strategy description from backward-based to forwards based.</p>
<p>When join optimization is in progress, we re-consider semi-join strategies after we've added another table. Here's an illustration. Suppose the join optimization is underway:</p>
<p>1) ot1 it1 it2 sjX &ndash; looking at (ot1, it1, it2) join prefix, we decide to use semi-join strategy sjX.</p>
<p>2) ot1 it1 it2 ot2 sjX sjY &ndash; Having added table ot2, we now may consider another semi-join strategy and decide to use a different strategy sjY. Note that the record of sjX has remained under it2. That is necessary because we need to be able to get back to (ot1, it1, it2) join prefix. what makes things even worse is that there are cases where the choice of sjY changes the way we should access it2.</p>
<p>3) [ot1 it1 it2 ot2 ot3] sjX sjY &ndash; This means that after join optimization is finished, semi-join info should be read right-to-left (while nearly all plan refinement functions, EXPLAIN, etc proceed from left to right)</p>
<p>This function does the needed reversal, making it possible to read the join and semi-join order from left to right. </p>

</div>
</div>
<a id="gaec27fb1ea26091c151bc56ae9f416b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec27fb1ea26091c151bc56ae9f416b08">&#9670;&nbsp;</a></span>get_bound_sj_equalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> get_bound_sj_equalities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>not_available_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmap of bound semi-join equalities. </p>
<p>If we consider (oe1, .. oeN) IN (SELECT ie1, .. ieN) then ieK=oeK is called sj-equality. If ieK or oeK depends only on tables available before 'tab' in this plan, then such equality is called "bound".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>table </td></tr>
    <tr><td class="paramname">not_available_tables</td><td>bitmap of not-available tables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga945145266f4a865c166692aea42818ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga945145266f4a865c166692aea42818ed">&#9670;&nbsp;</a></span>get_partial_join_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_partial_join_cost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cost_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rowcount_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a cost of given partial join order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>Join to use. <code>positions</code> holds the partial join order </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n_tables</td><td>Number of tables in the partial join order </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cost_arg</td><td>Store read time here </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rowcount_arg</td><td>Store record count here</td></tr>
  </table>
  </dd>
</dl>
<p>This is needed for semi-join materialization code. The idea is that we detect sj-materialization after we've put all sj-inner tables into the join prefix</p>
<p>prefix-tables semi-join-inner-tables tN ^&ndash;we're here</p>
<p>and we'll need to get the cost of prefix-tables prefix again. </p>

</div>
</div>
<a id="ga1d0e0e4bba8f362f8b3c60cfb2736559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0e0e4bba8f362f8b3c60cfb2736559">&#9670;&nbsp;</a></span>greedy_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::greedy_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a good, possibly optimal, query execution plan (QEP) by a greedy search. </p>
<p>The search procedure uses a hybrid greedy/exhaustive search with controlled exhaustiveness. The search is performed in N = card(remaining_tables) steps. Each step evaluates how promising is each of the unoptimized tables, selects the most promising table, and extends the current partial QEP with that table. Currenly the most 'promising' table is the one with least expensive extension.\</p>
<p>There are two extreme cases:</p><ol type="1">
<li>When (card(remaining_tables) &lt; search_depth), the estimate finds the best complete continuation of the partial QEP. This continuation can be used directly as a result of the search.</li>
<li>When (search_depth == 1) the 'best_extension_by_limited_search' consideres the extension of the current QEP with each of the remaining unoptimized tables.</li>
</ol>
<p>All other cases are in-between these two extremes. Thus the parameter 'search_depth' controlls the exhaustiveness of the search. The higher the value, the longer the optimizaton time and possibly the better the resulting plan. The lower the value, the fewer alternative plans are estimated, but the more likely to get a bad QEP.</p>
<p>All intermediate and final results of the procedure are stored in 'join':</p><ul>
<li>join-&gt;positions : modified for every partial QEP that is explored</li>
<li>join-&gt;best_positions: modified for the current best complete QEP</li>
<li>join-&gt;best_read : modified for the current best complete QEP</li>
<li>join-&gt;best_ref : might be partially reordered</li>
</ul>
<p>The final optimal plan is stored in 'join-&gt;best_positions', and its corresponding cost in 'join-&gt;best_read'.</p>
<dl class="section note"><dt>Note</dt><dd>The following pseudocode describes the algorithm of 'greedy_search':</dd></dl>
<div class="fragment"><div class="line">procedure <a class="code" href="group__Query__Planner.html#ga1d0e0e4bba8f362f8b3c60cfb2736559">greedy_search</a></div><div class="line">input: remaining_tables</div><div class="line">output: pplan;</div><div class="line">{</div><div class="line">  pplan = &lt;&gt;;</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    (t, a) = best_extension(pplan, remaining_tables);</div><div class="line">    pplan = concat(pplan, (t, a));</div><div class="line">    remaining_tables = remaining_tables - t;</div><div class="line">  } <span class="keywordflow">while</span> (remaining_tables != {})</div><div class="line">  <span class="keywordflow">return</span> pplan;</div><div class="line">}</div></div><!-- fragment --><p> where 'best_extension' is a placeholder for a procedure that selects the most "promising" of all tables in 'remaining_tables'. Currently this estimate is performed by calling 'best_extension_by_limited_search' to evaluate all extensions of the current QEP of size 'search_depth', thus the complexity of 'greedy_search' mainly depends on that of 'best_extension_by_limited_search'.</p>
<dl class="section user"><dt></dt><dd>If 'best_extension()' == 'best_extension_by_limited_search()', then the worst-case complexity of this algorithm is &lt;= O(N*N^search_depth/search_depth). When serch_depth &gt;= N, then the complexity of greedy_search is O(N!). 'N' is the number of 'non eq_ref' tables + 'eq_ref groups' which normally are considerable less than total numbers of tables in the query.</dd></dl>
<dl class="section user"><dt></dt><dd>In the future, 'greedy_search' might be extended to support other implementations of 'best_extension'.</dd></dl>
<dl class="section user"><dt></dt><dd><code>search_depth</code> from Optimize_table_order controls the exhaustiveness of the search, and <code>prune_level</code> controls the pruning heuristics that should be applied during search.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>set of tables not included into the partial plan yet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>

</div>
</div>
<a id="gaabc697b97e535ae45b31fc3e65b11ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc697b97e535ae45b31fc3e65b11ce5">&#9670;&nbsp;</a></span>lateral_derived_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Optimize_table_order::lateral_derived_cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>prefix_rowcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCost__model__server.html">Cost_model_server</a> *&#160;</td>
          <td class="paramname"><em>cost_model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If table is a lateral derived table, calculates the "cost of
materialization", which is the cost of a single materialization (available in the DT's underlying JOIN final plan) multiplied by the number of rows output by the last-in-plan table which DT references (available in a POSITION structure). </p>
<p>For example if plan is t1 (outputs 2 rows) - t2 (outputs 20 rows) - dt and dt's definition references only t1, we multiply by 2, not by 20. This cost is divided by the number of times the DT will be read (20, here), to provide a number which best_access_path() can add to best_read_cost. </p>

</div>
</div>
<a id="ga2f81044d8b2b8a2af2a3325bf58f6f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f81044d8b2b8a2af2a3325bf58f6f69">&#9670;&nbsp;</a></span>max_part_bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> max_part_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad4471d2dbc1e6a0c471c56c950ab7cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4471d2dbc1e6a0c471c56c950ab7cac">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Join_tab_compare_default::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>jt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>jt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Less than" comparison function object used to compare two JOIN_TAB objects based on a number of factors in this order: </p>
<ul>
<li>table before another table that depends on it (straight join, outer join etc), then</li>
<li>table before another table that depends on it to use a key as access method, then</li>
<li>table with smallest number of records first, then</li>
<li>the table with lowest-value pointer (i.e., the one located in the lowest memory address) first.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jt1</td><td>first JOIN_TAB object </td></tr>
    <tr><td class="paramname">jt2</td><td>second JOIN_TAB object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The order relation implemented by Join_tab_compare_default is not transitive, i.e. it is possible to choose a, b and c such that (a &lt; b) &amp;&amp; (b &lt; c) but (c &lt; a). This is the case in the following example:</dd></dl>
<p>a: dependent = &lt;none&gt; found_records = 3 b: dependent = &lt;none&gt; found_records = 4 c: dependent = b found_records = 2</p>
<p>a &lt; b: because a has fewer records b &lt; c: because c depends on b (e.g outer join dependency) c &lt; a: because c has fewer records</p>
<p>This implies that the result of a sort using the relation implemented by Join_tab_compare_default () depends on the order in which elements are compared, i.e. the result is implementation-specific.</p>
<dl class="section return"><dt>Returns</dt><dd>true if jt1 is smaller than jt2, false otherwise </dd></dl>

</div>
</div>
<a id="gae4eb4a2a802676363d5079335af9106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4eb4a2a802676363d5079335af9106d">&#9670;&nbsp;</a></span>optimize_straight_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::optimize_straight_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>join_tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the best ways to access the tables in a query without reordering them. </p>
<p>Find the best access paths for each query table and compute their costs according to their order in the array 'join-&gt;best_ref' (thus without reordering the join tables). The function calls sequentially 'best_access_path' for each table in the query to select the best table access method. The final optimal plan is stored in the array 'join-&gt;best_positions', and the corresponding cost in 'join-&gt;best_read'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tables</td><td>set of the tables in the query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can be applied to:<ul>
<li>queries with STRAIGHT_JOIN</li>
<li>internally to compute the cost of an arbitrary QEP </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Thus 'optimize_straight_join' can be used at any stage of the query optimization process to finalize a QEP as it is. </dd></dl>
<p>If many plans have identical cost, which one will be used depends on how compiler optimizes floating-point calculations. this fix adds repeatability to the optimizer. (Similar code in best_extension_by_li...)</p>

</div>
</div>
<a id="ga42f852eb43f8bc7a538dad8571f9b36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f852eb43f8bc7a538dad8571f9b36f">&#9670;&nbsp;</a></span>prev_record_reads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double prev_record_reads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>found_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga632cc5e05186538f3f511bb4c83e413e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga632cc5e05186538f3f511bb4c83e413e">&#9670;&nbsp;</a></span>secondary_engine_handlerton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structhandlerton.html">handlerton</a>* secondary_engine_handlerton </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the handlerton of the secondary engine that will execute the current statement, or nullptr if a secondary engine is not used. </p>

</div>
</div>
<a id="ga107b06a43541ee7398f271e802aaa27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga107b06a43541ee7398f271e802aaa27a">&#9670;&nbsp;</a></span>semijoin_dupsweedout_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::semijoin_dupsweedout_access_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>first_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>last_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find best access paths for semi-join DuplicateWeedout strategy and calculate rowcount and cost based on these. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">first_tab</td><td>The first tab to calculate access paths for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">last_tab</td><td>The last tab to calculate access paths for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<p>Notice that new best access paths need not be calculated. The proper access path information is already in join-&gt;positions, because DuplicateWeedout can handle any join buffering strategy. The only action performed by this function is to calculate output rowcount, and an updated cost estimate.</p>
<p>The cost estimate is based on performing a join over the involved tables, but we must also add the cost of creating and populating the temporary table used for duplicate removal, and the cost of doing lookups against this table. </p>
<p>Some times, some outer fanout is "absorbed" into the inner fanout. In this case, we should make a better estimate for outer_fanout that is used to calculate the output rowcount. If we have inner table(s) before an outer table, there are dependencies between these tables. The fanout for the outer table is not a good estimate for the final number of rows from the weedout execution, therefore we convert some of the inner fanout into an outer fanout, limited to the number of possible rows in the outer table.</p>

</div>
</div>
<a id="gace3c9edffdbb4ac2a34132ab34c5e410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3c9edffdbb4ac2a34132ab34c5e410">&#9670;&nbsp;</a></span>semijoin_firstmatch_loosescan_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::semijoin_firstmatch_loosescan_access_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>first_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>last_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>loosescan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find best access paths for semi-join FirstMatch or LooseScan strategy and calculate rowcount and cost based on these. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">first_tab</td><td>The first tab to calculate access paths for, this is always a semi-join inner table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">last_tab</td><td>The last tab to calculate access paths for, always a semi-join inner table for FirstMatch, may be inner or outer for LooseScan. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td>Bitmap of tables that are not in the [0...last_tab] join prefix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">loosescan</td><td>If true, use LooseScan strategy, otherwise FirstMatch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if strategy selection successful, false otherwise.</dd></dl>
<p>Calculate best access paths for the tables of a semi-join FirstMatch or LooseScan strategy, given the order of tables provided in join-&gt;positions (or join-&gt;best_positions when calculating the cost of a final plan). Calculate estimated cost and rowcount for this plan. Given a join prefix [0; ... first_tab-1], change the access to the tables in the range [first_tab; last_tab] according to the constraints set by the relevant semi-join strategy. Those constraints are:</p>
<ul>
<li>For the LooseScan strategy, join buffering can be used for the outer tables following the last inner table.</li>
<li>For the FirstMatch strategy, join buffering can be used if there is a single inner table in the semi-join nest.</li>
</ul>
<p>For FirstMatch, the handled range of tables may be a mix of inner tables and non-dependent outer tables. The first and last table in the handled range are always inner tables. For LooseScan, the handled range can be a mix of inner tables and dependent and non-dependent outer tables. The first table is always an inner table.</p>
<p>Depending on member 'got_final_plan', the function uses and updates access path data in join-&gt;best_positions, otherwise uses join-&gt;positions and updates a local buffer. </p>

</div>
</div>
<a id="gac0107529f7577410e85d151cd359778e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0107529f7577410e85d151cd359778e">&#9670;&nbsp;</a></span>semijoin_loosescan_fill_driving_table_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Optimize_table_order::semijoin_loosescan_fill_driving_table_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prefix_rowcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a POSITION object of the driving table of a semi-join LooseScan range, with the cheapest access path. </p>
<p>This function was created by copying the code from best_access_path, and then eliminating everything which isn't related to semi-join LooseScan.</p>
<p>Preconditions:</p><ol type="1">
<li>Those checked by advance_sj_state(), ensuring that 'tab' is a valid LooseScan candidate.</li>
<li>This function uses the members 'bound_keyparts', 'cost' and 'records' of each Key_use; thus best_access_path () must have been called, for this table, with the current join prefix, so that the members are up to date.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>the driving table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td>set of tables not included in the partial plan yet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>the index in join-&gt;position[] where 'tab' is added to the partial plan. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prefix_rowcount</td><td>estimate for the number of records returned by the partial plan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>If return code is 'true': table access path that uses loosescan</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it found a loosescan access path for this table. </dd></dl>

</div>
</div>
<a id="gac0e9baa19f09976372ae2ed2c19d5a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0e9baa19f09976372ae2ed2c19d5a7d">&#9670;&nbsp;</a></span>semijoin_mat_lookup_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::semijoin_mat_lookup_access_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>last_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sjm_nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find best access paths for semi-join MaterializeLookup strategy. </p>
<p>and calculate rowcount and cost based on these.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">last_inner</td><td>Index of the last inner table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sjm_nest</td><td>Pointer to semi-join nest for inner tables </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<p>All outer tables may use join buffering, so there is no need to recalculate access paths nor costs for these. Add cost of materialization and scanning the materialized table to the costs of accessing the outer tables. </p>

</div>
</div>
<a id="ga32406fd2c6934703eddb9131f42b51cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32406fd2c6934703eddb9131f42b51cc">&#9670;&nbsp;</a></span>semijoin_mat_scan_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::semijoin_mat_scan_access_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>last_inner_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>last_outer_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sjm_nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find best access paths for semi-join MaterializeScan strategy and calculate rowcount and cost based on these. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">last_inner_tab</td><td>The last tab in the set of inner tables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">last_outer_tab</td><td>The last tab in the set of outer tables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td>Bitmap of tables that are not in the join prefix including the inner and outer tables processed here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sjm_nest</td><td>Pointer to semi-join nest for inner tables </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<p>Calculate best access paths for the outer tables of the MaterializeScan semi-join strategy. All outer tables may use join buffering. The prefix row count is adjusted with the estimated number of rows in the materialized tables, before taking into consideration the rows contributed by the outer tables. </p>

</div>
</div>
<a id="gaf51edd4249ea43d69718f9754c9422fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf51edd4249ea43d69718f9754c9422fd">&#9670;&nbsp;</a></span>semijoin_order_allows_materialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int semijoin_order_allows_materialization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a semijoin materialization strategy is allowed for the current (semi)join table order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join object </td></tr>
    <tr><td class="paramname">remaining_tables</td><td>Tables that have not yet been added to the join plan </td></tr>
    <tr><td class="paramname">tab</td><td>Join_tab of the table being considered </td></tr>
    <tr><td class="paramname">idx</td><td>Index in join-&gt;position[] with Join_tab "tab"</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SJ_OPT_NONE</td><td>- Materialization not applicable </td></tr>
    <tr><td class="paramname">SJ_OPT_MATERIALIZE_LOOKUP</td><td>- Materialization with lookup applicable </td></tr>
    <tr><td class="paramname">SJ_OPT_MATERIALIZE_SCAN</td><td>- Materialization with scan applicable</td></tr>
  </table>
  </dd>
</dl>
<p>The function checks applicability of both MaterializeLookup and MaterializeScan strategies. No checking is made until "tab" is pointing to the last inner table of a semijoin nest that can be executed using materialization - for all other cases SJ_OPT_NONE is returned.</p>
<p>MaterializeLookup and MaterializeScan are both applicable in the following two cases:</p>
<ol type="1">
<li>There are no correlated outer tables, or</li>
<li>There are correlated outer tables within the prefix only.</li>
</ol>
<p>In this case, MaterializeLookup is returned based on a heuristic decision. </p>

</div>
</div>
<a id="ga287945c7b5b4a7419bb032390c634fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287945c7b5b4a7419bb032390c634fe5">&#9670;&nbsp;</a></span>trace_plan_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trace_plan_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>excluded_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to write the current plan's prefix to the optimizer trace. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
