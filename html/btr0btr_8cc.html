<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/btr/btr0btr.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('btr0btr_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0btr.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The B-tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0pcur_8h_source.html">btr0pcur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0stats_8h_source.html">buf0stats.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0sysspace_8h_source.html">fsp0sysspace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="gis0geo_8h_source.html">gis0geo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="gis0rtree_8h_source.html">gis0rtree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0new_8h_source.html">ut0new.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9a7b333362dba21f0eb6daa9f099c65b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a9a7b333362dba21f0eb6daa9f099c65b">btr_page_get_father_node_ptr</a>(of,  heap,  cur,  mtr)</td></tr>
<tr class="separator:a9a7b333362dba21f0eb6daa9f099c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb291c0fe0b0ff90c1f06cbf228dac5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a1eb291c0fe0b0ff90c1f06cbf228dac5">btr_page_get_father_node_ptr_for_validate</a>(of,  heap,  cur,  mtr)</td></tr>
<tr class="separator:a1eb291c0fe0b0ff90c1f06cbf228dac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d84cafbd50734c76f7fa98b2de216b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ae6d84cafbd50734c76f7fa98b2de216b">btr_level_list_remove</a>(space,  page_size,  <a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>,  <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>,  mtr)&#160;&#160;&#160;<a class="el" href="btr0btr_8cc.html#a06973981866c030ce12bdf893e000345">btr_level_list_remove_func</a>(space, page_size, <a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, mtr)</td></tr>
<tr class="memdesc:ae6d84cafbd50734c76f7fa98b2de216b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a page from the level list of pages.  <a href="#ae6d84cafbd50734c76f7fa98b2de216b">More...</a><br /></td></tr>
<tr class="separator:ae6d84cafbd50734c76f7fa98b2de216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a812577be2df7cba3aead5d16e988b14f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a812577be2df7cba3aead5d16e988b14f">btr_can_merge_with_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, <a class="el" href="structbuf__block__t.html">buf_block_t</a> **merge_block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a812577be2df7cba3aead5d16e988b14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the page in the cursor can be merged with given page.  <a href="#a812577be2df7cba3aead5d16e988b14f">More...</a><br /></td></tr>
<tr class="separator:a812577be2df7cba3aead5d16e988b14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad9cada00c117d6f550724e4cf9c107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a1ad9cada00c117d6f550724e4cf9c107">btr_corruption_report</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a1ad9cada00c117d6f550724e4cf9c107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report that an index page is corrupted.  <a href="#a1ad9cada00c117d6f550724e4cf9c107">More...</a><br /></td></tr>
<tr class="separator:a1ad9cada00c117d6f550724e4cf9c107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd1295c03b53daf3008ad4859e2cab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aedd1295c03b53daf3008ad4859e2cab8">btr_root_block_get</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint mode, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aedd1295c03b53daf3008ad4859e2cab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root node of a tree and x- or s-latches it.  <a href="#aedd1295c03b53daf3008ad4859e2cab8">More...</a><br /></td></tr>
<tr class="separator:aedd1295c03b53daf3008ad4859e2cab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ea96c431b04a3bc2944e7e22eadb35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa0ea96c431b04a3bc2944e7e22eadb35">btr_root_get</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa0ea96c431b04a3bc2944e7e22eadb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root node of a tree and sx-latches it for segment access.  <a href="#aa0ea96c431b04a3bc2944e7e22eadb35">More...</a><br /></td></tr>
<tr class="separator:aa0ea96c431b04a3bc2944e7e22eadb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3b94ce40c2202dd2678f5fda28e4e"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#af6f3b94ce40c2202dd2678f5fda28e4e">btr_height_get</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af6f3b94ce40c2202dd2678f5fda28e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the B-tree (the level of the root, when the leaf level is assumed to be 0).  <a href="#af6f3b94ce40c2202dd2678f5fda28e4e">More...</a><br /></td></tr>
<tr class="separator:af6f3b94ce40c2202dd2678f5fda28e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4b78e796c99d908e4b50c8349ebf2c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a6a4b78e796c99d908e4b50c8349ebf2c">btr_root_fseg_adjust_on_import</a> (<a class="el" href="fsp0types_8h.html#ac30356c590b728068c1b3685bb7535f8">fseg_header_t</a> *seg_header, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a6a4b78e796c99d908e4b50c8349ebf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a file segment header within a B-tree root page and updates the segment header space id.  <a href="#a6a4b78e796c99d908e4b50c8349ebf2c">More...</a><br /></td></tr>
<tr class="separator:a6a4b78e796c99d908e4b50c8349ebf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147370fa0331bbfa2534ff64b077830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a4147370fa0331bbfa2534ff64b077830">btr_root_adjust_on_import</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a4147370fa0331bbfa2534ff64b077830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and adjusts the root node of a tree during IMPORT TABLESPACE.  <a href="#a4147370fa0331bbfa2534ff64b077830">More...</a><br /></td></tr>
<tr class="separator:a4147370fa0331bbfa2534ff64b077830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0eab34f77f8475935b6683d95c22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ab8b0eab34f77f8475935b6683d95c22e">btr_page_create</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab8b0eab34f77f8475935b6683d95c22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new index page (not the root, and also not used in page reorganization).  <a href="#ab8b0eab34f77f8475935b6683d95c22e">More...</a><br /></td></tr>
<tr class="separator:ab8b0eab34f77f8475935b6683d95c22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95bf5ca68b072c40ed669b891d6fbdc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ac95bf5ca68b072c40ed669b891d6fbdc">btr_page_alloc_for_ibuf</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac95bf5ca68b072c40ed669b891d6fbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new file page to be used in an ibuf tree.  <a href="#ac95bf5ca68b072c40ed669b891d6fbdc">More...</a><br /></td></tr>
<tr class="separator:ac95bf5ca68b072c40ed669b891d6fbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3795e0c3c87ba9e2c44af0d7f08c578d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a3795e0c3c87ba9e2c44af0d7f08c578d">btr_page_alloc_low</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> hint_page_no, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> file_direction, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structmtr__t.html">mtr_t</a> *init_mtr)</td></tr>
<tr class="memdesc:a3795e0c3c87ba9e2c44af0d7f08c578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new file page to be used in an index tree.  <a href="#a3795e0c3c87ba9e2c44af0d7f08c578d">More...</a><br /></td></tr>
<tr class="separator:a3795e0c3c87ba9e2c44af0d7f08c578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b6e143b4d70a1656c1f9110ebc62a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a56b6e143b4d70a1656c1f9110ebc62a1">btr_page_alloc</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> hint_page_no, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> file_direction, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structmtr__t.html">mtr_t</a> *init_mtr)</td></tr>
<tr class="memdesc:a56b6e143b4d70a1656c1f9110ebc62a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new file page to be used in an index tree.  <a href="#a56b6e143b4d70a1656c1f9110ebc62a1">More...</a><br /></td></tr>
<tr class="separator:a56b6e143b4d70a1656c1f9110ebc62a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e65306550a56feffb3904a9c619778"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a79e65306550a56feffb3904a9c619778">btr_get_size</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a79e65306550a56feffb3904a9c619778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pages in a B-tree.  <a href="#a79e65306550a56feffb3904a9c619778">More...</a><br /></td></tr>
<tr class="separator:a79e65306550a56feffb3904a9c619778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77f1439ec7f9cb150e381f265b17cbc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa77f1439ec7f9cb150e381f265b17cbc">btr_page_free_for_ibuf</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa77f1439ec7f9cb150e381f265b17cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a page used in an ibuf tree.  <a href="#aa77f1439ec7f9cb150e381f265b17cbc">More...</a><br /></td></tr>
<tr class="separator:aa77f1439ec7f9cb150e381f265b17cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444dc4bd2155c2ea85dea09bf5c78931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a444dc4bd2155c2ea85dea09bf5c78931">btr_page_free_low</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a444dc4bd2155c2ea85dea09bf5c78931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a file page used in an index tree.  <a href="#a444dc4bd2155c2ea85dea09bf5c78931">More...</a><br /></td></tr>
<tr class="separator:a444dc4bd2155c2ea85dea09bf5c78931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b6c9643b6c0950f74c5926291e66fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#af3b6c9643b6c0950f74c5926291e66fd">btr_page_free</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af3b6c9643b6c0950f74c5926291e66fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a file page used in an index tree.  <a href="#af3b6c9643b6c0950f74c5926291e66fd">More...</a><br /></td></tr>
<tr class="separator:af3b6c9643b6c0950f74c5926291e66fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1750952584e7f7bad8a0983ef20be48e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a1750952584e7f7bad8a0983ef20be48e">btr_node_ptr_set_child_page_no</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const ulint *offsets, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a1750952584e7f7bad8a0983ef20be48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the child node file address in a node pointer.  <a href="#a1750952584e7f7bad8a0983ef20be48e">More...</a><br /></td></tr>
<tr class="separator:a1750952584e7f7bad8a0983ef20be48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afbb437814c69cc94937013cb4f879c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a2afbb437814c69cc94937013cb4f879c">btr_node_ptr_get_child</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *node_ptr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a> type)</td></tr>
<tr class="memdesc:a2afbb437814c69cc94937013cb4f879c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the child page of a node pointer and sx-latches it.  <a href="#a2afbb437814c69cc94937013cb4f879c">More...</a><br /></td></tr>
<tr class="separator:a2afbb437814c69cc94937013cb4f879c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea0b90ccc89cc7ecc8ef13cc3876231"><td class="memItemLeft" align="right" valign="top">static ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#afea0b90ccc89cc7ecc8ef13cc3876231">btr_page_get_father_node_ptr_func</a> (ulint *offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint latch_mode, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:afea0b90ccc89cc7ecc8ef13cc3876231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper level node pointer to a page.  <a href="#afea0b90ccc89cc7ecc8ef13cc3876231">More...</a><br /></td></tr>
<tr class="separator:afea0b90ccc89cc7ecc8ef13cc3876231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3932d4dbf34d80e117f38e776c5fce"><td class="memItemLeft" align="right" valign="top">static ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aff3932d4dbf34d80e117f38e776c5fce">btr_page_get_father_block</a> (ulint *offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memdesc:aff3932d4dbf34d80e117f38e776c5fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper level node pointer to a page.  <a href="#aff3932d4dbf34d80e117f38e776c5fce">More...</a><br /></td></tr>
<tr class="separator:aff3932d4dbf34d80e117f38e776c5fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7ce1bf5f89f0be26a4fb11d989bde"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#adcc7ce1bf5f89f0be26a4fb11d989bde">btr_page_get_father</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memdesc:adcc7ce1bf5f89f0be26a4fb11d989bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks to the upper level node pointer to a page.  <a href="#adcc7ce1bf5f89f0be26a4fb11d989bde">More...</a><br /></td></tr>
<tr class="separator:adcc7ce1bf5f89f0be26a4fb11d989bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c73338c7e6b5dafc608a03728dc33e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a44c73338c7e6b5dafc608a03728dc33e">btr_free_root</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a44c73338c7e6b5dafc608a03728dc33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a B-tree root page.  <a href="#a44c73338c7e6b5dafc608a03728dc33e">More...</a><br /></td></tr>
<tr class="separator:a44c73338c7e6b5dafc608a03728dc33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efaceff4278cced6d2d4d67d6376c7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a4efaceff4278cced6d2d4d67d6376c7a">btr_free_root_invalidate</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a4efaceff4278cced6d2d4d67d6376c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate an index root page so that btr_free_root_check() will not find it.  <a href="#a4efaceff4278cced6d2d4d67d6376c7a">More...</a><br /></td></tr>
<tr class="separator:a4efaceff4278cced6d2d4d67d6376c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8afe850fa95aeaaddf1d984f1fb28be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ab8afe850fa95aeaaddf1d984f1fb28be">btr_free_root_check</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a> index_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab8afe850fa95aeaaddf1d984f1fb28be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to free a B-tree.  <a href="#ab8afe850fa95aeaaddf1d984f1fb28be">More...</a><br /></td></tr>
<tr class="separator:ab8afe850fa95aeaaddf1d984f1fb28be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c675c012fdbf24ab0f4d81dd16d1ac"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a08c675c012fdbf24ab0f4d81dd16d1ac">btr_create</a> (ulint type, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a> index_id, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a08c675c012fdbf24ab0f4d81dd16d1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the root node for a new index tree.  <a href="#a08c675c012fdbf24ab0f4d81dd16d1ac">More...</a><br /></td></tr>
<tr class="separator:a08c675c012fdbf24ab0f4d81dd16d1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35125cc3ea4edd6fa5f44f657f8f315e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a35125cc3ea4edd6fa5f44f657f8f315e">btr_free_but_not_root</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="mtr0types_8h.html#a84bed98f1f44be6de72e9486e75ce3f9">mtr_log_t</a> log_mode)</td></tr>
<tr class="memdesc:a35125cc3ea4edd6fa5f44f657f8f315e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a B-tree except the root page.  <a href="#a35125cc3ea4edd6fa5f44f657f8f315e">More...</a><br /></td></tr>
<tr class="separator:a35125cc3ea4edd6fa5f44f657f8f315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0d34be2b0c8e2b14490bd1a3e507c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a1b0d34be2b0c8e2b14490bd1a3e507c1">btr_free_if_exists</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a> index_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a1b0d34be2b0c8e2b14490bd1a3e507c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a persistent index tree if it exists.  <a href="#a1b0d34be2b0c8e2b14490bd1a3e507c1">More...</a><br /></td></tr>
<tr class="separator:a1b0d34be2b0c8e2b14490bd1a3e507c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193fcd2b57ae443bdeb7d72fa98cd40e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a193fcd2b57ae443bdeb7d72fa98cd40e">btr_free</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size)</td></tr>
<tr class="memdesc:a193fcd2b57ae443bdeb7d72fa98cd40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an index tree in a temporary tablespace.  <a href="#a193fcd2b57ae443bdeb7d72fa98cd40e">More...</a><br /></td></tr>
<tr class="separator:a193fcd2b57ae443bdeb7d72fa98cd40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d21d2a6fa315b6aef46ee926f98ceae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a0d21d2a6fa315b6aef46ee926f98ceae">btr_truncate</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a0d21d2a6fa315b6aef46ee926f98ceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate an index tree.  <a href="#a0d21d2a6fa315b6aef46ee926f98ceae">More...</a><br /></td></tr>
<tr class="separator:a0d21d2a6fa315b6aef46ee926f98ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adbc37056b85a4b15d771e526602792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5adbc37056b85a4b15d771e526602792">btr_truncate_recover</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a5adbc37056b85a4b15d771e526602792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovery function for btr_truncate.  <a href="#a5adbc37056b85a4b15d771e526602792">More...</a><br /></td></tr>
<tr class="separator:a5adbc37056b85a4b15d771e526602792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41fefade013636c0ff53fef29c29e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa41fefade013636c0ff53fef29c29e3c">btr_page_reorganize_low</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> recovery, ulint z_level, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa41fefade013636c0ff53fef29c29e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganizes an index page.  <a href="#aa41fefade013636c0ff53fef29c29e3c">More...</a><br /></td></tr>
<tr class="separator:aa41fefade013636c0ff53fef29c29e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdb4a7570a5165fc58008381a367079"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a6bdb4a7570a5165fc58008381a367079">btr_page_reorganize_block</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> recovery, ulint z_level, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a6bdb4a7570a5165fc58008381a367079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganizes an index page.  <a href="#a6bdb4a7570a5165fc58008381a367079">More...</a><br /></td></tr>
<tr class="separator:a6bdb4a7570a5165fc58008381a367079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21abcd4da4bc353f9a2b855a79450490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a21abcd4da4bc353f9a2b855a79450490">btr_page_reorganize</a> (<a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a21abcd4da4bc353f9a2b855a79450490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganizes an index page.  <a href="#a21abcd4da4bc353f9a2b855a79450490">More...</a><br /></td></tr>
<tr class="separator:a21abcd4da4bc353f9a2b855a79450490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6387b234b3e7ebc7c8bc1a8d023e587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#af6387b234b3e7ebc7c8bc1a8d023e587">btr_parse_page_reorganize</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> compressed, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af6387b234b3e7ebc7c8bc1a8d023e587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a redo log record of reorganizing a page.  <a href="#af6387b234b3e7ebc7c8bc1a8d023e587">More...</a><br /></td></tr>
<tr class="separator:af6387b234b3e7ebc7c8bc1a8d023e587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a2e070bba36d2e557fa7e1761a8ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a356a2e070bba36d2e557fa7e1761a8ab">btr_page_empty</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a356a2e070bba36d2e557fa7e1761a8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties an index page.  <a href="#a356a2e070bba36d2e557fa7e1761a8ab">More...</a><br /></td></tr>
<tr class="separator:a356a2e070bba36d2e557fa7e1761a8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dbcd9ec49055114b55b9b4e50c43a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ad4dbcd9ec49055114b55b9b4e50c43a1">btr_root_raise_and_insert</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ad4dbcd9ec49055114b55b9b4e50c43a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes tree one level higher by splitting the root, and inserts the tuple.  <a href="#ad4dbcd9ec49055114b55b9b4e50c43a1">More...</a><br /></td></tr>
<tr class="separator:ad4dbcd9ec49055114b55b9b4e50c43a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9814eaf18cf608e29cb25cc24b1aa766"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a9814eaf18cf608e29cb25cc24b1aa766">btr_page_get_split_rec_to_left</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **split_rec)</td></tr>
<tr class="memdesc:a9814eaf18cf608e29cb25cc24b1aa766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides if the page should be split at the convergence point of inserts converging to the left.  <a href="#a9814eaf18cf608e29cb25cc24b1aa766">More...</a><br /></td></tr>
<tr class="separator:a9814eaf18cf608e29cb25cc24b1aa766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dc7dce0944faaeaa433b5d611b8d11"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a28dc7dce0944faaeaa433b5d611b8d11">btr_page_get_split_rec_to_right</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **split_rec)</td></tr>
<tr class="memdesc:a28dc7dce0944faaeaa433b5d611b8d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides if the page should be split at the convergence point of inserts converging to the right.  <a href="#a28dc7dce0944faaeaa433b5d611b8d11">More...</a><br /></td></tr>
<tr class="separator:a28dc7dce0944faaeaa433b5d611b8d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09c044e71a6e5d33ba9f9c9f1381469"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ac09c044e71a6e5d33ba9f9c9f1381469">btr_page_get_split_rec</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:ac09c044e71a6e5d33ba9f9c9f1381469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a split record such that the tuple will certainly fit on its half-page when the split is performed.  <a href="#ac09c044e71a6e5d33ba9f9c9f1381469">More...</a><br /></td></tr>
<tr class="separator:ac09c044e71a6e5d33ba9f9c9f1381469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81618a8a52fbda1e43f558c180f9695"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ac81618a8a52fbda1e43f558c180f9695">btr_page_insert_fits</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *split_rec, ulint **offsets, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap)</td></tr>
<tr class="memdesc:ac81618a8a52fbda1e43f558c180f9695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the insert fits on the appropriate half-page with the chosen split_rec.  <a href="#ac81618a8a52fbda1e43f558c180f9695">More...</a><br /></td></tr>
<tr class="separator:ac81618a8a52fbda1e43f558c180f9695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a13ed2995588a23441f93237aa2843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a18a13ed2995588a23441f93237aa2843">btr_insert_on_non_leaf_level_func</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a18a13ed2995588a23441f93237aa2843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a data tuple to a tree on a non-leaf level.  <a href="#a18a13ed2995588a23441f93237aa2843">More...</a><br /></td></tr>
<tr class="separator:a18a13ed2995588a23441f93237aa2843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0907db3ff75da8b88a673790ba8a9588"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a0907db3ff75da8b88a673790ba8a9588">btr_attach_half_pages</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *split_rec, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, ulint direction, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a0907db3ff75da8b88a673790ba8a9588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the halves of an index page on the appropriate level in an index tree.  <a href="#a0907db3ff75da8b88a673790ba8a9588">More...</a><br /></td></tr>
<tr class="separator:a0907db3ff75da8b88a673790ba8a9588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb93aaf7dbddcb67ab79461a96e30d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5eb93aaf7dbddcb67ab79461a96e30d1">btr_page_tuple_smaller</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint **offsets, ulint n_uniq, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap)</td></tr>
<tr class="memdesc:a5eb93aaf7dbddcb67ab79461a96e30d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a tuple is smaller than any record on the page.  <a href="#a5eb93aaf7dbddcb67ab79461a96e30d1">More...</a><br /></td></tr>
<tr class="separator:a5eb93aaf7dbddcb67ab79461a96e30d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b375be4e7b6f7aa0a1b820a1e884f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ad2b375be4e7b6f7aa0a1b820a1e884f8">btr_insert_into_right_sibling</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ad2b375be4e7b6f7aa0a1b820a1e884f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the tuple into the right sibling page, if the cursor is at the end of a page.  <a href="#ad2b375be4e7b6f7aa0a1b820a1e884f8">More...</a><br /></td></tr>
<tr class="separator:ad2b375be4e7b6f7aa0a1b820a1e884f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41424f75ebce380f498a411829d22c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a41424f75ebce380f498a411829d22c48">btr_page_split_and_insert</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a41424f75ebce380f498a411829d22c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits an index page to halves and inserts the tuple.  <a href="#a41424f75ebce380f498a411829d22c48">More...</a><br /></td></tr>
<tr class="separator:a41424f75ebce380f498a411829d22c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06973981866c030ce12bdf893e000345"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a06973981866c030ce12bdf893e000345">btr_level_list_remove_func</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a06973981866c030ce12bdf893e000345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a page from the level list of pages.  <a href="#a06973981866c030ce12bdf893e000345">More...</a><br /></td></tr>
<tr class="separator:a06973981866c030ce12bdf893e000345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b385b20bbe4374df2f79550d580570"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ae8b385b20bbe4374df2f79550d580570">btr_set_min_rec_mark_log</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="mtr0types_8h.html#a11a0f116bed9e1c33900d379901595d1">mlog_id_t</a> type, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae8b385b20bbe4374df2f79550d580570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the redo log record for setting an index record as the predefined minimum record.  <a href="#ae8b385b20bbe4374df2f79550d580570">More...</a><br /></td></tr>
<tr class="separator:ae8b385b20bbe4374df2f79550d580570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b38ae3a4b9a9d41758c1d7a989d426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a76b38ae3a4b9a9d41758c1d7a989d426">btr_parse_set_min_rec_mark</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, ulint comp, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a76b38ae3a4b9a9d41758c1d7a989d426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the redo log record for setting an index record as the predefined minimum record.  <a href="#a76b38ae3a4b9a9d41758c1d7a989d426">More...</a><br /></td></tr>
<tr class="separator:a76b38ae3a4b9a9d41758c1d7a989d426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4330cef72fbfbb638446103baddd5c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ac4330cef72fbfbb638446103baddd5c0">btr_set_min_rec_mark</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac4330cef72fbfbb638446103baddd5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a record as the predefined minimum record.  <a href="#ac4330cef72fbfbb638446103baddd5c0">More...</a><br /></td></tr>
<tr class="separator:ac4330cef72fbfbb638446103baddd5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900f501e4015c67b08fc4f58e5f704df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a900f501e4015c67b08fc4f58e5f704df">btr_node_ptr_delete</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a900f501e4015c67b08fc4f58e5f704df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes on the upper level the node pointer to a page.  <a href="#a900f501e4015c67b08fc4f58e5f704df">More...</a><br /></td></tr>
<tr class="separator:a900f501e4015c67b08fc4f58e5f704df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24f869553390e4ae34621c1fc1f930b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ab24f869553390e4ae34621c1fc1f930b">btr_lift_page_up</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab24f869553390e4ae34621c1fc1f930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If page is the only on its level, this function moves its records to the father page, thus reducing the tree height.  <a href="#ab24f869553390e4ae34621c1fc1f930b">More...</a><br /></td></tr>
<tr class="separator:ab24f869553390e4ae34621c1fc1f930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a4adfc9b6b2aac22fef42be5d75235"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa8a4adfc9b6b2aac22fef42be5d75235">btr_compress</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ibool adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa8a4adfc9b6b2aac22fef42be5d75235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to merge the page first to the left immediate brother if such a brother exists, and the node pointers to the current page and to the brother reside on the same page.  <a href="#aa8a4adfc9b6b2aac22fef42be5d75235">More...</a><br /></td></tr>
<tr class="separator:aa8a4adfc9b6b2aac22fef42be5d75235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b0935bbe094292342ae9351919101e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa0b0935bbe094292342ae9351919101e">btr_discard_only_page_on_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa0b0935bbe094292342ae9351919101e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards a page that is the only page on its level.  <a href="#aa0b0935bbe094292342ae9351919101e">More...</a><br /></td></tr>
<tr class="separator:aa0b0935bbe094292342ae9351919101e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22a428cb7087e01af9c80a814e4fcfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ad22a428cb7087e01af9c80a814e4fcfb">btr_discard_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ad22a428cb7087e01af9c80a814e4fcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards a page from a B-tree.  <a href="#ad22a428cb7087e01af9c80a814e4fcfb">More...</a><br /></td></tr>
<tr class="separator:ad22a428cb7087e01af9c80a814e4fcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98340cedd4876607365ac140c3c9549"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#af98340cedd4876607365ac140c3c9549">btr_check_node_ptr</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af98340cedd4876607365ac140c3c9549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the node pointer to a page is appropriate.  <a href="#af98340cedd4876607365ac140c3c9549">More...</a><br /></td></tr>
<tr class="separator:af98340cedd4876607365ac140c3c9549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70adcf6bbce7b319642aa3a3955519"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a3c70adcf6bbce7b319642aa3a3955519">btr_index_rec_validate_report</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a3c70adcf6bbce7b319642aa3a3955519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display identification information for a record.  <a href="#a3c70adcf6bbce7b319642aa3a3955519">More...</a><br /></td></tr>
<tr class="separator:a3c70adcf6bbce7b319642aa3a3955519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e281cd01a4261bf7f681c49cc6ef2"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a031e281cd01a4261bf7f681c49cc6ef2">btr_index_rec_validate</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ibool dump_on_error)</td></tr>
<tr class="memdesc:a031e281cd01a4261bf7f681c49cc6ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the size and number of fields in a record based on the definition of the index.  <a href="#a031e281cd01a4261bf7f681c49cc6ef2">More...</a><br /></td></tr>
<tr class="separator:a031e281cd01a4261bf7f681c49cc6ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce16f83edead92058fc37477d742c58"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a9ce16f83edead92058fc37477d742c58">btr_index_page_validate</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a9ce16f83edead92058fc37477d742c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the size and number of fields in records based on the definition of the index.  <a href="#a9ce16f83edead92058fc37477d742c58">More...</a><br /></td></tr>
<tr class="separator:a9ce16f83edead92058fc37477d742c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc2e5603db7d844425d09e00b91299"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#afbcc2e5603db7d844425d09e00b91299">btr_validate_report1</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:afbcc2e5603db7d844425d09e00b91299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an error on one page of an index tree.  <a href="#afbcc2e5603db7d844425d09e00b91299">More...</a><br /></td></tr>
<tr class="separator:afbcc2e5603db7d844425d09e00b91299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201f40a474ab44ea3f6cc69885424dd2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a201f40a474ab44ea3f6cc69885424dd2">btr_validate_report2</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block1, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block2)</td></tr>
<tr class="memdesc:a201f40a474ab44ea3f6cc69885424dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an error on two pages of an index tree.  <a href="#a201f40a474ab44ea3f6cc69885424dd2">More...</a><br /></td></tr>
<tr class="separator:a201f40a474ab44ea3f6cc69885424dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf244e30008a4bd118a5159eb083b30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#afbf244e30008a4bd118a5159eb083b30">btr_validate_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint level, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lockout)</td></tr>
<tr class="memdesc:afbf244e30008a4bd118a5159eb083b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates index tree level.  <a href="#afbf244e30008a4bd118a5159eb083b30">More...</a><br /></td></tr>
<tr class="separator:afbf244e30008a4bd118a5159eb083b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589972caf439c8bca22b80ecce8aa296"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a589972caf439c8bca22b80ecce8aa296">btr_validate_spatial_index</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a589972caf439c8bca22b80ecce8aa296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an index level validation of spaital index tree.  <a href="#a589972caf439c8bca22b80ecce8aa296">More...</a><br /></td></tr>
<tr class="separator:a589972caf439c8bca22b80ecce8aa296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85fb82a7c6060cfa8f1ced5a610615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a2a85fb82a7c6060cfa8f1ced5a610615">btr_validate_index</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lockout)</td></tr>
<tr class="memdesc:a2a85fb82a7c6060cfa8f1ced5a610615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the consistency of an index tree.  <a href="#a2a85fb82a7c6060cfa8f1ced5a610615">More...</a><br /></td></tr>
<tr class="separator:a2a85fb82a7c6060cfa8f1ced5a610615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c26b7f127e4d1ae18852189d487595"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a63c26b7f127e4d1ae18852189d487595">btr_sdi_create</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a63c26b7f127e4d1ae18852189d487595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an SDI Index.  <a href="#a63c26b7f127e4d1ae18852189d487595">More...</a><br /></td></tr>
<tr class="separator:a63c26b7f127e4d1ae18852189d487595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98f3838f331835474a95ffe18d0aae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ab98f3838f331835474a95ffe18d0aae8">btr_sdi_create_index</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_locked)</td></tr>
<tr class="memdesc:ab98f3838f331835474a95ffe18d0aae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates SDI index and stores the root page numbers in page 1 &amp; 2.  <a href="#ab98f3838f331835474a95ffe18d0aae8">More...</a><br /></td></tr>
<tr class="separator:ab98f3838f331835474a95ffe18d0aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6f0e8e504ea8fc8b59b97d69a465a3f1"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a6f0e8e504ea8fc8b59b97d69a465a3f1">BTR_FREED_INDEX_ID</a> = 0</td></tr>
<tr class="memdesc:a6f0e8e504ea8fc8b59b97d69a465a3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">PAGE_INDEX_ID value for freed index B-trees.  <a href="#a6f0e8e504ea8fc8b59b97d69a465a3f1">More...</a><br /></td></tr>
<tr class="separator:a6f0e8e504ea8fc8b59b97d69a465a3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The B-tree. </p>
<p>Created 6/2/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae6d84cafbd50734c76f7fa98b2de216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d84cafbd50734c76f7fa98b2de216b">&#9670;&nbsp;</a></span>btr_level_list_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_level_list_remove</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">space, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="btr0btr_8cc.html#a06973981866c030ce12bdf893e000345">btr_level_list_remove_func</a>(space, page_size, <a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, mtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a page from the level list of pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Space where removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page</td><td>Page to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a7b333362dba21f0eb6daa9f099c65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7b333362dba21f0eb6daa9f099c65b">&#9670;&nbsp;</a></span>btr_page_get_father_node_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_page_get_father_node_ptr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">of, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cur, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="btr0btr_8cc.html#afea0b90ccc89cc7ecc8ef13cc3876231">btr_page_get_father_node_ptr_func</a>(of, heap, cur, <a class="code" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a0c6b78ce4b3f3ff9e86bbe769841aa6b">BTR_CONT_MODIFY_TREE</a>, \</div><div class="line">                                    __FILE__, __LINE__, mtr)</div><div class="ttc" id="btr0btr_8h_html_a2e8da6642741a4294e1de2a0ff5f2dc8a0c6b78ce4b3f3ff9e86bbe769841aa6b"><div class="ttname"><a href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a0c6b78ce4b3f3ff9e86bbe769841aa6b">BTR_CONT_MODIFY_TREE</a></div><div class="ttdoc">Continue modifying the entire B-tree. </div><div class="ttdef"><b>Definition:</b> btr0btr.h:71</div></div>
<div class="ttc" id="btr0btr_8cc_html_afea0b90ccc89cc7ecc8ef13cc3876231"><div class="ttname"><a href="btr0btr_8cc.html#afea0b90ccc89cc7ecc8ef13cc3876231">btr_page_get_father_node_ptr_func</a></div><div class="ttdeci">static ulint * btr_page_get_father_node_ptr_func(ulint *offsets, mem_heap_t *heap, btr_cur_t *cursor, ulint latch_mode, const char *file, ulint line, mtr_t *mtr)</div><div class="ttdoc">Returns the upper level node pointer to a page. </div><div class="ttdef"><b>Definition:</b> btr0btr.cc:637</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1eb291c0fe0b0ff90c1f06cbf228dac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb291c0fe0b0ff90c1f06cbf228dac5">&#9670;&nbsp;</a></span>btr_page_get_father_node_ptr_for_validate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_page_get_father_node_ptr_for_validate</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">of, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cur, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="btr0btr_8cc.html#afea0b90ccc89cc7ecc8ef13cc3876231">btr_page_get_father_node_ptr_func</a>(of, heap, cur, <a class="code" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8ac226de21f5121a5fe7bc94ed50229ff2">BTR_CONT_SEARCH_TREE</a>, \</div><div class="line">                                    __FILE__, __LINE__, mtr)</div><div class="ttc" id="btr0btr_8cc_html_afea0b90ccc89cc7ecc8ef13cc3876231"><div class="ttname"><a href="btr0btr_8cc.html#afea0b90ccc89cc7ecc8ef13cc3876231">btr_page_get_father_node_ptr_func</a></div><div class="ttdeci">static ulint * btr_page_get_father_node_ptr_func(ulint *offsets, mem_heap_t *heap, btr_cur_t *cursor, ulint latch_mode, const char *file, ulint line, mtr_t *mtr)</div><div class="ttdoc">Returns the upper level node pointer to a page. </div><div class="ttdef"><b>Definition:</b> btr0btr.cc:637</div></div>
<div class="ttc" id="btr0btr_8h_html_a2e8da6642741a4294e1de2a0ff5f2dc8ac226de21f5121a5fe7bc94ed50229ff2"><div class="ttname"><a href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8ac226de21f5121a5fe7bc94ed50229ff2">BTR_CONT_SEARCH_TREE</a></div><div class="ttdoc">Continue searching the entire B-tree. </div><div class="ttdef"><b>Definition:</b> btr0btr.h:79</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0907db3ff75da8b88a673790ba8a9588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0907db3ff75da8b88a673790ba8a9588">&#9670;&nbsp;</a></span>btr_attach_half_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_attach_half_pages </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>split_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches the halves of an index page on the appropriate level in an index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree </td></tr>
    <tr><td class="paramname">block</td><td>in/out: page to be split </td></tr>
    <tr><td class="paramname">split_rec</td><td>in: first record on upper half page </td></tr>
    <tr><td class="paramname">new_block</td><td>in/out: the new half page </td></tr>
    <tr><td class="paramname">direction</td><td>in: FSP_UP or FSP_DOWN </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a812577be2df7cba3aead5d16e988b14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812577be2df7cba3aead5d16e988b14f">&#9670;&nbsp;</a></span>btr_can_merge_with_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_can_merge_with_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> **&#160;</td>
          <td class="paramname"><em>merge_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the page in the cursor can be merged with given page. </p>
<p>If necessary, re-organize the merge_page. </p><dl class="section return"><dt>Returns</dt><dd>true if possible to merge. in: mini-transaction</dd></dl>
<p>If necessary, re-organize the merge_page. </p><dl class="section return"><dt>Returns</dt><dd>true if possible to merge. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the page to merge </td></tr>
    <tr><td class="paramname">page_no</td><td>in: a sibling page </td></tr>
    <tr><td class="paramname">merge_block</td><td>out: the merge block </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af98340cedd4876607365ac140c3c9549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98340cedd4876607365ac140c3c9549">&#9670;&nbsp;</a></span>btr_check_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_check_node_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the node pointer to a page is appropriate. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a4adfc9b6b2aac22fef42be5d75235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a4adfc9b6b2aac22fef42be5d75235">&#9670;&nbsp;</a></span>btr_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to merge the page first to the left immediate brother if such a brother exists, and the node pointers to the current page and to the brother reside on the same page. </p>
<p>If the left brother does not satisfy these conditions, looks at the right brother. If the page is the only one on that level lifts the records of the page to the father page, thus reducing the tree height. It is assumed that mtr holds an x-latch on the tree and on the page. If cursor is on the leaf level, mtr must also hold x-latches to the brothers, if they exist. </p><dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to merge or lift; the page must not be empty: when deleting records, use btr_discard_page() if the page would become empty </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ad9cada00c117d6f550724e4cf9c107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad9cada00c117d6f550724e4cf9c107">&#9670;&nbsp;</a></span>btr_corruption_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_corruption_report </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report that an index page is corrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: corrupted block </td></tr>
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08c675c012fdbf24ab0f4d81dd16d1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c675c012fdbf24ab0f4d81dd16d1ac">&#9670;&nbsp;</a></span>btr_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a>&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the root node for a new index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of the index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Space where created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_id</td><td>Index id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>page number of the created root </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FIL_NULL</td><td>if did not succeed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0b0935bbe094292342ae9351919101e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b0935bbe094292342ae9351919101e">&#9670;&nbsp;</a></span>btr_discard_only_page_on_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_discard_only_page_on_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards a page that is the only page on its level. </p>
<p>This will empty the whole B-tree, leaving just an empty root page. This function should never be reached, because btr_compress(), which is invoked in delete operations, calls btr_lift_page_up() to flatten the B-tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: page which is the only on its level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad22a428cb7087e01af9c80a814e4fcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22a428cb7087e01af9c80a814e4fcfb">&#9670;&nbsp;</a></span>btr_discard_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_discard_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards a page from a B-tree. </p>
<p>This is used to remove the last record from a B-tree page: the whole page must be removed at the same time. This cannot be used for the root page, which is allowed to be empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the page to discard: not on the root page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a193fcd2b57ae443bdeb7d72fa98cd40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193fcd2b57ae443bdeb7d72fa98cd40e">&#9670;&nbsp;</a></span>btr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_free </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an index tree in a temporary tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>root page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35125cc3ea4edd6fa5f44f657f8f315e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35125cc3ea4edd6fa5f44f657f8f315e">&#9670;&nbsp;</a></span>btr_free_but_not_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_free_but_not_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mtr0types_8h.html#a84bed98f1f44be6de72e9486e75ce3f9">mtr_log_t</a>&#160;</td>
          <td class="paramname"><em>log_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a B-tree except the root page. </p>
<p>The root page MUST be freed after this by calling btr_free_root. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>root page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_mode</td><td>mtr logging mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b0d34be2b0c8e2b14490bd1a3e507c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0d34be2b0c8e2b14490bd1a3e507c1">&#9670;&nbsp;</a></span>btr_free_if_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_free_if_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a>&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a persistent index tree if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Root page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_id</td><td>PAGE_INDEX_ID contents </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44c73338c7e6b5dafc608a03728dc33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c73338c7e6b5dafc608a03728dc33e">&#9670;&nbsp;</a></span>btr_free_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_free_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a B-tree root page. </p>
<p>btr_free_but_not_root() must already have been called. In a persistent tablespace, the caller must invoke fsp_init_file_page() before mtr.commit(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>Index root page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8afe850fa95aeaaddf1d984f1fb28be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8afe850fa95aeaaddf1d984f1fb28be">&#9670;&nbsp;</a></span>btr_free_root_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_free_root_check </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a>&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare to free a B-tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_id</td><td>PAGE_INDEX_ID contents </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root block, to invoke btr_free_but_not_root() and btr_free_root() </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if the page is no longer a matching B-tree page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4efaceff4278cced6d2d4d67d6376c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efaceff4278cced6d2d4d67d6376c7a">&#9670;&nbsp;</a></span>btr_free_root_invalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_free_root_invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate an index root page so that btr_free_root_check() will not find it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>Index root page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79e65306550a56feffb3904a9c619778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e65306550a56feffb3904a9c619778">&#9670;&nbsp;</a></span>btr_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of pages in a B-tree. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pages, or ULINT_UNDEFINED if the index is unavailable </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">flag</td><td>in: BTR_N_LEAF_PAGES or BTR_TOTAL_SIZE </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction where index is s-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6f3b94ce40c2202dd2678f5fda28e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f3b94ce40c2202dd2678f5fda28e4e">&#9670;&nbsp;</a></span>btr_height_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_height_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the height of the B-tree (the level of the root, when the leaf level is assumed to be 0). </p>
<p>The caller must hold an S or X latch on the index. </p><dl class="section return"><dt>Returns</dt><dd>tree height (level of the root) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ce16f83edead92058fc37477d742c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce16f83edead92058fc37477d742c58">&#9670;&nbsp;</a></span>btr_index_page_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool btr_index_page_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the size and number of fields in records based on the definition of the index. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a031e281cd01a4261bf7f681c49cc6ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e281cd01a4261bf7f681c49cc6ef2">&#9670;&nbsp;</a></span>btr_index_rec_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_index_rec_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dump_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the size and number of fields in a record based on the definition of the index. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">dump_on_error</td><td>in: TRUE if the function should print hex dump of record and page on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c70adcf6bbce7b319642aa3a3955519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c70adcf6bbce7b319642aa3a3955519">&#9670;&nbsp;</a></span>btr_index_rec_validate_report()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_index_rec_validate_report </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Display identification information for a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
    <tr><td class="paramname">rec</td><td>in: index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b375be4e7b6f7aa0a1b820a1e884f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b375be4e7b6f7aa0a1b820a1e884f8">&#9670;&nbsp;</a></span>btr_insert_into_right_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* btr_insert_into_right_sibling </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the tuple into the right sibling page, if the cursor is at the end of a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Undo logging and locking flags </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Cursor at which to insert; when the function succeeds, the cursor is positioned before the insert point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offsets</td><td>Offsets on inserted record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>Memory heap for allocating offsets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>Tuple to insert </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inserted record (first record on the right sibling page); the cursor will be positioned on the page infimum </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if the operation was not performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18a13ed2995588a23441f93237aa2843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a13ed2995588a23441f93237aa2843">&#9670;&nbsp;</a></span>btr_insert_on_non_leaf_level_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_insert_on_non_leaf_level_func </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a data tuple to a tree on a non-leaf level. </p>
<p>It is assumed that mtr holds an x-latch on the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: level, must be &gt; 0 </td></tr>
    <tr><td class="paramname">tuple</td><td>in: the record to be inserted </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06973981866c030ce12bdf893e000345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06973981866c030ce12bdf893e000345">&#9670;&nbsp;</a></span>btr_level_list_remove_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_level_list_remove_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a page from the level list of pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Space where removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page</td><td>Page to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24f869553390e4ae34621c1fc1f930b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24f869553390e4ae34621c1fc1f930b">&#9670;&nbsp;</a></span>btr_lift_page_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_lift_page_up </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If page is the only on its level, this function moves its records to the father page, thus reducing the tree height. </p>
<dl class="section return"><dt>Returns</dt><dd>father block </dd></dl>
<p>&lt; last used index in blocks[] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: page which is the only on its level; must not be empty: use btr_discard_only_page_on_level if the last record from the page should be removed </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a900f501e4015c67b08fc4f58e5f704df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900f501e4015c67b08fc4f58e5f704df">&#9670;&nbsp;</a></span>btr_node_ptr_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_node_ptr_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes on the upper level the node pointer to a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Page whose node pointer is deleted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2afbb437814c69cc94937013cb4f879c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afbb437814c69cc94937013cb4f879c">&#9670;&nbsp;</a></span>btr_node_ptr_get_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_node_ptr_get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574a0a61b228e5530d2c67679946b4bca4f2">RW_SX_LATCH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the child page of a node pointer and sx-latches it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>node pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>latch type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>child page, latched as per the type </dd></dl>

</div>
</div>
<a id="a1750952584e7f7bad8a0983ef20be48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1750952584e7f7bad8a0983ef20be48e">&#9670;&nbsp;</a></span>btr_node_ptr_set_child_page_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_node_ptr_set_child_page_no </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the child node file address in a node pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: node pointer record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">page_no</td><td>in: child node address </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b6e143b4d70a1656c1f9110ebc62a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b6e143b4d70a1656c1f9110ebc62a1">&#9670;&nbsp;</a></span>btr_page_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_page_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>hint_page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>file_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new file page to be used in an index tree. </p>
<p>NOTE: we assume that the caller has made the reservation for free extents! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint_page_no</td><td>Hint of a good page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_direction</td><td>Direction where a possible page split is made </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level where the page is placed in the tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction for the allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">init_mtr</td><td>Mini-transaction for x-latching and initializing the page </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr), returned block is not allocated nor initialized otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac95bf5ca68b072c40ed669b891d6fbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95bf5ca68b072c40ed669b891d6fbdc">&#9670;&nbsp;</a></span>btr_page_alloc_for_ibuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_page_alloc_for_ibuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new file page to be used in an ibuf tree. </p>
<p>Takes the page from the free list of the tree, which must contain pages! </p><dl class="section return"><dt>Returns</dt><dd>new allocated block, x-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3795e0c3c87ba9e2c44af0d7f08c578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3795e0c3c87ba9e2c44af0d7f08c578d">&#9670;&nbsp;</a></span>btr_page_alloc_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_page_alloc_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>hint_page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>file_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new file page to be used in an index tree. </p>
<p>NOTE: we assume that the caller has made the reservation for free extents! </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr), returned block is not allocated nor initialized otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">hint_page_no</td><td>in: hint of a good page </td></tr>
    <tr><td class="paramname">file_direction</td><td>in: direction where a possible page split is made </td></tr>
    <tr><td class="paramname">level</td><td>in: level where the page is placed in the tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction for the allocation </td></tr>
    <tr><td class="paramname">init_mtr</td><td>in/out: mtr or another mini-transaction in which the page should be initialized. If init_mtr!=mtr, but the page is already X-latched in mtr, do not initialize the page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8b0eab34f77f8475935b6683d95c22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b0eab34f77f8475935b6683d95c22e">&#9670;&nbsp;</a></span>btr_page_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_page_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new index page (not the root, and also not used in page reorganization). </p>
<dl class="section see"><dt>See also</dt><dd>btr_page_empty(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: page to be created </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: the B-tree level of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a356a2e070bba36d2e557fa7e1761a8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a2e070bba36d2e557fa7e1761a8ab">&#9670;&nbsp;</a></span>btr_page_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_page_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties an index page. </p>
<dl class="section see"><dt>See also</dt><dd>btr_page_create(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: page to be emptied </td></tr>
    <tr><td class="paramname">page_zip</td><td>out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">level</td><td>in: the B-tree level of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3b6c9643b6c0950f74c5926291e66fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b6c9643b6c0950f74c5926291e66fd">&#9670;&nbsp;</a></span>btr_page_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_page_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a file page used in an index tree. </p>
<p>NOTE: cannot free field external storage pages because the page must contain info on its level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77f1439ec7f9cb150e381f265b17cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77f1439ec7f9cb150e381f265b17cbc">&#9670;&nbsp;</a></span>btr_page_free_for_ibuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_page_free_for_ibuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a page used in an ibuf tree. </p>
<p>Puts the page to the free list of the ibuf tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a444dc4bd2155c2ea85dea09bf5c78931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444dc4bd2155c2ea85dea09bf5c78931">&#9670;&nbsp;</a></span>btr_page_free_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_page_free_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a file page used in an index tree. </p>
<p>Can be used also to (BLOB) external storage pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">level</td><td>in: page level (ULINT_UNDEFINED=BLOB) </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc7ce1bf5f89f0be26a4fb11d989bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc7ce1bf5f89f0be26a4fb11d989bde">&#9670;&nbsp;</a></span>btr_page_get_father()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_page_get_father </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeks to the upper level node pointer to a page. </p>
<p>It is assumed that mtr holds an x-latch on the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: b-tree index </td></tr>
    <tr><td class="paramname">block</td><td>in: child page in the index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
    <tr><td class="paramname">cursor</td><td>out: cursor on node pointer record, its page x-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff3932d4dbf34d80e117f38e776c5fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3932d4dbf34d80e117f38e776c5fce">&#9670;&nbsp;</a></span>btr_page_get_father_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint* btr_page_get_father_block </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the upper level node pointer to a page. </p>
<p>It is assumed that mtr holds an x-latch on the tree. </p><dl class="section return"><dt>Returns</dt><dd>rec_get_offsets() of the node pointer record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>in: work area for the return value </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap to use </td></tr>
    <tr><td class="paramname">index</td><td>in: b-tree index </td></tr>
    <tr><td class="paramname">block</td><td>in: child page in the index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
    <tr><td class="paramname">cursor</td><td>out: cursor on node pointer record, its page x-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afea0b90ccc89cc7ecc8ef13cc3876231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea0b90ccc89cc7ecc8ef13cc3876231">&#9670;&nbsp;</a></span>btr_page_get_father_node_ptr_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint* btr_page_get_father_node_ptr_func </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the upper level node pointer to a page. </p>
<p>It is assumed that mtr holds an sx-latch on the tree. </p><dl class="section return"><dt>Returns</dt><dd>rec_get_offsets() of the node pointer record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>in: work area for the return value </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap to use </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor pointing to user record, out: cursor on node pointer record, its page x-latched </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_CONT_MODIFY_TREE or BTR_CONT_SEARCH_TREE </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac09c044e71a6e5d33ba9f9c9f1381469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09c044e71a6e5d33ba9f9c9f1381469">&#9670;&nbsp;</a></span>btr_page_get_split_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* btr_page_get_split_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a split record such that the tuple will certainly fit on its half-page when the split is performed. </p>
<p>We assume in this function only that the cursor page has at least one user record. </p><dl class="section return"><dt>Returns</dt><dd>split record, or NULL if tuple will be the first record on the lower or upper half-page (determined by btr_page_tuple_smaller()) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which insert should be made </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9814eaf18cf608e29cb25cc24b1aa766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9814eaf18cf608e29cb25cc24b1aa766">&#9670;&nbsp;</a></span>btr_page_get_split_rec_to_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_page_get_split_rec_to_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides if the page should be split at the convergence point of inserts converging to the left. </p>
<p>Decides if the page should be split at the convergence point of inserts converging to left.</p>
<dl class="section return"><dt>Returns</dt><dd>true if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple to be inserted should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28dc7dce0944faaeaa433b5d611b8d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dc7dce0944faaeaa433b5d611b8d11">&#9670;&nbsp;</a></span>btr_page_get_split_rec_to_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_page_get_split_rec_to_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides if the page should be split at the convergence point of inserts converging to the right. </p>
<p>Decides if the page should be split at the convergence point of inserts converging to right.</p>
<dl class="section return"><dt>Returns</dt><dd>true if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple to be inserted should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac81618a8a52fbda1e43f558c180f9695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81618a8a52fbda1e43f558c180f9695">&#9670;&nbsp;</a></span>btr_page_insert_fits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_page_insert_fits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>split_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if the insert fits on the appropriate half-page with the chosen split_rec. </p>
<dl class="section return"><dt>Returns</dt><dd>true if fits </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which insert should be made </td></tr>
    <tr><td class="paramname">split_rec</td><td>in: suggestion for first record on upper half-page, or NULL if tuple to be inserted should be first </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets( split_rec, cursor-&gt;index); out: garbage </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">heap</td><td>in: temporary memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21abcd4da4bc353f9a2b855a79450490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21abcd4da4bc353f9a2b855a79450490">&#9670;&nbsp;</a></span>btr_page_reorganize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_page_reorganize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorganizes an index page. </p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking ibuf_reset_free_bits() before mtr_commit(). On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Page cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index tree of the page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bdb4a7570a5165fc58008381a367079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdb4a7570a5165fc58008381a367079">&#9670;&nbsp;</a></span>btr_page_reorganize_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_page_reorganize_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>z_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorganizes an index page. </p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking ibuf_reset_free_bits() before mtr_commit(). On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recovery</td><td>in: true if called in recovery: locks should not be updated, i.e., there cannot exist locks on the page, and a hash index should not be dropped: it cannot exist </td></tr>
    <tr><td class="paramname">z_level</td><td>in: compression level to be used if dealing with compressed page </td></tr>
    <tr><td class="paramname">block</td><td>in/out: B-tree page </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa41fefade013636c0ff53fef29c29e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41fefade013636c0ff53fef29c29e3c">&#9670;&nbsp;</a></span>btr_page_reorganize_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_page_reorganize_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>z_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorganizes an index page. </p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking ibuf_reset_free_bits() before mtr_commit(). On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recovery</td><td>in: true if called in recovery: locks should not be updated, i.e., there cannot exist locks on the page, and a hash index should not be dropped: it cannot exist </td></tr>
    <tr><td class="paramname">z_level</td><td>in: compression level to be used if dealing with compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41424f75ebce380f498a411829d22c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41424f75ebce380f498a411829d22c48">&#9670;&nbsp;</a></span>btr_page_split_and_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* btr_page_split_and_insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits an index page to halves and inserts the tuple. </p>
<p>It is assumed that mtr holds an x-latch to the index tree. NOTE: the tree x-latch is released within this function! NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space (2 pages) must be guaranteed to be available before this function is called. </p><dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5eb93aaf7dbddcb67ab79461a96e30d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb93aaf7dbddcb67ab79461a96e30d1">&#9670;&nbsp;</a></span>btr_page_tuple_smaller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_page_tuple_smaller </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_uniq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a tuple is smaller than any record on the page. </p>
<dl class="section return"><dt>Returns</dt><dd>true if smaller </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: b-tree cursor </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to consider </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: temporary storage </td></tr>
    <tr><td class="paramname">n_uniq</td><td>in: number of unique fields in the index page records </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: heap for offsets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6387b234b3e7ebc7c8bc1a8d023e587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6387b234b3e7ebc7c8bc1a8d023e587">&#9670;&nbsp;</a></span>btr_parse_page_reorganize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* btr_parse_page_reorganize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a redo log record of reorganizing a page. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">compressed</td><td>in: true if compressed page </td></tr>
    <tr><td class="paramname">block</td><td>in: page to be reorganized, or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76b38ae3a4b9a9d41758c1d7a989d426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b38ae3a4b9a9d41758c1d7a989d426">&#9670;&nbsp;</a></span>btr_parse_set_min_rec_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* btr_parse_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the redo log record for setting an index record as the predefined minimum record. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">comp</td><td>in: nonzero=compact page format </td></tr>
    <tr><td class="paramname">page</td><td>in: page or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4147370fa0331bbfa2534ff64b077830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147370fa0331bbfa2534ff64b077830">&#9670;&nbsp;</a></span>btr_root_adjust_on_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_root_adjust_on_import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and adjusts the root node of a tree during IMPORT TABLESPACE. </p>
<dl class="section return"><dt>Returns</dt><dd>error code, or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedd1295c03b53daf3008ad4859e2cab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd1295c03b53daf3008ad4859e2cab8">&#9670;&nbsp;</a></span>btr_root_block_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_root_block_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the root node of a tree and x- or s-latches it. </p>
<dl class="section return"><dt>Returns</dt><dd>root page, x- or s-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mode</td><td>in: either RW_S_LATCH or RW_X_LATCH </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a4b78e796c99d908e4b50c8349ebf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4b78e796c99d908e4b50c8349ebf2c">&#9670;&nbsp;</a></span>btr_root_fseg_adjust_on_import()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_root_fseg_adjust_on_import </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fsp0types_8h.html#ac30356c590b728068c1b3685bb7535f8">fseg_header_t</a> *&#160;</td>
          <td class="paramname"><em>seg_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks a file segment header within a B-tree root page and updates the segment header space id. </p>
<dl class="section return"><dt>Returns</dt><dd>true if valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_header</td><td>in/out: segment header </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">space</td><td>in: tablespace identifier </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0ea96c431b04a3bc2944e7e22eadb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ea96c431b04a3bc2944e7e22eadb35">&#9670;&nbsp;</a></span>btr_root_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* btr_root_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the root node of a tree and sx-latches it for segment access. </p>
<dl class="section return"><dt>Returns</dt><dd>root page, sx-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4dbcd9ec49055114b55b9b4e50c43a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dbcd9ec49055114b55b9b4e50c43a1">&#9670;&nbsp;</a></span>btr_root_raise_and_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* btr_root_raise_and_insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes tree one level higher by splitting the root, and inserts the tuple. </p>
<p>It is assumed that mtr contains an x-latch on the tree. NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space must be guaranteed to be available before this function is called. </p><dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert: must be on the root page; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63c26b7f127e4d1ae18852189d487595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c26b7f127e4d1ae18852189d487595">&#9670;&nbsp;</a></span>btr_sdi_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> btr_sdi_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an SDI Index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>Tablespace id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Size of page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>SDI table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root page number of the SDI index created or FIL_NULL on failure </dd></dl>

</div>
</div>
<a id="ab98f3838f331835474a95ffe18d0aae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98f3838f331835474a95ffe18d0aae8">&#9670;&nbsp;</a></span>btr_sdi_create_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_sdi_create_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dict_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates SDI index and stores the root page numbers in page 1 &amp; 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>tablespace id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dict_locked</td><td>true if dict_sys mutex is acquired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS on success, else DB_ERROR on failure </dd></dl>

</div>
</div>
<a id="ac4330cef72fbfbb638446103baddd5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4330cef72fbfbb638446103baddd5c0">&#9670;&nbsp;</a></span>btr_set_min_rec_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a record as the predefined minimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8b385b20bbe4374df2f79550d580570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b385b20bbe4374df2f79550d580570">&#9670;&nbsp;</a></span>btr_set_min_rec_mark_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_set_min_rec_mark_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mtr0types_8h.html#a11a0f116bed9e1c33900d379901595d1">mlog_id_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the redo log record for setting an index record as the predefined minimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">type</td><td>in: MLOG_COMP_REC_MIN_MARK or MLOG_REC_MIN_MARK </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d21d2a6fa315b6aef46ee926f98ceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d21d2a6fa315b6aef46ee926f98ceae">&#9670;&nbsp;</a></span>btr_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_truncate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate an index tree. </p>
<p>We just free all except the root. Currently, this function is only specific for clustered indexes and the only caller is DDTableBuffer which manages a table with only a clustered index. It is up to the caller to ensure atomicity and to ensure correct recovery by calling btr_truncate_recover(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5adbc37056b85a4b15d771e526602792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adbc37056b85a4b15d771e526602792">&#9670;&nbsp;</a></span>btr_truncate_recover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_truncate_recover </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recovery function for btr_truncate. </p>
<p>We will check if there is a crash during btr_truncate, if so, do recover it, if not, do nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a85fb82a7c6060cfa8f1ced5a610615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85fb82a7c6060cfa8f1ced5a610615">&#9670;&nbsp;</a></span>btr_validate_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_validate_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>lockout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the consistency of an index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction or NULL </td></tr>
    <tr><td class="paramname">lockout</td><td>in: true if X-latch index is intended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbf244e30008a4bd118a5159eb083b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf244e30008a4bd118a5159eb083b30">&#9670;&nbsp;</a></span>btr_validate_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_validate_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>lockout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates index tree level. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction or NULL </td></tr>
    <tr><td class="paramname">level</td><td>in: level number </td></tr>
    <tr><td class="paramname">lockout</td><td>in: true if X-latch index is intended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbcc2e5603db7d844425d09e00b91299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcc2e5603db7d844425d09e00b91299">&#9670;&nbsp;</a></span>btr_validate_report1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_validate_report1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report an error on one page of an index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: B-tree level </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a201f40a474ab44ea3f6cc69885424dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201f40a474ab44ea3f6cc69885424dd2">&#9670;&nbsp;</a></span>btr_validate_report2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_validate_report2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report an error on two pages of an index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: B-tree level </td></tr>
    <tr><td class="paramname">block1</td><td>in: first index page </td></tr>
    <tr><td class="paramname">block2</td><td>in: second index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a589972caf439c8bca22b80ecce8aa296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589972caf439c8bca22b80ecce8aa296">&#9670;&nbsp;</a></span>btr_validate_spatial_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_validate_spatial_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an index level validation of spaital index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>true if no error found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6f0e8e504ea8fc8b59b97d69a465a3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0e8e504ea8fc8b59b97d69a465a3f1">&#9670;&nbsp;</a></span>BTR_FREED_INDEX_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a> BTR_FREED_INDEX_ID = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PAGE_INDEX_ID value for freed index B-trees. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_f48f5f24c3af6e5b48618127168756b9.html">btr</a></li><li class="navelem"><a class="el" href="btr0btr_8cc.html">btr0btr.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
