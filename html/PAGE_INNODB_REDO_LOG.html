<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Innodb redo log</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PAGE_INNODB_REDO_LOG.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Innodb redo log </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sect_redo_log_general"></a>
General idea of redo log</h1>
<p>The redo log is a write ahead log of changes applied to contents of data pages. It provides durability for all changes applied to the pages. In case of crash, it is used to recover modifications to pages that were modified but have not been flushed to disk.</p>
<dl class="section note"><dt>Note</dt><dd>In case of clean shutdown, the redo log should be logically empty. This means that after the checkpoint lsn there should be no records to apply. However the log files still could contain some old data (which is not used during the recovery process).</dd></dl>
<p>Every change to content of a data page must be done through a mini-transaction (so called mtr - mtr_t), which in mtr_commit() writes all its log records to the redo log.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Normally these changes are performed using the mlog_write_ulint() or similar function. In some page-level operations, only a code number of a c-function and its parameters are written to the redo log, to reduce the size of the redo log. You should not add parameters to such functions (e.g. trx_undo_header_create(), trx_undo_insert_header_reuse()). You should not add functionality which can either change when compared to older versions, or which is dependent on data outside of the page being modified. Therefore all functions must implement self-contained page transformation and it should be unchanged if you don't have very essential reasons to change the log semantics or format.</dd></dl>
<p>Single mtr can cover changes to multiple pages. In case of crash, either the whole set of changes from a given mtr is recovered or none of the changes.</p>
<p>During life time of a mtr, a log of changes is collected inside an internal buffer of the mtr. It contains multiple log records, which describe changes applied to possibly different modified pages. When the mtr is committed, all the log records are written to the log buffer within a single group of the log records. Procedure:</p>
<ol type="1">
<li>Total number of data bytes of log records is calculated.</li>
<li>Space for the log records is reserved. Range of lsn values is assigned for a group of log records.</li>
<li>Log records are written to the reserved space in the log buffer.</li>
<li>Modified pages are marked as dirty and moved to flush lists. All the dirty pages are marked with the same range of lsn values.</li>
<li>Reserved space is closed.</li>
</ol>
<p>Background threads are responsible for writing of new changes in the log buffer to the log files. User threads that require durability for the logged records, have to wait until the log gets flushed up to the required point.</p>
<p>During recovery only complete groups of log records are recovered and applied. Example given, if we had rotation in a tree, which resulted in changes to three nodes (pages), we have a guarantee, that either the whole rotation is recovered or nothing, so we will not end up with a tree that has incorrect structure.</p>
<p>Consecutive bytes written to the redo log are enumerated by the lsn values. Every single byte written to the log buffer corresponds to current lsn increased by one.</p>
<p>Data in the redo log is structured in consecutive blocks of 512 bytes (<em>OS_FILE_LOG_BLOCK_SIZE</em>). Each block contains a header of 12 bytes (<em>LOG_BLOCK_HDR_SIZE</em>) and a footer of 4 bytes (<em>LOG_BLOCK_TRL_SIZE</em>). These extra bytes are also enumerated by lsn values. Whenever we refer to data bytes, we mean actual bytes of log records - not bytes of headers and footers of log blocks. The sequence of enumerated data bytes, is called the sn values. All headers and footers of log blocks are added within the log buffer, where data is actually stored in proper redo format.</p>
<p>When a user transaction commits, extra mtr is committed (related to undo log), and then user thread waits until the redo log is flushed up to the point, where log records of that mtr end.</p>
<p>When a dirty page is being flushed, a thread doing the flush, first needs to wait until the redo log gets flushed up to the newest modification of the page. Afterwards the page might be flushed. In case of crash, we might end up with the newest version of the page and without any earlier versions of the page. Then other pages, which potentially have not been flushed before the crash, need to be recovered to that version. This applies to: pages modified within the same group of log records, and pages modified within any earlier group of log records.</p>
<h1><a class="anchor" id="sect_redo_log_architecture"></a>
Architecture of redo log</h1>
<h2><a class="anchor" id="subsect_redo_log_data_layers"></a>
Data layers</h2>
<p>Redo log consists of following data layers:</p>
<ol type="1">
<li>Log files (typically 4 - 32 GB) - physical redo files that reside on the disk.</li>
<li>Log buffer (64 MB by default) - groups data to write to log files, formats data in proper way: include headers/footers of log blocks, calculates checksums, maintains boundaries of record groups.</li>
<li>Log recent written buffer (e.g. 4MB) - tracks recent writes to the log buffer. Allows to have concurrent writes to the log buffer and tracks up to which lsn all such writes have been already finished.</li>
<li>Log recent closed buffer (e.g. 4MB) - tracks for which recent writes, corresponding dirty pages have been already added to the flush lists. Allows to relax order in which dirty pages have to be added to the flush lists and tracks up to which lsn, all dirty pages have been added. This is required to not make checkpoint at lsn which is larger than oldest_modification of some dirty page, which still has not been added to the flush list (because user thread was scheduled out).</li>
<li>Log write ahead buffer (e.g. 4kB) - used to write ahead more bytes to the redo files, to avoid read-on-write problem. This buffer is also used when we need to write an incomplete log block, which might concurrently be receiving even more data from next user threads. In such case we first copy the incomplete block to the write ahead buffer.</li>
</ol>
<h2><a class="anchor" id="subsect_redo_log_general_rules"></a>
General rules</h2>
<ol type="1">
<li>User threads write their redo data only to the log buffer.</li>
<li>User threads write concurrently to the log buffer, without synchronization between each other.</li>
<li>The log recent written buffer is maintained to track concurrent writes.</li>
<li>Background log threads write and flush the log buffer to disk.</li>
<li>User threads do not touch log files. Background log threads are the only allowed to touch the log files.</li>
<li>User threads wait for the background threads when they need flushed redo.</li>
<li>Events per log block are exposed by redo log for users interested in waiting for the flushed redo.</li>
<li>Users can see up to which point log has been written / flushed.</li>
<li><p class="startli">User threads need to wait if there is no space in the log buffer.</p>
<p class="startli"><div class="diagraph">
<img src="dia_arch_writing.png" />
<div class="caption">
Writing to the redo log</div>
</div>
</p>
</li>
<li>User threads add dirty pages to flush lists in the relaxed order.</li>
<li>Order in which user threads reserve ranges of lsn values, order in which they write to the log buffer, and order in which they add dirty pages to flush lists, could all be three completely different orders.</li>
<li>User threads do not write checkpoints (are not allowed to touch log files).</li>
<li>Checkpoint is automatically written from time to time by a background thread.</li>
<li>User threads can request a forced write of checkpoint and wait.</li>
<li><p class="startli">User threads need to wait if there is no space in the log files.</p>
<p class="startli"><div class="diagraph">
<img src="dia_arch_deleting.png" />
<div class="caption">
Reclaiming space in the redo</div>
</div>
 log"</p>
</li>
<li>Well thought out and tested set of <em>MONITOR</em> counters is maintained and documented.</li>
<li>All settings are configurable through server variables, but the new server variables are hidden unless a special <em>EXPERIMENTAL</em> mode has been defined when running cmake.</li>
<li><p class="startli">All the new buffers could be resized dynamically during runtime. In practice, only size of the log buffer is accessible without the <em>EXPERIMENTAL</em> mode.</p>
<dl class="section note"><dt>Note</dt><dd>This is a functional change - the log buffer could be resized dynamically by users (also decreased).</dd></dl>
</li>
</ol>
<h1><a class="anchor" id="sect_redo_log_lsn_values"></a>
Glossary of lsn values</h1>
<p>Different fragments of head of the redo log are tracked by different values:</p><ul>
<li><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_write_lsn">log.write_lsn</a>,</li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_ready_for_write_lsn">log.buf_ready_for_write_lsn</a>,</li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_sn">log.sn</a>.</li>
</ul>
<p>Different fragments of the redo log's tail are tracked by different values:</p><ul>
<li><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_dirty_pages_added_up_to_lsn">subsect_redo_log_buf_dirty_pages_added_up_to_lsn</a>,</li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_available_for_checkpoint_lsn">subsect_redo_log_available_for_checkpoint_lsn</a>,</li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_last_checkpoint_lsn">log.last_checkpoint_lsn</a>.</li>
</ul>
<h2><a class="anchor" id="subsect_redo_log_write_lsn"></a>
log.write_lsn</h2>
<p>Up to this lsn we have written all data to log files. It's the beginning of the unwritten log buffer. Older bytes in the buffer are not required and might be overwritten in cyclic manner for lsn values larger by <em>log.buf_size</em>.</p>
<p>Value is updated by: <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_writer">log writer thread</a>.</p>
<h2><a class="anchor" id="subsect_redo_log_buf_ready_for_write_lsn"></a>
log.buf_ready_for_write_lsn</h2>
<p>Up to this lsn, all concurrent writes to log buffer have been finished. We don't need older part of the log recent-written buffer.</p>
<p>It obviously holds: </p><pre class="fragment">    log.buf_ready_for_write_lsn &gt;= log.write_lsn
</pre><p>Value is updated by: <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_writer">log writer thread</a>.</p>
<h2><a class="anchor" id="subsect_redo_log_flushed_to_disk_lsn"></a>
log.flushed_to_disk_lsn</h2>
<p>Up to this lsn, we have written and flushed data to log files.</p>
<p>It obviously holds: </p><pre class="fragment">    log.flushed_to_disk_lsn &lt;= log.write_lsn
</pre><p>Value is updated by: <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_flusher">log flusher thread</a>.</p>
<h2><a class="anchor" id="subsect_redo_log_sn"></a>
log.sn</h2>
<p>Corresponds to current lsn. Maximum assigned sn value (enumerates only data bytes).</p>
<p>It obviously holds: </p><pre class="fragment">    log.sn &gt;= log_translate_lsn_to_sn(log.buf_ready_for_write_lsn)
</pre><p>Value is updated by: user threads during reservation of space.</p>
<h2><a class="anchor" id="subsect_redo_log_buf_dirty_pages_added_up_to_lsn"></a>
subsect_redo_log_buf_dirty_pages_added_up_to_lsn</h2>
<p>log.buf_dirty_pages_added_up_to_lsn</p>
<p>Up to this lsn user threads have added all dirty pages to flush lists.</p>
<p>The redo log records are allowed to be deleted not further than up to this lsn. That's because there could be a page with <em>oldest_modification</em> smaller than the minimum <em>oldest_modification</em> available in flush lists. Note that such page is just about to be added to flush list by a user thread, but there is no mutex protecting access to the minimum <em>oldest_modification</em>, which would be acquired by the user thread before writing to redo log. Hence for any lsn greater than <em>buf_dirty_pages_added_up_to_lsn</em> we cannot trust that flush lists are complete and minimum calculated value (or its approximation) is valid.</p>
<dl class="section note"><dt>Note</dt><dd>Note that we do not delete redo log records physically, but we still can delete them logically by doing checkpoint at given lsn.</dd></dl>
<p>It holds (unless the log writer thread misses an update of the <a class="el" href="PAGE_INNODB_REDO_LOG.html#subsect_redo_log_buf_ready_for_write_lsn">log.buf_ready_for_write_lsn</a>): </p><pre class="fragment">    log.buf_dirty_pages_added_up_to_lsn &lt;= log.buf_ready_for_write_lsn.
</pre><h2><a class="anchor" id="subsect_redo_log_available_for_checkpoint_lsn"></a>
subsect_redo_log_available_for_checkpoint_lsn</h2>
<p>log.available_for_checkpoint_lsn</p>
<p>Up to this lsn all dirty pages have been flushed to disk. However, this value is not guaranteed to be the maximum such value. As insertion order to flush lists is relaxed, the buf_pool_get_oldest_modification_approx() returns modification time of some page that was inserted the earliest, it doesn't have to be the oldest modification though. However, the maximum difference between the first page in flush list, and one with the oldest modification lsn is limited by the number of entries in the log recent closed buffer.</p>
<p>That's why from result of buf_pool_get_oldest_modification_approx() size of the log recent closed buffer is subtracted. The result is used to update the lsn available for a next checkpoint.</p>
<p>This has impact on the redo format, because the checkpoint_lsn can now point to the middle of some group of log records (even to the middle of a single log record). Log files with such checkpoint are not recoverable by older versions of InnoDB by default.</p>
<p>Value is updated by: <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_checkpointer">log checkpointer thread</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_add_dirty_pages">Adding dirty pages to flush lists</a></dd></dl>
<h2><a class="anchor" id="subsect_redo_log_last_checkpoint_lsn"></a>
log.last_checkpoint_lsn</h2>
<p>Up to this lsn all dirty pages have been flushed to disk and the lsn value has been flushed to header of the first log file (<em>ib_logfile0</em>).</p>
<p>The lsn value points to place where recovery is supposed to start. Data bytes for smaller lsn values are not required and might be overwritten (log files are circular). One could consider them logically deleted.</p>
<p>Value is updated by: <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_checkpointer">log checkpointer thread</a>.</p>
<p>It holds: </p><pre class="fragment">    log.last_checkpoint_lsn
    &lt;= log.available_for_checkpoint_lsn
    &lt;= log.buf_dirty_pages_added_up_to_lsn.
</pre><p>Read more about redo log details:</p><ul>
<li><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html">Redo log buffer</a></li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html">Background redo log threads</a></li>
<li><a class="el" href="PAGE_INNODB_REDO_LOG_FORMAT.html">Format of redo log</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_STORAGE.html">Data Storage</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
