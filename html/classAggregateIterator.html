<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: AggregateIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classAggregateIterator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAggregateIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AggregateIterator Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Handles aggregation (typically used for GROUP BY) for the case where the rows are already properly grouped coming in, ie., all rows that are supposed to be part of the same group are adjacent in the input stream.  
 <a href="classAggregateIterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="composite__iterators_8h_source.html">composite_iterators.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AggregateIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAggregateIterator.png" usemap="#AggregateIterator_map" alt=""/>
  <map id="AggregateIterator_map" name="AggregateIterator_map">
<area href="classRowIterator.html" title="A context for reading through a single table using a chosen access method: index read, scan, etc, use of cache, etc. " alt="RowIterator" shape="rect" coords="0,0,111,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae21b34d2eb15e0721900abe7e5352a52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#ae21b34d2eb15e0721900abe7e5352a52">AggregateIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; source, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *temp_table_param, int output_slice, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> rollup)</td></tr>
<tr class="separator:ae21b34d2eb15e0721900abe7e5352a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa999babb48af75cb683d240b0f6c3791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#aa999babb48af75cb683d240b0f6c3791">Init</a> () override</td></tr>
<tr class="memdesc:aa999babb48af75cb683d240b0f6c3791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#aa999babb48af75cb683d240b0f6c3791">More...</a><br /></td></tr>
<tr class="separator:aa999babb48af75cb683d240b0f6c3791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3991cd698de121aaaa307577cbcac010"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a3991cd698de121aaaa307577cbcac010">Read</a> () override</td></tr>
<tr class="memdesc:a3991cd698de121aaaa307577cbcac010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single row.  <a href="#a3991cd698de121aaaa307577cbcac010">More...</a><br /></td></tr>
<tr class="separator:a3991cd698de121aaaa307577cbcac010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb01f76484eaa11e8d2a338f89ef1f3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#aeb01f76484eaa11e8d2a338f89ef1f3e">SetNullRowFlag</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_null_row) override</td></tr>
<tr class="memdesc:aeb01f76484eaa11e8d2a338f89ef1f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row).  <a href="#aeb01f76484eaa11e8d2a338f89ef1f3e">More...</a><br /></td></tr>
<tr class="separator:aeb01f76484eaa11e8d2a338f89ef1f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bff435252fd1b7bc787754f4465c6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a2bff435252fd1b7bc787754f4465c6ad">StartPSIBatchMode</a> () override</td></tr>
<tr class="memdesc:a2bff435252fd1b7bc787754f4465c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start performance schema batch mode, if supported (otherwise ignored).  <a href="#a2bff435252fd1b7bc787754f4465c6ad">More...</a><br /></td></tr>
<tr class="separator:a2bff435252fd1b7bc787754f4465c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc385de4b8dfbf68304a6233ee55c28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#acc385de4b8dfbf68304a6233ee55c28d">EndPSIBatchModeIfStarted</a> () override</td></tr>
<tr class="memdesc:acc385de4b8dfbf68304a6233ee55c28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends performance schema batch mode, if started.  <a href="#acc385de4b8dfbf68304a6233ee55c28d">More...</a><br /></td></tr>
<tr class="separator:acc385de4b8dfbf68304a6233ee55c28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1036a2a9187791fc58032cc34f142a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a1036a2a9187791fc58032cc34f142a90">UnlockRow</a> () override</td></tr>
<tr class="separator:a1036a2a9187791fc58032cc34f142a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a9e730a0c6722be2f9841fd6b7a3f6a52">RowIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>)</td></tr>
<tr class="separator:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a8778b8e93d01e1e47f0e98804882ea8e">~RowIterator</a> ()</td></tr>
<tr class="separator:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#acb75cd99708ea3f1d62b41c8072f1d96">TimingString</a> () const</td></tr>
<tr class="separator:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">real_iterator</a> ()</td></tr>
<tr class="memdesc:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this iterator is wrapping a different iterator (e.g.  <a href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">More...</a><br /></td></tr>
<tr class="separator:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#ad0baf633d8ed8803dc77c86a2c9faeda">real_iterator</a> () const</td></tr>
<tr class="separator:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a71d58e1dd49bc9c7bc03235cdc68669c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="classAggregateIterator.html#a71d58e1dd49bc9c7bc03235cdc68669ca379c0edcb72247caab3c457390de6dd6">READING_FIRST_ROW</a>, 
<a class="el" href="classAggregateIterator.html#a71d58e1dd49bc9c7bc03235cdc68669ca02e9388e37f45d6f104b1b9f631c8875">LAST_ROW_STARTED_NEW_GROUP</a>, 
<a class="el" href="classAggregateIterator.html#a71d58e1dd49bc9c7bc03235cdc68669cab2f9d83ead3d5a06a645039631b45479">READING_ROWS</a>, 
<a class="el" href="classAggregateIterator.html#a71d58e1dd49bc9c7bc03235cdc68669ca8de3d9b2e914bb1065c6999869592a65">OUTPUTTING_ROLLUP_ROWS</a>, 
<br />
&#160;&#160;<a class="el" href="classAggregateIterator.html#a71d58e1dd49bc9c7bc03235cdc68669ca9a3144234f38a99e1e708ae147335146">DONE_OUTPUTTING_ROWS</a>
<br />
 }</td></tr>
<tr class="separator:a71d58e1dd49bc9c7bc03235cdc68669c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acc366c86329cd262301c50244055233f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#acc366c86329cd262301c50244055233f">copy_sum_funcs</a> ()</td></tr>
<tr class="separator:acc366c86329cd262301c50244055233f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd3a5e05887cb645f5b652d8638652f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#aefd3a5e05887cb645f5b652d8638652f">SetRollupLevel</a> (int level)</td></tr>
<tr class="separator:aefd3a5e05887cb645f5b652d8638652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad18f208ea6c9c2a7f025f64697973c43"><td class="memItemLeft" align="right" valign="top">enum AggregateIterator:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#ad18f208ea6c9c2a7f025f64697973c43">m_state</a></td></tr>
<tr class="separator:ad18f208ea6c9c2a7f025f64697973c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00624d6060ffcef6060e586649bb803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#ab00624d6060ffcef6060e586649bb803">m_source</a></td></tr>
<tr class="separator:ab00624d6060ffcef6060e586649bb803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6144c182c93363814b6f1e7883aac456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a6144c182c93363814b6f1e7883aac456">m_join</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="memdesc:a6144c182c93363814b6f1e7883aac456"><td class="mdescLeft">&#160;</td><td class="mdescRight">The join we are part of.  <a href="#a6144c182c93363814b6f1e7883aac456">More...</a><br /></td></tr>
<tr class="separator:a6144c182c93363814b6f1e7883aac456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b927d8e118e2eeeabf1becdd2555c60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a0b927d8e118e2eeeabf1becdd2555c60">m_input_slice</a></td></tr>
<tr class="memdesc:a0b927d8e118e2eeeabf1becdd2555c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The slice of the fields we are reading from (see the class comment).  <a href="#a0b927d8e118e2eeeabf1becdd2555c60">More...</a><br /></td></tr>
<tr class="separator:a0b927d8e118e2eeeabf1becdd2555c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f195545b766527f6aa328c204a30f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#ab5f195545b766527f6aa328c204a30f5">m_output_slice</a></td></tr>
<tr class="memdesc:ab5f195545b766527f6aa328c204a30f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The slice of the fields we are outputting to. See the class comment.  <a href="#ab5f195545b766527f6aa328c204a30f5">More...</a><br /></td></tr>
<tr class="separator:ab5f195545b766527f6aa328c204a30f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dd90cf323e69d184628873b5bfc5a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a66dd90cf323e69d184628873b5bfc5a7">m_seen_eof</a></td></tr>
<tr class="memdesc:a66dd90cf323e69d184628873b5bfc5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we have seen the last input row.  <a href="#a66dd90cf323e69d184628873b5bfc5a7">More...</a><br /></td></tr>
<tr class="separator:a66dd90cf323e69d184628873b5bfc5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3f75b98ee9b61f9ea3ace7e3bbf3f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a9e3f75b98ee9b61f9ea3ace7e3bbf3f5">m_save_nullinfo</a></td></tr>
<tr class="memdesc:a9e3f75b98ee9b61f9ea3ace7e3bbf3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to save NULL information in the specific case where we have zero input rows.  <a href="#a9e3f75b98ee9b61f9ea3ace7e3bbf3f5">More...</a><br /></td></tr>
<tr class="separator:a9e3f75b98ee9b61f9ea3ace7e3bbf3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c5179eebd269c2e5b6f09faf58b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a240c5179eebd269c2e5b6f09faf58b62">m_temp_table_param</a></td></tr>
<tr class="memdesc:a240c5179eebd269c2e5b6f09faf58b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parameters for the temporary table we are materializing into, if any.  <a href="#a240c5179eebd269c2e5b6f09faf58b62">More...</a><br /></td></tr>
<tr class="separator:a240c5179eebd269c2e5b6f09faf58b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef69d1f598c81b5c2fe0dcb2fee646e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#acef69d1f598c81b5c2fe0dcb2fee646e">m_rollup</a></td></tr>
<tr class="memdesc:acef69d1f598c81b5c2fe0dcb2fee646e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is a rollup query.  <a href="#acef69d1f598c81b5c2fe0dcb2fee646e">More...</a><br /></td></tr>
<tr class="separator:acef69d1f598c81b5c2fe0dcb2fee646e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc00cb506f442577d7a322c6357c72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#af1dc00cb506f442577d7a322c6357c72">m_last_unchanged_group_item_idx</a></td></tr>
<tr class="memdesc:af1dc00cb506f442577d7a322c6357c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">For rollup: The index of the first group item that did <em>not</em> change when we last switched groups.  <a href="#af1dc00cb506f442577d7a322c6357c72">More...</a><br /></td></tr>
<tr class="separator:af1dc00cb506f442577d7a322c6357c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178f16953dcc008eae7ae99e18c9f0c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAggregateIterator.html#a178f16953dcc008eae7ae99e18c9f0c7">m_current_rollup_position</a></td></tr>
<tr class="memdesc:a178f16953dcc008eae7ae99e18c9f0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we are in state OUTPUTTING_ROLLUP_ROWS, where we are in the iteration.  <a href="#a178f16953dcc008eae7ae99e18c9f0c7">More...</a><br /></td></tr>
<tr class="separator:a178f16953dcc008eae7ae99e18c9f0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a> () const</td></tr>
<tr class="separator:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handles aggregation (typically used for GROUP BY) for the case where the rows are already properly grouped coming in, ie., all rows that are supposed to be part of the same group are adjacent in the input stream. </p>
<p>(This could be because they were sorted earlier, because we are scanning an index that already gives us the rows in a group-compatible order, or because there is no grouping.)</p>
<p>AggregateIterator is special in that it's one of the very few row iterators that actually change the shape of the rows; some columns are dropped as part of aggregation, others (the aggregates) are added. For this reason (and also because we need to make copies of the group expressions &ndash; see Read()), it conceptually always outputs to a temporary table. If we <em>are</em> outputting to a temporary table, that's not a problem &ndash; we take over responsibility for copying the group expressions from MaterializeIterator, which would otherwise do it.</p>
<p>However, if we are outputting directly to the user, we need somewhere to store the output. This is solved by abusing the slice system; since we only need to buffer a single row, we can set up just enough items in the REF_SLICE_ORDERED_GROUP_BY slice, so that it can hold a single row. This row is then used for our output, and we then switch to it just before the end of Read() so that anyone reading from the buffers will get that output. The caller knows the context about where our output goes, and thus also picks the appropriate output slice for us.</p>
<p>This isn't very pretty. What should be done is probably a more abstract concept of sending a row around and taking copies of it if needed, as opposed to it implicitly staying in the table's buffer. (This would also solve some issues in EQRefIterator and when synthesizing NULL rows for outer joins.) However, that's a large refactoring. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a71d58e1dd49bc9c7bc03235cdc68669c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d58e1dd49bc9c7bc03235cdc68669c">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a71d58e1dd49bc9c7bc03235cdc68669ca379c0edcb72247caab3c457390de6dd6"></a>READING_FIRST_ROW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a71d58e1dd49bc9c7bc03235cdc68669ca02e9388e37f45d6f104b1b9f631c8875"></a>LAST_ROW_STARTED_NEW_GROUP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a71d58e1dd49bc9c7bc03235cdc68669cab2f9d83ead3d5a06a645039631b45479"></a>READING_ROWS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a71d58e1dd49bc9c7bc03235cdc68669ca8de3d9b2e914bb1065c6999869592a65"></a>OUTPUTTING_ROLLUP_ROWS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a71d58e1dd49bc9c7bc03235cdc68669ca9a3144234f38a99e1e708ae147335146"></a>DONE_OUTPUTTING_ROWS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae21b34d2eb15e0721900abe7e5352a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21b34d2eb15e0721900abe7e5352a52">&#9670;&nbsp;</a></span>AggregateIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AggregateIterator::AggregateIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>temp_table_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>output_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>rollup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acc366c86329cd262301c50244055233f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc366c86329cd262301c50244055233f">&#9670;&nbsp;</a></span>copy_sum_funcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateIterator::copy_sum_funcs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc385de4b8dfbf68304a6233ee55c28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc385de4b8dfbf68304a6233ee55c28d">&#9670;&nbsp;</a></span>EndPSIBatchModeIfStarted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateIterator::EndPSIBatchModeIfStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends performance schema batch mode, if started. </p>
<p>It's always safe to call this.</p>
<p>Iterators that have children (composite iterators) must forward the EndPSIBatchModeIfStarted() call to every iterator they could conceivably have called StartPSIBatchMode() on. This ensures that after such a call to on the root iterator, all handlers are out of batch mode. </p>

<p>Reimplemented from <a class="el" href="classRowIterator.html#a9d2300ee51cfa38a5d6bfe0793d12540">RowIterator</a>.</p>

</div>
</div>
<a id="aa999babb48af75cb683d240b0f6c3791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa999babb48af75cb683d240b0f6c3791">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> AggregateIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="a3991cd698de121aaaa307577cbcac010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3991cd698de121aaaa307577cbcac010">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AggregateIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single row. </p>
<p>The row data is not actually returned from the function; it is put in the table's (or tables', in case of a join) record buffer, ie., table-&gt;records[0].</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="aeb01f76484eaa11e8d2a338f89ef1f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb01f76484eaa11e8d2a338f89ef1f3e">&#9670;&nbsp;</a></span>SetNullRowFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateIterator::SetNullRowFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_null_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row). </p>
<p>This is used for outer joins, when an iterator hasn't produced any rows and we need to produce a NULL-complemented row. Init() or Read() won't necessarily reset this flag, so if you ever set is to true, make sure to also set it to false when needed.</p>
<p>Note that this can be called without Init() having been called first. For example, NestedLoopIterator can hit EOF immediately on the outer iterator, which means the inner iterator doesn't get an Init() call, but will still forward SetNullRowFlag to both inner and outer iterators.</p>
<p>TODO: We shouldn't need this. See the comments on AggregateIterator for a bit more discussion on abstracting out a row interface. </p>

<p>Implements <a class="el" href="classRowIterator.html#a2fb51c6b0d8b763265d8b20710a31cb1">RowIterator</a>.</p>

</div>
</div>
<a id="aefd3a5e05887cb645f5b652d8638652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd3a5e05887cb645f5b652d8638652f">&#9670;&nbsp;</a></span>SetRollupLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateIterator::SetRollupLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bff435252fd1b7bc787754f4465c6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bff435252fd1b7bc787754f4465c6ad">&#9670;&nbsp;</a></span>StartPSIBatchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateIterator::StartPSIBatchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start performance schema batch mode, if supported (otherwise ignored). </p>
<p>PFS batch mode is a mitigation to reduce the overhead of performance schema, typically applied at the innermost table of the entire join. If you start it before scanning the table and then end it afterwards, the entire set of handler calls will be timed only once, as a group, and the costs will be distributed evenly out. This reduces timer overhead.</p>
<p>If you start PFS batch mode, you must also take care to end it at the end of the scan, one way or the other. Do note that this is true even if the query ends abruptly (LIMIT is reached, or an error happens). The easiest workaround for this is to simply call EndPSIBatchModeIfStarted() on the root iterator at the end of the scan. See the PFSBatchMode class for a useful helper.</p>
<p>The rules for starting batch and ending mode are:</p>
<ol type="1">
<li>If you are an iterator with exactly one child (FilterIterator etc.), forward any StartPSIBatchMode() calls to it.</li>
<li>If you drive an iterator (read rows from it using a for loop or similar), use PFSBatchMode as described above.</li>
<li>If you have multiple children, ignore the call and do your own handling of batch mode as appropriate. For materialization, #2 would typically apply. For joins, it depends on the join type (e.g., NestedLoopIterator applies batch mode only when scanning the innermost table).</li>
</ol>
<p>The upshot of this is that when scanning a single table, batch mode will typically be activated for that table (since we call StartPSIBatchMode() on the root iterator, and it will trickle all the way down to the table iterator), but for a join, the call will be ignored and the join iterator will activate batch mode by itself as needed. </p>

<p>Reimplemented from <a class="el" href="classRowIterator.html#a3c60f99cb3a1bc36776d718636aab5a0">RowIterator</a>.</p>

</div>
</div>
<a id="a1036a2a9187791fc58032cc34f142a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1036a2a9187791fc58032cc34f142a90">&#9670;&nbsp;</a></span>UnlockRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateIterator::UnlockRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRowIterator.html#a7590a98b54a85d3624cd9667c2da0764">RowIterator</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a178f16953dcc008eae7ae99e18c9f0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178f16953dcc008eae7ae99e18c9f0c7">&#9670;&nbsp;</a></span>m_current_rollup_position</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AggregateIterator::m_current_rollup_position</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we are in state OUTPUTTING_ROLLUP_ROWS, where we are in the iteration. </p>
<p>This value will start at the index of the last group expression and then count backwards down to and including m_last_unchanged_group_item_idx. It is used to communicate to the rollup group items whether to turn themselves into NULLs, and the sum items which of their sums to output. </p>

</div>
</div>
<a id="a0b927d8e118e2eeeabf1becdd2555c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b927d8e118e2eeeabf1becdd2555c60">&#9670;&nbsp;</a></span>m_input_slice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AggregateIterator::m_input_slice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The slice of the fields we are reading from (see the class comment). </p>

</div>
</div>
<a id="a6144c182c93363814b6f1e7883aac456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6144c182c93363814b6f1e7883aac456">&#9670;&nbsp;</a></span>m_join</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJOIN.html">JOIN</a>* AggregateIterator::m_join = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The join we are part of. </p>
<p>It would be nicer not to rely on this, but we need a large number of members from there, like which aggregate functions we have, the THD, temporary table parameters and so on. </p>

</div>
</div>
<a id="af1dc00cb506f442577d7a322c6357c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dc00cb506f442577d7a322c6357c72">&#9670;&nbsp;</a></span>m_last_unchanged_group_item_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AggregateIterator::m_last_unchanged_group_item_idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For rollup: The index of the first group item that did <em>not</em> change when we last switched groups. </p>
<p>E.g., if we have group fields A,B,C,D and then switch to group A,B,E,D, this value will become 1 (which means that we need to output rollup rows for 2 &ndash; A,B,E,NULL &ndash; and then 1 &ndash; A,B,NULL,NULL). m_current_rollup_position will count down from the end until it becomes less than this value.</p>
<p>If we do not have rollup, this value is perennially zero. </p>

</div>
</div>
<a id="ab5f195545b766527f6aa328c204a30f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f195545b766527f6aa328c204a30f5">&#9670;&nbsp;</a></span>m_output_slice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AggregateIterator::m_output_slice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The slice of the fields we are outputting to. See the class comment. </p>

</div>
</div>
<a id="acef69d1f598c81b5c2fe0dcb2fee646e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef69d1f598c81b5c2fe0dcb2fee646e">&#9670;&nbsp;</a></span>m_rollup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> AggregateIterator::m_rollup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this is a rollup query. </p>

</div>
</div>
<a id="a9e3f75b98ee9b61f9ea3ace7e3bbf3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3f75b98ee9b61f9ea3ace7e3bbf3f5">&#9670;&nbsp;</a></span>m_save_nullinfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> AggregateIterator::m_save_nullinfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to save NULL information in the specific case where we have zero input rows. </p>

</div>
</div>
<a id="a66dd90cf323e69d184628873b5bfc5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66dd90cf323e69d184628873b5bfc5a7">&#9670;&nbsp;</a></span>m_seen_eof</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> AggregateIterator::m_seen_eof</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we have seen the last input row. </p>

</div>
</div>
<a id="ab00624d6060ffcef6060e586649bb803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00624d6060ffcef6060e586649bb803">&#9670;&nbsp;</a></span>m_source</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt;<a class="el" href="classRowIterator.html">RowIterator</a>&gt; AggregateIterator::m_source</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad18f208ea6c9c2a7f025f64697973c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18f208ea6c9c2a7f025f64697973c43">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum { ... }   AggregateIterator::m_state</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a240c5179eebd269c2e5b6f09faf58b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240c5179eebd269c2e5b6f09faf58b62">&#9670;&nbsp;</a></span>m_temp_table_param</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTemp__table__param.html">Temp_table_param</a>* AggregateIterator::m_temp_table_param</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parameters for the temporary table we are materializing into, if any. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="composite__iterators_8h_source.html">composite_iterators.h</a></li>
<li>sql/<a class="el" href="composite__iterators_8cc.html">composite_iterators.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classAggregateIterator.html">AggregateIterator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
