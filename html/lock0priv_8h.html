<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/lock0priv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lock0priv_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lock0priv.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock module internal structures and methods.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &quot;lock0priv.ic&quot;</code><br />
</div>
<p><a href="lock0priv_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__table__t.html">lock_table_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table lock.  <a href="structlock__table__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__rec__t.html">lock_rec_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record lock for a page.  <a href="structlock__rec__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__t.html">lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock struct; protected by lock_sys latches.  <a href="structlock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRecID.html">RecID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record lock ID.  <a href="structRecID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRecLock.html">RecLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create record locks.  <a href="classRecLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLock__iter.html">Lock_iter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over record locks matching &lt;space, page_no, heap_no&gt;  <a href="structLock__iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlocksys_1_1Unsafe__global__latch__manipulator.html">locksys::Unsafe_global_latch_manipulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelocksys"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html">locksys</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa6e552c5c76599d5235fb2d36fbf87e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#aa6e552c5c76599d5235fb2d36fbf87e3">PRDT_HEAPNO</a>&#160;&#160;&#160;<a class="el" href="page0types_8h.html#a5b126406afda28a6d79e4f8ae0209c3d">PAGE_HEAP_NO_INFIMUM</a></td></tr>
<tr class="separator:aa6e552c5c76599d5235fb2d36fbf87e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aaa98e1bd917f95280993475788ea6c5b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a> { <a class="el" href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5ba12a47b5e4d2d01853958ecbc0513bb31">LOCK_REC_FAIL</a>, 
<a class="el" href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5ba4f02aa53c8580c293151a57282bdbdd6">LOCK_REC_SUCCESS</a>, 
<a class="el" href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5bab91e6212faed445182df02ef9497f066">LOCK_REC_SUCCESS_CREATED</a>
 }<tr class="memdesc:aaa98e1bd917f95280993475788ea6c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record locking request status.  <a href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aaa98e1bd917f95280993475788ea6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49bacfaaac1b0e5fcfd292189d099dfe"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a49bacfaaac1b0e5fcfd292189d099dfe">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structlock__table__t.html">lock_table_t</a> &amp;lock)</td></tr>
<tr class="memdesc:a49bacfaaac1b0e5fcfd292189d099dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global output operator is overloaded to conveniently print the lock_table_t object into the given output stream.  <a href="#a49bacfaaac1b0e5fcfd292189d099dfe">More...</a><br /></td></tr>
<tr class="separator:a49bacfaaac1b0e5fcfd292189d099dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c26a6d0cf38a657111e5cecd7aa194"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a43c26a6d0cf38a657111e5cecd7aa194">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structlock__rec__t.html">lock_rec_t</a> &amp;lock)</td></tr>
<tr class="separator:a43c26a6d0cf38a657111e5cecd7aa194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4d50e24df554a860fdc92e730199e0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#adc4d50e24df554a860fdc92e730199e0">lock_mode_is_next_key_lock</a> (ulint mode)</td></tr>
<tr class="memdesc:adc4d50e24df554a860fdc92e730199e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the <code>mode</code> is LOCK_S or LOCK_X, which means the lock is a Next Key Lock, a.k.a.  <a href="#adc4d50e24df554a860fdc92e730199e0">More...</a><br /></td></tr>
<tr class="separator:adc4d50e24df554a860fdc92e730199e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934e63f43c0caa00d7e0ba13fd9525cc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a934e63f43c0caa00d7e0ba13fd9525cc">lock_rec_get_nth_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint i)</td></tr>
<tr class="memdesc:a934e63f43c0caa00d7e0ba13fd9525cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the nth bit of a record lock.  <a href="#a934e63f43c0caa00d7e0ba13fd9525cc">More...</a><br /></td></tr>
<tr class="separator:a934e63f43c0caa00d7e0ba13fd9525cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea89ba03d27c046e1e35f1fcce5b54d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#abea89ba03d27c046e1e35f1fcce5b54d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structlock__t.html">lock_t</a> &amp;lock)</td></tr>
<tr class="separator:abea89ba03d27c046e1e35f1fcce5b54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7598ff3072373dabc18c756632ece1f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#ae7598ff3072373dabc18c756632ece1f">lock_get_type_low</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ae7598ff3072373dabc18c756632ece1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of a lock.  <a href="#ae7598ff3072373dabc18c756632ece1f">More...</a><br /></td></tr>
<tr class="separator:ae7598ff3072373dabc18c756632ece1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398c6b6d42fd740b9fa25ae4be1f660"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a9398c6b6d42fd740b9fa25ae4be1f660">lock_rec_get_prev</a> (const <a class="el" href="structlock__t.html">lock_t</a> *in_lock, ulint heap_no)</td></tr>
<tr class="memdesc:a9398c6b6d42fd740b9fa25ae4be1f660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previous record lock set on a record.  <a href="#a9398c6b6d42fd740b9fa25ae4be1f660">More...</a><br /></td></tr>
<tr class="separator:a9398c6b6d42fd740b9fa25ae4be1f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca77337242c4af78b916e503a81b57e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#aca77337242c4af78b916e503a81b57e2">lock_cancel_waiting_and_release</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aca77337242c4af78b916e503a81b57e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a waiting lock request and releases possible other transactions waiting behind it.  <a href="#aca77337242c4af78b916e503a81b57e2">More...</a><br /></td></tr>
<tr class="separator:aca77337242c4af78b916e503a81b57e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ad945a2410b29af7752e94ffa30ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a28ad945a2410b29af7752e94ffa30ae6">lock_reset_wait_and_release_thread_if_suspended</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a28ad945a2410b29af7752e94ffa30ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a wrapper around several functions which need to be called in particular order to wake up a transaction waiting for a lock.  <a href="#a28ad945a2410b29af7752e94ffa30ae6">More...</a><br /></td></tr>
<tr class="separator:a28ad945a2410b29af7752e94ffa30ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34549675db50fa2140bd18244c046f8d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a34549675db50fa2140bd18244c046f8d">lock_clust_rec_some_has_impl</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:a34549675db50fa2140bd18244c046f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if some transaction has an implicit x-lock on a record in a clustered index.  <a href="#a34549675db50fa2140bd18244c046f8d">More...</a><br /></td></tr>
<tr class="separator:a34549675db50fa2140bd18244c046f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0d0d9c1d6281cbe1a248f29d9e6dd7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a6c0d0d9c1d6281cbe1a248f29d9e6dd7">lock_rec_get_next_on_page_const</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a6c0d0d9c1d6281cbe1a248f29d9e6dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first or next record lock on a page.  <a href="#a6c0d0d9c1d6281cbe1a248f29d9e6dd7">More...</a><br /></td></tr>
<tr class="separator:a6c0d0d9c1d6281cbe1a248f29d9e6dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb79a43f5b92cea073f2cde49949308"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a3bb79a43f5b92cea073f2cde49949308">lock_rec_get_n_bits</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a3bb79a43f5b92cea073f2cde49949308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bits in a record lock bitmap.  <a href="#a3bb79a43f5b92cea073f2cde49949308">More...</a><br /></td></tr>
<tr class="separator:a3bb79a43f5b92cea073f2cde49949308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb59e5d76d0647bfbc4096682228f3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#ae0cb59e5d76d0647bfbc4096682228f3">lock_rec_set_nth_bit</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, ulint i)</td></tr>
<tr class="memdesc:ae0cb59e5d76d0647bfbc4096682228f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the nth bit of a record lock to TRUE.  <a href="#ae0cb59e5d76d0647bfbc4096682228f3">More...</a><br /></td></tr>
<tr class="separator:ae0cb59e5d76d0647bfbc4096682228f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e694a3a47a498c55bd09c5127b162a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#ad0e694a3a47a498c55bd09c5127b162a">lock_rec_get_next_on_page</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ad0e694a3a47a498c55bd09c5127b162a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first or next record lock on a page.  <a href="#ad0e694a3a47a498c55bd09c5127b162a">More...</a><br /></td></tr>
<tr class="separator:ad0e694a3a47a498c55bd09c5127b162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61561eadb600f37c0dc22bd4effad91b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a61561eadb600f37c0dc22bd4effad91b">lock_rec_get_first_on_page_addr</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *lock_hash, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a61561eadb600f37c0dc22bd4effad91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first record lock on a page, where the page is identified by its file address.  <a href="#a61561eadb600f37c0dc22bd4effad91b">More...</a><br /></td></tr>
<tr class="separator:a61561eadb600f37c0dc22bd4effad91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77353055fb4e9cff71124da74ecd85f4"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a77353055fb4e9cff71124da74ecd85f4">lock_rec_get_first_on_page</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *lock_hash, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a77353055fb4e9cff71124da74ecd85f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first record lock on a page, where the page is identified by a pointer to it.  <a href="#a77353055fb4e9cff71124da74ecd85f4">More...</a><br /></td></tr>
<tr class="separator:a77353055fb4e9cff71124da74ecd85f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f2ac5cbb634ee6ef9663ba8bf4bbab"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a81f2ac5cbb634ee6ef9663ba8bf4bbab">lock_rec_get_next</a> (ulint heap_no, <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a81f2ac5cbb634ee6ef9663ba8bf4bbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next explicit lock request on a record.  <a href="#a81f2ac5cbb634ee6ef9663ba8bf4bbab">More...</a><br /></td></tr>
<tr class="separator:a81f2ac5cbb634ee6ef9663ba8bf4bbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf1fd0b7f60894fecee9005803e62fa"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a9cf1fd0b7f60894fecee9005803e62fa">lock_rec_get_next_const</a> (ulint heap_no, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a9cf1fd0b7f60894fecee9005803e62fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next explicit lock request on a record.  <a href="#a9cf1fd0b7f60894fecee9005803e62fa">More...</a><br /></td></tr>
<tr class="separator:a9cf1fd0b7f60894fecee9005803e62fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340a22e43fd6b50411f084c5d4e9972d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a340a22e43fd6b50411f084c5d4e9972d">lock_rec_get_first</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *<a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no)</td></tr>
<tr class="memdesc:a340a22e43fd6b50411f084c5d4e9972d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first explicit lock request on a record.  <a href="#a340a22e43fd6b50411f084c5d4e9972d">More...</a><br /></td></tr>
<tr class="separator:a340a22e43fd6b50411f084c5d4e9972d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ba4d837532fb8eaf414d1cbaaf6d90"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ae4ba4d837532fb8eaf414d1cbaaf6d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mode of a lock.  <a href="#ae4ba4d837532fb8eaf414d1cbaaf6d90">More...</a><br /></td></tr>
<tr class="separator:ae4ba4d837532fb8eaf414d1cbaaf6d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07853bb83e125e4902a66d61cf24a658"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a07853bb83e125e4902a66d61cf24a658">lock_mode_compatible</a> (enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode1, enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode2)</td></tr>
<tr class="memdesc:a07853bb83e125e4902a66d61cf24a658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates if lock mode 1 is compatible with lock mode 2.  <a href="#a07853bb83e125e4902a66d61cf24a658">More...</a><br /></td></tr>
<tr class="separator:a07853bb83e125e4902a66d61cf24a658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a7b299a52356a1078b1ef78771e506"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a45a7b299a52356a1078b1ef78771e506">lock_mode_stronger_or_eq</a> (enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode1, enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode2)</td></tr>
<tr class="memdesc:a45a7b299a52356a1078b1ef78771e506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates if lock mode 1 is stronger or equal to lock mode 2.  <a href="#a45a7b299a52356a1078b1ef78771e506">More...</a><br /></td></tr>
<tr class="separator:a45a7b299a52356a1078b1ef78771e506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e45b1c0a23547fa21a02c765bcd29"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#ac39e45b1c0a23547fa21a02c765bcd29">lock_get_wait</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ac39e45b1c0a23547fa21a02c765bcd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the wait flag of a lock.  <a href="#ac39e45b1c0a23547fa21a02c765bcd29">More...</a><br /></td></tr>
<tr class="separator:ac39e45b1c0a23547fa21a02c765bcd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab51f58f1d7c2158a0c2eca6014ff26d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#aab51f58f1d7c2158a0c2eca6014ff26d">lock_table_has</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode)</td></tr>
<tr class="memdesc:aab51f58f1d7c2158a0c2eca6014ff26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a transaction has the specified table lock, or stronger.  <a href="#aab51f58f1d7c2158a0c2eca6014ff26d">More...</a><br /></td></tr>
<tr class="separator:aab51f58f1d7c2158a0c2eca6014ff26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9b9cd959650891d83421c521909b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a1f9b9cd959650891d83421c521909b88">lock_notify_about_deadlock</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; const <a class="el" href="structtrx__t.html">trx_t</a> *&gt; &amp;trxs_on_cycle, const <a class="el" href="structtrx__t.html">trx_t</a> *victim_trx)</td></tr>
<tr class="memdesc:a1f9b9cd959650891d83421c521909b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles writing the information about found deadlock to the log files and caches it for future lock_latest_err_file() calls (for example used by SHOW ENGINE INNODB STATUS)  <a href="#a1f9b9cd959650891d83421c521909b88">More...</a><br /></td></tr>
<tr class="separator:a1f9b9cd959650891d83421c521909b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad6facaed4aa238ad53ce0f202bcadc54"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#ad6facaed4aa238ad53ce0f202bcadc54">lock_print_waits</a></td></tr>
<tr class="separator:ad6facaed4aa238ad53ce0f202bcadc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592267d6eb97966dc430aae3827f40c6"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a592267d6eb97966dc430aae3827f40c6">LOCK_PAGE_BITMAP_MARGIN</a> = 64</td></tr>
<tr class="separator:a592267d6eb97966dc430aae3827f40c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3579e0d5ddc973a66fae09c8990e05ea"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a3579e0d5ddc973a66fae09c8990e05ea">lock_compatibility_matrix</a> [5][5]</td></tr>
<tr class="separator:a3579e0d5ddc973a66fae09c8990e05ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c37e6a5830ee34d6670d87ccc14128f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a1c37e6a5830ee34d6670d87ccc14128f">lock_strength_matrix</a> [5][5]</td></tr>
<tr class="separator:a1c37e6a5830ee34d6670d87ccc14128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4623ba68acd8e00ad5d81a0121f8e891"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a4623ba68acd8e00ad5d81a0121f8e891">MAX_STACK_SIZE</a> = 4096</td></tr>
<tr class="memdesc:a4623ba68acd8e00ad5d81a0121f8e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum depth of the DFS stack.  <a href="#a4623ba68acd8e00ad5d81a0121f8e891">More...</a><br /></td></tr>
<tr class="separator:a4623ba68acd8e00ad5d81a0121f8e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3508c405f6cb243c87e446622afdcf11"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0priv_8h.html#a3508c405f6cb243c87e446622afdcf11">lock_types</a> = UT_ARR_SIZE(<a class="el" href="lock0priv_8h.html#a3579e0d5ddc973a66fae09c8990e05ea">lock_compatibility_matrix</a>)</td></tr>
<tr class="memdesc:a3508c405f6cb243c87e446622afdcf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of the types of locks.  <a href="#a3508c405f6cb243c87e446622afdcf11">More...</a><br /></td></tr>
<tr class="separator:a3508c405f6cb243c87e446622afdcf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lock module internal structures and methods. </p>
<p>Created July 12, 2007 Vasil Dimov </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa6e552c5c76599d5235fb2d36fbf87e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e552c5c76599d5235fb2d36fbf87e3">&#9670;&nbsp;</a></span>PRDT_HEAPNO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRDT_HEAPNO&#160;&#160;&#160;<a class="el" href="page0types_8h.html#a5b126406afda28a6d79e4f8ae0209c3d">PAGE_HEAP_NO_INFIMUM</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aaa98e1bd917f95280993475788ea6c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa98e1bd917f95280993475788ea6c5b">&#9670;&nbsp;</a></span>lock_rec_req_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record locking request status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaa98e1bd917f95280993475788ea6c5ba12a47b5e4d2d01853958ecbc0513bb31"></a>LOCK_REC_FAIL&#160;</td><td class="fielddoc"><p>Failed to acquire a lock. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaa98e1bd917f95280993475788ea6c5ba4f02aa53c8580c293151a57282bdbdd6"></a>LOCK_REC_SUCCESS&#160;</td><td class="fielddoc"><p>Succeeded in acquiring a lock (implicit or already acquired) </p>
</td></tr>
<tr><td class="fieldname"><a id="aaa98e1bd917f95280993475788ea6c5bab91e6212faed445182df02ef9497f066"></a>LOCK_REC_SUCCESS_CREATED&#160;</td><td class="fielddoc"><p>Explicitly created a new lock. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aca77337242c4af78b916e503a81b57e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca77337242c4af78b916e503a81b57e2">&#9670;&nbsp;</a></span>lock_cancel_waiting_and_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_cancel_waiting_and_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels a waiting lock request and releases possible other transactions waiting behind it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>Waiting lock request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34549675db50fa2140bd18244c046f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34549675db50fa2140bd18244c046f8d">&#9670;&nbsp;</a></span>lock_clust_rec_some_has_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_clust_rec_some_has_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if some transaction has an implicit x-lock on a record in a clustered index. </p>
<dl class="section return"><dt>Returns</dt><dd>transaction id of the transaction which has the x-lock, or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4ba4d837532fb8eaf414d1cbaaf6d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ba4d837532fb8eaf414d1cbaaf6d90">&#9670;&nbsp;</a></span>lock_get_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> lock_get_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mode of a lock. </p>
<dl class="section return"><dt>Returns</dt><dd>mode in: lock </dd></dl>

</div>
</div>
<a id="ae7598ff3072373dabc18c756632ece1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7598ff3072373dabc18c756632ece1f">&#9670;&nbsp;</a></span>lock_get_type_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE uint32_t lock_get_type_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of a lock. </p>
<dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC in: lock </dd></dl>

</div>
</div>
<a id="ac39e45b1c0a23547fa21a02c765bcd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39e45b1c0a23547fa21a02c765bcd29">&#9670;&nbsp;</a></span>lock_get_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_get_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the wait flag of a lock. </p>
<dl class="section return"><dt>Returns</dt><dd>LOCK_WAIT if waiting, 0 if not in: lock </dd></dl>

</div>
</div>
<a id="a07853bb83e125e4902a66d61cf24a658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07853bb83e125e4902a66d61cf24a658">&#9670;&nbsp;</a></span>lock_mode_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_mode_compatible </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates if lock mode 1 is compatible with lock mode 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode1</td><td>lock mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode2</td><td>lock mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if mode1 compatible with mode2 </dd></dl>

</div>
</div>
<a id="adc4d50e24df554a860fdc92e730199e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4d50e24df554a860fdc92e730199e0">&#9670;&nbsp;</a></span>lock_mode_is_next_key_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_mode_is_next_key_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the <code>mode</code> is LOCK_S or LOCK_X, which means the lock is a Next Key Lock, a.k.a. </p>
<p>LOCK_ORDINARY, as opposed to Predicate Lock, GAP lock, Insert Intention or Record Lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>A mode and flags, of a non-waiting lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the only bits set in <code>mode</code> are LOCK_S or LOCK_X </dd></dl>

</div>
</div>
<a id="a45a7b299a52356a1078b1ef78771e506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a7b299a52356a1078b1ef78771e506">&#9670;&nbsp;</a></span>lock_mode_stronger_or_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_mode_stronger_or_eq </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates if lock mode 1 is stronger or equal to lock mode 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode1</td><td>lock mode 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode2</td><td>lock mode 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff mode1 stronger or equal to mode2 </dd></dl>

</div>
</div>
<a id="a1f9b9cd959650891d83421c521909b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9b9cd959650891d83421c521909b88">&#9670;&nbsp;</a></span>lock_notify_about_deadlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_notify_about_deadlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; const <a class="el" href="structtrx__t.html">trx_t</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>trxs_on_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>victim_trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles writing the information about found deadlock to the log files and caches it for future lock_latest_err_file() calls (for example used by SHOW ENGINE INNODB STATUS) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trxs_on_cycle</td><td>trxs causing deadlock, i-th waits for i+1-th </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">victim_trx</td><td>the trx from trx_on_cycle which will be rolled back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a340a22e43fd6b50411f084c5d4e9972d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340a22e43fd6b50411f084c5d4e9972d">&#9670;&nbsp;</a></span>lock_rec_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the first explicit lock request on a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>hash chain the lock on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>block containing the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of the record </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first lock, NULL if none exists </dd></dl>

</div>
</div>
<a id="a77353055fb4e9cff71124da74ecd85f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77353055fb4e9cff71124da74ecd85f4">&#9670;&nbsp;</a></span>lock_rec_get_first_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_first_on_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>lock_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the first record lock on a page, where the page is identified by a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_hash</td><td>lock hash table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first lock, NULL if none exists </dd></dl>

</div>
</div>
<a id="a61561eadb600f37c0dc22bd4effad91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61561eadb600f37c0dc22bd4effad91b">&#9670;&nbsp;</a></span>lock_rec_get_first_on_page_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_first_on_page_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>lock_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the first record lock on a page, where the page is identified by its file address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_hash</td><td>lock hash table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>specifies space id and page number of the page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first lock, NULL if none exists </dd></dl>

</div>
</div>
<a id="a3bb79a43f5b92cea073f2cde49949308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb79a43f5b92cea073f2cde49949308">&#9670;&nbsp;</a></span>lock_rec_get_n_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_n_bits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of bits in a record lock bitmap. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bits in: record lock </dd></dl>

</div>
</div>
<a id="a81f2ac5cbb634ee6ef9663ba8bf4bbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f2ac5cbb634ee6ef9663ba8bf4bbab">&#9670;&nbsp;</a></span>lock_rec_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next explicit lock request on a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists or if heap_no == ULINT_UNDEFINED </dd></dl>

</div>
</div>
<a id="a9cf1fd0b7f60894fecee9005803e62fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf1fd0b7f60894fecee9005803e62fa">&#9670;&nbsp;</a></span>lock_rec_get_next_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next_const </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next explicit lock request on a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists or if heap_no == ULINT_UNDEFINED </dd></dl>

</div>
</div>
<a id="ad0e694a3a47a498c55bd09c5127b162a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e694a3a47a498c55bd09c5127b162a">&#9670;&nbsp;</a></span>lock_rec_get_next_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next_on_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the first or next record lock on a page. </p>
<dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists in: a record lock </dd></dl>

</div>
</div>
<a id="a6c0d0d9c1d6281cbe1a248f29d9e6dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0d0d9c1d6281cbe1a248f29d9e6dd7">&#9670;&nbsp;</a></span>lock_rec_get_next_on_page_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next_on_page_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the first or next record lock on a page. </p>
<dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists in: a record lock </dd></dl>

</div>
</div>
<a id="a934e63f43c0caa00d7e0ba13fd9525cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934e63f43c0caa00d7e0ba13fd9525cc">&#9670;&nbsp;</a></span>lock_rec_get_nth_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_rec_get_nth_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the nth bit of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>record lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of the bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if bit set also if i == ULINT_UNDEFINED return false </dd></dl>

</div>
</div>
<a id="a9398c6b6d42fd740b9fa25ae4be1f660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9398c6b6d42fd740b9fa25ae4be1f660">&#9670;&nbsp;</a></span>lock_rec_get_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the previous record lock set on a record. </p>
<dl class="section return"><dt>Returns</dt><dd>previous lock on the same record, NULL if none exists in: heap number of the record</dd>
<dd>
previous lock on the same record, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0cb59e5d76d0647bfbc4096682228f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb59e5d76d0647bfbc4096682228f3">&#9670;&nbsp;</a></span>lock_rec_set_nth_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_rec_set_nth_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the nth bit of a record lock to TRUE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>record lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of the bit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28ad945a2410b29af7752e94ffa30ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ad945a2410b29af7752e94ffa30ae6">&#9670;&nbsp;</a></span>lock_reset_wait_and_release_thread_if_suspended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_reset_wait_and_release_thread_if_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a wrapper around several functions which need to be called in particular order to wake up a transaction waiting for a lock. </p>
<p>You should not call lock_wait_release_thread_if_suspended(thr) directly, but rather use this wrapper, as this makes it much easier to reason about all possible states in which lock, trx, and thr can be. It makes sure that trx is woken up exactly once, and only if it already went to sleep. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>The lock for which lock-&gt;trx is waiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab51f58f1d7c2158a0c2eca6014ff26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab51f58f1d7c2158a0c2eca6014ff26d">&#9670;&nbsp;</a></span>lock_table_has()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_table_has </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a transaction has the specified table lock, or stronger. </p>
<p>This function should only be called by the thread that owns the transaction. This function acquires trx-&gt;mutex which protects trx-&gt;lock.table_locks, but you should understand that this only makes it easier to argue against races at the level of access to the data structure, yet does not buy us any protection at the higher level of making actual decisions based on the result of this call - it may happen that another thread is performing lock_trx_table_locks_remove(), and even though lock_table_has returned true to the caller, the lock is no longer in possession of trx once the caller gets to evaluate if/else condition based on the result. Therefore it is up to caller to make sure that the context of the call to this function and making any decisions based on the result is protected from any concurrent modifications. This in turn makes the whole trx_mutex_enter/exit a bit redundant, but it does not affect performance yet makes the reasoning about data structure a bit easier and protects trx-&gt;lock.table_locks data structure from corruption in case our high level reasoning about absence of parallel modifications turns out wrong. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>lock mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>

</div>
</div>
<a id="a49bacfaaac1b0e5fcfd292189d099dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bacfaaac1b0e5fcfd292189d099dfe">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__table__t.html">lock_table_t</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The global output operator is overloaded to conveniently print the lock_table_t object into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>the table lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given output stream </dd></dl>

</div>
</div>
<a id="a43c26a6d0cf38a657111e5cecd7aa194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c26a6d0cf38a657111e5cecd7aa194">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__rec__t.html">lock_rec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abea89ba03d27c046e1e35f1fcce5b54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea89ba03d27c046e1e35f1fcce5b54d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3579e0d5ddc973a66fae09c8990e05ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3579e0d5ddc973a66fae09c8990e05ea">&#9670;&nbsp;</a></span>lock_compatibility_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> lock_compatibility_matrix[5][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    </div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, TRUE},</div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, TRUE},</div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, FALSE},</div><div class="line">     {<a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, FALSE},</div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, FALSE}}</div><div class="ttc" id="types_8h_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> types.h:46</div></div>
<div class="ttc" id="types_8h_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdef"><b>Definition:</b> types.h:50</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a592267d6eb97966dc430aae3827f40c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592267d6eb97966dc430aae3827f40c6">&#9670;&nbsp;</a></span>LOCK_PAGE_BITMAP_MARGIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint LOCK_PAGE_BITMAP_MARGIN = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6facaed4aa238ad53ce0f202bcadc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6facaed4aa238ad53ce0f202bcadc54">&#9670;&nbsp;</a></span>lock_print_waits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool lock_print_waits</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c37e6a5830ee34d6670d87ccc14128f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c37e6a5830ee34d6670d87ccc14128f">&#9670;&nbsp;</a></span>lock_strength_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> lock_strength_matrix[5][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    </div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, FALSE},</div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, FALSE},</div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, FALSE},</div><div class="line">     {<a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, TRUE},</div><div class="line">     {<a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="code" href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, TRUE}}</div><div class="ttc" id="types_8h_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="types_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> types.h:46</div></div>
<div class="ttc" id="types_8h_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="types_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdef"><b>Definition:</b> types.h:50</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3508c405f6cb243c87e446622afdcf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3508c405f6cb243c87e446622afdcf11">&#9670;&nbsp;</a></span>lock_types</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint lock_types = UT_ARR_SIZE(<a class="el" href="lock0priv_8h.html#a3579e0d5ddc973a66fae09c8990e05ea">lock_compatibility_matrix</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The count of the types of locks. </p>

</div>
</div>
<a id="a4623ba68acd8e00ad5d81a0121f8e891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4623ba68acd8e00ad5d81a0121f8e891">&#9670;&nbsp;</a></span>MAX_STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint MAX_STACK_SIZE = 4096</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum depth of the DFS stack. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="lock0priv_8h.html">lock0priv.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
