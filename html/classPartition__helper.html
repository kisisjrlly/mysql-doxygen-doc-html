<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Partition_helper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classPartition__helper.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPartition__helper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Partition_helper Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Partition_helper is a helper class that implements most generic partitioning functionality such as: table scan, index scan (both ordered and non-ordered), insert (write_row()), delete and update.  
 <a href="classPartition__helper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="partition__handler_8h_source.html">partition_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Partition_helper:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPartition__helper.png" usemap="#Partition_5Fhelper_map" alt=""/>
  <map id="Partition_5Fhelper_map" name="Partition_5Fhelper_map">
<area href="classha__innopart.html" title="The class defining a partitioning aware handle to an InnoDB table. " alt="ha_innopart" shape="rect" coords="0,56,101,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15e606f4498a1640d68976b310a0a74a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a15e606f4498a1640d68976b310a0a74a">Partition_helper</a> (<a class="el" href="classhandler.html">handler</a> *main_handler)</td></tr>
<tr class="separator:a15e606f4498a1640d68976b310a0a74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d34eb47df150130fff01bd4662de532"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5d34eb47df150130fff01bd4662de532">~Partition_helper</a> ()</td></tr>
<tr class="separator:a5d34eb47df150130fff01bd4662de532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc3f2f9f90cd789775c73a675a285a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a7cc3f2f9f90cd789775c73a675a285a9">set_part_info_low</a> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> early)</td></tr>
<tr class="memdesc:a7cc3f2f9f90cd789775c73a675a285a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set partition info.  <a href="#a7cc3f2f9f90cd789775c73a675a285a9">More...</a><br /></td></tr>
<tr class="separator:a7cc3f2f9f90cd789775c73a675a285a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19f3b7788c9d6c09637c1c487e0058e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ac19f3b7788c9d6c09637c1c487e0058e">init_partitioning</a> (<a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *<a class="el" href="client__plugin_8cc.html#a7d0fe2f135db987da18cea87b4778737">mem_root</a>)</td></tr>
<tr class="memdesc:ac19f3b7788c9d6c09637c1c487e0058e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize variables used before the table is opened.  <a href="#ac19f3b7788c9d6c09637c1c487e0058e">More...</a><br /></td></tr>
<tr class="separator:ac19f3b7788c9d6c09637c1c487e0058e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37610c88f4fac22f38328cc1e4c541c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ab37610c88f4fac22f38328cc1e4c541c">ph_release_auto_increment</a> ()</td></tr>
<tr class="memdesc:ab37610c88f4fac22f38328cc1e4c541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release unused auto increment values.  <a href="#ab37610c88f4fac22f38328cc1e4c541c">More...</a><br /></td></tr>
<tr class="separator:ab37610c88f4fac22f38328cc1e4c541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39d3732642cf7ded9c0db4adcd22aab9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a39d3732642cf7ded9c0db4adcd22aab9">ph_write_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a39d3732642cf7ded9c0db4adcd22aab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">INSERT/UPDATE/DELETE functions.  <a href="#a39d3732642cf7ded9c0db4adcd22aab9">More...</a><br /></td></tr>
<tr class="separator:a39d3732642cf7ded9c0db4adcd22aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7949ca4e2568b49ba0a80a4dde505c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a2a7949ca4e2568b49ba0a80a4dde505c">ph_update_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>)</td></tr>
<tr class="memdesc:a2a7949ca4e2568b49ba0a80a4dde505c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing row in the partitioned table.  <a href="#a2a7949ca4e2568b49ba0a80a4dde505c">More...</a><br /></td></tr>
<tr class="separator:a2a7949ca4e2568b49ba0a80a4dde505c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1de2e31241c899a076ea0068cfc6570"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ae1de2e31241c899a076ea0068cfc6570">ph_delete_row</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:ae1de2e31241c899a076ea0068cfc6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing row in the partitioned table.  <a href="#ae1de2e31241c899a076ea0068cfc6570">More...</a><br /></td></tr>
<tr class="separator:ae1de2e31241c899a076ea0068cfc6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a411098723b56a18eed1ac9fe55726fe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a411098723b56a18eed1ac9fe55726fe9">ph_rnd_init</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan)</td></tr>
<tr class="memdesc:a411098723b56a18eed1ac9fe55726fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">MODULE full table scan.  <a href="#a411098723b56a18eed1ac9fe55726fe9">More...</a><br /></td></tr>
<tr class="separator:a411098723b56a18eed1ac9fe55726fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef5933f1db11c10dbbbc94f98065e95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a8ef5933f1db11c10dbbbc94f98065e95">ph_rnd_end</a> ()</td></tr>
<tr class="memdesc:a8ef5933f1db11c10dbbbc94f98065e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of a table scan.  <a href="#a8ef5933f1db11c10dbbbc94f98065e95">More...</a><br /></td></tr>
<tr class="separator:a8ef5933f1db11c10dbbbc94f98065e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634ba7fca5971c62c9fea2ba0378604f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a634ba7fca5971c62c9fea2ba0378604f">ph_rnd_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a634ba7fca5971c62c9fea2ba0378604f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row during full table scan (scan in random row order).  <a href="#a634ba7fca5971c62c9fea2ba0378604f">More...</a><br /></td></tr>
<tr class="separator:a634ba7fca5971c62c9fea2ba0378604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8756342d79d9e976bde2a2278a87a0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a8756342d79d9e976bde2a2278a87a0ed">ph_position</a> (const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="memdesc:a8756342d79d9e976bde2a2278a87a0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save position of current row.  <a href="#a8756342d79d9e976bde2a2278a87a0ed">More...</a><br /></td></tr>
<tr class="separator:a8756342d79d9e976bde2a2278a87a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:addc09bd30772de1c0bf5a1070fe4d17d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#addc09bd30772de1c0bf5a1070fe4d17d">ph_index_init_setup</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> key_nr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="memdesc:addc09bd30772de1c0bf5a1070fe4d17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">MODULE index scan.  <a href="#addc09bd30772de1c0bf5a1070fe4d17d">More...</a><br /></td></tr>
<tr class="separator:addc09bd30772de1c0bf5a1070fe4d17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e474054bff81d327f19e3f214d0c0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a00e474054bff81d327f19e3f214d0c0d">ph_index_first</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a00e474054bff81d327f19e3f214d0c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an index scan from leftmost record and return first record.  <a href="#a00e474054bff81d327f19e3f214d0c0d">More...</a><br /></td></tr>
<tr class="separator:a00e474054bff81d327f19e3f214d0c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec894e99f298f59f87249324914bceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5ec894e99f298f59f87249324914bceb">ph_index_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a5ec894e99f298f59f87249324914bceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an index scan from rightmost record and return first record.  <a href="#a5ec894e99f298f59f87249324914bceb">More...</a><br /></td></tr>
<tr class="separator:a5ec894e99f298f59f87249324914bceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb52147154875848e1be8fc392ba687"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#abfb52147154875848e1be8fc392ba687">ph_index_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:abfb52147154875848e1be8fc392ba687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next record in a forward index scan.  <a href="#abfb52147154875848e1be8fc392ba687">More...</a><br /></td></tr>
<tr class="separator:abfb52147154875848e1be8fc392ba687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4952a27eab71a53d0bfed0f3375716ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a4952a27eab71a53d0bfed0f3375716ac">ph_index_next_same</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keylen)</td></tr>
<tr class="memdesc:a4952a27eab71a53d0bfed0f3375716ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next same record.  <a href="#a4952a27eab71a53d0bfed0f3375716ac">More...</a><br /></td></tr>
<tr class="separator:a4952a27eab71a53d0bfed0f3375716ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ae8e19f3929f2ccbc11711ff5a2390"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a27ae8e19f3929f2ccbc11711ff5a2390">ph_index_prev</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a27ae8e19f3929f2ccbc11711ff5a2390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next record when performing index scan backwards.  <a href="#a27ae8e19f3929f2ccbc11711ff5a2390">More...</a><br /></td></tr>
<tr class="separator:a27ae8e19f3929f2ccbc11711ff5a2390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1123015210554cb81fb17584e9040c1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a1123015210554cb81fb17584e9040c1e">ph_index_read_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:a1123015210554cb81fb17584e9040c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one record in an index scan and start an index scan.  <a href="#a1123015210554cb81fb17584e9040c1e">More...</a><br /></td></tr>
<tr class="separator:a1123015210554cb81fb17584e9040c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cfd9fa41cd0317d261b781b4514923"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aa3cfd9fa41cd0317d261b781b4514923">ph_index_read_last_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)</td></tr>
<tr class="memdesc:aa3cfd9fa41cd0317d261b781b4514923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read last using key.  <a href="#aa3cfd9fa41cd0317d261b781b4514923">More...</a><br /></td></tr>
<tr class="separator:aa3cfd9fa41cd0317d261b781b4514923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ecb3bcd4435cfe60c5285c2f67efb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a94ecb3bcd4435cfe60c5285c2f67efb9">ph_index_read_idx_map</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)</td></tr>
<tr class="memdesc:a94ecb3bcd4435cfe60c5285c2f67efb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read index by key and keymap.  <a href="#a94ecb3bcd4435cfe60c5285c2f67efb9">More...</a><br /></td></tr>
<tr class="separator:a94ecb3bcd4435cfe60c5285c2f67efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c1cc2266cae67329541349dcd20e95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ad7c1cc2266cae67329541349dcd20e95">ph_read_range_first</a> (const <a class="el" href="structkey__range.html">key_range</a> *start_key, const <a class="el" href="structkey__range.html">key_range</a> *end_key, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> eq_range_arg, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="memdesc:ad7c1cc2266cae67329541349dcd20e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a read of one range with start and end key.  <a href="#ad7c1cc2266cae67329541349dcd20e95">More...</a><br /></td></tr>
<tr class="separator:ad7c1cc2266cae67329541349dcd20e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b0759c44db5819a0165df4c21a5b34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a64b0759c44db5819a0165df4c21a5b34">ph_read_range_next</a> ()</td></tr>
<tr class="memdesc:a64b0759c44db5819a0165df4c21a5b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next record in read of a range with start and end key.  <a href="#a64b0759c44db5819a0165df4c21a5b34">More...</a><br /></td></tr>
<tr class="separator:a64b0759c44db5819a0165df4c21a5b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae984c0efde3d99693244a508bff8398e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ae984c0efde3d99693244a508bff8398e">get_dynamic_partition_info_low</a> (<a class="el" href="classha__statistics.html">ha_statistics</a> *stat_info, <a class="el" href="group__MYSYS.html#ga31ef2f6273d26427fe4a13ed5049b050">ha_checksum</a> *check_sum, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id)</td></tr>
<tr class="memdesc:ae984c0efde3d99693244a508bff8398e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions matching Partition_handler API.  <a href="#ae984c0efde3d99693244a508bff8398e">More...</a><br /></td></tr>
<tr class="separator:ae984c0efde3d99693244a508bff8398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c6fffef4cdcf8bcc11064be4019351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a98c6fffef4cdcf8bcc11064be4019351">prepare_change_partitions</a> ()</td></tr>
<tr class="memdesc:a98c6fffef4cdcf8bcc11064be4019351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare for reorganizing partitions by setting up partition_info::read_partitions according to the partition_info mark-up.  <a href="#a98c6fffef4cdcf8bcc11064be4019351">More...</a><br /></td></tr>
<tr class="separator:a98c6fffef4cdcf8bcc11064be4019351"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f4c35aadc6e54b0a10279633be79845"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a7f4c35aadc6e54b0a10279633be79845">ph_calculate_key_hash_value</a> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr class="memdesc:a7f4c35aadc6e54b0a10279633be79845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate key hash value from an null terminated array of fields.  <a href="#a7f4c35aadc6e54b0a10279633be79845">More...</a><br /></td></tr>
<tr class="separator:a7f4c35aadc6e54b0a10279633be79845"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a78223999427251c9856daaec550a1d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a78223999427251c9856daaec550a1d1d">open_partitioning</a> (<a class="el" href="classPartition__share.html">Partition_share</a> *part_share)</td></tr>
<tr class="memdesc:a78223999427251c9856daaec550a1d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set m_part_share, Allocate internal bitmaps etc.  <a href="#a78223999427251c9856daaec550a1d1d">More...</a><br /></td></tr>
<tr class="separator:a78223999427251c9856daaec550a1d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af811551fba3956755941e049e4b1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a0af811551fba3956755941e049e4b1f0">close_partitioning</a> ()</td></tr>
<tr class="memdesc:a0af811551fba3956755941e049e4b1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close partitioning for a table.  <a href="#a0af811551fba3956755941e049e4b1f0">More...</a><br /></td></tr>
<tr class="separator:a0af811551fba3956755941e049e4b1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeecebe45928e398ea3afc914bfcfe87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#abeecebe45928e398ea3afc914bfcfe87">lock_auto_increment</a> ()</td></tr>
<tr class="memdesc:abeecebe45928e398ea3afc914bfcfe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock auto increment value if needed.  <a href="#abeecebe45928e398ea3afc914bfcfe87">More...</a><br /></td></tr>
<tr class="separator:abeecebe45928e398ea3afc914bfcfe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdac13ff80e81802a04115f3f301140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a3bdac13ff80e81802a04115f3f301140">unlock_auto_increment</a> ()</td></tr>
<tr class="memdesc:a3bdac13ff80e81802a04115f3f301140"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlock auto increment.  <a href="#a3bdac13ff80e81802a04115f3f301140">More...</a><br /></td></tr>
<tr class="separator:a3bdac13ff80e81802a04115f3f301140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae9d6cb652ac8f6e1a9b39958578ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a1ae9d6cb652ac8f6e1a9b39958578ffa">get_auto_increment_first_field</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> increment, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> nb_desired_values, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *first_value, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *nb_reserved_values)</td></tr>
<tr class="memdesc:a1ae9d6cb652ac8f6e1a9b39958578ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range of auto increment values.  <a href="#a1ae9d6cb652ac8f6e1a9b39958578ffa">More...</a><br /></td></tr>
<tr class="separator:a1ae9d6cb652ac8f6e1a9b39958578ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebea96fab34a0fb8118455d787892a00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aebea96fab34a0fb8118455d787892a00">init_record_priority_queue</a> ()</td></tr>
<tr class="memdesc:aebea96fab34a0fb8118455d787892a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the record priority queue used for sorted index scans.  <a href="#aebea96fab34a0fb8118455d787892a00">More...</a><br /></td></tr>
<tr class="separator:aebea96fab34a0fb8118455d787892a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d75a2e65409288375dc50ed45237972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a8d75a2e65409288375dc50ed45237972">destroy_record_priority_queue</a> ()</td></tr>
<tr class="memdesc:a8d75a2e65409288375dc50ed45237972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the record priority queue used for sorted index scans.  <a href="#a8d75a2e65409288375dc50ed45237972">More...</a><br /></td></tr>
<tr class="separator:a8d75a2e65409288375dc50ed45237972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5889223c041f0ff1e5641e23fcb46483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5889223c041f0ff1e5641e23fcb46483">print_partition_error</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="memdesc:a5889223c041f0ff1e5641e23fcb46483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print partitioning specific error.  <a href="#a5889223c041f0ff1e5641e23fcb46483">More...</a><br /></td></tr>
<tr class="separator:a5889223c041f0ff1e5641e23fcb46483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5549f355a264b52a013d372686ba9ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5549f355a264b52a013d372686ba9ef1">print_admin_msg</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> len, const char *msg_type, const char *db_name, const char *table_name, const char *op_name, const char *fmt,...)</td></tr>
<tr class="memdesc:a5549f355a264b52a013d372686ba9ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message row formatted for ANALYZE/CHECK/OPTIMIZE/REPAIR TABLE.  <a href="#a5549f355a264b52a013d372686ba9ef1">More...</a><br /></td></tr>
<tr class="separator:a5549f355a264b52a013d372686ba9ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662b113c5b1fe57269af6b0611a9280e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a662b113c5b1fe57269af6b0611a9280e">check_misplaced_rows</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> read_part_id, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> repair)</td></tr>
<tr class="memdesc:a662b113c5b1fe57269af6b0611a9280e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check/fix misplaced rows.  <a href="#a662b113c5b1fe57269af6b0611a9280e">More...</a><br /></td></tr>
<tr class="separator:a662b113c5b1fe57269af6b0611a9280e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b2ae0ff2314729459030b2a59e83bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a04b2ae0ff2314729459030b2a59e83bf">set_altered_partitions</a> ()</td></tr>
<tr class="memdesc:a04b2ae0ff2314729459030b2a59e83bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set used partitions bitmap from Alter_info.  <a href="#a04b2ae0ff2314729459030b2a59e83bf">More...</a><br /></td></tr>
<tr class="separator:a04b2ae0ff2314729459030b2a59e83bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd21687bbd51dd22fffba5d032611c74"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#acd21687bbd51dd22fffba5d032611c74">copy_partitions</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *const deleted)</td></tr>
<tr class="memdesc:acd21687bbd51dd22fffba5d032611c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy partitions as part of ALTER TABLE of partitions.  <a href="#acd21687bbd51dd22fffba5d032611c74">More...</a><br /></td></tr>
<tr class="separator:acd21687bbd51dd22fffba5d032611c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9b9c1d86a06d3dc8426bad2579fec179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a9b9c1d86a06d3dc8426bad2579fec179">m_table</a></td></tr>
<tr class="memdesc:a9b9c1d86a06d3dc8426bad2579fec179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience pointer to table from m_handler (i.e.  <a href="#a9b9c1d86a06d3dc8426bad2579fec179">More...</a><br /></td></tr>
<tr class="separator:a9b9c1d86a06d3dc8426bad2579fec179"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aae15aadd4e7854e705866b9952014678"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678">partition_index_scan_type</a> { <br />
&#160;&#160;<a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678a439459ee87965f3fbc90ed6513428274">PARTITION_INDEX_READ</a> = 1, 
<a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678a4cd5c771b0b5ae42fcc058af17d911de">PARTITION_INDEX_FIRST</a>, 
<a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678a2f8011724b67faa6bb00d79a69bc06cd">PARTITION_INDEX_FIRST_UNORDERED</a>, 
<a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678a5589b5e0ff1678a4e70ad672cab646a0">PARTITION_INDEX_LAST</a>, 
<br />
&#160;&#160;<a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678af054714e88dcf526bbb0a696e60eec80">PARTITION_INDEX_READ_LAST</a>, 
<a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678a855eee4cbd45f0e3bc59107534b0e3df">PARTITION_READ_RANGE</a>, 
<a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678a85f866fd8f07d685178877c4e4c89cbf">PARTITION_NO_INDEX_SCAN</a>
<br />
 }</td></tr>
<tr class="separator:aae15aadd4e7854e705866b9952014678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220cae60081f437684607865c72339e8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classPriority__queue.html">Priority_queue</a>&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, std::vector&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * &gt;, <a class="el" href="structKey__rec__less.html">Key_rec_less</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a220cae60081f437684607865c72339e8">Prio_queue</a></td></tr>
<tr class="separator:a220cae60081f437684607865c72339e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0c0c76737233fc59a603a166813c0f85"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a0c0c76737233fc59a603a166813c0f85">get_thd</a> () const =0</td></tr>
<tr class="separator:a0c0c76737233fc59a603a166813c0f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c6ab707c75086457a7e44dafc75640"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a87c6ab707c75086457a7e44dafc75640">get_table</a> () const =0</td></tr>
<tr class="separator:a87c6ab707c75086457a7e44dafc75640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc03a956eb8be074ff04fbc161e70188"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#afc03a956eb8be074ff04fbc161e70188">get_eq_range</a> () const =0</td></tr>
<tr class="separator:afc03a956eb8be074ff04fbc161e70188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a59c9539ff3caffe64df1c37d975a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a44a59c9539ff3caffe64df1c37d975a0">set_eq_range</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> eq_range)=0</td></tr>
<tr class="separator:a44a59c9539ff3caffe64df1c37d975a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabcc0d508f362c71e52dc84b2cf5c06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aeabcc0d508f362c71e52dc84b2cf5c06">set_range_key_part</a> (<a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part)=0</td></tr>
<tr class="separator:aeabcc0d508f362c71e52dc84b2cf5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971c4232545c78b7d3ddc33cbb66b7e2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a971c4232545c78b7d3ddc33cbb66b7e2">write_row_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="memdesc:a971c4232545c78b7d3ddc33cbb66b7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a row in the specified partition.  <a href="#a971c4232545c78b7d3ddc33cbb66b7e2">More...</a><br /></td></tr>
<tr class="separator:a971c4232545c78b7d3ddc33cbb66b7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74ba05f9a25e2b0ed4637f07cf1bd9b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ad74ba05f9a25e2b0ed4637f07cf1bd9b">update_row_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *old_data, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="app__data_8h.html#a4104c7043ba0f61a452a016adfd1869d">new_data</a>)=0</td></tr>
<tr class="memdesc:ad74ba05f9a25e2b0ed4637f07cf1bd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a row in the specified partition.  <a href="#ad74ba05f9a25e2b0ed4637f07cf1bd9b">More...</a><br /></td></tr>
<tr class="separator:ad74ba05f9a25e2b0ed4637f07cf1bd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8a9d4378532412520f658832aebe91"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a2d8a9d4378532412520f658832aebe91">delete_row_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="memdesc:a2d8a9d4378532412520f658832aebe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing row in the specified partition.  <a href="#a2d8a9d4378532412520f658832aebe91">More...</a><br /></td></tr>
<tr class="separator:a2d8a9d4378532412520f658832aebe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5c4efe169bd33304f5e25f8ec17647"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ada5c4efe169bd33304f5e25f8ec17647">initialize_auto_increment</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> no_lock)=0</td></tr>
<tr class="memdesc:ada5c4efe169bd33304f5e25f8ec17647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the shared auto increment value.  <a href="#ada5c4efe169bd33304f5e25f8ec17647">More...</a><br /></td></tr>
<tr class="separator:ada5c4efe169bd33304f5e25f8ec17647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931aebdf4753b66b76b76b34304379d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a931aebdf4753b66b76b76b34304379d6">release_auto_increment_all_parts</a> ()</td></tr>
<tr class="memdesc:a931aebdf4753b66b76b76b34304379d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release auto_increment in all underlying partitions.  <a href="#a931aebdf4753b66b76b76b34304379d6">More...</a><br /></td></tr>
<tr class="separator:a931aebdf4753b66b76b76b34304379d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e75b5b6901c53a6dfe0dec8cb3ae42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a14e75b5b6901c53a6dfe0dec8cb3ae42">save_auto_increment</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> nr)</td></tr>
<tr class="memdesc:a14e75b5b6901c53a6dfe0dec8cb3ae42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save or persist the current max auto increment.  <a href="#a14e75b5b6901c53a6dfe0dec8cb3ae42">More...</a><br /></td></tr>
<tr class="separator:a14e75b5b6901c53a6dfe0dec8cb3ae42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db002aa225adb01cc0d69cee4638ef"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ae2db002aa225adb01cc0d69cee4638ef">rnd_init_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> table_scan)=0</td></tr>
<tr class="memdesc:ae2db002aa225adb01cc0d69cee4638ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per partition equivalent of rnd_* and index_* functions.  <a href="#ae2db002aa225adb01cc0d69cee4638ef">More...</a><br /></td></tr>
<tr class="separator:ae2db002aa225adb01cc0d69cee4638ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eae202afb8e7e38d5779ce42826aae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ad6eae202afb8e7e38d5779ce42826aae">ph_rnd_next_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:ad6eae202afb8e7e38d5779ce42826aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row during full partition scan (scan in random row order).  <a href="#ad6eae202afb8e7e38d5779ce42826aae">More...</a><br /></td></tr>
<tr class="separator:ad6eae202afb8e7e38d5779ce42826aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6df63cb8cf1234403ef896c96bf3480"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ae6df63cb8cf1234403ef896c96bf3480">rnd_next_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="separator:ae6df63cb8cf1234403ef896c96bf3480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388c8f0c914c29d90649ad70de789484"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a388c8f0c914c29d90649ad70de789484">rnd_end_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan)=0</td></tr>
<tr class="separator:a388c8f0c914c29d90649ad70de789484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cbd52cd3051fdc26e519ac25e8f1b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a74cbd52cd3051fdc26e519ac25e8f1b9">position_in_last_part</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ref, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *row)=0</td></tr>
<tr class="separator:a74cbd52cd3051fdc26e519ac25e8f1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcf12377f2fb4da0d30bc9701ecc1f1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aadcf12377f2fb4da0d30bc9701ecc1f1">index_first_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="separator:aadcf12377f2fb4da0d30bc9701ecc1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0202e16bc9ded962e8a6358a06663b6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ae0202e16bc9ded962e8a6358a06663b6">index_last_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="separator:ae0202e16bc9ded962e8a6358a06663b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8017cc21f54ef9d182b04c35d001dd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#abb8017cc21f54ef9d182b04c35d001dd">index_prev_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="separator:abb8017cc21f54ef9d182b04c35d001dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2475c952726c8ad5c2127f65c2ae60"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5e2475c952726c8ad5c2127f65c2ae60">index_next_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="separator:a5e2475c952726c8ad5c2127f65c2ae60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfe18f89363bbfe2f32e3e55c70a32a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#acbfe18f89363bbfe2f32e3e55c70a32a">index_next_same_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> length)=0</td></tr>
<tr class="separator:acbfe18f89363bbfe2f32e3e55c70a32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b94a805363282febc185263c5e45bd7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a1b94a805363282febc185263c5e45bd7">index_read_map_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)=0</td></tr>
<tr class="separator:a1b94a805363282febc185263c5e45bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6379d75823eb997e618519aa740637"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#abe6379d75823eb997e618519aa740637">index_read_last_map_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map)=0</td></tr>
<tr class="separator:abe6379d75823eb997e618519aa740637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af025065432f6f0d722fc9bc1243d490b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#af025065432f6f0d722fc9bc1243d490b">read_range_first_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, const <a class="el" href="structkey__range.html">key_range</a> *start_key, const <a class="el" href="structkey__range.html">key_range</a> *end_key, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)=0</td></tr>
<tr class="memdesc:af025065432f6f0d722fc9bc1243d490b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do read_range_first in the specified partition.  <a href="#af025065432f6f0d722fc9bc1243d490b">More...</a><br /></td></tr>
<tr class="separator:af025065432f6f0d722fc9bc1243d490b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe57f61ce0e105cdb5b887be30860c04"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#abe57f61ce0e105cdb5b887be30860c04">read_range_next_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)=0</td></tr>
<tr class="memdesc:abe57f61ce0e105cdb5b887be30860c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do read_range_next in the specified partition.  <a href="#abe57f61ce0e105cdb5b887be30860c04">More...</a><br /></td></tr>
<tr class="separator:abe57f61ce0e105cdb5b887be30860c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b8c807ad9c0666a6be2a5f76a741b5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a66b8c807ad9c0666a6be2a5f76a741b5">index_read_idx_map_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> keypart_map, enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a> find_flag)=0</td></tr>
<tr class="separator:a66b8c807ad9c0666a6be2a5f76a741b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a91eebe7195eb16a07ff333f2262251"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a9a91eebe7195eb16a07ff333f2262251">init_record_priority_queue_for_parts</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> used_parts)</td></tr>
<tr class="memdesc:a9a91eebe7195eb16a07ff333f2262251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize engine specific resources for the record priority queue used duing ordered index reads for multiple partitions.  <a href="#a9a91eebe7195eb16a07ff333f2262251">More...</a><br /></td></tr>
<tr class="separator:a9a91eebe7195eb16a07ff333f2262251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1486153d959b44f9643ddc33671b9283"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a1486153d959b44f9643ddc33671b9283">destroy_record_priority_queue_for_parts</a> ()</td></tr>
<tr class="memdesc:a1486153d959b44f9643ddc33671b9283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and release engine specific resources used by the record priority queue.  <a href="#a1486153d959b44f9643ddc33671b9283">More...</a><br /></td></tr>
<tr class="separator:a1486153d959b44f9643ddc33671b9283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa80520af5c8647951f57128302b4ad2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__MYSYS.html#ga31ef2f6273d26427fe4a13ed5049b050">ha_checksum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#afa80520af5c8647951f57128302b4ad2">checksum_in_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> part_id) const</td></tr>
<tr class="memdesc:afa80520af5c8647951f57128302b4ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checksum for a partition.  <a href="#afa80520af5c8647951f57128302b4ad2">More...</a><br /></td></tr>
<tr class="separator:afa80520af5c8647951f57128302b4ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378c1d786efb0d92668aee3d913051d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a378c1d786efb0d92668aee3d913051d0">copy_cached_row</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *to_rec, const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *from_rec)</td></tr>
<tr class="memdesc:a378c1d786efb0d92668aee3d913051d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a cached row.  <a href="#a378c1d786efb0d92668aee3d913051d0">More...</a><br /></td></tr>
<tr class="separator:a378c1d786efb0d92668aee3d913051d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8ba633f49d8f749f09213aac80a56f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a1c8ba633f49d8f749f09213aac80a56f">write_row_in_new_part</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> new_part)=0</td></tr>
<tr class="memdesc:a1c8ba633f49d8f749f09213aac80a56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">write row to new partition.  <a href="#a1c8ba633f49d8f749f09213aac80a56f">More...</a><br /></td></tr>
<tr class="separator:a1c8ba633f49d8f749f09213aac80a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8166a3964219228f543d3048aed52664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a8166a3964219228f543d3048aed52664">set_auto_increment_if_higher</a> ()</td></tr>
<tr class="memdesc:a8166a3964219228f543d3048aed52664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update auto increment value if current row contains a higher value.  <a href="#a8166a3964219228f543d3048aed52664">More...</a><br /></td></tr>
<tr class="separator:a8166a3964219228f543d3048aed52664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef130f7979bc429bf9a3f31b19379c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aef130f7979bc429bf9a3f31b19379c5f">partition_scan_set_up</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> idx_read_flag)</td></tr>
<tr class="memdesc:aef130f7979bc429bf9a3f31b19379c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common routine to set up index scans.  <a href="#aef130f7979bc429bf9a3f31b19379c5f">More...</a><br /></td></tr>
<tr class="separator:aef130f7979bc429bf9a3f31b19379c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afa66a5e5e7ad01ea1b0ab5e5720ba1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5afa66a5e5e7ad01ea1b0ab5e5720ba1">handle_unordered_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_next_same)</td></tr>
<tr class="memdesc:a5afa66a5e5e7ad01ea1b0ab5e5720ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common routine to handle index_next with unordered results.  <a href="#a5afa66a5e5e7ad01ea1b0ab5e5720ba1">More...</a><br /></td></tr>
<tr class="separator:a5afa66a5e5e7ad01ea1b0ab5e5720ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41324582e188ec200c99f4ce93b3bc05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a41324582e188ec200c99f4ce93b3bc05">handle_unordered_scan_next_partition</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a41324582e188ec200c99f4ce93b3bc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle index_next when changing to new partition.  <a href="#a41324582e188ec200c99f4ce93b3bc05">More...</a><br /></td></tr>
<tr class="separator:a41324582e188ec200c99f4ce93b3bc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96dfe4c0c75cd9b7610fef5272d11b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ab96dfe4c0c75cd9b7610fef5272d11b2">handle_ordered_index_scan</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:ab96dfe4c0c75cd9b7610fef5272d11b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common routine to start index scan with ordered results.  <a href="#ab96dfe4c0c75cd9b7610fef5272d11b2">More...</a><br /></td></tr>
<tr class="separator:ab96dfe4c0c75cd9b7610fef5272d11b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470f20f37a05392c36ca06368582e1a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a470f20f37a05392c36ca06368582e1a8">handle_ordered_index_scan_key_not_found</a> ()</td></tr>
<tr class="memdesc:a470f20f37a05392c36ca06368582e1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add index_next/prev results from partitions without exact match.  <a href="#a470f20f37a05392c36ca06368582e1a8">More...</a><br /></td></tr>
<tr class="separator:a470f20f37a05392c36ca06368582e1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c89791b47b39be55721f81e62829296"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a6c89791b47b39be55721f81e62829296">handle_ordered_prev</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a6c89791b47b39be55721f81e62829296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common routine to handle index_prev with ordered results.  <a href="#a6c89791b47b39be55721f81e62829296">More...</a><br /></td></tr>
<tr class="separator:a6c89791b47b39be55721f81e62829296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30779a0ff6dae8bf655ae6825dffdbc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a30779a0ff6dae8bf655ae6825dffdbc8">handle_ordered_next</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_next_same)</td></tr>
<tr class="memdesc:a30779a0ff6dae8bf655ae6825dffdbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common routine to handle index_next with ordered results.  <a href="#a30779a0ff6dae8bf655ae6825dffdbc8">More...</a><br /></td></tr>
<tr class="separator:a30779a0ff6dae8bf655ae6825dffdbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0df1ffcbf2ddd17668d4a998062826"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a6d0df1ffcbf2ddd17668d4a998062826">common_index_read</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> have_start_key)</td></tr>
<tr class="memdesc:a6d0df1ffcbf2ddd17668d4a998062826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common routine for a number of index_read variants.  <a href="#a6d0df1ffcbf2ddd17668d4a998062826">More...</a><br /></td></tr>
<tr class="separator:a6d0df1ffcbf2ddd17668d4a998062826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18afc879b5be450c4aaf155ba4625b12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a18afc879b5be450c4aaf155ba4625b12">common_first_last</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a18afc879b5be450c4aaf155ba4625b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common routine for index_first/index_last.  <a href="#a18afc879b5be450c4aaf155ba4625b12">More...</a><br /></td></tr>
<tr class="separator:a18afc879b5be450c4aaf155ba4625b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0816ddff787fdba8c87ccc3b866f2596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a0816ddff787fdba8c87ccc3b866f2596">return_top_record</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *buf)</td></tr>
<tr class="memdesc:a0816ddff787fdba8c87ccc3b866f2596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the top record in sort order.  <a href="#a0816ddff787fdba8c87ccc3b866f2596">More...</a><br /></td></tr>
<tr class="separator:a0816ddff787fdba8c87ccc3b866f2596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c7169bc4d90c5da290cf5eb89d33a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ad4c7169bc4d90c5da290cf5eb89d33a9">set_partition_read_set</a> ()</td></tr>
<tr class="memdesc:ad4c7169bc4d90c5da290cf5eb89d33a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set table-&gt;read_set taking partitioning expressions into account.  <a href="#ad4c7169bc4d90c5da290cf5eb89d33a9">More...</a><br /></td></tr>
<tr class="separator:ad4c7169bc4d90c5da290cf5eb89d33a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a45c329c2ed63e51fb2d74a8f2f84ce03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a45c329c2ed63e51fb2d74a8f2f84ce03">m_handler</a></td></tr>
<tr class="memdesc:a45c329c2ed63e51fb2d74a8f2f84ce03"><td class="mdescLeft">&#160;</td><td class="mdescRight">handler to use (ha_innopart etc.)  <a href="#a45c329c2ed63e51fb2d74a8f2f84ce03">More...</a><br /></td></tr>
<tr class="separator:a45c329c2ed63e51fb2d74a8f2f84ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b66b4c2d36f1410b5bf1ac492cc48c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPartition__share.html">Partition_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a7b66b4c2d36f1410b5bf1ac492cc48c3">m_part_share</a></td></tr>
<tr class="memdesc:a7b66b4c2d36f1410b5bf1ac492cc48c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition share for auto_inc handling.  <a href="#a7b66b4c2d36f1410b5bf1ac492cc48c3">More...</a><br /></td></tr>
<tr class="separator:a7b66b4c2d36f1410b5bf1ac492cc48c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd2c2d2a13273db60ffb1ca66b9adf1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a2dd2c2d2a13273db60ffb1ca66b9adf1">enum_using_ref</a> { <a class="el" href="classPartition__helper.html#a2dd2c2d2a13273db60ffb1ca66b9adf1ae0f6c9ce94ce6b84b805339885643fb3">REF_NOT_USED</a> = 0, 
<a class="el" href="classPartition__helper.html#a2dd2c2d2a13273db60ffb1ca66b9adf1a9eca90525ff6fda83a90d01dbfeb3d14">REF_STORED_IN_PQ</a>, 
<a class="el" href="classPartition__helper.html#a2dd2c2d2a13273db60ffb1ca66b9adf1a7bd268eff39730c71a9021f881b07337">REF_USED_FOR_SORT</a>
 }</td></tr>
<tr class="separator:a2dd2c2d2a13273db60ffb1ca66b9adf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f923b6267c3cb5ba564beba35c453df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpartition__info.html">partition_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a3f923b6267c3cb5ba564beba35c453df">m_part_info</a></td></tr>
<tr class="memdesc:a3f923b6267c3cb5ba564beba35c453df"><td class="mdescLeft">&#160;</td><td class="mdescRight">All internal partitioning data!  <a href="#a3f923b6267c3cb5ba564beba35c453df">More...</a><br /></td></tr>
<tr class="separator:a3f923b6267c3cb5ba564beba35c453df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852dc28cead1da9ce8bd3e72a95b45fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a852dc28cead1da9ce8bd3e72a95b45fb">m_pkey_is_clustered</a></td></tr>
<tr class="memdesc:a852dc28cead1da9ce8bd3e72a95b45fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is primary key clustered.  <a href="#a852dc28cead1da9ce8bd3e72a95b45fb">More...</a><br /></td></tr>
<tr class="separator:a852dc28cead1da9ce8bd3e72a95b45fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb57748f7c4f5fc4f43f8276f6c48ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5cb57748f7c4f5fc4f43f8276f6c48ae">m_is_sub_partitioned</a></td></tr>
<tr class="memdesc:a5cb57748f7c4f5fc4f43f8276f6c48ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached value of m_part_info-&gt;is_sub_partitioned().  <a href="#a5cb57748f7c4f5fc4f43f8276f6c48ae">More...</a><br /></td></tr>
<tr class="separator:a5cb57748f7c4f5fc4f43f8276f6c48ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5226dbbe405ca4974a8dee9b910b6d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a5226dbbe405ca4974a8dee9b910b6d0a">m_tot_parts</a></td></tr>
<tr class="memdesc:a5226dbbe405ca4974a8dee9b910b6d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of partitions.  <a href="#a5226dbbe405ca4974a8dee9b910b6d0a">More...</a><br /></td></tr>
<tr class="separator:a5226dbbe405ca4974a8dee9b910b6d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10de1de75ca1c130b805dcd4439d489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ab10de1de75ca1c130b805dcd4439d489">m_last_part</a></td></tr>
<tr class="separator:ab10de1de75ca1c130b805dcd4439d489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3a794bb8c49d2c6947f6a46e216fe1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a2e3a794bb8c49d2c6947f6a46e216fe1">m_err_rec</a></td></tr>
<tr class="separator:a2e3a794bb8c49d2c6947f6a46e216fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e2ff55e365d13379b755dcf620fd00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a87e2ff55e365d13379b755dcf620fd00">m_auto_increment_safe_stmt_log_lock</a></td></tr>
<tr class="separator:a87e2ff55e365d13379b755dcf620fd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2facfb803d0f4105accba9afb693ba93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a2facfb803d0f4105accba9afb693ba93">m_auto_increment_lock</a></td></tr>
<tr class="separator:a2facfb803d0f4105accba9afb693ba93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc77088ac861b3065ae75d2db68f6ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpart__id__range.html">part_id_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a0fc77088ac861b3065ae75d2db68f6ab">m_part_spec</a></td></tr>
<tr class="separator:a0fc77088ac861b3065ae75d2db68f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54832ff562b6dfa256fd6dfe80fa6b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a54832ff562b6dfa256fd6dfe80fa6b69">m_scan_value</a></td></tr>
<tr class="separator:a54832ff562b6dfa256fd6dfe80fa6b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce368a659ec7d646ef2b60e904c4ffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkey__range.html">key_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#abce368a659ec7d646ef2b60e904c4ffc">m_start_key</a></td></tr>
<tr class="separator:abce368a659ec7d646ef2b60e904c4ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1661c58c24f402ff0d7ae3a814bcb6d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678">partition_index_scan_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#ab1661c58c24f402ff0d7ae3a814bcb6d">m_index_scan_type</a></td></tr>
<tr class="separator:ab1661c58c24f402ff0d7ae3a814bcb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a84f01836276fe0f927783895ce370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a14a84f01836276fe0f927783895ce370">m_rec_length</a></td></tr>
<tr class="separator:a14a84f01836276fe0f927783895ce370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7979176e3710a34d248f03b854f7c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a2c7979176e3710a34d248f03b854f7c2">m_ordered</a></td></tr>
<tr class="separator:a2c7979176e3710a34d248f03b854f7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0c3c33678849d684c2ca5eadb551ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a8d0c3c33678849d684c2ca5eadb551ae">m_ordered_scan_ongoing</a></td></tr>
<tr class="separator:a8d0c3c33678849d684c2ca5eadb551ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4427ddab67516ac557ad36b3cdcedad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a4427ddab67516ac557ad36b3cdcedad8">m_reverse_order</a></td></tr>
<tr class="separator:a4427ddab67516ac557ad36b3cdcedad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac5d0f451a5f2c7c40e708e91766e6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#abac5d0f451a5f2c7c40e708e91766e6f">m_ordered_rec_buffer</a></td></tr>
<tr class="memdesc:abac5d0f451a5f2c7c40e708e91766e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row and key buffer for ordered index scan.  <a href="#abac5d0f451a5f2c7c40e708e91766e6f">More...</a><br /></td></tr>
<tr class="separator:abac5d0f451a5f2c7c40e708e91766e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071ce63f960f15ca6bda1755958d555f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPartition__helper.html#a220cae60081f437684607865c72339e8">Prio_queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a071ce63f960f15ca6bda1755958d555f">m_queue</a></td></tr>
<tr class="memdesc:a071ce63f960f15ca6bda1755958d555f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prio queue used by sorted read.  <a href="#a071ce63f960f15ca6bda1755958d555f">More...</a><br /></td></tr>
<tr class="separator:a071ce63f960f15ca6bda1755958d555f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdfff6182c6c837319c1abe7bf7c6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a1bdfff6182c6c837319c1abe7bf7c6e8">m_top_entry</a></td></tr>
<tr class="memdesc:a1bdfff6182c6c837319c1abe7bf7c6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which partition is to deliver next result.  <a href="#a1bdfff6182c6c837319c1abe7bf7c6e8">More...</a><br /></td></tr>
<tr class="separator:a1bdfff6182c6c837319c1abe7bf7c6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba25c469f2f83f3d19bb3232859e8297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aba25c469f2f83f3d19bb3232859e8297">m_rec_offset</a></td></tr>
<tr class="memdesc:aba25c469f2f83f3d19bb3232859e8297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset in m_ordered_rec_buffer from part buffer to its record buffer.  <a href="#aba25c469f2f83f3d19bb3232859e8297">More...</a><br /></td></tr>
<tr class="separator:aba25c469f2f83f3d19bb3232859e8297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cf9c194a25b44c10e6196e04e968a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKEY.html">KEY</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#af9cf9c194a25b44c10e6196e04e968a2">m_curr_key_info</a> [3]</td></tr>
<tr class="memdesc:af9cf9c194a25b44c10e6196e04e968a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current index used for sorting.  <a href="#af9cf9c194a25b44c10e6196e04e968a2">More...</a><br /></td></tr>
<tr class="separator:af9cf9c194a25b44c10e6196e04e968a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5eee2709a12792f7da903b3f1aca9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPartition__helper.html#a2dd2c2d2a13273db60ffb1ca66b9adf1">enum_using_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#adf5eee2709a12792f7da903b3f1aca9c">m_ref_usage</a></td></tr>
<tr class="memdesc:adf5eee2709a12792f7da903b3f1aca9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">How handler::ref is used in the priority queue.  <a href="#adf5eee2709a12792f7da903b3f1aca9c">More...</a><br /></td></tr>
<tr class="separator:adf5eee2709a12792f7da903b3f1aca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2b5acc743493d38db2ac2beca2dc91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#aca2b5acc743493d38db2ac2beca2dc91">m_key_not_found</a></td></tr>
<tr class="memdesc:aca2b5acc743493d38db2ac2beca2dc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if previous index_* call returned HA_ERR_KEY_NOT_FOUND.  <a href="#aca2b5acc743493d38db2ac2beca2dc91">More...</a><br /></td></tr>
<tr class="separator:aca2b5acc743493d38db2ac2beca2dc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562467eae6cb6797159e824119b89c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMY__BITMAP.html">MY_BITMAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartition__helper.html#a562467eae6cb6797159e824119b89c78">m_key_not_found_partitions</a></td></tr>
<tr class="memdesc:a562467eae6cb6797159e824119b89c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions that returned HA_ERR_KEY_NOT_FOUND.  <a href="#a562467eae6cb6797159e824119b89c78">More...</a><br /></td></tr>
<tr class="separator:a562467eae6cb6797159e824119b89c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Partition_helper is a helper class that implements most generic partitioning functionality such as: table scan, index scan (both ordered and non-ordered), insert (write_row()), delete and update. </p>
<p>And includes ALTER TABLE ... ADD/COALESCE/DROP/REORGANIZE/... PARTITION support. It also implements a cache for the auto increment value and check/repair for rows in wrong partition.</p>
<p>How to use it: Inherit it and implement:</p><ul>
<li>*_in_part() functions for row operations.</li>
<li>write_row_in_new_part() for handling 'fast' alter partition. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a220cae60081f437684607865c72339e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220cae60081f437684607865c72339e8">&#9670;&nbsp;</a></span>Prio_queue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPriority__queue.html">Priority_queue</a>&lt;<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, std::vector&lt;<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&gt;, <a class="el" href="structKey__rec__less.html">Key_rec_less</a>&gt; <a class="el" href="classPartition__helper.html#a220cae60081f437684607865c72339e8">Partition_helper::Prio_queue</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2dd2c2d2a13273db60ffb1ca66b9adf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd2c2d2a13273db60ffb1ca66b9adf1">&#9670;&nbsp;</a></span>enum_using_ref</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPartition__helper.html#a2dd2c2d2a13273db60ffb1ca66b9adf1">Partition_helper::enum_using_ref</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2dd2c2d2a13273db60ffb1ca66b9adf1ae0f6c9ce94ce6b84b805339885643fb3"></a>REF_NOT_USED&#160;</td><td class="fielddoc"><p>handler::ref is not copied to the PQ. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2dd2c2d2a13273db60ffb1ca66b9adf1a9eca90525ff6fda83a90d01dbfeb3d14"></a>REF_STORED_IN_PQ&#160;</td><td class="fielddoc"><p>handler::ref is copied to the PQ but does not need to be used in sorting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2dd2c2d2a13273db60ffb1ca66b9adf1a7bd268eff39730c71a9021f881b07337"></a>REF_USED_FOR_SORT&#160;</td><td class="fielddoc"><p>handler::ref is copied to the PQ and must be used during sorting. </p>
</td></tr>
</table>

</div>
</div>
<a id="aae15aadd4e7854e705866b9952014678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae15aadd4e7854e705866b9952014678">&#9670;&nbsp;</a></span>partition_index_scan_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678">Partition_helper::partition_index_scan_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae15aadd4e7854e705866b9952014678a439459ee87965f3fbc90ed6513428274"></a>PARTITION_INDEX_READ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae15aadd4e7854e705866b9952014678a4cd5c771b0b5ae42fcc058af17d911de"></a>PARTITION_INDEX_FIRST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae15aadd4e7854e705866b9952014678a2f8011724b67faa6bb00d79a69bc06cd"></a>PARTITION_INDEX_FIRST_UNORDERED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae15aadd4e7854e705866b9952014678a5589b5e0ff1678a4e70ad672cab646a0"></a>PARTITION_INDEX_LAST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae15aadd4e7854e705866b9952014678af054714e88dcf526bbb0a696e60eec80"></a>PARTITION_INDEX_READ_LAST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae15aadd4e7854e705866b9952014678a855eee4cbd45f0e3bc59107534b0e3df"></a>PARTITION_READ_RANGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae15aadd4e7854e705866b9952014678a85f866fd8f07d685178877c4e4c89cbf"></a>PARTITION_NO_INDEX_SCAN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a15e606f4498a1640d68976b310a0a74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e606f4498a1640d68976b310a0a74a">&#9670;&nbsp;</a></span>Partition_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Partition_helper::Partition_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandler.html">handler</a> *&#160;</td>
          <td class="paramname"><em>main_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d34eb47df150130fff01bd4662de532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d34eb47df150130fff01bd4662de532">&#9670;&nbsp;</a></span>~Partition_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Partition_helper::~Partition_helper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a662b113c5b1fe57269af6b0611a9280e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662b113c5b1fe57269af6b0611a9280e">&#9670;&nbsp;</a></span>check_misplaced_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::check_misplaced_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>read_part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>repair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check/fix misplaced rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_part_id</td><td>Partition to check/fix. </td></tr>
    <tr><td class="paramname">repair</td><td>If true, move misplaced rows to correct partition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa80520af5c8647951f57128302b4ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa80520af5c8647951f57128302b4ad2">&#9670;&nbsp;</a></span>checksum_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__MYSYS.html#ga31ef2f6273d26427fe4a13ed5049b050">ha_checksum</a> Partition_helper::checksum_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checksum for a partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_id</td><td>Partition to checksum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af811551fba3956755941e049e4b1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af811551fba3956755941e049e4b1f0">&#9670;&nbsp;</a></span>close_partitioning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::close_partitioning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close partitioning for a table. </p>
<p>Frees memory and release other resources. </p>

</div>
</div>
<a id="a18afc879b5be450c4aaf155ba4625b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18afc879b5be450c4aaf155ba4625b12">&#9670;&nbsp;</a></span>common_first_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::common_first_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common routine for index_first/index_last. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d0df1ffcbf2ddd17668d4a998062826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0df1ffcbf2ddd17668d4a998062826">&#9670;&nbsp;</a></span>common_index_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::common_index_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>have_start_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common routine for a number of index_read variants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer where the record should be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">have_start_key</td><td>true &lt;=&gt; the left endpoint is available, i.e. we're in index_read call or in read_range_first call and the range has left endpoint. false &lt;=&gt; there is no left endpoint (we're in read_range_first() call and the range has no left endpoint).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Whole index scanned, without finding the record. </td></tr>
    <tr><td class="paramname">HA_ERR_KEY_NOT_FOUND</td><td>Record not found, but index cursor positioned. </td></tr>
    <tr><td class="paramname">other</td><td>Error code.</td></tr>
  </table>
  </dd>
</dl>
<p>Start scanning the range (when invoked from read_range_first()) or doing an index lookup (when invoked from index_read_XXX):</p><ul>
<li>If possible, perform partition selection</li>
<li>Find the set of partitions we're going to use</li>
<li>Depending on whether we need ordering: NO: Get the first record from first used partition (see handle_unordered_scan_next_partition) YES: Fill the priority queue and get the record that is the first in the ordering </li>
</ul>

</div>
</div>
<a id="a378c1d786efb0d92668aee3d913051d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378c1d786efb0d92668aee3d913051d0">&#9670;&nbsp;</a></span>copy_cached_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partition_helper::copy_cached_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>to_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>from_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a cached row. </p>
<p>Used when copying a row from the record priority queue to the return buffer. For some engines, like InnoDB, only marked columns must be copied, to preserve non-read columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to_rec</td><td>Buffer to copy to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_rec</td><td>Buffer to copy from. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga1f61acb268d52fe8e0e8201be33d3864">ha_innopart</a>.</p>

</div>
</div>
<a id="acd21687bbd51dd22fffba5d032611c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd21687bbd51dd22fffba5d032611c74">&#9670;&nbsp;</a></span>copy_partitions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::copy_partitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *const&#160;</td>
          <td class="paramname"><em>deleted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy partitions as part of ALTER TABLE of partitions. </p>
<p>SE and prepare_change_partitions has done all the preparations, now it is time to actually copy the data from the reorganized partitions to the new partitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">deleted</td><td>Number of records deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d8a9d4378532412520f658832aebe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8a9d4378532412520f658832aebe91">&#9670;&nbsp;</a></span>delete_row_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::delete_row_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an existing row in the specified partition. </p>
<dl class="section see"><dt>See also</dt><dd>handler::delete_row().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_id</td><td>Partition to delete from. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer containing row to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga871332ed92313fc5e65cc2ebc89b72b7">ha_innopart</a>.</p>

</div>
</div>
<a id="a8d75a2e65409288375dc50ed45237972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d75a2e65409288375dc50ed45237972">&#9670;&nbsp;</a></span>destroy_record_priority_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::destroy_record_priority_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the record priority queue used for sorted index scans. </p>
<p>Destroy the ordered record buffer and the priority queue. </p>

</div>
</div>
<a id="a1486153d959b44f9643ddc33671b9283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1486153d959b44f9643ddc33671b9283">&#9670;&nbsp;</a></span>destroy_record_priority_queue_for_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partition_helper::destroy_record_priority_queue_for_parts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy and release engine specific resources used by the record priority queue. </p>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga0bd854d802dffba36d7635f9aaa6fc5d">ha_innopart</a>.</p>

</div>
</div>
<a id="a1ae9d6cb652ac8f6e1a9b39958578ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae9d6cb652ac8f6e1a9b39958578ffa">&#9670;&nbsp;</a></span>get_auto_increment_first_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::get_auto_increment_first_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a range of auto increment values. </p>
<p>Can only be used if the auto increment field is the first field in an index.</p>
<p>This method is called by update_auto_increment which in turn is called by the individual handlers as part of write_row. We use the part_share-&gt;next_auto_inc_val, or search all partitions for the highest auto_increment_value if not initialized or if auto_increment field is a secondary part of a key, we must search every partition when holding a mutex to be sure of correctness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">increment</td><td>Increment value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_desired_values</td><td>Number of desired values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_value</td><td>First auto inc value reserved or MAX if failure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_reserved_values</td><td>Number of values reserved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae984c0efde3d99693244a508bff8398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae984c0efde3d99693244a508bff8398e">&#9670;&nbsp;</a></span>get_dynamic_partition_info_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::get_dynamic_partition_info_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classha__statistics.html">ha_statistics</a> *&#160;</td>
          <td class="paramname"><em>stat_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MYSYS.html#ga31ef2f6273d26427fe4a13ed5049b050">ha_checksum</a> *&#160;</td>
          <td class="paramname"><em>check_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functions matching Partition_handler API. </p>
<p>Get statistics from a specific partition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stat_info</td><td>Area to report values into. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">check_sum</td><td>Check sum of partition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">part_id</td><td>Partition to report from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc03a956eb8be074ff04fbc161e70188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc03a956eb8be074ff04fbc161e70188">&#9670;&nbsp;</a></span>get_eq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::get_eq_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classha__innopart.html#af8f36f269c08b5d873d6b315f8bd5741">ha_innopart</a>.</p>

</div>
</div>
<a id="a87c6ab707c75086457a7e44dafc75640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c6ab707c75086457a7e44dafc75640">&#9670;&nbsp;</a></span>get_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structTABLE.html">TABLE</a>* Partition_helper::get_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classha__innopart.html#a2bf7c94daf280ec61e09301dc06cbb67">ha_innopart</a>.</p>

</div>
</div>
<a id="a0c0c76737233fc59a603a166813c0f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0c76737233fc59a603a166813c0f85">&#9670;&nbsp;</a></span>get_thd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTHD.html">THD</a>* Partition_helper::get_thd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classha__innopart.html#ae3e7636c09330f04cc8dddc098d1cc92">ha_innopart</a>.</p>

</div>
</div>
<a id="ab96dfe4c0c75cd9b7610fef5272d11b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96dfe4c0c75cd9b7610fef5272d11b2">&#9670;&nbsp;</a></span>handle_ordered_index_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::handle_ordered_index_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common routine to start index scan with ordered results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>End of scan </td></tr>
    <tr><td class="paramname">HA_ERR_KEY_NOT_FOUND</td><td>End of scan </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Error code</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>End of scan </td></tr>
    <tr><td class="paramname">HA_ERR_KEY_NOT_FOUND</td><td>End of scan </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Error code</td></tr>
  </table>
  </dd>
</dl>
<p>This part contains the logic to handle index scans that require ordered output. This includes all except those started by read_range_first with the flag ordered set to false. Thus most direct index_read and all index_first and index_last.</p>
<p>We implement ordering by keeping one record plus a key buffer for each partition. Every time a new entry is requested we will fetch a new entry from the partition that is currently not filled with an entry. Then the entry is put into its proper sort position.</p>
<p>Returning a record is done by getting the top record, copying the record to the request buffer and setting the partition as empty on entries. </p>

</div>
</div>
<a id="a470f20f37a05392c36ca06368582e1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470f20f37a05392c36ca06368582e1a8">&#9670;&nbsp;</a></span>handle_ordered_index_scan_key_not_found()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::handle_ordered_index_scan_key_not_found </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add index_next/prev results from partitions without exact match. </p>
<p>If there where any partitions that returned HA_ERR_KEY_NOT_FOUND when ha_index_read_map was done, those partitions must be included in the following index_next/prev call.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>End of scan </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Error code</td></tr>
  </table>
  </dd>
</dl>
<p>If there where any partitions that returned HA_ERR_KEY_NOT_FOUND when ha_index_read_map was done, those partitions must be included in the following index_next/prev call. </p>

</div>
</div>
<a id="a30779a0ff6dae8bf655ae6825dffdbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30779a0ff6dae8bf655ae6825dffdbc8">&#9670;&nbsp;</a></span>handle_ordered_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::handle_ordered_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_next_same</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common routine to handle index_next with ordered results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_next_same</td><td>Called from index_next_same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>End of scan </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c89791b47b39be55721f81e62829296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c89791b47b39be55721f81e62829296">&#9670;&nbsp;</a></span>handle_ordered_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::handle_ordered_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common routine to handle index_prev with ordered results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>End of scan </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5afa66a5e5e7ad01ea1b0ab5e5720ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afa66a5e5e7ad01ea1b0ab5e5720ba1">&#9670;&nbsp;</a></span>handle_unordered_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::handle_unordered_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_next_same</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common routine to handle index_next with unordered results. </p>
<p>These routines are used to scan partitions without considering order. This is performed in two situations. 1) In read_multi_range this is the normal case 2) When performing any type of index_read, index_first, index_last where all fields in the partition function is bound. In this case the index scan is performed on only one partition and thus it isn't necessary to perform any sort.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_next_same</td><td>Called from index_next_same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>End of scan </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41324582e188ec200c99f4ce93b3bc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41324582e188ec200c99f4ce93b3bc05">&#9670;&nbsp;</a></span>handle_unordered_scan_next_partition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::handle_unordered_scan_next_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle index_next when changing to new partition. </p>
<p>This routine is used to start the index scan on the next partition. Both initial start and after completing scan on one partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>End of scan </td></tr>
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadcf12377f2fb4da0d30bc9701ecc1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcf12377f2fb4da0d30bc9701ecc1f1">&#9670;&nbsp;</a></span>index_first_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_first_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga8486801734fc9865863d8ccfc90b2210">ha_innopart</a>.</p>

</div>
</div>
<a id="ae0202e16bc9ded962e8a6358a06663b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0202e16bc9ded962e8a6358a06663b6">&#9670;&nbsp;</a></span>index_last_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_last_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga2cd803f4cbbbc5731dfc61f52bd61dff">ha_innopart</a>.</p>

</div>
</div>
<a id="a5e2475c952726c8ad5c2127f65c2ae60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2475c952726c8ad5c2127f65c2ae60">&#9670;&nbsp;</a></span>index_next_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_next_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#gadf176fcfe5def0413d9ed35f0d9341c3">ha_innopart</a>.</p>

</div>
</div>
<a id="acbfe18f89363bbfe2f32e3e55c70a32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfe18f89363bbfe2f32e3e55c70a32a">&#9670;&nbsp;</a></span>index_next_same_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_next_same_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga7c7190bf771039ed268073e92ac6271f">ha_innopart</a>.</p>

</div>
</div>
<a id="abb8017cc21f54ef9d182b04c35d001dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8017cc21f54ef9d182b04c35d001dd">&#9670;&nbsp;</a></span>index_prev_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_prev_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#gaca66fbda97ed62a930d4cf5fd64ff64e">ha_innopart</a>.</p>

</div>
</div>
<a id="a66b8c807ad9c0666a6be2a5f76a741b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b8c807ad9c0666a6be2a5f76a741b5">&#9670;&nbsp;</a></span>index_read_idx_map_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_read_idx_map_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#gab045471e3cf7716034d53992750e3b6d">ha_innopart</a>.</p>

</div>
</div>
<a id="abe6379d75823eb997e618519aa740637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6379d75823eb997e618519aa740637">&#9670;&nbsp;</a></span>index_read_last_map_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_read_last_map_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#gaf8ce69ff7021a6b8bb9c754b755716f1">ha_innopart</a>.</p>

</div>
</div>
<a id="a1b94a805363282febc185263c5e45bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b94a805363282febc185263c5e45bd7">&#9670;&nbsp;</a></span>index_read_map_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::index_read_map_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga5f9a1294d97f3fd0525806833e30bcc0">ha_innopart</a>.</p>

</div>
</div>
<a id="ac19f3b7788c9d6c09637c1c487e0058e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19f3b7788c9d6c09637c1c487e0058e">&#9670;&nbsp;</a></span>init_partitioning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::init_partitioning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>mem_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize variables used before the table is opened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_root</td><td>Memory root to allocate things from (not yet used).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>success. </td></tr>
    <tr><td class="paramname">true</td><td>failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebea96fab34a0fb8118455d787892a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebea96fab34a0fb8118455d787892a00">&#9670;&nbsp;</a></span>init_record_priority_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::init_record_priority_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the record priority queue used for sorted index scans. </p>
<p>Setup the ordered record buffer and the priority queue.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code.</td></tr>
  </table>
  </dd>
</dl>
<p>Call destroy_record_priority_queue() to deallocate or clean-up from failure.</p>
<dl class="section return"><dt>Returns</dt><dd>false on success, else true. </dd></dl>

</div>
</div>
<a id="a9a91eebe7195eb16a07ff333f2262251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a91eebe7195eb16a07ff333f2262251">&#9670;&nbsp;</a></span>init_record_priority_queue_for_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::init_record_priority_queue_for_parts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>used_parts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize engine specific resources for the record priority queue used duing ordered index reads for multiple partitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">used_parts</td><td>Number of partitions used in query (number of set bits in m_part_info-&gt;read_partitions).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga5a54209d43be9f9e301e68a4a8d4b528">ha_innopart</a>.</p>

</div>
</div>
<a id="ada5c4efe169bd33304f5e25f8ec17647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5c4efe169bd33304f5e25f8ec17647">&#9670;&nbsp;</a></span>initialize_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::initialize_auto_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>no_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the shared auto increment value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no_lock</td><td>If HA_STATUS_NO_LOCK should be used in info(HA_STATUS_AUTO).</td></tr>
  </table>
  </dd>
</dl>
<p>Also sets stats.auto_increment_value. </p>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga71bc245164b1d3ca3a6983191451281d">ha_innopart</a>.</p>

</div>
</div>
<a id="abeecebe45928e398ea3afc914bfcfe87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeecebe45928e398ea3afc914bfcfe87">&#9670;&nbsp;</a></span>lock_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::lock_auto_increment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock auto increment value if needed. </p>

</div>
</div>
<a id="a78223999427251c9856daaec550a1d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78223999427251c9856daaec550a1d1d">&#9670;&nbsp;</a></span>open_partitioning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::open_partitioning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartition__share.html">Partition_share</a> *&#160;</td>
          <td class="paramname"><em>part_share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set m_part_share, Allocate internal bitmaps etc. </p>
<p>Initialize the partitioning helper for use after the table is opened.</p>
<p>used by open tables.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>success. </td></tr>
    <tr><td class="paramname">true</td><td>failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_share</td><td>Partitioning share (used for auto increment).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>for success otherwise true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef130f7979bc429bf9a3f31b19379c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef130f7979bc429bf9a3f31b19379c5f">&#9670;&nbsp;</a></span>partition_scan_set_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::partition_scan_set_up </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>idx_read_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common routine to set up index scans. </p>
<p>Find out which partitions we'll need to read when scanning the specified range.</p>
<p>If we need to scan only one partition, set m_ordered_scan_ongoing=false as we will not need to do merge ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to later return record in (this function needs it to calculate partitioning function values)</td></tr>
    <tr><td class="paramname">idx_read_flag</td><td>True &lt;=&gt; m_start_key has range start endpoint which probably can be used to determine the set of partitions to scan. False &lt;=&gt; there is no start endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=0</td><td>Error code</td></tr>
  </table>
  </dd>
</dl>
<p>Find out which partitions we'll need to read when scanning the specified range.</p>
<p>If we need to scan only one partition, set m_ordered_scan_ongoing=false as we will not need to do merge ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to later return record in (this function needs it to calculate partitioning function values)</td></tr>
    <tr><td class="paramname">idx_read_flag</td><td>true &lt;=&gt; m_start_key has range start endpoint which probably can be used to determine the set of partitions to scan. false &lt;=&gt; there is no start endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f4c35aadc6e54b0a10279633be79845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4c35aadc6e54b0a10279633be79845">&#9670;&nbsp;</a></span>ph_calculate_key_hash_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> Partition_helper::ph_calculate_key_hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>field_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate key hash value from an null terminated array of fields. </p>
<p>Support function for KEY partitioning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_array</td><td>An array of the fields in KEY partitioning</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash_value calculated</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses the hash function on the character set of the field. Integer and floating point fields use the binary character set by default. </dd></dl>

</div>
</div>
<a id="ae1de2e31241c899a076ea0068cfc6570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1de2e31241c899a076ea0068cfc6570">&#9670;&nbsp;</a></span>ph_delete_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_delete_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing row in the partitioned table. </p>
<p>This will delete a row. buf will contain a copy of the row to be deleted. The server will call this right after the current row has been read (from either a previous rnd_xxx() or index_xxx() call). If you keep a pointer to the last row or can access a primary key it will make doing the deletion quite a bit easier. Keep in mind that the server does no guarantee consecutive deletions. ORDER BY clauses can be used.</p>
<p>buf is either record[0] or record[1]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The record in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00e474054bff81d327f19e3f214d0c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e474054bff81d327f19e3f214d0c0d">&#9670;&nbsp;</a></span>ph_index_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an index scan from leftmost record and return first record. </p>
<p>index_first() asks for the first key in the index. This is similar to index_read except that there is no start key since the scan starts from the leftmost entry and proceeds forward with index_next.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addc09bd30772de1c0bf5a1070fe4d17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc09bd30772de1c0bf5a1070fe4d17d">&#9670;&nbsp;</a></span>ph_index_init_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_init_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>inx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MODULE index scan. </p>
<p>Common setup for index_init.</p>
<p>This part of the handler interface is used to perform access through indexes. The interface is defined as a scan interface but the handler can also use key lookup if the index is a unique index or a primary key index. Index scans are mostly useful for SELECT queries but are an important part also of UPDATE, DELETE, REPLACE and CREATE TABLE table AS SELECT and so forth. Naturally an index is needed for an index scan and indexes can either be ordered, hash based. Some ordered indexes can return data in order but not necessarily all of them. There are many flags that define the behavior of indexes in the </p><h2>various handlers. These methods are found in the optimizer module. </h2>
<p>index_read is called to start a scan of an index. The find_flag defines the semantics of the scan. These flags are defined in include/my_base.h index_read_idx is the same but also initializes index before calling doing the same thing as index_read. Thus it is similar to index_init followed by index_read. This is also how we implement it.</p>
<p>index_read/index_read_idx does also return the first row. Thus for key lookups, the index_read will be the only call to the handler in the index scan.</p>
<p>index_init initializes an index before using it and index_end does any end processing needed.</p>
<p>Set up variables and initialize the record priority queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inx</td><td>Index to be used. </td></tr>
    <tr><td class="paramname">sorted</td><td>True if the rows must be returned in index order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec894e99f298f59f87249324914bceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec894e99f298f59f87249324914bceb">&#9670;&nbsp;</a></span>ph_index_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an index scan from rightmost record and return first record. </p>
<p>index_last() asks for the last key in the index. This is similar to index_read except that there is no start key since the scan starts from the rightmost entry and proceeds forward with index_prev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb52147154875848e1be8fc392ba687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb52147154875848e1be8fc392ba687">&#9670;&nbsp;</a></span>ph_index_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next record in a forward index scan. </p>
<p>Used to read forward through the index (left to right, low to high).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4952a27eab71a53d0bfed0f3375716ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4952a27eab71a53d0bfed0f3375716ac">&#9670;&nbsp;</a></span>ph_index_next_same()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_next_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next same record. </p>
<p>This routine is used to read the next but only if the key is the same as supplied in the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keylen</td><td>Length of key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27ae8e19f3929f2ccbc11711ff5a2390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ae8e19f3929f2ccbc11711ff5a2390">&#9670;&nbsp;</a></span>ph_index_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next record when performing index scan backwards. </p>
<p>Used to read backwards through the index (right to left, high to low).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94ecb3bcd4435cfe60c5285c2f67efb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ecb3bcd4435cfe60c5285c2f67efb9">&#9670;&nbsp;</a></span>ph_index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read index by key and keymap. </p>
<p>Positions an index cursor to the index specified. Fetches the row if available. If the key value is null, begin at first key of the index.</p>
<p>Optimization of the default implementation to take advantage of dynamic partition pruning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keypart_map</td><td>Which part of key is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">find_flag</td><td>Direction/how to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3cfd9fa41cd0317d261b781b4514923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cfd9fa41cd0317d261b781b4514923">&#9670;&nbsp;</a></span>ph_index_read_last_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_read_last_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read last using key. </p>
<p>This is used in join_read_last_key to optimize away an ORDER BY. Can only be used on indexes supporting HA_READ_ORDER.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keypart_map</td><td>Which part of key is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1123015210554cb81fb17584e9040c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1123015210554cb81fb17584e9040c1e">&#9670;&nbsp;</a></span>ph_index_read_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_index_read_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a>&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#a842536653de5adad090382ec4ddd150f">ha_rkey_function</a>&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one record in an index scan and start an index scan. </p>
<p>index_read_map starts a new index scan using a start key. The MySQL Server will check the end key on its own. Thus to function properly the partitioned handler need to ensure that it delivers records in the sort order of the MySQL Server. index_read_map can be restarted without calling index_end on the previous index scan and without calling index_init. In this case the index_read_map is on the same index as the previous index_scan. This is particularly used in conjunction with multi read ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Read row in MySQL Row Format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key parts in consecutive order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keypart_map</td><td>Which part of key is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">find_flag</td><td>What type of key condition is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8756342d79d9e976bde2a2278a87a0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8756342d79d9e976bde2a2278a87a0ed">&#9670;&nbsp;</a></span>ph_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::ph_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save position of current row. </p>
<p>position() is called after each call to rnd_next() if the data needs to be ordered or accessed later.</p>
<p>The server uses ref to store data. ref_length in the above case is the size needed to store current_position. ref is just a byte array that the server will maintain. If you are using offsets to mark rows, then current_position should be the offset. If it is a primary key like in InnoDB, then it needs to be a primary key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>Current record in MySQL Row Format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7c1cc2266cae67329541349dcd20e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c1cc2266cae67329541349dcd20e95">&#9670;&nbsp;</a></span>ph_read_range_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_read_range_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a read of one range with start and end key. </p>
<p>We re-implement read_range_first since we don't want the compare_key check at the end. This is already performed in the partition handler. read_range_next is very much different due to that we need to scan all underlying handlers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Specification of start key. </td></tr>
    <tr><td class="paramname">end_key</td><td>Specification of end key. </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Is it equal range. </td></tr>
    <tr><td class="paramname">sorted</td><td>Should records be returned in sorted order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b0759c44db5819a0165df4c21a5b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b0759c44db5819a0165df4c21a5b34">&#9670;&nbsp;</a></span>ph_read_range_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next record in read of a range with start and end key. </p>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab37610c88f4fac22f38328cc1e4c541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37610c88f4fac22f38328cc1e4c541c">&#9670;&nbsp;</a></span>ph_release_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::ph_release_auto_increment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release unused auto increment values. </p>

</div>
</div>
<a id="a8ef5933f1db11c10dbbbc94f98065e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef5933f1db11c10dbbbc94f98065e95">&#9670;&nbsp;</a></span>ph_rnd_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_rnd_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of a table scan. </p>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a411098723b56a18eed1ac9fe55726fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411098723b56a18eed1ac9fe55726fe9">&#9670;&nbsp;</a></span>ph_rnd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_rnd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MODULE full table scan. </p>
<p>Initialize engine for random reads.</p>
<p>This module is used for the most basic access method for any table handler. This is to fetch all data through a full table scan. No indexes are needed to implement this part. It contains one method to start the scan (rnd_init) that can also be called multiple times (typical in a nested loop join). Then proceeding to the next record (rnd_next) and closing the scan (rnd_end). To remember a record for later access there is a method (position) and there is a method used to retrieve the record based on the stored position. The position can be a file position, a primary key, a ROWID dependent on the handler below.</p>
<p>unlike index_init(), rnd_init() can be called two times without rnd_end() in between (it only makes sense if scan=1). then the second call should prepare for the new table scan (e.g if rnd_init allocates the cursor, second call should position it to the start of the table, no need to deallocate and allocate it again. </p><dl class="section see"><dt>See also</dt><dd>handler.h</dd></dl>
<p>rnd_init() is called when the server wants the storage engine to do a table scan or when the server wants to access data through rnd_pos.</p>
<p>When scan is used we will scan one handler partition at a time. When preparing for rnd_pos we will initialize all handler partitions. No extra cache handling is needed when scanning is not performed.</p>
<p>Before initializing we will call rnd_end to ensure that we clean up from any previous incarnation of a table scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>false for initialize for random reads through rnd_pos() true for initialize for random scan through rnd_next().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a634ba7fca5971c62c9fea2ba0378604f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634ba7fca5971c62c9fea2ba0378604f">&#9670;&nbsp;</a></span>ph_rnd_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_rnd_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read next row during full table scan (scan in random row order). </p>
<p>This is called for each row of the table scan. When you run out of records you should return HA_ERR_END_OF_FILE. The Field structure for the table is the key to getting data into buf in a manner that will allow the server to understand it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer that should be filled with data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6eae202afb8e7e38d5779ce42826aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6eae202afb8e7e38d5779ce42826aae">&#9670;&nbsp;</a></span>ph_rnd_next_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_rnd_next_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next row during full partition scan (scan in random row order). </p>
<p>This function can evaluate the virtual generated columns. If virtual generated columns are involved, you should not call rnd_next_in_part directly but this one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">part_id</td><td>Partition to read from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>buffer that should be filled with data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a7949ca4e2568b49ba0a80a4dde505c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7949ca4e2568b49ba0a80a4dde505c">&#9670;&nbsp;</a></span>ph_update_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_update_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>new_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing row in the partitioned table. </p>
<p>Yes, update_row() does what you expect, it updates a row. old_data will have the previous row record in it, while new_data will have the newest data in it. Keep in mind that the server can do updates based on ordering if an ORDER BY clause was used. Consecutive ordering is not guaranteed.</p>
<p>If the new record belongs to a different partition than the old record then it will be inserted into the new partition and deleted from the old.</p>
<p>new_data is always record[0] old_data is always record[1]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>The old record in MySQL Row Format. </td></tr>
    <tr><td class="paramname">new_data</td><td>The new record in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39d3732642cf7ded9c0db4adcd22aab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d3732642cf7ded9c0db4adcd22aab9">&#9670;&nbsp;</a></span>ph_write_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Partition_helper::ph_write_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INSERT/UPDATE/DELETE functions. </p>
<p>Insert a row to the partitioned table.</p>
<dl class="section see"><dt>See also</dt><dd>handler.h Insert a row to the partitioned table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The row in MySQL Row Format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74cbd52cd3051fdc26e519ac25e8f1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cbd52cd3051fdc26e519ac25e8f1b9">&#9670;&nbsp;</a></span>position_in_last_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partition_helper::position_in_last_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga3df7335840b583422d80a8fe1f384947">ha_innopart</a>.</p>

</div>
</div>
<a id="a98c6fffef4cdcf8bcc11064be4019351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c6fffef4cdcf8bcc11064be4019351">&#9670;&nbsp;</a></span>prepare_change_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::prepare_change_partitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare for reorganizing partitions by setting up partition_info::read_partitions according to the partition_info mark-up. </p>
<p>This is helper method which can also be used by SEs implementing support for reorganizing partitions through ALTER TABLE INPLACE SE API. </p>

</div>
</div>
<a id="a5549f355a264b52a013d372686ba9ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5549f355a264b52a013d372686ba9ef1">&#9670;&nbsp;</a></span>print_admin_msg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::print_admin_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a message row formatted for ANALYZE/CHECK/OPTIMIZE/REPAIR TABLE. </p>
<p>Modeled after mi_check_print_msg.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">len</td><td>Needed length for message buffer. </td></tr>
    <tr><td class="paramname">msg_type</td><td>Message type. </td></tr>
    <tr><td class="paramname">db_name</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">op_name</td><td>Operation name. </td></tr>
    <tr><td class="paramname">fmt</td><td>Message (in printf format with additional arguments).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>for success else true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5889223c041f0ff1e5641e23fcb46483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5889223c041f0ff1e5641e23fcb46483">&#9670;&nbsp;</a></span>print_partition_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::print_partition_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print partitioning specific error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if error is printed else true. </dd></dl>

</div>
</div>
<a id="af025065432f6f0d722fc9bc1243d490b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af025065432f6f0d722fc9bc1243d490b">&#9670;&nbsp;</a></span>read_range_first_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::read_range_first_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkey__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do read_range_first in the specified partition. </p>
<p>If buf is set, then copy the result there instead of table-&gt;record[0]. </p>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#gac370ef59960a427d3011abbba1248938">ha_innopart</a>.</p>

</div>
</div>
<a id="abe57f61ce0e105cdb5b887be30860c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe57f61ce0e105cdb5b887be30860c04">&#9670;&nbsp;</a></span>read_range_next_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::read_range_next_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do read_range_next in the specified partition. </p>
<p>If buf is set, then copy the result there instead of table-&gt;record[0]. </p>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga86571e735e2c704a080e50a01a37b5d5">ha_innopart</a>.</p>

</div>
</div>
<a id="a931aebdf4753b66b76b76b34304379d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931aebdf4753b66b76b76b34304379d6">&#9670;&nbsp;</a></span>release_auto_increment_all_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partition_helper::release_auto_increment_all_parts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release auto_increment in all underlying partitions. </p>

</div>
</div>
<a id="a0816ddff787fdba8c87ccc3b866f2596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0816ddff787fdba8c87ccc3b866f2596">&#9670;&nbsp;</a></span>return_top_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::return_top_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the top record in sort order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row returned in MySQL Row Format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a388c8f0c914c29d90649ad70de789484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388c8f0c914c29d90649ad70de789484">&#9670;&nbsp;</a></span>rnd_end_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::rnd_end_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga0b87c312b1f7d4cccf922eb3ab36fc84">ha_innopart</a>.</p>

</div>
</div>
<a id="ae2db002aa225adb01cc0d69cee4638ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2db002aa225adb01cc0d69cee4638ef">&#9670;&nbsp;</a></span>rnd_init_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::rnd_init_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>table_scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Per partition equivalent of rnd_* and index_* functions. </p>
<dl class="section see"><dt>See also</dt><dd>class handler. </dd></dl>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#gab28e455bc906298fc26983c010299769">ha_innopart</a>.</p>

</div>
</div>
<a id="ae6df63cb8cf1234403ef896c96bf3480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6df63cb8cf1234403ef896c96bf3480">&#9670;&nbsp;</a></span>rnd_next_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::rnd_next_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga09023ebd3b5958a95c822bd6d4a3d18f">ha_innopart</a>.</p>

</div>
</div>
<a id="a14e75b5b6901c53a6dfe0dec8cb3ae42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e75b5b6901c53a6dfe0dec8cb3ae42">&#9670;&nbsp;</a></span>save_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partition_helper::save_auto_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save or persist the current max auto increment. </p>

<p>Reimplemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga48b283137b6bcb427cd1399e397fe15a">ha_innopart</a>.</p>

</div>
</div>
<a id="a04b2ae0ff2314729459030b2a59e83bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b2ae0ff2314729459030b2a59e83bf">&#9670;&nbsp;</a></span>set_altered_partitions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::set_altered_partitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set used partitions bitmap from Alter_info. </p>
<dl class="section return"><dt>Returns</dt><dd>false if success else true. </dd></dl>

</div>
</div>
<a id="a8166a3964219228f543d3048aed52664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8166a3964219228f543d3048aed52664">&#9670;&nbsp;</a></span>set_auto_increment_if_higher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::set_auto_increment_if_higher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update auto increment value if current row contains a higher value. </p>

</div>
</div>
<a id="a44a59c9539ff3caffe64df1c37d975a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a59c9539ff3caffe64df1c37d975a0">&#9670;&nbsp;</a></span>set_eq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partition_helper::set_eq_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>eq_range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classha__innopart.html#a78fc253eddb0aaf9dda72fbd258347f2">ha_innopart</a>.</p>

</div>
</div>
<a id="a7cc3f2f9f90cd789775c73a675a285a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc3f2f9f90cd789775c73a675a285a9">&#9670;&nbsp;</a></span>set_part_info_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::set_part_info_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpartition__info.html">partition_info</a> *&#160;</td>
          <td class="paramname"><em>part_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>early</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set partition info. </p>
<p>To be called from Partition_handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_info</td><td>Partition info to use. </td></tr>
    <tr><td class="paramname">early</td><td>True if called when part_info only created and parsed, but not setup, checked or fixed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4c7169bc4d90c5da290cf5eb89d33a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c7169bc4d90c5da290cf5eb89d33a9">&#9670;&nbsp;</a></span>set_partition_read_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::set_partition_read_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set table-&gt;read_set taking partitioning expressions into account. </p>

</div>
</div>
<a id="aeabcc0d508f362c71e52dc84b2cf5c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabcc0d508f362c71e52dc84b2cf5c06">&#9670;&nbsp;</a></span>set_range_key_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partition_helper::set_range_key_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classha__innopart.html#a052a4024953a1cb353104ed656e70e24">ha_innopart</a>.</p>

</div>
</div>
<a id="a3bdac13ff80e81802a04115f3f301140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdac13ff80e81802a04115f3f301140">&#9670;&nbsp;</a></span>unlock_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Partition_helper::unlock_auto_increment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unlock auto increment. </p>

</div>
</div>
<a id="ad74ba05f9a25e2b0ed4637f07cf1bd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74ba05f9a25e2b0ed4637f07cf1bd9b">&#9670;&nbsp;</a></span>update_row_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::update_row_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>new_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a row in the specified partition. </p>
<dl class="section see"><dt>See also</dt><dd>handler::update_row().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_id</td><td>Partition to update in. </td></tr>
    <tr><td class="paramname">old_data</td><td>Buffer containing old row. </td></tr>
    <tr><td class="paramname">new_data</td><td>Buffer containing new row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga09b7b7ea96f406b28c3377d44371bdb4">ha_innopart</a>.</p>

</div>
</div>
<a id="a1c8ba633f49d8f749f09213aac80a56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8ba633f49d8f749f09213aac80a56f">&#9670;&nbsp;</a></span>write_row_in_new_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::write_row_in_new_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>new_part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write row to new partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_part</td><td>New partition to write to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga75c201ac073f020066e638e63b27c0c4">ha_innopart</a>.</p>

</div>
</div>
<a id="a971c4232545c78b7d3ddc33cbb66b7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971c4232545c78b7d3ddc33cbb66b7e2">&#9670;&nbsp;</a></span>write_row_in_part()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Partition_helper::write_row_in_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a row in the specified partition. </p>
<dl class="section see"><dt>See also</dt><dd>handler::write_row().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_id</td><td>Partition to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer with data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error code. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__PARTITION__HANDLER__HELPERS.html#ga587998c21a5ff8b1111fc28a835409b6">ha_innopart</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2facfb803d0f4105accba9afb693ba93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2facfb803d0f4105accba9afb693ba93">&#9670;&nbsp;</a></span>m_auto_increment_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_auto_increment_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e2ff55e365d13379b755dcf620fd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e2ff55e365d13379b755dcf620fd00">&#9670;&nbsp;</a></span>m_auto_increment_safe_stmt_log_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_auto_increment_safe_stmt_log_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9cf9c194a25b44c10e6196e04e968a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cf9c194a25b44c10e6196e04e968a2">&#9670;&nbsp;</a></span>m_curr_key_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKEY.html">KEY</a>* Partition_helper::m_curr_key_info[3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current index used for sorting. </p>
<p>If clustered PK exists, then it will be used as secondary index to sort on if the first is equal in key_rec_cmp. So if clustered pk: m_curr_key_info[0]= current index and m_curr_key_info[1]= pk and [2]= NULL. Otherwise [0]= current index, [1]= NULL, and we will sort by rowid as secondary sort key if equal first key. </p>

</div>
</div>
<a id="a2e3a794bb8c49d2c6947f6a46e216fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3a794bb8c49d2c6947f6a46e216fe1">&#9670;&nbsp;</a></span>m_err_rec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* Partition_helper::m_err_rec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45c329c2ed63e51fb2d74a8f2f84ce03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c329c2ed63e51fb2d74a8f2f84ce03">&#9670;&nbsp;</a></span>m_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html">handler</a>* Partition_helper::m_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>handler to use (ha_innopart etc.) </p>

</div>
</div>
<a id="ab1661c58c24f402ff0d7ae3a814bcb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1661c58c24f402ff0d7ae3a814bcb6d">&#9670;&nbsp;</a></span>m_index_scan_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPartition__helper.html#aae15aadd4e7854e705866b9952014678">partition_index_scan_type</a> Partition_helper::m_index_scan_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cb57748f7c4f5fc4f43f8276f6c48ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb57748f7c4f5fc4f43f8276f6c48ae">&#9670;&nbsp;</a></span>m_is_sub_partitioned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_is_sub_partitioned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cached value of m_part_info-&gt;is_sub_partitioned(). </p>

</div>
</div>
<a id="aca2b5acc743493d38db2ac2beca2dc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2b5acc743493d38db2ac2beca2dc91">&#9670;&nbsp;</a></span>m_key_not_found</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_key_not_found</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if previous index_* call returned HA_ERR_KEY_NOT_FOUND. </p>

</div>
</div>
<a id="a562467eae6cb6797159e824119b89c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562467eae6cb6797159e824119b89c78">&#9670;&nbsp;</a></span>m_key_not_found_partitions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> Partition_helper::m_key_not_found_partitions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitions that returned HA_ERR_KEY_NOT_FOUND. </p>

</div>
</div>
<a id="ab10de1de75ca1c130b805dcd4439d489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10de1de75ca1c130b805dcd4439d489">&#9670;&nbsp;</a></span>m_last_part</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Partition_helper::m_last_part</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c7979176e3710a34d248f03b854f7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7979176e3710a34d248f03b854f7c2">&#9670;&nbsp;</a></span>m_ordered</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_ordered</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abac5d0f451a5f2c7c40e708e91766e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac5d0f451a5f2c7c40e708e91766e6f">&#9670;&nbsp;</a></span>m_ordered_rec_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* Partition_helper::m_ordered_rec_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Row and key buffer for ordered index scan. </p>

</div>
</div>
<a id="a8d0c3c33678849d684c2ca5eadb551ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0c3c33678849d684c2ca5eadb551ae">&#9670;&nbsp;</a></span>m_ordered_scan_ongoing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_ordered_scan_ongoing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f923b6267c3cb5ba564beba35c453df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f923b6267c3cb5ba564beba35c453df">&#9670;&nbsp;</a></span>m_part_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpartition__info.html">partition_info</a>* Partition_helper::m_part_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All internal partitioning data! </p>
<p>Tables partitioning info (same as table-&gt;part_info) </p>

</div>
</div>
<a id="a7b66b4c2d36f1410b5bf1ac492cc48c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b66b4c2d36f1410b5bf1ac492cc48c3">&#9670;&nbsp;</a></span>m_part_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartition__share.html">Partition_share</a>* Partition_helper::m_part_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition share for auto_inc handling. </p>

</div>
</div>
<a id="a0fc77088ac861b3065ae75d2db68f6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc77088ac861b3065ae75d2db68f6ab">&#9670;&nbsp;</a></span>m_part_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpart__id__range.html">part_id_range</a> Partition_helper::m_part_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a852dc28cead1da9ce8bd3e72a95b45fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852dc28cead1da9ce8bd3e72a95b45fb">&#9670;&nbsp;</a></span>m_pkey_is_clustered</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_pkey_is_clustered</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is primary key clustered. </p>

</div>
</div>
<a id="a071ce63f960f15ca6bda1755958d555f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071ce63f960f15ca6bda1755958d555f">&#9670;&nbsp;</a></span>m_queue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartition__helper.html#a220cae60081f437684607865c72339e8">Prio_queue</a>* Partition_helper::m_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prio queue used by sorted read. </p>

</div>
</div>
<a id="a14a84f01836276fe0f927783895ce370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a84f01836276fe0f927783895ce370">&#9670;&nbsp;</a></span>m_rec_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Partition_helper::m_rec_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba25c469f2f83f3d19bb3232859e8297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba25c469f2f83f3d19bb3232859e8297">&#9670;&nbsp;</a></span>m_rec_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Partition_helper::m_rec_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset in m_ordered_rec_buffer from part buffer to its record buffer. </p>

</div>
</div>
<a id="adf5eee2709a12792f7da903b3f1aca9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5eee2709a12792f7da903b3f1aca9c">&#9670;&nbsp;</a></span>m_ref_usage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartition__helper.html#a2dd2c2d2a13273db60ffb1ca66b9adf1">enum_using_ref</a> Partition_helper::m_ref_usage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How handler::ref is used in the priority queue. </p>

</div>
</div>
<a id="a4427ddab67516ac557ad36b3cdcedad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4427ddab67516ac557ad36b3cdcedad8">&#9670;&nbsp;</a></span>m_reverse_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Partition_helper::m_reverse_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54832ff562b6dfa256fd6dfe80fa6b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54832ff562b6dfa256fd6dfe80fa6b69">&#9670;&nbsp;</a></span>m_scan_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Partition_helper::m_scan_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abce368a659ec7d646ef2b60e904c4ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce368a659ec7d646ef2b60e904c4ffc">&#9670;&nbsp;</a></span>m_start_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkey__range.html">key_range</a> Partition_helper::m_start_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b9c1d86a06d3dc8426bad2579fec179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9c1d86a06d3dc8426bad2579fec179">&#9670;&nbsp;</a></span>m_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* Partition_helper::m_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience pointer to table from m_handler (i.e. </p>
<p>m_handler-&gt;table). </p>

</div>
</div>
<a id="a1bdfff6182c6c837319c1abe7bf7c6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdfff6182c6c837319c1abe7bf7c6e8">&#9670;&nbsp;</a></span>m_top_entry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Partition_helper::m_top_entry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Which partition is to deliver next result. </p>

</div>
</div>
<a id="a5226dbbe405ca4974a8dee9b910b6d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5226dbbe405ca4974a8dee9b910b6d0a">&#9670;&nbsp;</a></span>m_tot_parts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Partition_helper::m_tot_parts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of partitions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/partitioning/<a class="el" href="partition__handler_8h_source.html">partition_handler.h</a></li>
<li>sql/partitioning/<a class="el" href="partition__handler_8cc.html">partition_handler.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPartition__helper.html">Partition_helper</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
