<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: SEL_ROOT Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSEL__ROOT.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classSEL__ROOT-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SEL_ROOT Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A graph of (possible multiple) key ranges, represented as a red-black binary tree.  
 <a href="classSEL__ROOT.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0dac90fe787ba2a6250fbaf16b19feac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">Type</a> { <a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feacae23b33dee677e4477f0f7ddeb6cf87bd">Type::IMPOSSIBLE</a>, 
<a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feaca878ffe7dd283694c0b9dc849c23b9fa4">Type::MAYBE_KEY</a>, 
<a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feaca13c50269ec17c9fbb42cf4dff083b989">Type::KEY_RANGE</a>
 }<tr class="memdesc:a0dac90fe787ba2a6250fbaf16b19feac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate if the range predicate for an index is always true/false, depends on values from other tables or can be evaluated as is.  <a href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0dac90fe787ba2a6250fbaf16b19feac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a083c8cefb7c45f95640e74c4be17f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a5a083c8cefb7c45f95640e74c4be17f7">SEL_ROOT</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> *<a class="el" href="classSEL__ROOT.html#acf9bb08280f050e6203a9307be25d1b4">root</a>)</td></tr>
<tr class="memdesc:a5a083c8cefb7c45f95640e74c4be17f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tree of type KEY_RANGE, using the given root.  <a href="#a5a083c8cefb7c45f95640e74c4be17f7">More...</a><br /></td></tr>
<tr class="separator:a5a083c8cefb7c45f95640e74c4be17f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b06a02e133ffacd9d168f55d1a95a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ad8b06a02e133ffacd9d168f55d1a95a7">SEL_ROOT</a> (<a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *memroot, <a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">Type</a> type_arg)</td></tr>
<tr class="memdesc:ad8b06a02e133ffacd9d168f55d1a95a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct MAYBE_KEY and IMPOSSIBLE SEL_ARGs.  <a href="#ad8b06a02e133ffacd9d168f55d1a95a7">More...</a><br /></td></tr>
<tr class="separator:ad8b06a02e133ffacd9d168f55d1a95a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d15597a8c3b9905f6ad650a09aa1201"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a5d15597a8c3b9905f6ad650a09aa1201">~SEL_ROOT</a> ()</td></tr>
<tr class="memdesc:a5d15597a8c3b9905f6ad650a09aa1201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that almost all SEL_ROOTs are created on the MEM_ROOT, so this destructor will only rarely be called.  <a href="#a5d15597a8c3b9905f6ad650a09aa1201">More...</a><br /></td></tr>
<tr class="separator:a5d15597a8c3b9905f6ad650a09aa1201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d45fc1fe4e8702884745e9a0596b84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ad8d45fc1fe4e8702884745e9a0596b84">is_always</a> () const</td></tr>
<tr class="memdesc:ad8d45fc1fe4e8702884745e9a0596b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff we have a single node that has no max nor min.  <a href="#ad8d45fc1fe4e8702884745e9a0596b84">More...</a><br /></td></tr>
<tr class="separator:ad8d45fc1fe4e8702884745e9a0596b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69428bb91a7d0fe478fd6959c7dc0fc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a69428bb91a7d0fe478fd6959c7dc0fc6">store_min_key</a> (<a class="el" href="structKEY__PART.html">KEY_PART</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> **range_key, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *range_key_flag, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> last_part, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> start_key)</td></tr>
<tr class="memdesc:a69428bb91a7d0fe478fd6959c7dc0fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number of keypart values appended to the key buffer for min key and max key.  <a href="#a69428bb91a7d0fe478fd6959c7dc0fc6">More...</a><br /></td></tr>
<tr class="separator:a69428bb91a7d0fe478fd6959c7dc0fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae864894e8b38095735932e280a748548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ae864894e8b38095735932e280a748548">store_max_key</a> (<a class="el" href="structKEY__PART.html">KEY_PART</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> **range_key, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *range_key_flag, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> last_part, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> start_key)</td></tr>
<tr class="separator:ae864894e8b38095735932e280a748548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96b8330d1d8a9d556774027e13982a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ab96b8330d1d8a9d556774027e13982a8">free_tree</a> ()</td></tr>
<tr class="memdesc:ab96b8330d1d8a9d556774027e13982a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal to the tree that the caller will shortly be dropping it on the floor; if others are still using it, this is a no-op, but if the caller was the last one, it is now an orphan, and references from it should not count.  <a href="#ab96b8330d1d8a9d556774027e13982a8">More...</a><br /></td></tr>
<tr class="separator:ab96b8330d1d8a9d556774027e13982a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79c62da0ad18fc12d33b213c87626b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ad79c62da0ad18fc12d33b213c87626b2">insert</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:ad79c62da0ad18fc12d33b213c87626b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given node into the tree, and update the root.  <a href="#ad79c62da0ad18fc12d33b213c87626b2">More...</a><br /></td></tr>
<tr class="separator:ad79c62da0ad18fc12d33b213c87626b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e076ee1462b4d226db399c5adbafda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ae5e076ee1462b4d226db399c5adbafda">tree_delete</a> (<a class="el" href="classSEL__ARG.html">SEL_ARG</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:ae5e076ee1462b4d226db399c5adbafda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given node from the tree, and update the root.  <a href="#ae5e076ee1462b4d226db399c5adbafda">More...</a><br /></td></tr>
<tr class="separator:ae5e076ee1462b4d226db399c5adbafda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f30a8ccbe14f8fd0eac53d968657d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ab0f30a8ccbe14f8fd0eac53d968657d4">find_range</a> (const <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>) const</td></tr>
<tr class="memdesc:ab0f30a8ccbe14f8fd0eac53d968657d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find best key with min &lt;= given key.  <a href="#ab0f30a8ccbe14f8fd0eac53d968657d4">More...</a><br /></td></tr>
<tr class="separator:ab0f30a8ccbe14f8fd0eac53d968657d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7482cffcac45a77e3c8776083379422b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a7482cffcac45a77e3c8776083379422b">clone_tree</a> (<a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *param) const</td></tr>
<tr class="memdesc:a7482cffcac45a77e3c8776083379422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new tree that's a duplicate of this one.  <a href="#a7482cffcac45a77e3c8776083379422b">More...</a><br /></td></tr>
<tr class="separator:a7482cffcac45a77e3c8776083379422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cd3350b1437fbf8b57b0f5b1b70d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a49cd3350b1437fbf8b57b0f5b1b70d44">test_use_count</a> (const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *<a class="el" href="classSEL__ROOT.html#acf9bb08280f050e6203a9307be25d1b4">root</a>) const</td></tr>
<tr class="memdesc:a49cd3350b1437fbf8b57b0f5b1b70d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if SEL_ROOT::use_count value is correct.  <a href="#a49cd3350b1437fbf8b57b0f5b1b70d44">More...</a><br /></td></tr>
<tr class="separator:a49cd3350b1437fbf8b57b0f5b1b70d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cac2346f9a6adb17c3c66073f808e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#ad6cac2346f9a6adb17c3c66073f808e5">simple_key</a> () const</td></tr>
<tr class="memdesc:ad6cac2346f9a6adb17c3c66073f808e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this is a single-element, single-field predicate.  <a href="#ad6cac2346f9a6adb17c3c66073f808e5">More...</a><br /></td></tr>
<tr class="separator:ad6cac2346f9a6adb17c3c66073f808e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a89ce35e2d71d923cef516c8e6e8f481d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">SEL_ROOT::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a89ce35e2d71d923cef516c8e6e8f481d">type</a></td></tr>
<tr class="separator:a89ce35e2d71d923cef516c8e6e8f481d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9bb08280f050e6203a9307be25d1b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#acf9bb08280f050e6203a9307be25d1b4">root</a></td></tr>
<tr class="memdesc:acf9bb08280f050e6203a9307be25d1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root node of the tree.  <a href="#acf9bb08280f050e6203a9307be25d1b4">More...</a><br /></td></tr>
<tr class="separator:acf9bb08280f050e6203a9307be25d1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece31b78a35024373c3660d5ceccbd04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#aece31b78a35024373c3660d5ceccbd04">use_count</a> {0}</td></tr>
<tr class="memdesc:aece31b78a35024373c3660d5ceccbd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of references to this SEL_ARG tree.  <a href="#aece31b78a35024373c3660d5ceccbd04">More...</a><br /></td></tr>
<tr class="separator:aece31b78a35024373c3660d5ceccbd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1357f14e86be07aa0548ea9a848dda68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSEL__ROOT.html#a1357f14e86be07aa0548ea9a848dda68">elements</a> {0}</td></tr>
<tr class="memdesc:a1357f14e86be07aa0548ea9a848dda68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the RB-tree, not including sentinels.  <a href="#a1357f14e86be07aa0548ea9a848dda68">More...</a><br /></td></tr>
<tr class="separator:a1357f14e86be07aa0548ea9a848dda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A graph of (possible multiple) key ranges, represented as a red-black binary tree. </p>
<p>There are three types (see the Type enum); if KEY_RANGE, we have zero or more SEL_ARGs, described in the documentation on SEL_ARG.</p>
<p>As a special case, a nullptr SEL_ROOT means a range that is always true. This is true both for keys[] and next_key_part. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0dac90fe787ba2a6250fbaf16b19feac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dac90fe787ba2a6250fbaf16b19feac">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">SEL_ROOT::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to indicate if the range predicate for an index is always true/false, depends on values from other tables or can be evaluated as is. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0dac90fe787ba2a6250fbaf16b19feacae23b33dee677e4477f0f7ddeb6cf87bd"></a>IMPOSSIBLE&#160;</td><td class="fielddoc"><p>The range predicate for this index is always false. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0dac90fe787ba2a6250fbaf16b19feaca878ffe7dd283694c0b9dc849c23b9fa4"></a>MAYBE_KEY&#160;</td><td class="fielddoc"><p>There is a range predicate that refers to another table. </p>
<p>The range access method cannot be used on this index unless that other table is earlier in the join sequence. The bit representing the index is set in JOIN_TAB::needed_reg to notify the join optimizer that there is a table dependency. After deciding on join order, the optimizer may chose to rerun the range optimizer for tables with such dependencies. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0dac90fe787ba2a6250fbaf16b19feaca13c50269ec17c9fbb42cf4dff083b989"></a>KEY_RANGE&#160;</td><td class="fielddoc"><p>There is a range condition that can be used on this index. </p>
<p>The range conditions for this index in stored in the SEL_ARG tree. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5a083c8cefb7c45f95640e74c4be17f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a083c8cefb7c45f95640e74c4be17f7">&#9670;&nbsp;</a></span>SEL_ROOT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SEL_ROOT::SEL_ROOT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a tree of type KEY_RANGE, using the given root. </p>
<p>(The root is allowed to have children.) </p>

</div>
</div>
<a id="ad8b06a02e133ffacd9d168f55d1a95a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b06a02e133ffacd9d168f55d1a95a7">&#9670;&nbsp;</a></span>SEL_ROOT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SEL_ROOT::SEL_ROOT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>memroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">Type</a>&#160;</td>
          <td class="paramname"><em>type_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to construct MAYBE_KEY and IMPOSSIBLE SEL_ARGs. </p>

</div>
</div>
<a id="a5d15597a8c3b9905f6ad650a09aa1201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d15597a8c3b9905f6ad650a09aa1201">&#9670;&nbsp;</a></span>~SEL_ROOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEL_ROOT::~SEL_ROOT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note that almost all SEL_ROOTs are created on the MEM_ROOT, so this destructor will only rarely be called. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7482cffcac45a77e3c8776083379422b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7482cffcac45a77e3c8776083379422b">&#9670;&nbsp;</a></span>clone_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> * SEL_ROOT::clone_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRANGE__OPT__PARAM.html">RANGE_OPT_PARAM</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new tree that's a duplicate of this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The parameters for the new tree. Used to find out which MEM_ROOT to allocate the new nodes on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new tree, or nullptr in case of out of memory. </dd></dl>

</div>
</div>
<a id="ab0f30a8ccbe14f8fd0eac53d968657d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f30a8ccbe14f8fd0eac53d968657d4">&#9670;&nbsp;</a></span>find_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> * SEL_ROOT::find_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find best key with min &lt;= given key. </p>
<p>Because of the call context, this should never return nullptr to get_range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab96b8330d1d8a9d556774027e13982a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96b8330d1d8a9d556774027e13982a8">&#9670;&nbsp;</a></span>free_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SEL_ROOT::free_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal to the tree that the caller will shortly be dropping it on the floor; if others are still using it, this is a no-op, but if the caller was the last one, it is now an orphan, and references from it should not count. </p>

</div>
</div>
<a id="ad79c62da0ad18fc12d33b213c87626b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79c62da0ad18fc12d33b213c87626b2">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SEL_ROOT::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the given node into the tree, and update the root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The node to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8d45fc1fe4e8702884745e9a0596b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d45fc1fe4e8702884745e9a0596b84">&#9670;&nbsp;</a></span>is_always()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SEL_ROOT::is_always </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff we have a single node that has no max nor min. </p>
<p>Note that by convention, a nullptr SEL_ROOT means the same. </p>

</div>
</div>
<a id="ad6cac2346f9a6adb17c3c66073f808e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cac2346f9a6adb17c3c66073f808e5">&#9670;&nbsp;</a></span>simple_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SEL_ROOT::simple_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff this is a single-element, single-field predicate. </p>

</div>
</div>
<a id="ae864894e8b38095735932e280a748548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae864894e8b38095735932e280a748548">&#9670;&nbsp;</a></span>store_max_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SEL_ROOT::store_max_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> **&#160;</td>
          <td class="paramname"><em>range_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>range_key_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>last_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>start_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69428bb91a7d0fe478fd6959c7dc0fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69428bb91a7d0fe478fd6959c7dc0fc6">&#9670;&nbsp;</a></span>store_min_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SEL_ROOT::store_min_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKEY__PART.html">KEY_PART</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> **&#160;</td>
          <td class="paramname"><em>range_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>range_key_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>last_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>start_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a number of keypart values appended to the key buffer for min key and max key. </p>
<p>This function is used by both Range Analysis and Partition pruning. For partition pruning we have to ensure that we don't store also subpartition fields. Thus we have to stop at the last partition part and not step into the subpartition fields. For Range Analysis we set last_part to MAX_KEY which we should never reach. </p>

</div>
</div>
<a id="a49cd3350b1437fbf8b57b0f5b1b70d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cd3350b1437fbf8b57b0f5b1b70d44">&#9670;&nbsp;</a></span>test_use_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SEL_ROOT::test_use_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSEL__ROOT.html">SEL_ROOT</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if SEL_ROOT::use_count value is correct. </p>
<p>See the definition of use_count for what is "correct".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The origin tree of the SEL_ARG graph (an RB-tree that has the least value of root-&gt;sel_root-&gt;root-&gt;part in the entire graph, and thus is the "origin" of the graph)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff an incorrect SEL_ARG::use_count is found. </dd></dl>

</div>
</div>
<a id="ae5e076ee1462b4d226db399c5adbafda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e076ee1462b4d226db399c5adbafda">&#9670;&nbsp;</a></span>tree_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SEL_ROOT::tree_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSEL__ARG.html">SEL_ARG</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the given node from the tree, and update the root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The node to delete. Must exist in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1357f14e86be07aa0548ea9a848dda68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1357f14e86be07aa0548ea9a848dda68">&#9670;&nbsp;</a></span>elements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#ac2a9e79eb120216f855626495b7bd18a">uint16</a> SEL_ROOT::elements {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of nodes in the RB-tree, not including sentinels. </p>

</div>
</div>
<a id="acf9bb08280f050e6203a9307be25d1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9bb08280f050e6203a9307be25d1b4">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSEL__ARG.html">SEL_ARG</a>* SEL_ROOT::root</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The root node of the tree. </p>
<p>Note that this may change as the result of rotations during insertions or deletions, so pointers should be to the SEL_ROOT, not individual SEL_ARG nodes.</p>
<p>This element can never be nullptr, but can be null_element if type == KEY_RANGE and the tree is empty (which then means the same as type == IMPOSSIBLE).</p>
<p>If type == IMPOSSIBLE or type == MAYBE_KEY, there's a single root element which only serves to hold next_key_part (we don't really care about root-&gt;part in this case); the actual min/max values etc. do not matter and should not be accessed. </p>

</div>
</div>
<a id="a89ce35e2d71d923cef516c8e6e8f481d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ce35e2d71d923cef516c8e6e8f481d">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSEL__ROOT.html#a0dac90fe787ba2a6250fbaf16b19feac">SEL_ROOT::Type</a>  SEL_ROOT::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aece31b78a35024373c3660d5ceccbd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece31b78a35024373c3660d5ceccbd04">&#9670;&nbsp;</a></span>use_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> SEL_ROOT::use_count {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of references to this SEL_ARG tree. </p>
<p>References may be from SEL_ARG::next_key_part of SEL_ARGs from earlier keyparts or SEL_TREE::keys[i].</p>
<p>The SEL_ARG trees are re-used in a lazy-copy manner based on this reference counting. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sql/<a class="el" href="opt__range_8cc.html">opt_range.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSEL__ROOT.html">SEL_ROOT</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
