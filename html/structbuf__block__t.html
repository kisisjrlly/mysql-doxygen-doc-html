<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: buf_block_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structbuf__block__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structbuf__block__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">buf_block_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The buffer control block structure.  
 <a href="structbuf__block__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a155be9f1e032ea05b056b890360fc4a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a155be9f1e032ea05b056b890360fc4a4">get_page_id</a> () const</td></tr>
<tr class="memdesc:a155be9f1e032ea05b056b890360fc4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the page number and space id of the current buffer block.  <a href="#a155be9f1e032ea05b056b890360fc4a4">More...</a><br /></td></tr>
<tr class="separator:a155be9f1e032ea05b056b890360fc4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cec978d7812da8c2bc0b832f1ae390e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a9cec978d7812da8c2bc0b832f1ae390e">get_page_no</a> () const</td></tr>
<tr class="memdesc:a9cec978d7812da8c2bc0b832f1ae390e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the page number of the current buffer block.  <a href="#a9cec978d7812da8c2bc0b832f1ae390e">More...</a><br /></td></tr>
<tr class="separator:a9cec978d7812da8c2bc0b832f1ae390e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28623dd39a05dc77710756e2be9f4ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a28623dd39a05dc77710756e2be9f4ac0">get_next_page_no</a> () const</td></tr>
<tr class="memdesc:a28623dd39a05dc77710756e2be9f4ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next page number of the current buffer block.  <a href="#a28623dd39a05dc77710756e2be9f4ac0">More...</a><br /></td></tr>
<tr class="separator:a28623dd39a05dc77710756e2be9f4ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5ac54b3d0c1a0c5d4a950c8b9f61a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a4e5ac54b3d0c1a0c5d4a950c8b9f61a9">get_prev_page_no</a> () const</td></tr>
<tr class="memdesc:a4e5ac54b3d0c1a0c5d4a950c8b9f61a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the prev page number of the current buffer block.  <a href="#a4e5ac54b3d0c1a0c5d4a950c8b9f61a9">More...</a><br /></td></tr>
<tr class="separator:a4e5ac54b3d0c1a0c5d4a950c8b9f61a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdae1d22204e98f3a6ae31892020e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fil0fil_8h.html#a28736d878c89fb4395c9bc86f4530dfc">page_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a1fdae1d22204e98f3a6ae31892020e0a">get_page_type</a> () const</td></tr>
<tr class="memdesc:a1fdae1d22204e98f3a6ae31892020e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the page type of the current buffer block.  <a href="#a1fdae1d22204e98f3a6ae31892020e0a">More...</a><br /></td></tr>
<tr class="separator:a1fdae1d22204e98f3a6ae31892020e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498241645ad8d9236fd7aeefd6723cc7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a498241645ad8d9236fd7aeefd6723cc7">get_page_type_str</a> () const</td></tr>
<tr class="memdesc:a498241645ad8d9236fd7aeefd6723cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the page type of the current buffer block as string.  <a href="#a498241645ad8d9236fd7aeefd6723cc7">More...</a><br /></td></tr>
<tr class="separator:a498241645ad8d9236fd7aeefd6723cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad0299484987534038b0f7d9febdcfe86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#ad0299484987534038b0f7d9febdcfe86">made_dirty_with_no_latch</a></td></tr>
<tr class="memdesc:ad0299484987534038b0f7d9febdcfe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if block has been made dirty without acquiring X/SX latch as the block belongs to temporary tablespace and block is always accessed by a single thread.  <a href="#ad0299484987534038b0f7d9febdcfe86">More...</a><br /></td></tr>
<tr class="separator:ad0299484987534038b0f7d9febdcfe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7b5093768acbd9bc67b1ec6a6f4c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a728dccae958dd22a0f7ddd16cf6e4f0a">BPageMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a8d7b5093768acbd9bc67b1ec6a6f4c21">mutex</a></td></tr>
<tr class="memdesc:a8d7b5093768acbd9bc67b1ec6a6f4c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex protecting this block: state (also protected by the buffer pool mutex), io_fix, buf_fix_count, and accessed; we introduce this new mutex in InnoDB-5.1 to relieve contention on the buffer pool mutex  <a href="#a8d7b5093768acbd9bc67b1ec6a6f4c21">More...</a><br /></td></tr>
<tr class="separator:a8d7b5093768acbd9bc67b1ec6a6f4c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Optimistic search field</div></td></tr>
<tr class="memitem:a0b5817c9011789ee63367a3818581b12"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a0b5817c9011789ee63367a3818581b12">modify_clock</a></td></tr>
<tr class="memdesc:a0b5817c9011789ee63367a3818581b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This clock is incremented every time a pointer to a record on the page may become obsolete; this is used in the optimistic cursor positioning: if the modify clock has not changed, we know that the pointer is still valid; this field may be changed if the thread (1) owns the LRU list mutex and the page is not bufferfixed, or (2) the thread has an x-latch on the block, or (3) the block must belong to an intrinsic table.  <a href="#a0b5817c9011789ee63367a3818581b12">More...</a><br /></td></tr>
<tr class="separator:a0b5817c9011789ee63367a3818581b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hash search fields (unprotected)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>NOTE that these fields are NOT protected by any semaphore! </p>
</div></td></tr>
<tr class="memitem:acb908f99682168e39a9dfd69624f7954"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#acb908f99682168e39a9dfd69624f7954">n_hash_helps</a></td></tr>
<tr class="memdesc:acb908f99682168e39a9dfd69624f7954"><td class="mdescLeft">&#160;</td><td class="mdescRight">counter which controls building of a new hash index for the page  <a href="#acb908f99682168e39a9dfd69624f7954">More...</a><br /></td></tr>
<tr class="separator:acb908f99682168e39a9dfd69624f7954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972cf65b12b166a38318f5057f712c8a"><td class="memItemLeft" align="right" valign="top">volatile ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a972cf65b12b166a38318f5057f712c8a">n_bytes</a></td></tr>
<tr class="memdesc:a972cf65b12b166a38318f5057f712c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">recommended prefix length for hash search: number of bytes in an incomplete last field  <a href="#a972cf65b12b166a38318f5057f712c8a">More...</a><br /></td></tr>
<tr class="separator:a972cf65b12b166a38318f5057f712c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28d95bdb91ffa6591f756eb1628f4e8"><td class="memItemLeft" align="right" valign="top">volatile ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#ac28d95bdb91ffa6591f756eb1628f4e8">n_fields</a></td></tr>
<tr class="memdesc:ac28d95bdb91ffa6591f756eb1628f4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">recommended prefix length for hash search: number of full fields  <a href="#ac28d95bdb91ffa6591f756eb1628f4e8">More...</a><br /></td></tr>
<tr class="separator:ac28d95bdb91ffa6591f756eb1628f4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d0a79e91ab56e851dc8a0826abff1"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a859d0a79e91ab56e851dc8a0826abff1">left_side</a></td></tr>
<tr class="memdesc:a859d0a79e91ab56e851dc8a0826abff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">true or false, depending on whether the leftmost record of several records with the same prefix should be indexed in the hash index  <a href="#a859d0a79e91ab56e851dc8a0826abff1">More...</a><br /></td></tr>
<tr class="separator:a859d0a79e91ab56e851dc8a0826abff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hash search fields</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These 5 fields may only be modified when: we are holding the appropriate x-latch in btr_search_latches[], and one of the following holds: (1) the block state is BUF_BLOCK_FILE_PAGE, and we are holding an s-latch or x-latch on buf_block_t::lock, or (2) buf_block_t::buf_fix_count == 0, or (3) the block state is BUF_BLOCK_REMOVE_HASH.</p>
<p>An exception to this is when we init or create a page in the buffer pool in buf0buf.cc.</p>
<p>Another exception for buf_pool_clear_hash_index() is that assigning block-&gt;index = NULL (and block-&gt;n_pointers = 0) is allowed whenever btr_search_own_all(RW_LOCK_X).</p>
<p>Another exception is that ha_insert_for_fold_func() may decrement n_pointers without holding the appropriate latch in btr_search_latches[]. Thus, n_pointers must be protected by atomic memory access.</p>
<p>This implies that the fields may be read without race condition whenever any of the following hold:</p><ul>
<li>the btr_search_latches[] s-latch or x-latch is being held, or</li>
<li>the block state is not BUF_BLOCK_FILE_PAGE or BUF_BLOCK_REMOVE_HASH, and holding some latch prevents the state from changing to that.</li>
</ul>
<p>Some use of assert_block_ahi_empty() or assert_block_ahi_valid() is prone to race conditions while buf_pool_clear_hash_index() is executing (the adaptive hash index is being disabled). Such use is explicitly commented. </p>
</div></td></tr>
<tr class="memitem:ac50b25d43035c9879d046f193ca7c1c3"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#ac50b25d43035c9879d046f193ca7c1c3">n_pointers</a></td></tr>
<tr class="memdesc:ac50b25d43035c9879d046f193ca7c1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in debugging: the number of pointers in the adaptive hash index pointing to this frame; protected by atomic memory access or btr_search_own_all().  <a href="#ac50b25d43035c9879d046f193ca7c1c3">More...</a><br /></td></tr>
<tr class="separator:ac50b25d43035c9879d046f193ca7c1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd502c27ab099e000f52980eb5320a5d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#abd502c27ab099e000f52980eb5320a5d">curr_n_fields</a>: 10</td></tr>
<tr class="memdesc:abd502c27ab099e000f52980eb5320a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">prefix length for hash indexing: number of full fields  <a href="#abd502c27ab099e000f52980eb5320a5d">More...</a><br /></td></tr>
<tr class="separator:abd502c27ab099e000f52980eb5320a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1feaf77a181565201cf1e76ae69a890"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#ae1feaf77a181565201cf1e76ae69a890">curr_n_bytes</a>: 15</td></tr>
<tr class="memdesc:ae1feaf77a181565201cf1e76ae69a890"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bytes in hash indexing  <a href="#ae1feaf77a181565201cf1e76ae69a890">More...</a><br /></td></tr>
<tr class="separator:ae1feaf77a181565201cf1e76ae69a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab266dbdd4987a973d17481a3adda93a7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#ab266dbdd4987a973d17481a3adda93a7">curr_left_side</a>: 1</td></tr>
<tr class="memdesc:ab266dbdd4987a973d17481a3adda93a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE or FALSE in hash indexing.  <a href="#ab266dbdd4987a973d17481a3adda93a7">More...</a><br /></td></tr>
<tr class="separator:ab266dbdd4987a973d17481a3adda93a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5e0c130f4eb214c713eab5cc530733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#abe5e0c130f4eb214c713eab5cc530733">index</a></td></tr>
<tr class="memdesc:abe5e0c130f4eb214c713eab5cc530733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for which the adaptive hash index has been created, or NULL if the page does not exist in the index.  <a href="#abe5e0c130f4eb214c713eab5cc530733">More...</a><br /></td></tr>
<tr class="separator:abe5e0c130f4eb214c713eab5cc530733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debug fields</div></td></tr>
<tr class="memitem:a05158d5f9b4078d10a38e9a3edc628fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a05158d5f9b4078d10a38e9a3edc628fa">debug_latch</a></td></tr>
<tr class="memdesc:a05158d5f9b4078d10a38e9a3edc628fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the debug version, each thread which bufferfixes the block acquires an s-latch here; so we can use the debug utilities in sync0rw.  <a href="#a05158d5f9b4078d10a38e9a3edc628fa">More...</a><br /></td></tr>
<tr class="separator:a05158d5f9b4078d10a38e9a3edc628fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
General fields</h2></td></tr>
<tr class="memitem:a275b67563d761a5581aa734a383f5ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a275b67563d761a5581aa734a383f5ee2">page</a></td></tr>
<tr class="memdesc:a275b67563d761a5581aa734a383f5ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">page information; this must be the first field, so that buf_pool-&gt;page_hash can point to buf_page_t or buf_block_t  <a href="#a275b67563d761a5581aa734a383f5ee2">More...</a><br /></td></tr>
<tr class="separator:a275b67563d761a5581aa734a383f5ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef8d133a86de0277832fc291bb7f081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a8ef8d133a86de0277832fc291bb7f081">frame</a></td></tr>
<tr class="memdesc:a8ef8d133a86de0277832fc291bb7f081"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to buffer frame which is of size UNIV_PAGE_SIZE, and aligned to an address divisible by UNIV_PAGE_SIZE  <a href="#a8ef8d133a86de0277832fc291bb7f081">More...</a><br /></td></tr>
<tr class="separator:a8ef8d133a86de0277832fc291bb7f081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10b800772d9306afba5350635a4e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#aa4d3f828f533110cc385fb15987ddeeb">BPageLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a0c10b800772d9306afba5350635a4e7f">lock</a></td></tr>
<tr class="memdesc:a0c10b800772d9306afba5350635a4e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-write lock of the buffer frame  <a href="#a0c10b800772d9306afba5350635a4e7f">More...</a><br /></td></tr>
<tr class="separator:a0c10b800772d9306afba5350635a4e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d009e6bec069b5e7be12b387032b23c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a7d009e6bec069b5e7be12b387032b23c">in_unzip_LRU_list</a></td></tr>
<tr class="memdesc:a7d009e6bec069b5e7be12b387032b23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if the page is in the decompressed LRU list; used in debugging.  <a href="#a7d009e6bec069b5e7be12b387032b23c">More...</a><br /></td></tr>
<tr class="separator:a7d009e6bec069b5e7be12b387032b23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423fa57d7af8ae1a362d5c33a788f063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a423fa57d7af8ae1a362d5c33a788f063">in_withdraw_list</a></td></tr>
<tr class="separator:a423fa57d7af8ae1a362d5c33a788f063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2fe504c95e66fee175149cc7943b05"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a9a2fe504c95e66fee175149cc7943b05">lock_hash_val</a>: 32</td></tr>
<tr class="memdesc:a9a2fe504c95e66fee175149cc7943b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">hashed value of the page address in the record lock hash table; protected by buf_block_t::lock (or buf_block_t::mutex in buf_page_get_gen(), buf_page_init_for_read() and buf_page_create())  <a href="#a9a2fe504c95e66fee175149cc7943b05">More...</a><br /></td></tr>
<tr class="separator:a9a2fe504c95e66fee175149cc7943b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e45a83762965ff4cd839aff952a9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html#a4a4e45a83762965ff4cd839aff952a9a">UT_LIST_NODE_T</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a>) unzip_LRU</td></tr>
<tr class="memdesc:a4a4e45a83762965ff4cd839aff952a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">node of the decompressed LRU list; a block is in the unzip_LRU list if page.state == BUF_BLOCK_FILE_PAGE and page.zip.data != NULL.  <a href="#a4a4e45a83762965ff4cd839aff952a9a">More...</a><br /></td></tr>
<tr class="separator:a4a4e45a83762965ff4cd839aff952a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The buffer control block structure. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a28623dd39a05dc77710756e2be9f4ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28623dd39a05dc77710756e2be9f4ac0">&#9670;&nbsp;</a></span>get_next_page_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> buf_block_t::get_next_page_no </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next page number of the current buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>next page number of the current buffer block. </dd></dl>

</div>
</div>
<a id="a155be9f1e032ea05b056b890360fc4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155be9f1e032ea05b056b890360fc4a4">&#9670;&nbsp;</a></span>get_page_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpage__id__t.html">page_id_t</a>&amp; buf_block_t::get_page_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the page number and space id of the current buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>page number of the current buffer block. </dd></dl>

</div>
</div>
<a id="a9cec978d7812da8c2bc0b832f1ae390e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cec978d7812da8c2bc0b832f1ae390e">&#9670;&nbsp;</a></span>get_page_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> buf_block_t::get_page_no </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the page number of the current buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>page number of the current buffer block. </dd></dl>

</div>
</div>
<a id="a1fdae1d22204e98f3a6ae31892020e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdae1d22204e98f3a6ae31892020e0a">&#9670;&nbsp;</a></span>get_page_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fil0fil_8h.html#a28736d878c89fb4395c9bc86f4530dfc">page_type_t</a> buf_block_t::get_page_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the page type of the current buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>page type of the current buffer block. </dd></dl>

</div>
</div>
<a id="a498241645ad8d9236fd7aeefd6723cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498241645ad8d9236fd7aeefd6723cc7">&#9670;&nbsp;</a></span>get_page_type_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * buf_block_t::get_page_type_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the page type of the current buffer block as string. </p>
<p>Get the page type as a string.</p>
<dl class="section return"><dt>Returns</dt><dd>page type of the current buffer block as string.</dd>
<dd>
the page type as a string. </dd></dl>

</div>
</div>
<a id="a4e5ac54b3d0c1a0c5d4a950c8b9f61a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5ac54b3d0c1a0c5d4a950c8b9f61a9">&#9670;&nbsp;</a></span>get_prev_page_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> buf_block_t::get_prev_page_no </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the prev page number of the current buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>prev page number of the current buffer block. </dd></dl>

</div>
</div>
<a id="a4a4e45a83762965ff4cd839aff952a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4e45a83762965ff4cd839aff952a9a">&#9670;&nbsp;</a></span>UT_LIST_NODE_T()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_block_t::UT_LIST_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>node of the decompressed LRU list; a block is in the unzip_LRU list if page.state == BUF_BLOCK_FILE_PAGE and page.zip.data != NULL. </p>
<p>Protected by both LRU_list_mutex and the block mutex. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab266dbdd4987a973d17481a3adda93a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab266dbdd4987a973d17481a3adda93a7">&#9670;&nbsp;</a></span>curr_left_side</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned buf_block_t::curr_left_side</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE or FALSE in hash indexing. </p>

</div>
</div>
<a id="ae1feaf77a181565201cf1e76ae69a890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1feaf77a181565201cf1e76ae69a890">&#9670;&nbsp;</a></span>curr_n_bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned buf_block_t::curr_n_bytes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of bytes in hash indexing </p>

</div>
</div>
<a id="abd502c27ab099e000f52980eb5320a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd502c27ab099e000f52980eb5320a5d">&#9670;&nbsp;</a></span>curr_n_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned buf_block_t::curr_n_fields</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prefix length for hash indexing: number of full fields </p>

</div>
</div>
<a id="a05158d5f9b4078d10a38e9a3edc628fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05158d5f9b4078d10a38e9a3edc628fa">&#9670;&nbsp;</a></span>debug_latch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> buf_block_t::debug_latch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the debug version, each thread which bufferfixes the block acquires an s-latch here; so we can use the debug utilities in sync0rw. </p>

</div>
</div>
<a id="a8ef8d133a86de0277832fc291bb7f081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef8d133a86de0277832fc291bb7f081">&#9670;&nbsp;</a></span>frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* buf_block_t::frame</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to buffer frame which is of size UNIV_PAGE_SIZE, and aligned to an address divisible by UNIV_PAGE_SIZE </p>

</div>
</div>
<a id="a7d009e6bec069b5e7be12b387032b23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d009e6bec069b5e7be12b387032b23c">&#9670;&nbsp;</a></span>in_unzip_LRU_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_block_t::in_unzip_LRU_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if the page is in the decompressed LRU list; used in debugging. </p>

</div>
</div>
<a id="a423fa57d7af8ae1a362d5c33a788f063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423fa57d7af8ae1a362d5c33a788f063">&#9670;&nbsp;</a></span>in_withdraw_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_block_t::in_withdraw_list</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5e0c130f4eb214c713eab5cc530733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5e0c130f4eb214c713eab5cc530733">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* buf_block_t::index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index for which the adaptive hash index has been created, or NULL if the page does not exist in the index. </p>
<p>Note that it does not guarantee that the index is complete, though: there may have been hash collisions, record deletions, etc. </p>

</div>
</div>
<a id="a859d0a79e91ab56e851dc8a0826abff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d0a79e91ab56e851dc8a0826abff1">&#9670;&nbsp;</a></span>left_side</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_block_t::left_side</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true or false, depending on whether the leftmost record of several records with the same prefix should be indexed in the hash index </p>

</div>
</div>
<a id="a0c10b800772d9306afba5350635a4e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c10b800772d9306afba5350635a4e7f">&#9670;&nbsp;</a></span>lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#aa4d3f828f533110cc385fb15987ddeeb">BPageLock</a> buf_block_t::lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read-write lock of the buffer frame </p>

</div>
</div>
<a id="a9a2fe504c95e66fee175149cc7943b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2fe504c95e66fee175149cc7943b05">&#9670;&nbsp;</a></span>lock_hash_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned buf_block_t::lock_hash_val</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hashed value of the page address in the record lock hash table; protected by buf_block_t::lock (or buf_block_t::mutex in buf_page_get_gen(), buf_page_init_for_read() and buf_page_create()) </p>

</div>
</div>
<a id="ad0299484987534038b0f7d9febdcfe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0299484987534038b0f7d9febdcfe86">&#9670;&nbsp;</a></span>made_dirty_with_no_latch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_block_t::made_dirty_with_no_latch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true if block has been made dirty without acquiring X/SX latch as the block belongs to temporary tablespace and block is always accessed by a single thread. </p>

</div>
</div>
<a id="a0b5817c9011789ee63367a3818581b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5817c9011789ee63367a3818581b12">&#9670;&nbsp;</a></span>modify_clock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t buf_block_t::modify_clock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This clock is incremented every time a pointer to a record on the page may become obsolete; this is used in the optimistic cursor positioning: if the modify clock has not changed, we know that the pointer is still valid; this field may be changed if the thread (1) owns the LRU list mutex and the page is not bufferfixed, or (2) the thread has an x-latch on the block, or (3) the block must belong to an intrinsic table. </p>

</div>
</div>
<a id="a8d7b5093768acbd9bc67b1ec6a6f4c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7b5093768acbd9bc67b1ec6a6f4c21">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a728dccae958dd22a0f7ddd16cf6e4f0a">BPageMutex</a> buf_block_t::mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mutex protecting this block: state (also protected by the buffer pool mutex), io_fix, buf_fix_count, and accessed; we introduce this new mutex in InnoDB-5.1 to relieve contention on the buffer pool mutex </p>

</div>
</div>
<a id="a972cf65b12b166a38318f5057f712c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972cf65b12b166a38318f5057f712c8a">&#9670;&nbsp;</a></span>n_bytes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ulint buf_block_t::n_bytes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recommended prefix length for hash search: number of bytes in an incomplete last field </p>

</div>
</div>
<a id="ac28d95bdb91ffa6591f756eb1628f4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28d95bdb91ffa6591f756eb1628f4e8">&#9670;&nbsp;</a></span>n_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ulint buf_block_t::n_fields</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recommended prefix length for hash search: number of full fields </p>

</div>
</div>
<a id="acb908f99682168e39a9dfd69624f7954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb908f99682168e39a9dfd69624f7954">&#9670;&nbsp;</a></span>n_hash_helps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_block_t::n_hash_helps</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>counter which controls building of a new hash index for the page </p>

</div>
</div>
<a id="ac50b25d43035c9879d046f193ca7c1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50b25d43035c9879d046f193ca7c1c3">&#9670;&nbsp;</a></span>n_pointers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_block_t::n_pointers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used in debugging: the number of pointers in the adaptive hash index pointing to this frame; protected by atomic memory access or btr_search_own_all(). </p>

</div>
</div>
<a id="a275b67563d761a5581aa734a383f5ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275b67563d761a5581aa734a383f5ee2">&#9670;&nbsp;</a></span>page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a> buf_block_t::page</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>page information; this must be the first field, so that buf_pool-&gt;page_hash can point to buf_page_t or buf_block_t </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>storage/innobase/include/<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a></li>
<li>storage/innobase/buf/<a class="el" href="buf0buf_8cc.html">buf0buf.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structbuf__block__t.html">buf_block_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
