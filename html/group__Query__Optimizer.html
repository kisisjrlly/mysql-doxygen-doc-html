<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Query Optimizer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Query__Optimizer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Query Optimizer</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__RefOptimizerModule"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html">Ref Optimizer</a></td></tr>
<tr class="memdesc:group__RefOptimizerModule"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module analyzes all equality predicates to determine the best independent ref/eq_ref/ref_or_null index access methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlan__change__watchdog.html">Plan_change_watchdog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is not obvious to see that test_if_skip_sort_order() never changes the plan if no_changes is true.  <a href="classPlan__change__watchdog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOND__CMP.html">COND_CMP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf7424a43da6deb8d6a928d20012e570a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf7424a43da6deb8d6a928d20012e570a">Global_tables_iterator</a> = <a class="el" href="classIntrusiveListIterator.html">IntrusiveListIterator</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>, &amp;<a class="el" href="structTABLE__LIST.html#a8e3206715feef5e95f8d2c3c3f324fa6">TABLE_LIST::next_global</a> &gt;</td></tr>
<tr class="separator:gaf7424a43da6deb8d6a928d20012e570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade220b9879946408da6785ebea5bc62"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaade220b9879946408da6785ebea5bc62">Global_tables_list</a> = <a class="el" href="classIteratorContainer.html">IteratorContainer</a>&lt; <a class="el" href="group__Query__Optimizer.html#gaf7424a43da6deb8d6a928d20012e570a">Global_tables_iterator</a> &gt;</td></tr>
<tr class="memdesc:gaade220b9879946408da6785ebea5bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list interface over the TABLE_LIST::next_global pointer.  <a href="#gaade220b9879946408da6785ebea5bc62">More...</a><br /></td></tr>
<tr class="separator:gaade220b9879946408da6785ebea5bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2b0c1fe8bf704242bb61acaa40a81fb4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2b0c1fe8bf704242bb61acaa40a81fb4">optimize_semijoin_nests_for_materialization</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="memdesc:ga2b0c1fe8bf704242bb61acaa40a81fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize semi-join nests that could be run with sj-materialization.  <a href="#ga2b0c1fe8bf704242bb61acaa40a81fb4">More...</a><br /></td></tr>
<tr class="separator:ga2b0c1fe8bf704242bb61acaa40a81fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ca5e962b784c066559515c5286e6c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga76ca5e962b784c066559515c5286e6c5">calculate_materialization_costs</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *sj_nest, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_tables, <a class="el" href="structSemijoin__mat__optimize.html">Semijoin_mat_optimize</a> *sjm)</td></tr>
<tr class="memdesc:ga76ca5e962b784c066559515c5286e6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For {semijoin,subquery} materialization: calculates various cost information, based on a plan in join-&gt;best_positions covering the to-be-materialized query block and only this.  <a href="#ga76ca5e962b784c066559515c5286e6c5">More...</a><br /></td></tr>
<tr class="separator:ga76ca5e962b784c066559515c5286e6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e200feaabd87014fd301f6fa6994754"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga1e200feaabd87014fd301f6fa6994754">make_join_select</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr class="memdesc:ga1e200feaabd87014fd301f6fa6994754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates the predicates in a join condition and pushes them to the join step where all involved tables are available in the join prefix.  <a href="#ga1e200feaabd87014fd301f6fa6994754">More...</a><br /></td></tr>
<tr class="separator:ga1e200feaabd87014fd301f6fa6994754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fa24dcc32ac483c17625d748cc09d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga93fa24dcc32ac483c17625d748cc09d9">list_contains_unique_index</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(*find_func)(<a class="el" href="classField.html">Field</a> *, void *), void *data)</td></tr>
<tr class="memdesc:ga93fa24dcc32ac483c17625d748cc09d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if GROUP BY/DISTINCT can be optimized away because the set is already known to be distinct.  <a href="#ga93fa24dcc32ac483c17625d748cc09d9">More...</a><br /></td></tr>
<tr class="separator:ga93fa24dcc32ac483c17625d748cc09d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f21fed3a20651b87cac72bbb304b33c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3f21fed3a20651b87cac72bbb304b33c">find_field_in_item_list</a> (<a class="el" href="classField.html">Field</a> *field, void *data)</td></tr>
<tr class="memdesc:ga3f21fed3a20651b87cac72bbb304b33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for list_contains_unique_index.  <a href="#ga3f21fed3a20651b87cac72bbb304b33c">More...</a><br /></td></tr>
<tr class="separator:ga3f21fed3a20651b87cac72bbb304b33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac97c3001abc54d7c0fd18d26601d4fdf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac97c3001abc54d7c0fd18d26601d4fdf">find_field_in_order_list</a> (<a class="el" href="classField.html">Field</a> *field, void *data)</td></tr>
<tr class="memdesc:gac97c3001abc54d7c0fd18d26601d4fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for list_contains_unique_index.  <a href="#gac97c3001abc54d7c0fd18d26601d4fdf">More...</a><br /></td></tr>
<tr class="separator:gac97c3001abc54d7c0fd18d26601d4fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60338e02a4512db7d658add6f008fd2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga60338e02a4512db7d658add6f008fd2e">get_sort_by_table</a> (<a class="el" href="structORDER.html">ORDER</a> *a, <a class="el" href="structORDER.html">ORDER</a> *b, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr class="memdesc:ga60338e02a4512db7d658add6f008fd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return table number if there is only one table in sort order and group and order is compatible, else return 0.  <a href="#ga60338e02a4512db7d658add6f008fd2e">More...</a><br /></td></tr>
<tr class="separator:ga60338e02a4512db7d658add6f008fd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c540754bd726695a5a7e36952136f3d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga1c540754bd726695a5a7e36952136f3d">trace_table_dependencies</a> (<a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *trace, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tabs, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> table_count)</td></tr>
<tr class="memdesc:ga1c540754bd726695a5a7e36952136f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the optimizer trace information about dependencies between tables.  <a href="#ga1c540754bd726695a5a7e36952136f3d">More...</a><br /></td></tr>
<tr class="separator:ga1c540754bd726695a5a7e36952136f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84f052660af684b9f827e801c3daaf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae84f052660af684b9f827e801c3daaf3">update_ref_and_keys</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a> *keyuse, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> tables, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> normal_tables, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex, <a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="memdesc:gae84f052660af684b9f827e801c3daaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update keyuse array with all possible keys we can use to fetch rows.  <a href="#gae84f052660af684b9f827e801c3daaf3">More...</a><br /></td></tr>
<tr class="separator:gae84f052660af684b9f827e801c3daaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec74b2258a6fa694f7c1e4cca9242b2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaec74b2258a6fa694f7c1e4cca9242b2f">pull_out_semijoin_tables</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="memdesc:gaec74b2258a6fa694f7c1e4cca9242b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull tables out of semi-join nests based on functional dependencies.  <a href="#gaec74b2258a6fa694f7c1e4cca9242b2f">More...</a><br /></td></tr>
<tr class="separator:gaec74b2258a6fa694f7c1e4cca9242b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20ec40256339d93da167dde6632143b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac20ec40256339d93da167dde6632143b">add_loose_index_scan_and_skip_scan_keys</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="memdesc:gac20ec40256339d93da167dde6632143b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover the indexes that might be used for GROUP BY or DISTINCT queries or indexes that might be used for SKIP SCAN.  <a href="#gac20ec40256339d93da167dde6632143b">More...</a><br /></td></tr>
<tr class="separator:gac20ec40256339d93da167dde6632143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2593853e2e7906aae3ab807690db898b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2593853e2e7906aae3ab807690db898b">get_quick_record_count</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> limit)</td></tr>
<tr class="memdesc:ga2593853e2e7906aae3ab807690db898b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns estimated number of rows that could be fetched by given access method.  <a href="#ga2593853e2e7906aae3ab807690db898b">More...</a><br /></td></tr>
<tr class="separator:ga2593853e2e7906aae3ab807690db898b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5943531e04254b574e4e0f9aa77b82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4e5943531e04254b574e4e0f9aa77b82">only_eq_ref_tables</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structORDER.html">ORDER</a> *order, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tables, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *cached_eq_ref_tables, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *eq_ref_tables)</td></tr>
<tr class="separator:ga4e5943531e04254b574e4e0f9aa77b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c98e119d5015f0fc32f950b5c0fc86b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0c98e119d5015f0fc32f950b5c0fc86b">setup_join_buffering</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> no_jbuf_after)</td></tr>
<tr class="memdesc:ga0c98e119d5015f0fc32f950b5c0fc86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up join buffering for a specified table, if possible.  <a href="#ga0c98e119d5015f0fc32f950b5c0fc86b">More...</a><br /></td></tr>
<tr class="separator:ga0c98e119d5015f0fc32f950b5c0fc86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3a8607d8a43fc5206c1449f09c470e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaeb3a8607d8a43fc5206c1449f09c470e">test_if_skip_sort_order</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="classORDER__with__src.html">ORDER_with_src</a> &amp;order, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> <a class="el" href="mysql_8cc.html#a9511379c243f7fd0f9e96bf76e3e09e3">select_limit</a>, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> no_changes, const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *map, int *order_idx)</td></tr>
<tr class="memdesc:gaeb3a8607d8a43fc5206c1449f09c470e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if we can skip ordering by using an index.  <a href="#gaeb3a8607d8a43fc5206c1449f09c470e">More...</a><br /></td></tr>
<tr class="separator:gaeb3a8607d8a43fc5206c1449f09c470e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62e67db4efd171d1f741f1a41e0c82f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem__func__match.html">Item_func_match</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae62e67db4efd171d1f741f1a41e0c82f">test_if_ft_index_order</a> (<a class="el" href="structORDER.html">ORDER</a> *order)</td></tr>
<tr class="memdesc:gae62e67db4efd171d1f741f1a41e0c82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if ORDER BY is a single MATCH function(ORDER BY MATCH) and sort order is descending.  <a href="#gae62e67db4efd171d1f741f1a41e0c82f">More...</a><br /></td></tr>
<tr class="separator:gae62e67db4efd171d1f741f1a41e0c82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f287f864e757469de8894de45d49b0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2f287f864e757469de8894de45d49b0f">get_key_length_tmp_table</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:ga2f287f864e757469de8894de45d49b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(end of group Query_Optimizer)  <a href="#ga2f287f864e757469de8894de45d49b0f">More...</a><br /></td></tr>
<tr class="separator:ga2f287f864e757469de8894de45d49b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ae76202144e523704ebe6be47e2c7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga58ae76202144e523704ebe6be47e2c7f">can_switch_from_ref_to_range</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="key__spec_8h.html#ad747dc49681b256d83aa9a9e35375ded">enum_order</a> ordering, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> recheck_range)</td></tr>
<tr class="memdesc:ga58ae76202144e523704ebe6be47e2c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to check whether it's better to use range than ref.  <a href="#ga58ae76202144e523704ebe6be47e2c7f">More...</a><br /></td></tr>
<tr class="separator:ga58ae76202144e523704ebe6be47e2c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1988b091d27a7072e1d8343f079a43a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac1988b091d27a7072e1d8343f079a43a">has_not_null_predicate</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem__field.html">Item_field</a> *not_null_item)</td></tr>
<tr class="memdesc:gac1988b091d27a7072e1d8343f079a43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check all existing AND'ed predicates in 'cond' for an existing 'is not null 'not_null_item''-predicate.  <a href="#gac1988b091d27a7072e1d8343f079a43a">More...</a><br /></td></tr>
<tr class="separator:gac1988b091d27a7072e1d8343f079a43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95a062cdd785687a638e01d7ad85d11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa95a062cdd785687a638e01d7ad85d11">substitute_gc</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex, <a class="el" href="classItem.html">Item</a> *where_cond, <a class="el" href="structORDER.html">ORDER</a> *group_list, <a class="el" href="structORDER.html">ORDER</a> *order)</td></tr>
<tr class="memdesc:gaa95a062cdd785687a638e01d7ad85d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all expressions in the WHERE condition and ORDER/GROUP lists that match generated columns (GC) expressions with GC fields, if any.  <a href="#gaa95a062cdd785687a638e01d7ad85d11">More...</a><br /></td></tr>
<tr class="separator:gaa95a062cdd785687a638e01d7ad85d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3819a0b6a5459bd00c3333e836fc2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2f3819a0b6a5459bd00c3333e836fc2f">is_prefix_index</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx)</td></tr>
<tr class="memdesc:ga2f3819a0b6a5459bd00c3333e836fc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this is a prefix index.  <a href="#ga2f3819a0b6a5459bd00c3333e836fc2f">More...</a><br /></td></tr>
<tr class="separator:ga2f3819a0b6a5459bd00c3333e836fc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54996e06c3934bd6ee3082e0b9c67e49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga54996e06c3934bd6ee3082e0b9c67e49">test_if_order_by_key</a> (<a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *order_src, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *used_key_parts, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *skip_quick)</td></tr>
<tr class="memdesc:ga54996e06c3934bd6ee3082e0b9c67e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if one can use the key to resolve ordering.  <a href="#ga54996e06c3934bd6ee3082e0b9c67e49">More...</a><br /></td></tr>
<tr class="separator:ga54996e06c3934bd6ee3082e0b9c67e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6685d7e8762b223a126002bb6a45a36d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6685d7e8762b223a126002bb6a45a36d">find_shortest_key</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *usable_keys)</td></tr>
<tr class="memdesc:ga6685d7e8762b223a126002bb6a45a36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find shortest key suitable for full table scan.  <a href="#ga6685d7e8762b223a126002bb6a45a36d">More...</a><br /></td></tr>
<tr class="separator:ga6685d7e8762b223a126002bb6a45a36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8d854a364ab749539a9363619acf99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4a8d854a364ab749539a9363619acf99">is_subkey</a> (<a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *ref_key_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *ref_key_part_end)</td></tr>
<tr class="memdesc:ga4a8d854a364ab749539a9363619acf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a second key is the subkey of the first one.  <a href="#ga4a8d854a364ab749539a9363619acf99">More...</a><br /></td></tr>
<tr class="separator:ga4a8d854a364ab749539a9363619acf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30906cdf5fbe1016d2fbf9471747235d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga30906cdf5fbe1016d2fbf9471747235d">is_ref_or_null_optimized</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ref_key)</td></tr>
<tr class="memdesc:ga30906cdf5fbe1016d2fbf9471747235d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if REF_OR_NULL optimization will be used if the specified ref_key is used for REF-access to 'tab'.  <a href="#ga30906cdf5fbe1016d2fbf9471747235d">More...</a><br /></td></tr>
<tr class="separator:ga30906cdf5fbe1016d2fbf9471747235d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c554fe46402549598f7d273ebb77bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa4c554fe46402549598f7d273ebb77bf">test_if_subkey</a> (<a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *order, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ref, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ref_key_parts, const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *usable_keys)</td></tr>
<tr class="memdesc:gaa4c554fe46402549598f7d273ebb77bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if we can use one of the 'usable_keys' instead of 'ref' key for sorting.  <a href="#gaa4c554fe46402549598f7d273ebb77bf">More...</a><br /></td></tr>
<tr class="separator:gaa4c554fe46402549598f7d273ebb77bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0385fefcc15abb1cf1eec240c394b69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab0385fefcc15abb1cf1eec240c394b69">alloc_jtab_array</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> table_count)</td></tr>
<tr class="separator:gab0385fefcc15abb1cf1eec240c394b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0283c484bf5fee7f5b6650d9e05020f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0283c484bf5fee7f5b6650d9e05020f7">revise_cache_usage</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:ga0283c484bf5fee7f5b6650d9e05020f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874abd8fac03d08de3598b7ea65f4dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__equal.html">Item_equal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga874abd8fac03d08de3598b7ea65f4dd0">find_item_equal</a> (<a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal, const <a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *inherited_fl)</td></tr>
<tr class="memdesc:ga874abd8fac03d08de3598b7ea65f4dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the multiple equality predicate containing a field.  <a href="#ga874abd8fac03d08de3598b7ea65f4dd0">More...</a><br /></td></tr>
<tr class="separator:ga874abd8fac03d08de3598b7ea65f4dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d1175177356bf1c9b05e9104d28c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga67d1175177356bf1c9b05e9104d28c5b">get_best_field</a> (<a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal)</td></tr>
<tr class="memdesc:ga67d1175177356bf1c9b05e9104d28c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the best field substitution for a given field.  <a href="#ga67d1175177356bf1c9b05e9104d28c5b">More...</a><br /></td></tr>
<tr class="separator:ga67d1175177356bf1c9b05e9104d28c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3560b97f2f3ef1f74be30da9ce2bfa80"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3560b97f2f3ef1f74be30da9ce2bfa80">check_simple_equality</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *left_item, <a class="el" href="classItem.html">Item</a> *right_item, <a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *simple_equality)</td></tr>
<tr class="memdesc:ga3560b97f2f3ef1f74be30da9ce2bfa80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an equality can be used to build multiple equalities.  <a href="#ga3560b97f2f3ef1f74be30da9ce2bfa80">More...</a><br /></td></tr>
<tr class="separator:ga3560b97f2f3ef1f74be30da9ce2bfa80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d7d1207abe68616dfe64e211bc3fa2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga52d7d1207abe68616dfe64e211bc3fa2">check_row_equality</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *left_row, <a class="el" href="classItem__row.html">Item_row</a> *right_row, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *eq_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *simple_equality)</td></tr>
<tr class="memdesc:ga52d7d1207abe68616dfe64e211bc3fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert row equalities into a conjunction of regular equalities.  <a href="#ga52d7d1207abe68616dfe64e211bc3fa2">More...</a><br /></td></tr>
<tr class="separator:ga52d7d1207abe68616dfe64e211bc3fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7826a5beaf7a31c8b971a28919e3b4e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7826a5beaf7a31c8b971a28919e3b4e7">check_equality</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *eq_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *equality)</td></tr>
<tr class="memdesc:ga7826a5beaf7a31c8b971a28919e3b4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate row equalities and form multiple equalities predicates.  <a href="#ga7826a5beaf7a31c8b971a28919e3b4e7">More...</a><br /></td></tr>
<tr class="separator:ga7826a5beaf7a31c8b971a28919e3b4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cb02362e547839e5cdc6fa13fad054"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa2cb02362e547839e5cdc6fa13fad054">build_equal_items_for_cond</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> **retcond, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *inherited, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> do_inherit)</td></tr>
<tr class="memdesc:gaa2cb02362e547839e5cdc6fa13fad054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all equality predicates in a condition by multiple equality items.  <a href="#gaa2cb02362e547839e5cdc6fa13fad054">More...</a><br /></td></tr>
<tr class="separator:gaa2cb02362e547839e5cdc6fa13fad054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348b33d99b2bb2271c80442c0378852b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga348b33d99b2bb2271c80442c0378852b">build_equal_items</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> **retcond, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *inherited, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> do_inherit, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *join_list, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **cond_equal_ref)</td></tr>
<tr class="memdesc:ga348b33d99b2bb2271c80442c0378852b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build multiple equalities for a WHERE condition and all join conditions that inherit these multiple equalities.  <a href="#ga348b33d99b2bb2271c80442c0378852b">More...</a><br /></td></tr>
<tr class="separator:ga348b33d99b2bb2271c80442c0378852b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0208854e710ff5f8d6793f8812c9776f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0208854e710ff5f8d6793f8812c9776f">compare_fields_by_table_order</a> (<a class="el" href="classItem__field.html">Item_field</a> *field1, <a class="el" href="classItem__field.html">Item_field</a> *field2, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> **table_join_idx)</td></tr>
<tr class="memdesc:ga0208854e710ff5f8d6793f8812c9776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare field items by table order in the execution plan.  <a href="#ga0208854e710ff5f8d6793f8812c9776f">More...</a><br /></td></tr>
<tr class="separator:ga0208854e710ff5f8d6793f8812c9776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4207baaf2253f1e31be14b072bb1fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0f4207baaf2253f1e31be14b072bb1fe">eliminate_item_equal</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *upper_levels, <a class="el" href="classItem__equal.html">Item_equal</a> *item_equal)</td></tr>
<tr class="memdesc:ga0f4207baaf2253f1e31be14b072bb1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate minimal set of simple equalities equivalent to a multiple equality.  <a href="#ga0f4207baaf2253f1e31be14b072bb1fe">More...</a><br /></td></tr>
<tr class="separator:ga0f4207baaf2253f1e31be14b072bb1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969165446a2bd1152d11e32c5a2e8d68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga969165446a2bd1152d11e32c5a2e8d68">substitute_for_best_equal_field</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> **table_join_idx)</td></tr>
<tr class="memdesc:ga969165446a2bd1152d11e32c5a2e8d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute every field reference in a condition by the best equal field and eliminate all multiple equality predicates.  <a href="#ga969165446a2bd1152d11e32c5a2e8d68">More...</a><br /></td></tr>
<tr class="separator:ga969165446a2bd1152d11e32c5a2e8d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb4d89eb72721ed3cfee494d0a0ba26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga9cb4d89eb72721ed3cfee494d0a0ba26">change_cond_ref_to_const</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classI__List.html">I_List</a>&lt; <a class="el" href="classCOND__CMP.html">COND_CMP</a> &gt; *save_list, <a class="el" href="classItem.html">Item</a> *and_father, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> *field, <a class="el" href="classItem.html">Item</a> *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:ga9cb4d89eb72721ed3cfee494d0a0ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">change field = field to field = const for each found field = const in the and_level  <a href="#ga9cb4d89eb72721ed3cfee494d0a0ba26">More...</a><br /></td></tr>
<tr class="separator:ga9cb4d89eb72721ed3cfee494d0a0ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa02a9c5953372b94ac6edf44a5afef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gadfa02a9c5953372b94ac6edf44a5afef">propagate_cond_constants</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classI__List.html">I_List</a>&lt; <a class="el" href="classCOND__CMP.html">COND_CMP</a> &gt; *save_list, <a class="el" href="classItem.html">Item</a> *and_father, <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr class="memdesc:gadfa02a9c5953372b94ac6edf44a5afef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate constant values in a condition.  <a href="#gadfa02a9c5953372b94ac6edf44a5afef">More...</a><br /></td></tr>
<tr class="separator:gadfa02a9c5953372b94ac6edf44a5afef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe571c98d87a5062d82a0e8e66a128ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafe571c98d87a5062d82a0e8e66a128ba">build_bitmap_for_nested_joins</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *join_list, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> first_unused)</td></tr>
<tr class="memdesc:gafe571c98d87a5062d82a0e8e66a128ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign each nested join structure a bit in nested_join_map.  <a href="#gafe571c98d87a5062d82a0e8e66a128ba">More...</a><br /></td></tr>
<tr class="separator:gafe571c98d87a5062d82a0e8e66a128ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf7d0c085b6fa2c810619adfcc8cfd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaaaf7d0c085b6fa2c810619adfcc8cfd9">semijoin_types_allow_materialization</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *sj_nest)</td></tr>
<tr class="memdesc:gaaaf7d0c085b6fa2c810619adfcc8cfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if semijoin's compared types allow materialization.  <a href="#gaaaf7d0c085b6fa2c810619adfcc8cfd9">More...</a><br /></td></tr>
<tr class="separator:gaaaf7d0c085b6fa2c810619adfcc8cfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114620bef79e173403342eb2968ec285"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga114620bef79e173403342eb2968ec285">check_skip_records_in_range_qualification</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga114620bef79e173403342eb2968ec285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index dive can be skipped if the following conditions are satisfied: F1) For a single table query: a) FORCE INDEX applies to a single index.  <a href="#ga114620bef79e173403342eb2968ec285">More...</a><br /></td></tr>
<tr class="separator:ga114620bef79e173403342eb2968ec285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496897de00e555d82e8826fd8ae55b9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga496897de00e555d82e8826fd8ae55b9d">get_tmp_table_rec_length</a> (const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;<a class="el" href="structitems.html">items</a>)</td></tr>
<tr class="separator:ga496897de00e555d82e8826fd8ae55b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd1a69b3e1720db0f18324d53135288b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafd1a69b3e1720db0f18324d53135288b">add_not_null_conds</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="memdesc:gafd1a69b3e1720db0f18324d53135288b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to join_tab[i]-&gt;condition() "table.field IS NOT NULL" conditions we've inferred from ref/eq_ref access performed.  <a href="#gafd1a69b3e1720db0f18324d53135288b">More...</a><br /></td></tr>
<tr class="separator:gafd1a69b3e1720db0f18324d53135288b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652bf7109dfbe0fdd7deb75c05c0a7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga652bf7109dfbe0fdd7deb75c05c0a7a3">uses_index_fields_only</a> (<a class="el" href="classItem.html">Item</a> *item, <a class="el" href="structTABLE.html">TABLE</a> *tbl, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> other_tbls_ok)</td></tr>
<tr class="memdesc:ga652bf7109dfbe0fdd7deb75c05c0a7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given expression only uses fields covered by index <em>keyno</em> in the table tbl.  <a href="#ga652bf7109dfbe0fdd7deb75c05c0a7a3">More...</a><br /></td></tr>
<tr class="separator:ga652bf7109dfbe0fdd7deb75c05c0a7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10df978ef681f041d62558e278876e95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga10df978ef681f041d62558e278876e95">find_eq_ref_candidate</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> sj_inner_tables)</td></tr>
<tr class="separator:ga10df978ef681f041d62558e278876e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e622501615212f22ca3d4ab13d0fbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2e622501615212f22ca3d4ab13d0fbb0">is_indexed_agg_distinct</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem__field.html">Item_field</a> *&gt; *out_args)</td></tr>
<tr class="memdesc:ga2e622501615212f22ca3d4ab13d0fbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for the presence of AGGFN(DISTINCT a) queries that may be subject to loose index scan.  <a href="#ga2e622501615212f22ca3d4ab13d0fbb0">More...</a><br /></td></tr>
<tr class="separator:ga2e622501615212f22ca3d4ab13d0fbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a5dae85600d51fdc79def4ad5ff867"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga78a5dae85600d51fdc79def4ad5ff867">trace_indexes_added_group_distinct</a> (<a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *trace, const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab, const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> new_keys, const char *cause)</td></tr>
<tr class="memdesc:ga78a5dae85600d51fdc79def4ad5ff867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print keys that were appended to join_tab-&gt;const_keys because they can be used for GROUP BY or DISTINCT to the optimizer trace.  <a href="#ga78a5dae85600d51fdc79def4ad5ff867">More...</a><br /></td></tr>
<tr class="separator:ga78a5dae85600d51fdc79def4ad5ff867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d32cd303d430b9aea224023f81366ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5d32cd303d430b9aea224023f81366ae">create_keyuse_for_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyparts, <a class="el" href="classItem__field.html">Item_field</a> **fields, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;outer_exprs)</td></tr>
<tr class="memdesc:ga5d32cd303d430b9aea224023f81366ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a keyuse array for a table with a primary key.  <a href="#ga5d32cd303d430b9aea224023f81366ae">More...</a><br /></td></tr>
<tr class="separator:ga5d32cd303d430b9aea224023f81366ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7252c09f8c4bb8c212a719b88adb44c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7252c09f8c4bb8c212a719b88adb44c6">add_found_match_trig_cond</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> idx, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> root_idx)</td></tr>
<tr class="memdesc:ga7252c09f8c4bb8c212a719b88adb44c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a condition guarded by match variables for embedded outer joins.  <a href="#ga7252c09f8c4bb8c212a719b88adb44c6">More...</a><br /></td></tr>
<tr class="separator:ga7252c09f8c4bb8c212a719b88adb44c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de853250ebf294ab84cf50d8f9234ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3de853250ebf294ab84cf50d8f9234ce">part_of_refkey</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, const <a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr class="separator:ga3de853250ebf294ab84cf50d8f9234ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f6a1f0bfeb420f0093002d4814c782"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga16f6a1f0bfeb420f0093002d4814c782">test_if_ref</a> (<a class="el" href="classItem__field.html">Item_field</a> *left_item, <a class="el" href="classItem.html">Item</a> *right_item)</td></tr>
<tr class="memdesc:ga16f6a1f0bfeb420f0093002d4814c782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify redundant predicates.  <a href="#ga16f6a1f0bfeb420f0093002d4814c782">More...</a><br /></td></tr>
<tr class="separator:ga16f6a1f0bfeb420f0093002d4814c782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae85874c3c0521511d02daba0b891e17b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae85874c3c0521511d02daba0b891e17b">reduce_cond_for_table</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> null_extended)</td></tr>
<tr class="memdesc:gae85874c3c0521511d02daba0b891e17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove redundant predicates from condition, return the reduced condition.  <a href="#gae85874c3c0521511d02daba0b891e17b">More...</a><br /></td></tr>
<tr class="separator:gae85874c3c0521511d02daba0b891e17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb279aada05a574f0745fe7dc700389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga9cb279aada05a574f0745fe7dc700389">make_cond_for_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tables, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> used_table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> exclude_expensive_cond)</td></tr>
<tr class="memdesc:ga9cb279aada05a574f0745fe7dc700389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a condition that can be checked after reading given table.  <a href="#ga9cb279aada05a574f0745fe7dc700389">More...</a><br /></td></tr>
<tr class="separator:ga9cb279aada05a574f0745fe7dc700389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6581c041c0e0f1f0f681536e0ca35dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad6581c041c0e0f1f0f681536e0ca35dc">eq_ref_table</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structORDER.html">ORDER</a> *start_order, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *cached_eq_ref_tables, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *eq_ref_tables)</td></tr>
<tr class="memdesc:gad6581c041c0e0f1f0f681536e0ca35dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the following expressions from ORDER BY and GROUP BY: Constant expressions <br />
Expression that only uses tables that are of type EQ_REF and the reference is in the ORDER list or if all refereed tables are of the above type.  <a href="#gad6581c041c0e0f1f0f681536e0ca35dc">More...</a><br /></td></tr>
<tr class="separator:gad6581c041c0e0f1f0f681536e0ca35dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae977f888923f3443e09345a10bbee9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaae977f888923f3443e09345a10bbee9a">duplicate_order</a> (const <a class="el" href="structORDER.html">ORDER</a> *first_order, const <a class="el" href="structORDER.html">ORDER</a> *possible_dup)</td></tr>
<tr class="memdesc:gaae977f888923f3443e09345a10bbee9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an expression in ORDER BY or GROUP BY is a duplicate of a preceding expression.  <a href="#gaae977f888923f3443e09345a10bbee9a">More...</a><br /></td></tr>
<tr class="separator:gaae977f888923f3443e09345a10bbee9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e311ce93e412ea78a25b7016f91574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab2e311ce93e412ea78a25b7016f91574">optimize_cond</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> **cond, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **cond_equal, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *join_list, <a class="el" href="classItem.html#ab74b339b7c522a3a7aa2b8e4e8123a1b">Item::cond_result</a> *cond_value)</td></tr>
<tr class="memdesc:gab2e311ce93e412ea78a25b7016f91574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize conditions by.  <a href="#gab2e311ce93e412ea78a25b7016f91574">More...</a><br /></td></tr>
<tr class="separator:gab2e311ce93e412ea78a25b7016f91574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac401066634b96cf4a9e7309cad34414e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac401066634b96cf4a9e7309cad34414e">can_evaluate_condition</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *condition)</td></tr>
<tr class="memdesc:gac401066634b96cf4a9e7309cad34414e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a condition can be evaluated during constant folding.  <a href="#gac401066634b96cf4a9e7309cad34414e">More...</a><br /></td></tr>
<tr class="separator:gac401066634b96cf4a9e7309cad34414e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8c5bf080cc0dc7eb7a5c8496cbd0f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga9d8c5bf080cc0dc7eb7a5c8496cbd0f8">fold_condition_exec</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> **retcond, <a class="el" href="classItem.html#ab74b339b7c522a3a7aa2b8e4e8123a1b">Item::cond_result</a> *cond_value)</td></tr>
<tr class="memdesc:ga9d8c5bf080cc0dc7eb7a5c8496cbd0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls fold_condition.  <a href="#ga9d8c5bf080cc0dc7eb7a5c8496cbd0f8">More...</a><br /></td></tr>
<tr class="separator:ga9d8c5bf080cc0dc7eb7a5c8496cbd0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c7623dfe6301253414f9155999c43b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf8c7623dfe6301253414f9155999c43b">remove_eq_conds</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> **retcond, <a class="el" href="classItem.html#ab74b339b7c522a3a7aa2b8e4e8123a1b">Item::cond_result</a> *cond_value)</td></tr>
<tr class="memdesc:gaf8c7623dfe6301253414f9155999c43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes const and eq items.  <a href="#gaf8c7623dfe6301253414f9155999c43b">More...</a><br /></td></tr>
<tr class="separator:gaf8c7623dfe6301253414f9155999c43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b6ab09ca6fe0b8e9b32afeedc792a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab9b6ab09ca6fe0b8e9b32afeedc792a3">create_order_from_distinct</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="structORDER.html">ORDER</a> *order_list, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> skip_aggregates, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> convert_bit_fields_to_long, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *all_order_by_fields_used)</td></tr>
<tr class="memdesc:gab9b6ab09ca6fe0b8e9b32afeedc792a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an order list that consists of all non-const fields and items.  <a href="#gab9b6ab09ca6fe0b8e9b32afeedc792a3">More...</a><br /></td></tr>
<tr class="separator:gab9b6ab09ca6fe0b8e9b32afeedc792a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68dccbbb65e6bd21dc9ed043f2e974d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga68dccbbb65e6bd21dc9ed043f2e974d4">calculate_subquery_executions</a> (const <a class="el" href="classItem__subselect.html">Item_subselect</a> *subquery, <a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *trace)</td></tr>
<tr class="memdesc:ga68dccbbb65e6bd21dc9ed043f2e974d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates how many times a subquery will be executed as part of a query execution.  <a href="#ga68dccbbb65e6bd21dc9ed043f2e974d4">More...</a><br /></td></tr>
<tr class="separator:ga68dccbbb65e6bd21dc9ed043f2e974d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34118cfe3438321eb175c855298cead0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstore__key.html">store_key</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga34118cfe3438321eb175c855298cead0">get_store_key</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classKey__use.html">Key_use</a> *keyuse, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> used_tables, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *key_buff, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> maybe_null)</td></tr>
<tr class="separator:ga34118cfe3438321eb175c855298cead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917e7ed7a41a5ba223ef428d52797ce7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga917e7ed7a41a5ba223ef428d52797ce7">actual_key_flags</a> (<a class="el" href="classKEY.html">KEY</a> *key_info)</td></tr>
<tr class="memdesc:ga917e7ed7a41a5ba223ef428d52797ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns key flags depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.  <a href="#ga917e7ed7a41a5ba223ef428d52797ce7">More...</a><br /></td></tr>
<tr class="separator:ga917e7ed7a41a5ba223ef428d52797ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e80da3a71b87f39e4a6844bd59651e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga43e80da3a71b87f39e4a6844bd59651e">is_show_cmd_using_system_view</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga43e80da3a71b87f39e4a6844bd59651e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the statement is a SHOW command using INFORMATION_SCHEMA system views.  <a href="#ga43e80da3a71b87f39e4a6844bd59651e">More...</a><br /></td></tr>
<tr class="separator:ga43e80da3a71b87f39e4a6844bd59651e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77d58d476f44178e469e2cbe16e9e01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae77d58d476f44178e469e2cbe16e9e01">handle_query</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structLEX.html">LEX</a> *lex, <a class="el" href="classQuery__result.html">Query_result</a> *<a class="el" href="structresult.html">result</a>, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> added_options, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> removed_options)</td></tr>
<tr class="memdesc:gae77d58d476f44178e469e2cbe16e9e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle data manipulation query which is not represented by Sql_cmd_dml class.  <a href="#gae77d58d476f44178e469e2cbe16e9e01">More...</a><br /></td></tr>
<tr class="separator:gae77d58d476f44178e469e2cbe16e9e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef546408e2eb81836284e515a871fbd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8ef546408e2eb81836284e515a871fbd">get_max_execution_time</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga8ef546408e2eb81836284e515a871fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum execution time for a statement.  <a href="#ga8ef546408e2eb81836284e515a871fbd">More...</a><br /></td></tr>
<tr class="separator:ga8ef546408e2eb81836284e515a871fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a494ca0bf471a2068fdb8211df2ed1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5a494ca0bf471a2068fdb8211df2ed1d">is_timer_applicable_to_statement</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga5a494ca0bf471a2068fdb8211df2ed1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether max statement time is applicable to statement or not.  <a href="#ga5a494ca0bf471a2068fdb8211df2ed1d">More...</a><br /></td></tr>
<tr class="separator:ga5a494ca0bf471a2068fdb8211df2ed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6887d6c5f56788688c7c727da969350c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6887d6c5f56788688c7c727da969350c">set_statement_timer</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga6887d6c5f56788688c7c727da969350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time until the currently running statement is aborted.  <a href="#ga6887d6c5f56788688c7c727da969350c">More...</a><br /></td></tr>
<tr class="separator:ga6887d6c5f56788688c7c727da969350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3632047b55b1b225c609f0f9ff46250a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3632047b55b1b225c609f0f9ff46250a">reset_statement_timer</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga3632047b55b1b225c609f0f9ff46250a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the timer associated with the statement that was executed.  <a href="#ga3632047b55b1b225c609f0f9ff46250a">More...</a><br /></td></tr>
<tr class="separator:ga3632047b55b1b225c609f0f9ff46250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2098edca4505e2804c6c948550e2829b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2098edca4505e2804c6c948550e2829b">reads_not_secondary_columns</a> (const <a class="el" href="structLEX.html">LEX</a> *lex)</td></tr>
<tr class="memdesc:ga2098edca4505e2804c6c948550e2829b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a query reads a column that is <em>not</em> available in the secondary engine (i.e.  <a href="#ga2098edca4505e2804c6c948550e2829b">More...</a><br /></td></tr>
<tr class="separator:ga2098edca4505e2804c6c948550e2829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523dd2f072c461823acd18472bd06193"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga523dd2f072c461823acd18472bd06193">validate_use_secondary_engine</a> (const <a class="el" href="structLEX.html">LEX</a> *lex)</td></tr>
<tr class="memdesc:ga523dd2f072c461823acd18472bd06193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates a query that uses the secondary engine.  <a href="#ga523dd2f072c461823acd18472bd06193">More...</a><br /></td></tr>
<tr class="separator:ga523dd2f072c461823acd18472bd06193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26de77d071499423b8d79d524e0d945"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac26de77d071499423b8d79d524e0d945">accumulate_statement_cost</a> (const <a class="el" href="structLEX.html">LEX</a> *lex)</td></tr>
<tr class="memdesc:gac26de77d071499423b8d79d524e0d945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cost of executing a statement, including all its subqueries.  <a href="#gac26de77d071499423b8d79d524e0d945">More...</a><br /></td></tr>
<tr class="separator:gac26de77d071499423b8d79d524e0d945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d63fd61180432c250b2c474d55878b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7d63fd61180432c250b2c474d55878b8">retry_with_secondary_engine</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga7d63fd61180432c250b2c474d55878b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a query should be retried using a secondary storage engine.  <a href="#ga7d63fd61180432c250b2c474d55878b8">More...</a><br /></td></tr>
<tr class="separator:ga7d63fd61180432c250b2c474d55878b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1005a29706ad2d0486b8445016b16be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac1005a29706ad2d0486b8445016b16be">optimize_secondary_engine</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gac1005a29706ad2d0486b8445016b16be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform query optimizations that are specific to a secondary storage engine.  <a href="#gac1005a29706ad2d0486b8445016b16be">More...</a><br /></td></tr>
<tr class="separator:gac1005a29706ad2d0486b8445016b16be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc4588ad768d8db29b298d7bb4f6dcf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3bc4588ad768d8db29b298d7bb4f6dcf">check_locking_clause_access</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="group__Query__Optimizer.html#gaade220b9879946408da6785ebea5bc62">Global_tables_list</a> tables)</td></tr>
<tr class="memdesc:ga3bc4588ad768d8db29b298d7bb4f6dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs access check for the locking clause, if present.  <a href="#ga3bc4588ad768d8db29b298d7bb4f6dcf">More...</a><br /></td></tr>
<tr class="separator:ga3bc4588ad768d8db29b298d7bb4f6dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410e1c85b186cd5520a7d21930ead6e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga410e1c85b186cd5520a7d21930ead6e5">types_allow_materialization</a> (<a class="el" href="classItem.html">Item</a> *outer, <a class="el" href="classItem.html">Item</a> *inner)</td></tr>
<tr class="memdesc:ga410e1c85b186cd5520a7d21930ead6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two items are compatible wrt.  <a href="#ga410e1c85b186cd5520a7d21930ead6e5">More...</a><br /></td></tr>
<tr class="separator:ga410e1c85b186cd5520a7d21930ead6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683fa9f64c971af8a34e9711877a82ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga683fa9f64c971af8a34e9711877a82ee">sj_table_is_included</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:ga683fa9f64c971af8a34e9711877a82ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36219da5efa004452f343d3b329286e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga36219da5efa004452f343d3b329286e8">create_sj_tmp_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structSJ__TMP__TABLE__TAB.html">SJ_TMP_TABLE_TAB</a> *first_tab, <a class="el" href="structSJ__TMP__TABLE__TAB.html">SJ_TMP_TABLE_TAB</a> *last_tab)</td></tr>
<tr class="memdesc:ga36219da5efa004452f343d3b329286e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the support structures (NULL bits, row offsets, etc.) for a semijoin duplicate weedout table.  <a href="#ga36219da5efa004452f343d3b329286e8">More...</a><br /></td></tr>
<tr class="separator:ga36219da5efa004452f343d3b329286e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fa6e0c548ce639a90994ae43b49ef9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga66fa6e0c548ce639a90994ae43b49ef9">setup_semijoin_dups_elimination</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> no_jbuf_after)</td></tr>
<tr class="memdesc:ga66fa6e0c548ce639a90994ae43b49ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the strategies to eliminate semi-join duplicates.  <a href="#ga66fa6e0c548ce639a90994ae43b49ef9">More...</a><br /></td></tr>
<tr class="separator:ga66fa6e0c548ce639a90994ae43b49ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2581670e2e142b312e64ba314181980"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae2581670e2e142b312e64ba314181980">destroy_sj_tmp_tables</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="separator:gae2581670e2e142b312e64ba314181980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0ad5c49654db58fe3be002e652ba5b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad0ad5c49654db58fe3be002e652ba5b3">check_privileges_for_join</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *tables)</td></tr>
<tr class="memdesc:gad0ad5c49654db58fe3be002e652ba5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check privileges for column references in a JOIN expression.  <a href="#gad0ad5c49654db58fe3be002e652ba5b3">More...</a><br /></td></tr>
<tr class="separator:gad0ad5c49654db58fe3be002e652ba5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05979f955bc1cecfc80d1ff7523b97df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga05979f955bc1cecfc80d1ff7523b97df">check_privileges_for_list</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;<a class="el" href="structitems.html">items</a>, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> privileges)</td></tr>
<tr class="memdesc:ga05979f955bc1cecfc80d1ff7523b97df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check privileges for column references in an item list.  <a href="#ga05979f955bc1cecfc80d1ff7523b97df">More...</a><br /></td></tr>
<tr class="separator:ga05979f955bc1cecfc80d1ff7523b97df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff9e6d6a3acbc2b2799a8e28d132f06b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaff9e6d6a3acbc2b2799a8e28d132f06b">calc_used_field_length</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> needs_rowid, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *p_used_fieldlength)</td></tr>
<tr class="memdesc:gaff9e6d6a3acbc2b2799a8e28d132f06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find how much space the prevous read not const tables takes in cache.  <a href="#gaff9e6d6a3acbc2b2799a8e28d132f06b">More...</a><br /></td></tr>
<tr class="separator:gaff9e6d6a3acbc2b2799a8e28d132f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f8a3668a5d5771061e14f5d87c30794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5f8a3668a5d5771061e14f5d87c30794">calc_length_and_keyparts</a> (<a class="el" href="classKey__use.html">Key_use</a> *keyuse, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> used_tables, <a class="el" href="classKey__use.html">Key_use</a> **chosen_keyuses, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *length_out, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *keyparts_out, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *dep_map, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *maybe_null)</td></tr>
<tr class="memdesc:ga5f8a3668a5d5771061e14f5d87c30794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate properties of ref key: key length, number of used key parts, dependency map, possibility of null.  <a href="#ga5f8a3668a5d5771061e14f5d87c30794">More...</a><br /></td></tr>
<tr class="separator:ga5f8a3668a5d5771061e14f5d87c30794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b518fb7975676afc7395b412e803368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3b518fb7975676afc7395b412e803368">create_ref_for_key</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *j, <a class="el" href="classKey__use.html">Key_use</a> *org_keyuse, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> used_tables)</td></tr>
<tr class="memdesc:ga3b518fb7975676afc7395b412e803368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup a ref access for looking up rows via an index (a key).  <a href="#ga3b518fb7975676afc7395b412e803368">More...</a><br /></td></tr>
<tr class="separator:ga3b518fb7975676afc7395b412e803368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc53770d0c83ac40c0a13e832af2612"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key::store_key_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaedc53770d0c83ac40c0a13e832af2612">type_conversion_status_to_store_key</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="sql_2field_8h.html#a3c413a12689e3e6ec053b6d7bc9ef160">type_conversion_status</a> ts)</td></tr>
<tr class="separator:gaedc53770d0c83ac40c0a13e832af2612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c0a5624f789fb0bf0c5fc5ec057de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad3c0a5624f789fb0bf0c5fc5ec057de9">and_conditions</a> (<a class="el" href="classItem.html">Item</a> **e1, <a class="el" href="classItem.html">Item</a> *e2)</td></tr>
<tr class="memdesc:gad3c0a5624f789fb0bf0c5fc5ec057de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend e1 by AND'ing e2 to the condition e1 points to.  <a href="#gad3c0a5624f789fb0bf0c5fc5ec057de9">More...</a><br /></td></tr>
<tr class="separator:gad3c0a5624f789fb0bf0c5fc5ec057de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7f25e97254e2d750e0a4c342dff519"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gada7f25e97254e2d750e0a4c342dff519">make_cond_for_index</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> other_tbls_ok)</td></tr>
<tr class="separator:gada7f25e97254e2d750e0a4c342dff519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7f2f6ab05ccb685726a77994db1c2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gace7f2f6ab05ccb685726a77994db1c2f">make_cond_remainder</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> exclude_index)</td></tr>
<tr class="separator:gace7f2f6ab05ccb685726a77994db1c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b74179b9a9207753aa3f93a9df4225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga27b74179b9a9207753aa3f93a9df4225">make_join_readinfo</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> no_jbuf_after)</td></tr>
<tr class="memdesc:ga27b74179b9a9207753aa3f93a9df4225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plan refinement stage: do various setup things for the executor.  <a href="#ga27b74179b9a9207753aa3f93a9df4225">More...</a><br /></td></tr>
<tr class="separator:ga27b74179b9a9207753aa3f93a9df4225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1351457ee30a4e67786117e50413541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf1351457ee30a4e67786117e50413541">error_if_full_join</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="memdesc:gaf1351457ee30a4e67786117e50413541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give error if we some tables are done with a full join.  <a href="#gaf1351457ee30a4e67786117e50413541">More...</a><br /></td></tr>
<tr class="separator:gaf1351457ee30a4e67786117e50413541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc980a72c17c8442fab87af085697d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gadbc980a72c17c8442fab87af085697d4">simple_remove_const</a> (<a class="el" href="structORDER.html">ORDER</a> *order, <a class="el" href="classItem.html">Item</a> *<a class="el" href="mysqldump_8cc.html#a620672e6df4b200a417a270c445a1e2a">where</a>)</td></tr>
<tr class="memdesc:gadbc980a72c17c8442fab87af085697d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out ORDER items those are equal to constants in WHERE.  <a href="#gadbc980a72c17c8442fab87af085697d4">More...</a><br /></td></tr>
<tr class="separator:gadbc980a72c17c8442fab87af085697d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723b75a22f5be037a5769a6e39d4ee5b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga723b75a22f5be037a5769a6e39d4ee5b">test_if_equality_guarantees_uniqueness</a> (const <a class="el" href="classItem.html">Item</a> *l, const <a class="el" href="classItem.html">Item</a> *<a class="el" href="pfs__example__plugin__employee_8cc.html#ab3f8ffa864d702be7152eed806293ad9">r</a>)</td></tr>
<tr class="separator:ga723b75a22f5be037a5769a6e39d4ee5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb541e941e7c4614ceb9eeddae48f9dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafb541e941e7c4614ceb9eeddae48f9dc">equal</a> (const <a class="el" href="classItem.html">Item</a> *i1, const <a class="el" href="classItem.html">Item</a> *i2, const <a class="el" href="classField.html">Field</a> *f2)</td></tr>
<tr class="separator:gafb541e941e7c4614ceb9eeddae48f9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b453613ff2aebe1f7fd2f46474953cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3b453613ff2aebe1f7fd2f46474953cd">const_expression_in_where</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> *comp_item, const <a class="el" href="classField.html">Field</a> *comp_field, <a class="el" href="classItem.html">Item</a> **const_item)</td></tr>
<tr class="memdesc:ga3b453613ff2aebe1f7fd2f46474953cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a field or an item is equal to a constant value in WHERE.  <a href="#ga3b453613ff2aebe1f7fd2f46474953cd">More...</a><br /></td></tr>
<tr class="separator:ga3b453613ff2aebe1f7fd2f46474953cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73711fd03f3d32c120a6cfcbb72cfbe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga73711fd03f3d32c120a6cfcbb72cfbe5">count_field_types</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reset_with_sum_func, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> save_sum_fields)</td></tr>
<tr class="memdesc:ga73711fd03f3d32c120a6cfcbb72cfbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update TMP_TABLE_PARAM with count of the different type of fields.  <a href="#ga73711fd03f3d32c120a6cfcbb72cfbe5">More...</a><br /></td></tr>
<tr class="separator:ga73711fd03f3d32c120a6cfcbb72cfbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5a2e1822e2131fcfbe6501a8a97525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4d5a2e1822e2131fcfbe6501a8a97525">test_if_subpart</a> (<a class="el" href="structORDER.html">ORDER</a> *a, <a class="el" href="structORDER.html">ORDER</a> *b)</td></tr>
<tr class="memdesc:ga4d5a2e1822e2131fcfbe6501a8a97525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if second is a subpart of first argument.  <a href="#ga4d5a2e1822e2131fcfbe6501a8a97525">More...</a><br /></td></tr>
<tr class="separator:ga4d5a2e1822e2131fcfbe6501a8a97525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa978828bfe7be091fb76e1c5da80d644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa978828bfe7be091fb76e1c5da80d644">calc_group_buffer</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structORDER.html">ORDER</a> *group)</td></tr>
<tr class="memdesc:gaa978828bfe7be091fb76e1c5da80d644"><td class="mdescLeft">&#160;</td><td class="mdescRight">calc how big buffer we need for comparing group entries.  <a href="#gaa978828bfe7be091fb76e1c5da80d644">More...</a><br /></td></tr>
<tr class="separator:gaa978828bfe7be091fb76e1c5da80d644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59080a3acd829efcf18fc56d51df215c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga59080a3acd829efcf18fc56d51df215c">free_underlaid_joins</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select)</td></tr>
<tr class="memdesc:ga59080a3acd829efcf18fc56d51df215c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free joins of subselect of this select.  <a href="#ga59080a3acd829efcf18fc56d51df215c">More...</a><br /></td></tr>
<tr class="separator:ga59080a3acd829efcf18fc56d51df215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110ac08d482c9821d4db6708b1a88bf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga110ac08d482c9821d4db6708b1a88bf2">test_if_cheaper_ordering</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *order, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> usable_keys, int ref_key, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> <a class="el" href="mysql_8cc.html#a9511379c243f7fd0f9e96bf76e3e09e3">select_limit</a>, int *new_key, int *new_key_direction, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *new_select_limit, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *new_used_key_parts, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *saved_best_key_parts)</td></tr>
<tr class="memdesc:ga110ac08d482c9821d4db6708b1a88bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a cheaper access key than a given key.  <a href="#ga110ac08d482c9821d4db6708b1a88bf2">More...</a><br /></td></tr>
<tr class="separator:ga110ac08d482c9821d4db6708b1a88bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd263bd63c9fcc617e0e879c765bb802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gacd263bd63c9fcc617e0e879c765bb802">get_index_for_order</a> (<a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *order, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> limit, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_sort, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *reverse)</td></tr>
<tr class="memdesc:gacd263bd63c9fcc617e0e879c765bb802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a key to apply single table UPDATE/DELETE by a given ORDER.  <a href="#gacd263bd63c9fcc617e0e879c765bb802">More...</a><br /></td></tr>
<tr class="separator:gacd263bd63c9fcc617e0e879c765bb802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6609ac0420a8a415d5a57cc6659f460d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6609ac0420a8a415d5a57cc6659f460d">actual_key_parts</a> (const <a class="el" href="classKEY.html">KEY</a> *key_info)</td></tr>
<tr class="memdesc:ga6609ac0420a8a415d5a57cc6659f460d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of key parts depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.  <a href="#ga6609ac0420a8a415d5a57cc6659f460d">More...</a><br /></td></tr>
<tr class="separator:ga6609ac0420a8a415d5a57cc6659f460d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf336d1a31135fd93a5564c5e090b50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaaf336d1a31135fd93a5564c5e090b50a">calc_join_type</a> (int <a class="el" href="sql__select_8h.html#a931d06905210c0f917b25d180eeb643f">quick_type</a>)</td></tr>
<tr class="separator:gaaf336d1a31135fd93a5564c5e090b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae61cb563ddbc36edfe43024c8a479190"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae61cb563ddbc36edfe43024c8a479190">JOIN::JOIN</a> (<a class="el" href="classTHD.html">THD</a> *thd_arg, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select)</td></tr>
<tr class="separator:gae61cb563ddbc36edfe43024c8a479190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0959185357c952da3da8a86ef979877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa0959185357c952da3da8a86ef979877">JOIN::alloc_ref_item_slice</a> (<a class="el" href="classTHD.html">THD</a> *thd_arg, int sliceno)</td></tr>
<tr class="memdesc:gaa0959185357c952da3da8a86ef979877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a ref_item slice, assume that slice size is in ref_items[0].  <a href="#gaa0959185357c952da3da8a86ef979877">More...</a><br /></td></tr>
<tr class="separator:gaa0959185357c952da3da8a86ef979877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3745c0a56d93ab20bee91493e11bcf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad3745c0a56d93ab20bee91493e11bcf8">JOIN::alloc_indirection_slices</a> ()</td></tr>
<tr class="separator:gad3745c0a56d93ab20bee91493e11bcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f01afeabbc410693c8f98d4f3559cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7f01afeabbc410693c8f98d4f3559cd5">JOIN::optimize</a> ()</td></tr>
<tr class="memdesc:ga7f01afeabbc410693c8f98d4f3559cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes one query block into a query execution plan (QEP.)  <a href="#ga7f01afeabbc410693c8f98d4f3559cd5">More...</a><br /></td></tr>
<tr class="separator:ga7f01afeabbc410693c8f98d4f3559cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719cd05281dd8ccc4a1dfac47eeeac92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga719cd05281dd8ccc4a1dfac47eeeac92">JOIN::create_access_paths_for_zero_rows</a> ()</td></tr>
<tr class="memdesc:ga719cd05281dd8ccc4a1dfac47eeeac92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create access paths with the knowledge that there are going to be zero rows coming from tables (before aggregation); typically because we know that all of them would be filtered away by WHERE (e.g.  <a href="#ga719cd05281dd8ccc4a1dfac47eeeac92">More...</a><br /></td></tr>
<tr class="separator:ga719cd05281dd8ccc4a1dfac47eeeac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6a205591a47565a5e3c2244d0c74a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2c6a205591a47565a5e3c2244d0c74a5">JOIN::push_to_engines</a> ()</td></tr>
<tr class="memdesc:ga2c6a205591a47565a5e3c2244d0c74a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle offloading of query parts to the underlying engines, when such is supported by their implementation.  <a href="#ga2c6a205591a47565a5e3c2244d0c74a5">More...</a><br /></td></tr>
<tr class="separator:ga2c6a205591a47565a5e3c2244d0c74a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff952112cba4e545fff770e79158220"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaeff952112cba4e545fff770e79158220">JOIN::set_plan_state</a> (<a class="el" href="classJOIN.html#a965b8cb3ded4b0e826a3cab5f7d88694">enum_plan_state</a> plan_state_arg)</td></tr>
<tr class="memdesc:gaeff952112cba4e545fff770e79158220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the plan's state of the JOIN.  <a href="#gaeff952112cba4e545fff770e79158220">More...</a><br /></td></tr>
<tr class="separator:gaeff952112cba4e545fff770e79158220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25137692b43e77232e60ccc9e502fcfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga25137692b43e77232e60ccc9e502fcfa">JOIN::alloc_qep</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="separator:ga25137692b43e77232e60ccc9e502fcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a07bf891c57c62aad090896e118cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga31a07bf891c57c62aad090896e118cd1">QEP_TAB::init</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *jt)</td></tr>
<tr class="memdesc:ga31a07bf891c57c62aad090896e118cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the object from a JOIN_TAB.  <a href="#ga31a07bf891c57c62aad090896e118cd1">More...</a><br /></td></tr>
<tr class="separator:ga31a07bf891c57c62aad090896e118cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0363af5ecbde624f02fbc38a695a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaee0363af5ecbde624f02fbc38a695a3b">QEP_TAB::get_sj_strategy</a> () const</td></tr>
<tr class="separator:gaee0363af5ecbde624f02fbc38a695a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada415e1d087c014e9b8a22b39980bfea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gada415e1d087c014e9b8a22b39980bfea">QEP_TAB::effective_index</a> () const</td></tr>
<tr class="memdesc:gada415e1d087c014e9b8a22b39980bfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index used for a table in a QEP.  <a href="#gada415e1d087c014e9b8a22b39980bfea">More...</a><br /></td></tr>
<tr class="separator:gada415e1d087c014e9b8a22b39980bfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc77304fe7c751bce4fa59ef52d91fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gabc77304fe7c751bce4fa59ef52d91fb0">JOIN_TAB::get_sj_strategy</a> () const</td></tr>
<tr class="separator:gabc77304fe7c751bce4fa59ef52d91fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09d537f6629efe192657db2e0205687"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf09d537f6629efe192657db2e0205687">JOIN::replace_index_subquery</a> ()</td></tr>
<tr class="memdesc:gaf09d537f6629efe192657db2e0205687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this is a subquery that can be evaluated by index look-ups.  <a href="#gaf09d537f6629efe192657db2e0205687">More...</a><br /></td></tr>
<tr class="separator:gaf09d537f6629efe192657db2e0205687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c2d0cf3f4b9f73f56a0d9d95a54507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga56c2d0cf3f4b9f73f56a0d9d95a54507">JOIN::optimize_distinct_group_order</a> ()</td></tr>
<tr class="memdesc:ga56c2d0cf3f4b9f73f56a0d9d95a54507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize DISTINCT, GROUP BY, ORDER BY clauses.  <a href="#ga56c2d0cf3f4b9f73f56a0d9d95a54507">More...</a><br /></td></tr>
<tr class="separator:ga56c2d0cf3f4b9f73f56a0d9d95a54507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e68fb1d5e464b534b0aa16efefb8a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga70e68fb1d5e464b534b0aa16efefb8a0">JOIN::test_skip_sort</a> ()</td></tr>
<tr class="memdesc:ga70e68fb1d5e464b534b0aa16efefb8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an index could be used to replace filesort for ORDER BY/GROUP BY.  <a href="#ga70e68fb1d5e464b534b0aa16efefb8a0">More...</a><br /></td></tr>
<tr class="separator:ga70e68fb1d5e464b534b0aa16efefb8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83205e07366599292b152f463e675776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga83205e07366599292b152f463e675776">JOIN::prune_table_partitions</a> ()</td></tr>
<tr class="memdesc:ga83205e07366599292b152f463e675776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune partitions for all tables of a join (query block).  <a href="#ga83205e07366599292b152f463e675776">More...</a><br /></td></tr>
<tr class="separator:ga83205e07366599292b152f463e675776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7528c5e9d72db9a2ad7da0a9a8249820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7528c5e9d72db9a2ad7da0a9a8249820">JOIN::adjust_access_methods</a> ()</td></tr>
<tr class="memdesc:ga7528c5e9d72db9a2ad7da0a9a8249820"><td class="mdescLeft">&#160;</td><td class="mdescRight">An utility function - apply heuristics and optimize access methods to tables.  <a href="#ga7528c5e9d72db9a2ad7da0a9a8249820">More...</a><br /></td></tr>
<tr class="separator:ga7528c5e9d72db9a2ad7da0a9a8249820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c1cf0874f4bda777557d012148e059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae9c1cf0874f4bda777557d012148e059">JOIN::get_best_combination</a> ()</td></tr>
<tr class="memdesc:gae9c1cf0874f4bda777557d012148e059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up JOIN_TAB structs according to the picked join order in best_positions.  <a href="#gae9c1cf0874f4bda777557d012148e059">More...</a><br /></td></tr>
<tr class="separator:gae9c1cf0874f4bda777557d012148e059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ebfbbca25d50293c45bac8ced7e75c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga27ebfbbca25d50293c45bac8ced7e75c">JOIN::recalculate_deps_of_remaining_lateral_derived_tables</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> plan_tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx)</td></tr>
<tr class="memdesc:ga27ebfbbca25d50293c45bac8ced7e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates JOIN::deps_of_remaining_lateral_derived_tables.  <a href="#ga27ebfbbca25d50293c45bac8ced7e75c">More...</a><br /></td></tr>
<tr class="separator:ga27ebfbbca25d50293c45bac8ced7e75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb89e9019215d5e8a281afe0573a62b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafb89e9019215d5e8a281afe0573a62b4">JOIN::update_depend_map</a> ()</td></tr>
<tr class="memdesc:gafb89e9019215d5e8a281afe0573a62b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the dependency map for the tables.  <a href="#gafb89e9019215d5e8a281afe0573a62b4">More...</a><br /></td></tr>
<tr class="separator:gafb89e9019215d5e8a281afe0573a62b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78adac8cc612e1c973ce448594c5523e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga78adac8cc612e1c973ce448594c5523e">JOIN::update_depend_map</a> (<a class="el" href="structORDER.html">ORDER</a> *<a class="el" href="classJOIN.html#ac06839682aae707b0e1d4fafd53abaf5">order</a>)</td></tr>
<tr class="memdesc:ga78adac8cc612e1c973ce448594c5523e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the dependency map for the sort order.  <a href="#ga78adac8cc612e1c973ce448594c5523e">More...</a><br /></td></tr>
<tr class="separator:ga78adac8cc612e1c973ce448594c5523e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa6edcfa6c4d934dd42d505d9de2fef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaeaa6edcfa6c4d934dd42d505d9de2fef">JOIN::update_equalities_for_sjm</a> ()</td></tr>
<tr class="memdesc:gaeaa6edcfa6c4d934dd42d505d9de2fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update equalities and keyuse references after semi-join materialization strategy is chosen.  <a href="#gaeaa6edcfa6c4d934dd42d505d9de2fef">More...</a><br /></td></tr>
<tr class="separator:gaeaa6edcfa6c4d934dd42d505d9de2fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a9a63131b536315d16d122eed3102a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga61a9a63131b536315d16d122eed3102a">JOIN::set_prefix_tables</a> ()</td></tr>
<tr class="memdesc:ga61a9a63131b536315d16d122eed3102a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign set of available (prefix) tables to all tables in query block.  <a href="#ga61a9a63131b536315d16d122eed3102a">More...</a><br /></td></tr>
<tr class="separator:ga61a9a63131b536315d16d122eed3102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411d49ad6ee9cee6b02f30d624022ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga411d49ad6ee9cee6b02f30d624022ae4">JOIN::make_join_plan</a> ()</td></tr>
<tr class="memdesc:ga411d49ad6ee9cee6b02f30d624022ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate best possible join order and initialize the join structure.  <a href="#ga411d49ad6ee9cee6b02f30d624022ae4">More...</a><br /></td></tr>
<tr class="separator:ga411d49ad6ee9cee6b02f30d624022ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e5e43ef7fb8034403c346059f9cfa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab5e5e43ef7fb8034403c346059f9cfa6">JOIN::init_planner_arrays</a> ()</td></tr>
<tr class="memdesc:gab5e5e43ef7fb8034403c346059f9cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize scratch arrays for the join order optimization.  <a href="#gab5e5e43ef7fb8034403c346059f9cfa6">More...</a><br /></td></tr>
<tr class="separator:gab5e5e43ef7fb8034403c346059f9cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga740bdc7fe4c25e9c0b1612fea1d999f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga740bdc7fe4c25e9c0b1612fea1d999f5">JOIN::propagate_dependencies</a> ()</td></tr>
<tr class="memdesc:ga740bdc7fe4c25e9c0b1612fea1d999f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate dependencies between tables due to outer join relations.  <a href="#ga740bdc7fe4c25e9c0b1612fea1d999f5">More...</a><br /></td></tr>
<tr class="separator:ga740bdc7fe4c25e9c0b1612fea1d999f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea741e73aad45b858b391622a33273ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaea741e73aad45b858b391622a33273ef">JOIN::extract_const_tables</a> ()</td></tr>
<tr class="memdesc:gaea741e73aad45b858b391622a33273ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract const tables based on row counts.  <a href="#gaea741e73aad45b858b391622a33273ef">More...</a><br /></td></tr>
<tr class="separator:gaea741e73aad45b858b391622a33273ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4a152ded12d0566290c25dbc358f38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab4a152ded12d0566290c25dbc358f38f">JOIN::extract_func_dependent_tables</a> ()</td></tr>
<tr class="memdesc:gab4a152ded12d0566290c25dbc358f38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract const tables based on functional dependencies.  <a href="#gab4a152ded12d0566290c25dbc358f38f">More...</a><br /></td></tr>
<tr class="separator:gab4a152ded12d0566290c25dbc358f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185f5a9bf8b8825fa0ed29b1a3aacd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga185f5a9bf8b8825fa0ed29b1a3aacd45">JOIN::update_sargable_from_const</a> (<a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> *sargables)</td></tr>
<tr class="memdesc:ga185f5a9bf8b8825fa0ed29b1a3aacd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update info on indexes that can be used for search lookups as reading const tables may has added new sargable predicates.  <a href="#ga185f5a9bf8b8825fa0ed29b1a3aacd45">More...</a><br /></td></tr>
<tr class="separator:ga185f5a9bf8b8825fa0ed29b1a3aacd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b09506dcb39946820202191577595b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga80b09506dcb39946820202191577595b">JOIN::estimate_rowcount</a> ()</td></tr>
<tr class="memdesc:ga80b09506dcb39946820202191577595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the number of matched rows for each joined table.  <a href="#ga80b09506dcb39946820202191577595b">More...</a><br /></td></tr>
<tr class="separator:ga80b09506dcb39946820202191577595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d3829776ab95dee43086b5aa43b234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga52d3829776ab95dee43086b5aa43b234">JOIN::set_semijoin_embedding</a> ()</td></tr>
<tr class="memdesc:ga52d3829776ab95dee43086b5aa43b234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set semi-join embedding join nest pointers.  <a href="#ga52d3829776ab95dee43086b5aa43b234">More...</a><br /></td></tr>
<tr class="separator:ga52d3829776ab95dee43086b5aa43b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db5dc577ffd7662b800cc6307183c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0db5dc577ffd7662b800cc6307183c2b">JOIN::mark_const_table</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *table, <a class="el" href="classKey__use.html">Key_use</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:ga0db5dc577ffd7662b800cc6307183c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move const tables first in the position array.  <a href="#ga0db5dc577ffd7662b800cc6307183c2b">More...</a><br /></td></tr>
<tr class="separator:ga0db5dc577ffd7662b800cc6307183c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6d51becf5eba76fdbca3e38597322a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6c6d51becf5eba76fdbca3e38597322a">JOIN::make_outerjoin_info</a> ()</td></tr>
<tr class="memdesc:ga6c6d51becf5eba76fdbca3e38597322a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in outer join related info for the execution plan structure.  <a href="#ga6c6d51becf5eba76fdbca3e38597322a">More...</a><br /></td></tr>
<tr class="separator:ga6c6d51becf5eba76fdbca3e38597322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a895f9d1ed62d02a455d1bf7c944c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0a895f9d1ed62d02a455d1bf7c944c3f">JOIN::attach_join_condition_to_nest</a> (<a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> first_inner, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> last_tab, <a class="el" href="classItem.html">Item</a> *join_cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_sj_mat_cond)</td></tr>
<tr class="memdesc:ga0a895f9d1ed62d02a455d1bf7c944c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for JOIN::attach_join_conditions().  <a href="#ga0a895f9d1ed62d02a455d1bf7c944c3f">More...</a><br /></td></tr>
<tr class="separator:ga0a895f9d1ed62d02a455d1bf7c944c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea10268473cae92c3bdbcf0ea4f97cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaaea10268473cae92c3bdbcf0ea4f97cc">JOIN::attach_join_conditions</a> (<a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> last_tab)</td></tr>
<tr class="memdesc:gaaea10268473cae92c3bdbcf0ea4f97cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach outer join conditions to generated table conditions in an optimal way.  <a href="#gaaea10268473cae92c3bdbcf0ea4f97cc">More...</a><br /></td></tr>
<tr class="separator:gaaea10268473cae92c3bdbcf0ea4f97cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8618420be2a887d3506a097f490b1d14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8618420be2a887d3506a097f490b1d14">JOIN::finalize_table_conditions</a> ()</td></tr>
<tr class="memdesc:ga8618420be2a887d3506a097f490b1d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove redundant predicates and cache constant expressions.  <a href="#ga8618420be2a887d3506a097f490b1d14">More...</a><br /></td></tr>
<tr class="separator:ga8618420be2a887d3506a097f490b1d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bf64a03ec666f565627fbb48ba4677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga92bf64a03ec666f565627fbb48ba4677">JOIN::generate_derived_keys</a> ()</td></tr>
<tr class="memdesc:ga92bf64a03ec666f565627fbb48ba4677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add keys to derived tables'/views' result tables in a list.  <a href="#ga92bf64a03ec666f565627fbb48ba4677">More...</a><br /></td></tr>
<tr class="separator:ga92bf64a03ec666f565627fbb48ba4677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace5d28995814f1af3b17478b8af4b23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gace5d28995814f1af3b17478b8af4b23f">JOIN::finalize_derived_keys</a> ()</td></tr>
<tr class="memdesc:gace5d28995814f1af3b17478b8af4b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each materialized derived table/view, informs every TABLE of the key it will (not) use, segregates used keys from unused keys in TABLE::key_info, and eliminates unused keys.  <a href="#gace5d28995814f1af3b17478b8af4b23f">More...</a><br /></td></tr>
<tr class="separator:gace5d28995814f1af3b17478b8af4b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac512af3edf6254e3de69d6ae645e5d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac512af3edf6254e3de69d6ae645e5d31">JOIN::remove_const</a> (<a class="el" href="structORDER.html">ORDER</a> *first_order, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> change_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *<a class="el" href="classJOIN.html#a4db755c5e40a9e7ef838b00b590aa848">simple_order</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> group_by)</td></tr>
<tr class="memdesc:gac512af3edf6254e3de69d6ae645e5d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all constants and check if ORDER only contains simple expressions.  <a href="#gac512af3edf6254e3de69d6ae645e5d31">More...</a><br /></td></tr>
<tr class="separator:gac512af3edf6254e3de69d6ae645e5d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c982de3c6d0e121753053df9a743bd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7c982de3c6d0e121753053df9a743bd5">JOIN::optimize_keyuse</a> ()</td></tr>
<tr class="memdesc:ga7c982de3c6d0e121753053df9a743bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update some values in keyuse for faster choose_table_order() loop.  <a href="#ga7c982de3c6d0e121753053df9a743bd5">More...</a><br /></td></tr>
<tr class="separator:ga7c982de3c6d0e121753053df9a743bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958fa96e63ffbd0291b04c7a39058bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga958fa96e63ffbd0291b04c7a39058bd5">JOIN::optimize_fts_query</a> ()</td></tr>
<tr class="memdesc:ga958fa96e63ffbd0291b04c7a39058bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function sets FT hints, initializes FT handlers and checks if FT index can be used as covered.  <a href="#ga958fa96e63ffbd0291b04c7a39058bd5">More...</a><br /></td></tr>
<tr class="separator:ga958fa96e63ffbd0291b04c7a39058bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c20a9b8d13f14275a4ee01f44f8cfa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7c20a9b8d13f14275a4ee01f44f8cfa2">JOIN::fts_index_access</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="memdesc:ga7c20a9b8d13f14275a4ee01f44f8cfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if FTS index only access is possible.  <a href="#ga7c20a9b8d13f14275a4ee01f44f8cfa2">More...</a><br /></td></tr>
<tr class="separator:ga7c20a9b8d13f14275a4ee01f44f8cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab466b49a22220854ef8f11a2c4a2ae8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab466b49a22220854ef8f11a2c4a2ae8a">JOIN::decide_subquery_strategy</a> ()</td></tr>
<tr class="memdesc:gab466b49a22220854ef8f11a2c4a2ae8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides between EXISTS and materialization; performs last steps to set up the chosen strategy.  <a href="#gab466b49a22220854ef8f11a2c4a2ae8a">More...</a><br /></td></tr>
<tr class="separator:gab466b49a22220854ef8f11a2c4a2ae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef71e4d47995d23cb99a76ef392eb2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gacef71e4d47995d23cb99a76ef392eb2a">JOIN::compare_costs_of_subquery_strategies</a> (<a class="el" href="item__subselect_8h.html#a7c264705c6dd06393c82679a17dc58fa">Subquery_strategy</a> *method)</td></tr>
<tr class="memdesc:gacef71e4d47995d23cb99a76ef392eb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells what is the cheapest between IN-&gt;EXISTS and subquery materialization, in terms of cost, for the subquery's JOIN.  <a href="#gacef71e4d47995d23cb99a76ef392eb2a">More...</a><br /></td></tr>
<tr class="separator:gacef71e4d47995d23cb99a76ef392eb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac99b2256ee62ddd1a435289c2acb8e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaac99b2256ee62ddd1a435289c2acb8e2">JOIN::optimize_rollup</a> ()</td></tr>
<tr class="memdesc:gaac99b2256ee62ddd1a435289c2acb8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize rollup specification.  <a href="#gaac99b2256ee62ddd1a435289c2acb8e2">More...</a><br /></td></tr>
<tr class="separator:gaac99b2256ee62ddd1a435289c2acb8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4f64b9b280796d9abe945b2eda94ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaef4f64b9b280796d9abe945b2eda94ac">JOIN::refine_best_rowcount</a> ()</td></tr>
<tr class="memdesc:gaef4f64b9b280796d9abe945b2eda94ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine the best_rowcount estimation based on what happens after tables have been joined: LIMIT and type of result sink.  <a href="#gaef4f64b9b280796d9abe945b2eda94ac">More...</a><br /></td></tr>
<tr class="separator:gaef4f64b9b280796d9abe945b2eda94ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09e0947bd16c224381213ad74798e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae09e0947bd16c224381213ad74798e0a">JOIN::get_current_fields</a> ()</td></tr>
<tr class="memdesc:gae09e0947bd16c224381213ad74798e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the clone of fields_list which is appropriate for evaluating expressions at the current stage of execution; which stage is denoted by the value of current_ref_item_slice.  <a href="#gae09e0947bd16c224381213ad74798e0a">More...</a><br /></td></tr>
<tr class="separator:gae09e0947bd16c224381213ad74798e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga005d0cdbd93b1354f4f55746664a2df2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCost__model__server.html">Cost_model_server</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga005d0cdbd93b1354f4f55746664a2df2">JOIN::cost_model</a> () const</td></tr>
<tr class="memdesc:ga005d0cdbd93b1354f4f55746664a2df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the cost model object to be used for this join.  <a href="#ga005d0cdbd93b1354f4f55746664a2df2">More...</a><br /></td></tr>
<tr class="separator:ga005d0cdbd93b1354f4f55746664a2df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fca8dbb532f59224d9ca897f3311e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga1fca8dbb532f59224d9ca897f3311e91">Sql_cmd_dml::prepare</a> (<a class="el" href="classTHD.html">THD</a> *thd) override</td></tr>
<tr class="memdesc:ga1fca8dbb532f59224d9ca897f3311e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-specific resolving (doesn't include LEX::prepare())  <a href="#ga1fca8dbb532f59224d9ca897f3311e91">More...</a><br /></td></tr>
<tr class="separator:ga1fca8dbb532f59224d9ca897f3311e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16791455bd548298dcd5b21828a9272b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga16791455bd548298dcd5b21828a9272b">Sql_cmd_select::accept</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSelect__lex__visitor.html">Select_lex_visitor</a> *visitor) override</td></tr>
<tr class="separator:ga16791455bd548298dcd5b21828a9272b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9828b3ec4766a8dd7ae897244c827b0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMYSQL__LEX__CSTRING.html">MYSQL_LEX_CSTRING</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga9828b3ec4766a8dd7ae897244c827b0e">Sql_cmd_select::eligible_secondary_storage_engine</a> () const override</td></tr>
<tr class="memdesc:ga9828b3ec4766a8dd7ae897244c827b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this statement of a type and on a form that makes it eligible for execution in a secondary storage engine?  <a href="#ga9828b3ec4766a8dd7ae897244c827b0e">More...</a><br /></td></tr>
<tr class="separator:ga9828b3ec4766a8dd7ae897244c827b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb5671ceeb1b43091f690fc9968d4291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gadb5671ceeb1b43091f690fc9968d4291">Sql_cmd_select::prepare_inner</a> (<a class="el" href="classTHD.html">THD</a> *thd) override</td></tr>
<tr class="memdesc:gadb5671ceeb1b43091f690fc9968d4291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a SELECT statement.  <a href="#gadb5671ceeb1b43091f690fc9968d4291">More...</a><br /></td></tr>
<tr class="separator:gadb5671ceeb1b43091f690fc9968d4291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd34eb4762fa59c46d42cb74b915a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3dd34eb4762fa59c46d42cb74b915a86">Sql_cmd_dml::execute</a> (<a class="el" href="classTHD.html">THD</a> *thd) override</td></tr>
<tr class="memdesc:ga3dd34eb4762fa59c46d42cb74b915a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a DML statement.  <a href="#ga3dd34eb4762fa59c46d42cb74b915a86">More...</a><br /></td></tr>
<tr class="separator:ga3dd34eb4762fa59c46d42cb74b915a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe316b62ad85228d8931a8474dee8b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaefe316b62ad85228d8931a8474dee8b3">Sql_cmd_dml::execute_inner</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gaefe316b62ad85228d8931a8474dee8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inner parts of query optimization and execution.  <a href="#gaefe316b62ad85228d8931a8474dee8b3">More...</a><br /></td></tr>
<tr class="separator:gaefe316b62ad85228d8931a8474dee8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17a75373e1849b6c001db7c0022bb54"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa17a75373e1849b6c001db7c0022bb54">Sql_cmd_dml::restore_cmd_properties</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gaa17a75373e1849b6c001db7c0022bb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore command properties before execution.  <a href="#gaa17a75373e1849b6c001db7c0022bb54">More...</a><br /></td></tr>
<tr class="separator:gaa17a75373e1849b6c001db7c0022bb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d6643eaddcec99ec847250bbc2e01a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga85d6643eaddcec99ec847250bbc2e01a">Sql_cmd_dml::save_cmd_properties</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga85d6643eaddcec99ec847250bbc2e01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save command properties, such as prepared query details and table props.  <a href="#ga85d6643eaddcec99ec847250bbc2e01a">More...</a><br /></td></tr>
<tr class="separator:ga85d6643eaddcec99ec847250bbc2e01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b85110a470360e40530494669448f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQuery__result.html">Query_result</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7b85110a470360e40530494669448f44">Sql_cmd_dml::query_result</a> () const</td></tr>
<tr class="separator:ga7b85110a470360e40530494669448f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef0fb59d04cf7283ec4cf618aa578db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7ef0fb59d04cf7283ec4cf618aa578db">Sql_cmd_dml::set_query_result</a> (<a class="el" href="classQuery__result.html">Query_result</a> *<a class="el" href="structresult.html">result</a>)</td></tr>
<tr class="memdesc:ga7ef0fb59d04cf7283ec4cf618aa578db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set query result object for this query statement.  <a href="#ga7ef0fb59d04cf7283ec4cf618aa578db">More...</a><br /></td></tr>
<tr class="separator:ga7ef0fb59d04cf7283ec4cf618aa578db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817d27fe6f8590ac50498fca33ecd275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga817d27fe6f8590ac50498fca33ecd275">Sql_cmd_select::precheck</a> (<a class="el" href="classTHD.html">THD</a> *thd) override</td></tr>
<tr class="memdesc:ga817d27fe6f8590ac50498fca33ecd275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an authorization precheck for an unprepared SELECT statement.  <a href="#ga817d27fe6f8590ac50498fca33ecd275">More...</a><br /></td></tr>
<tr class="separator:ga817d27fe6f8590ac50498fca33ecd275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3dd35b938bbcf70868e079fb60e566d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac3dd35b938bbcf70868e079fb60e566d">Sql_cmd_select::check_privileges</a> (<a class="el" href="classTHD.html">THD</a> *thd) override</td></tr>
<tr class="memdesc:gac3dd35b938bbcf70868e079fb60e566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an authorization check for a prepared SELECT statement.  <a href="#gac3dd35b938bbcf70868e079fb60e566d">More...</a><br /></td></tr>
<tr class="separator:gac3dd35b938bbcf70868e079fb60e566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f004e1cb6ce6b40bd18635e8504015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga23f004e1cb6ce6b40bd18635e8504015">Sql_cmd_dml::check_all_table_privileges</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga23f004e1cb6ce6b40bd18635e8504015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and check privileges for all tables in a DML statement.  <a href="#ga23f004e1cb6ce6b40bd18635e8504015">More...</a><br /></td></tr>
<tr class="separator:ga23f004e1cb6ce6b40bd18635e8504015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2040e597275c664a217cbfaf89bd78ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2040e597275c664a217cbfaf89bd78ec">JOIN::clear_sj_tmp_tables</a> ()</td></tr>
<tr class="memdesc:ga2040e597275c664a217cbfaf89bd78ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all rows from all temp tables used by NL-semijoin runtime.  <a href="#ga2040e597275c664a217cbfaf89bd78ec">More...</a><br /></td></tr>
<tr class="separator:ga2040e597275c664a217cbfaf89bd78ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067d6da56e62bca3d59a1b4f03564abb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga067d6da56e62bca3d59a1b4f03564abb">JOIN::clear_corr_derived_tmp_tables</a> ()</td></tr>
<tr class="memdesc:ga067d6da56e62bca3d59a1b4f03564abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties all correlated materialized derived tables.  <a href="#ga067d6da56e62bca3d59a1b4f03564abb">More...</a><br /></td></tr>
<tr class="separator:ga067d6da56e62bca3d59a1b4f03564abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e09d71987062663db1836d651ec4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad4e09d71987062663db1836d651ec4d4">JOIN::reset</a> ()</td></tr>
<tr class="memdesc:gad4e09d71987062663db1836d651ec4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the state of this join object so that it is ready for a new execution.  <a href="#gad4e09d71987062663db1836d651ec4d4">More...</a><br /></td></tr>
<tr class="separator:gad4e09d71987062663db1836d651ec4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed62f6e6cc8f6d042c806a154ea7137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gabed62f6e6cc8f6d042c806a154ea7137">JOIN::prepare_result</a> ()</td></tr>
<tr class="memdesc:gabed62f6e6cc8f6d042c806a154ea7137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare join result.  <a href="#gabed62f6e6cc8f6d042c806a154ea7137">More...</a><br /></td></tr>
<tr class="separator:gabed62f6e6cc8f6d042c806a154ea7137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a423667e0e552a7ae8609848ff43d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac7a423667e0e552a7ae8609848ff43d7">JOIN::destroy</a> ()</td></tr>
<tr class="memdesc:gac7a423667e0e552a7ae8609848ff43d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up and destroy join object.  <a href="#gac7a423667e0e552a7ae8609848ff43d7">More...</a><br /></td></tr>
<tr class="separator:gac7a423667e0e552a7ae8609848ff43d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c2491087beb6a3ad518e9926570e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga29c2491087beb6a3ad518e9926570e46">JOIN::cleanup_item_list</a> (const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;<a class="el" href="structitems.html">items</a>) const</td></tr>
<tr class="separator:ga29c2491087beb6a3ad518e9926570e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae627edcb32cecc272357bb0d0d38c597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae627edcb32cecc272357bb0d0d38c597">SELECT_LEX::optimize</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gae627edcb32cecc272357bb0d0d38c597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize a query block and all inner query expressions.  <a href="#gae627edcb32cecc272357bb0d0d38c597">More...</a><br /></td></tr>
<tr class="separator:gae627edcb32cecc272357bb0d0d38c597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6440d8645c9c66515254f7ae785d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6a6440d8645c9c66515254f7ae785d1d">SELECT_LEX::check_column_privileges</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga6a6440d8645c9c66515254f7ae785d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check privileges for all columns referenced from query block.  <a href="#ga6a6440d8645c9c66515254f7ae785d1d">More...</a><br /></td></tr>
<tr class="separator:ga6a6440d8645c9c66515254f7ae785d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f406638ef7004ded904c6a95fae79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga92f406638ef7004ded904c6a95fae79b">SELECT_LEX::check_privileges_for_subqueries</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga92f406638ef7004ded904c6a95fae79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check privileges for column references in subqueries of a query block.  <a href="#ga92f406638ef7004ded904c6a95fae79b">More...</a><br /></td></tr>
<tr class="separator:ga92f406638ef7004ded904c6a95fae79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22f3c04c1f8f32d744714cd2ab4332b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae22f3c04c1f8f32d744714cd2ab4332b">JOIN::init_ref_access</a> ()</td></tr>
<tr class="memdesc:gae22f3c04c1f8f32d744714cd2ab4332b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize ref access for all tables that use it.  <a href="#gae22f3c04c1f8f32d744714cd2ab4332b">More...</a><br /></td></tr>
<tr class="separator:gae22f3c04c1f8f32d744714cd2ab4332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ec58d0faabade96e5378b0e5a1c2c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab7ec58d0faabade96e5378b0e5a1c2c2">JOIN::set_semijoin_info</a> ()</td></tr>
<tr class="memdesc:gab7ec58d0faabade96e5378b0e5a1c2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the first_sj_inner_tab and last_sj_inner_tab fields for all tables inside the semijoin nests of the query.  <a href="#gab7ec58d0faabade96e5378b0e5a1c2c2">More...</a><br /></td></tr>
<tr class="separator:gab7ec58d0faabade96e5378b0e5a1c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee16bb48187eccb2a220efe292abc2ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaee16bb48187eccb2a220efe292abc2ca">store_key_field::store_key_field</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classField.html">Field</a> *to_field_arg, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ptr, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *null_ptr_arg, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> length, <a class="el" href="classField.html">Field</a> *from_field, const char *name_arg)</td></tr>
<tr class="separator:gaee16bb48187eccb2a220efe292abc2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03837179836dfc4291d28e7c1ab44ca9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga03837179836dfc4291d28e7c1ab44ca9">store_key_field::copy_inner</a> () override</td></tr>
<tr class="separator:ga03837179836dfc4291d28e7c1ab44ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0508bf7a0f0aa01ca757dd1ebdcdefb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0508bf7a0f0aa01ca757dd1ebdcdefb1">store_key_field::replace_from_field</a> (<a class="el" href="classField.html">Field</a> *from_field)</td></tr>
<tr class="separator:ga0508bf7a0f0aa01ca757dd1ebdcdefb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4ca6ff9b86660b16b133baf9483799"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5a4ca6ff9b86660b16b133baf9483799">store_key::store_key</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classField.html">Field</a> *field_arg, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ptr, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *null, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> length)</td></tr>
<tr class="separator:ga5a4ca6ff9b86660b16b133baf9483799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647c683a8a4fe8db606270f2a9c4e1c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga647c683a8a4fe8db606270f2a9c4e1c9">store_key::copy</a> ()</td></tr>
<tr class="memdesc:ga647c683a8a4fe8db606270f2a9c4e1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets ignore truncation warnings mode and calls the real copy method  <a href="#ga647c683a8a4fe8db606270f2a9c4e1c9">More...</a><br /></td></tr>
<tr class="separator:ga647c683a8a4fe8db606270f2a9c4e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a480457c43f6a2d73bd5d3d3766fdab"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga1a480457c43f6a2d73bd5d3d3766fdab">store_key_hash_item::copy_inner</a> () override</td></tr>
<tr class="separator:ga1a480457c43f6a2d73bd5d3d3766fdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b52c45009d9df070623dac245d876d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa0b52c45009d9df070623dac245d876d">store_key_item::store_key_item</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classField.html">Field</a> *to_field_arg, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ptr, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *null_ptr_arg, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> length, <a class="el" href="classItem.html">Item</a> *item_arg)</td></tr>
<tr class="separator:gaa0b52c45009d9df070623dac245d876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f61b04f1bdea3256f92050bf9bb521"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf1f61b04f1bdea3256f92050bf9bb521">store_key_item::copy_inner</a> () override</td></tr>
<tr class="separator:gaf1f61b04f1bdea3256f92050bf9bb521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ededf725731bb0cfd5a3871181f496e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5ededf725731bb0cfd5a3871181f496e">QEP_TAB::push_index_cond</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> keyno, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *trace_obj)</td></tr>
<tr class="memdesc:ga5ededf725731bb0cfd5a3871181f496e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to extract and push the index condition down to table handler.  <a href="#ga5ededf725731bb0cfd5a3871181f496e">More...</a><br /></td></tr>
<tr class="separator:ga5ededf725731bb0cfd5a3871181f496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35fc9fd6c8f8961fb6b03d1efc74f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa35fc9fd6c8f8961fb6b03d1efc74f10">JOIN::setup_semijoin_materialized_table</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> tableno, <a class="el" href="structPOSITION.html">POSITION</a> *inner_pos, <a class="el" href="structPOSITION.html">POSITION</a> *sjm_pos)</td></tr>
<tr class="memdesc:gaa35fc9fd6c8f8961fb6b03d1efc74f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the materialized table for a semi-join nest.  <a href="#gaa35fc9fd6c8f8961fb6b03d1efc74f10">More...</a><br /></td></tr>
<tr class="separator:gaa35fc9fd6c8f8961fb6b03d1efc74f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c5164eb9405b18a16ca8a3ee339047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga44c5164eb9405b18a16ca8a3ee339047">QEP_TAB::init_join_cache</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="memdesc:ga44c5164eb9405b18a16ca8a3ee339047"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function that allocates appropriate join cache object and sets next_select function of previous tab.  <a href="#ga44c5164eb9405b18a16ca8a3ee339047">More...</a><br /></td></tr>
<tr class="separator:ga44c5164eb9405b18a16ca8a3ee339047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a217df3532c76cee211d7e65dd86d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa0a217df3532c76cee211d7e65dd86d0">JOIN_TAB::set_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *t)</td></tr>
<tr class="separator:gaa0a217df3532c76cee211d7e65dd86d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ceb1154cde60c27cf304af914f6b5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5ceb1154cde60c27cf304af914f6b5ba">JOIN_TAB::init_join_cond_ref</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:ga5ceb1154cde60c27cf304af914f6b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pointer to the join condition of TABLE_LIST.  <a href="#ga5ceb1154cde60c27cf304af914f6b5ba">More...</a><br /></td></tr>
<tr class="separator:ga5ceb1154cde60c27cf304af914f6b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae913870950feb0d927de9b53963f0a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae913870950feb0d927de9b53963f0a6a">JOIN_TAB::cleanup</a> ()</td></tr>
<tr class="memdesc:gae913870950feb0d927de9b53963f0a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up associated table after query execution, including resources.  <a href="#gae913870950feb0d927de9b53963f0a6a">More...</a><br /></td></tr>
<tr class="separator:gae913870950feb0d927de9b53963f0a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5426869c15b3f454986507ede09bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaaf5426869c15b3f454986507ede09bab">QEP_TAB::cleanup</a> ()</td></tr>
<tr class="separator:gaaf5426869c15b3f454986507ede09bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907897f1c70ca51d710d46da42645cfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga907897f1c70ca51d710d46da42645cfc">QEP_shared_owner::qs_cleanup</a> ()</td></tr>
<tr class="separator:ga907897f1c70ca51d710d46da42645cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c4cb376fec34447cf5df2b3d4c238a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac2c4cb376fec34447cf5df2b3d4c238a">QEP_TAB::sjm_query_block_id</a> () const</td></tr>
<tr class="separator:gac2c4cb376fec34447cf5df2b3d4c238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d28b10dac195744ef3daaab70d84208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2d28b10dac195744ef3daaab70d84208">QEP_shared_owner::and_with_condition</a> (<a class="el" href="classItem.html">Item</a> *tmp_cond)</td></tr>
<tr class="memdesc:ga2d28b10dac195744ef3daaab70d84208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend join_tab-&gt;cond by AND'ing add_cond to it.  <a href="#ga2d28b10dac195744ef3daaab70d84208">More...</a><br /></td></tr>
<tr class="separator:ga2d28b10dac195744ef3daaab70d84208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62d47da29f3853e87b1069ee5c1ff21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a> ()</td></tr>
<tr class="memdesc:gaa62d47da29f3853e87b1069ee5c1ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release memory and, if possible, the open tables held by this execution plan (and nested plans).  <a href="#gaa62d47da29f3853e87b1069ee5c1ff21">More...</a><br /></td></tr>
<tr class="separator:gaa62d47da29f3853e87b1069ee5c1ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633799af14ae0a6e3abbac98b428c46f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga633799af14ae0a6e3abbac98b428c46f">JOIN::cleanup</a> ()</td></tr>
<tr class="memdesc:ga633799af14ae0a6e3abbac98b428c46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup this JOIN.  <a href="#ga633799af14ae0a6e3abbac98b428c46f">More...</a><br /></td></tr>
<tr class="separator:ga633799af14ae0a6e3abbac98b428c46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140c4ff912190f1c0f6279897103a720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga140c4ff912190f1c0f6279897103a720">JOIN::alloc_func_list</a> ()</td></tr>
<tr class="memdesc:ga140c4ff912190f1c0f6279897103a720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an array of pointers to sum_functions to speed up sum_func calculation.  <a href="#ga140c4ff912190f1c0f6279897103a720">More...</a><br /></td></tr>
<tr class="separator:ga140c4ff912190f1c0f6279897103a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9904341bd01f9e9aabc4d9b9f5123266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga9904341bd01f9e9aabc4d9b9f5123266">JOIN::make_sum_func_list</a> (const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;<a class="el" href="classJOIN.html#a72e08c3445519114971d13ab7c0c7bf0">fields</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> before_group_by, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> recompute=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:ga9904341bd01f9e9aabc4d9b9f5123266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize 'sum_funcs' array with all Item_sum objects.  <a href="#ga9904341bd01f9e9aabc4d9b9f5123266">More...</a><br /></td></tr>
<tr class="separator:ga9904341bd01f9e9aabc4d9b9f5123266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7ccb1a66664be06f1398f91b55b9d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8c7ccb1a66664be06f1398f91b55b9d9">SELECT_LEX::change_query_result</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__result__interceptor.html">Query_result_interceptor</a> *new_result, <a class="el" href="classQuery__result__interceptor.html">Query_result_interceptor</a> *old_result)</td></tr>
<tr class="memdesc:ga8c7ccb1a66664be06f1398f91b55b9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the Query_result object of the query block.  <a href="#ga8c7ccb1a66664be06f1398f91b55b9d9">More...</a><br /></td></tr>
<tr class="separator:ga8c7ccb1a66664be06f1398f91b55b9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dddcfeba3aeaf7d96cac4f1bc020e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac7dddcfeba3aeaf7d96cac4f1bc020e7">JOIN::add_having_as_tmp_table_cond</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> curr_tmp_table)</td></tr>
<tr class="memdesc:gac7dddcfeba3aeaf7d96cac4f1bc020e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add having condition as a filter condition, which is applied when reading from the temp table.  <a href="#gac7dddcfeba3aeaf7d96cac4f1bc020e7">More...</a><br /></td></tr>
<tr class="separator:gac7dddcfeba3aeaf7d96cac4f1bc020e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d12748a936ddf29bf434f926bff493b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3d12748a936ddf29bf434f926bff493b">JOIN::make_tmp_tables_info</a> ()</td></tr>
<tr class="memdesc:ga3d12748a936ddf29bf434f926bff493b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init tmp tables usage info.  <a href="#ga3d12748a936ddf29bf434f926bff493b">More...</a><br /></td></tr>
<tr class="separator:ga3d12748a936ddf29bf434f926bff493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3155cda5c5a0005811dc6d4d424fa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2b3155cda5c5a0005811dc6d4d424fa5">JOIN::unplug_join_tabs</a> ()</td></tr>
<tr class="separator:ga2b3155cda5c5a0005811dc6d4d424fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e3fd188854b9119bca4f811395ee7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa5e3fd188854b9119bca4f811395ee7a">JOIN::add_sorting_to_table</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *<a class="el" href="classJOIN.html#ac06839682aae707b0e1d4fafd53abaf5">order</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> force_stable_sort, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sort_before_group)</td></tr>
<tr class="memdesc:gaa5e3fd188854b9119bca4f811395ee7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Filesort object to the given table to sort if with filesort.  <a href="#gaa5e3fd188854b9119bca4f811395ee7a">More...</a><br /></td></tr>
<tr class="separator:gaa5e3fd188854b9119bca4f811395ee7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad3716313e877e16afe545f6d944558c0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad3716313e877e16afe545f6d944558c0">antijoin_null_cond</a> = &quot;&lt;ANTIJOIN-<a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>&gt;&quot;</td></tr>
<tr class="separator:gad3716313e877e16afe545f6d944558c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf7424a43da6deb8d6a928d20012e570a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7424a43da6deb8d6a928d20012e570a">&#9670;&nbsp;</a></span>Global_tables_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Query__Optimizer.html#gaf7424a43da6deb8d6a928d20012e570a">Global_tables_iterator</a> =  <a class="el" href="classIntrusiveListIterator.html">IntrusiveListIterator</a>&lt;<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>, &amp;<a class="el" href="structTABLE__LIST.html#a8e3206715feef5e95f8d2c3c3f324fa6">TABLE_LIST::next_global</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaade220b9879946408da6785ebea5bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaade220b9879946408da6785ebea5bc62">&#9670;&nbsp;</a></span>Global_tables_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Query__Optimizer.html#gaade220b9879946408da6785ebea5bc62">Global_tables_list</a> =  <a class="el" href="classIteratorContainer.html">IteratorContainer</a>&lt;<a class="el" href="group__Query__Optimizer.html#gaf7424a43da6deb8d6a928d20012e570a">Global_tables_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list interface over the TABLE_LIST::next_global pointer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae61cb563ddbc36edfe43024c8a479190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae61cb563ddbc36edfe43024c8a479190">&#9670;&nbsp;</a></span>JOIN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JOIN::JOIN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5a4ca6ff9b86660b16b133baf9483799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a4ca6ff9b86660b16b133baf9483799">&#9670;&nbsp;</a></span>store_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">store_key::store_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaee16bb48187eccb2a220efe292abc2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee16bb48187eccb2a220efe292abc2ca">&#9670;&nbsp;</a></span>store_key_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">store_key_field::store_key_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>to_field_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>null_ptr_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>from_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa0b52c45009d9df070623dac245d876d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0b52c45009d9df070623dac245d876d">&#9670;&nbsp;</a></span>store_key_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">store_key_item::store_key_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>to_field_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>null_ptr_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga16791455bd548298dcd5b21828a9272b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16791455bd548298dcd5b21828a9272b">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_select::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSelect__lex__visitor.html">Select_lex_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classSql__cmd.html#abde8f91930c6ff486d4310d9480d8915">Sql_cmd</a>.</p>

</div>
</div>
<a id="gac26de77d071499423b8d79d524e0d945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac26de77d071499423b8d79d524e0d945">&#9670;&nbsp;</a></span>accumulate_statement_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double accumulate_statement_cost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structLEX.html">LEX</a> *&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cost of executing a statement, including all its subqueries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lex</td><td>the statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated cost of executing the statement </dd></dl>

</div>
</div>
<a id="ga917e7ed7a41a5ba223ef428d52797ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga917e7ed7a41a5ba223ef428d52797ce7">&#9670;&nbsp;</a></span>actual_key_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> actual_key_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns key flags depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>key flags. </dd></dl>

</div>
</div>
<a id="ga6609ac0420a8a415d5a57cc6659f460d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6609ac0420a8a415d5a57cc6659f460d">&#9670;&nbsp;</a></span>actual_key_parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> actual_key_parts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of key parts depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of key parts. </dd></dl>

</div>
</div>
<a id="ga7252c09f8c4bb8c212a719b88adb44c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7252c09f8c4bb8c212a719b88adb44c6">&#9670;&nbsp;</a></span>add_found_match_trig_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem.html">Item</a>* add_found_match_trig_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>root_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a condition guarded by match variables for embedded outer joins. </p>
<p>When generating a condition for a table as part of an outer join condition or the WHERE condition, the table in question may also be part of an embedded outer join. In such cases, the condition must be guarded by the match variable for this embedded outer join. Such embedded outer joins may also be recursively embedded in other joins.</p>
<p>The function recursively adds guards for a condition ascending from tab to root_tab, which is the first inner table of an outer join, or NULL if the condition being handled is the WHERE clause.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>the current join </td></tr>
    <tr><td class="paramname">idx</td><td>index of the first inner table for the inner-most outer join </td></tr>
    <tr><td class="paramname">cond</td><td>the predicate to be guarded (must be set) </td></tr>
    <tr><td class="paramname">root_idx</td><td>index of the inner table to stop at (is NO_PLAN_IDX if this is the WHERE clause)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the guarded predicate, if success</li>
<li>NULL if error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac7dddcfeba3aeaf7d96cac4f1bc020e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7dddcfeba3aeaf7d96cac4f1bc020e7">&#9670;&nbsp;</a></span>add_having_as_tmp_table_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::add_having_as_tmp_table_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>curr_tmp_table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add having condition as a filter condition, which is applied when reading from the temp table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_tmp_table</td><td>Table number to which having conds are added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error. </dd></dl>

</div>
</div>
<a id="gac20ec40256339d93da167dde6632143b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20ec40256339d93da167dde6632143b">&#9670;&nbsp;</a></span>add_loose_index_scan_and_skip_scan_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_loose_index_scan_and_skip_scan_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discover the indexes that might be used for GROUP BY or DISTINCT queries or indexes that might be used for SKIP SCAN. </p>
<p>If the query has a GROUP BY clause, find all indexes that contain all GROUP BY fields, and add those indexes to join_tab-&gt;const_keys and join_tab-&gt;keys.</p>
<p>If the query has a DISTINCT clause, find all indexes that contain all SELECT fields, and add those indexes to join_tab-&gt;const_keys and join_tab-&gt;keys. This allows later on such queries to be processed by a QUICK_GROUP_MIN_MAX_SELECT.</p>
<p>If the query does not have GROUP BY clause or any aggregate function the function collects possible keys to use for skip scan access.</p>
<p>Note that indexes that are not usable for resolving GROUP BY/DISTINCT may also be added in some corner cases. For example, an index covering 'a' and 'b' is not usable for the following query but is still added: "SELECT DISTINCT a+b FROM t1". This is not a big issue because a) although the optimizer will consider using the index, it will not chose it (so minor calculation cost added but not wrong result) and b) it applies only to corner cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>the current join </td></tr>
    <tr><td class="paramname">join_tab</td><td>joined table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd1a69b3e1720db0f18324d53135288b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd1a69b3e1720db0f18324d53135288b">&#9670;&nbsp;</a></span>add_not_null_conds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_not_null_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add to join_tab[i]-&gt;condition() "table.field IS NOT NULL" conditions we've inferred from ref/eq_ref access performed. </p>
<p>This function is a part of "Early NULL-values filtering for ref access" optimization.</p>
<p>Example of this optimization: For query SELECT * FROM t1,t2 WHERE t2.key=t1.field <br />
 and plan " any-access(t1), ref(t2.key=t1.field) " <br />
 add "t1.field IS NOT NULL" to t1's table condition. <br />
 Description of the optimization:</p>
<p>We look through equalities choosen to perform ref/eq_ref access, pick equalities that have form "tbl.part_of_key = othertbl.field" (where othertbl is a non-const table and othertbl.field may be NULL) and add them to conditions on correspoding tables (othertbl in this example).</p>
<p>Exception from that is the case when referred_tab-&gt;join != join. I.e. don't add NOT NULL constraints from any embedded subquery. Consider this query: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> A.f2 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t2 A <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> A.f2 = f1</div><div class="line"><a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> A.f3=(<a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> <a class="code" href="crypt__genhash__impl_8cc.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(f3) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a>  t2 C <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> A.f4 = C.f4) OR A.f3 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a6cc1972e6d9d37556d516f78205a682b">IS</a> <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div></div><!-- fragment --><p> Here condition A.f3 IS NOT NULL is going to be added to the WHERE condition of the embedding query. Another example: SELECT * FROM t10, t11 WHERE (t10.a &lt; 10 OR t10.a IS NULL) AND t11.b &lt;=&gt; t10.b AND (t11.a = (SELECT MAX(a) FROM t12 WHERE t12.b = t10.a )); Here condition t10.a IS NOT NULL is going to be added. In both cases addition of NOT NULL condition will erroneously reject some rows of the result set. referred_tab-&gt;join != join constraint would disallow such additions.</p>
<p>This optimization doesn't affect the choices that ref, range, or join optimizer make. This was intentional because this was added after 4.1 was GA.</p>
<p>Implementation overview</p><ol type="1">
<li>update_ref_and_keys() accumulates info about null-rejecting predicates in in Key_field::null_rejecting 1.1 add_key_part saves these to Key_use.</li>
<li>create_ref_for_key copies them to TABLE_REF.</li>
<li>add_not_null_conds adds "x IS NOT NULL" to join_tab-&gt;m_condition of appropiate JOIN_TAB members.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error </dd></dl>

</div>
</div>
<a id="gaa5e3fd188854b9119bca4f811395ee7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5e3fd188854b9119bca4f811395ee7a">&#9670;&nbsp;</a></span>add_sorting_to_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::add_sorting_to_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>sort_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>force_stable_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sort_before_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add Filesort object to the given table to sort if with filesort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>JOIN_TAB's position in the qep_tab array. The created Filesort object gets attached to this.</td></tr>
    <tr><td class="paramname">sort_order</td><td>List of expressions to sort the table by </td></tr>
    <tr><td class="paramname">force_stable_sort</td><td>If true, use stable sort, that is the sort will keep the reative order of equivalent elements. Needed for windowing semantics. </td></tr>
    <tr><td class="paramname">sort_before_group</td><td>If true, this sort happens before grouping is done (potentially as a step of grouping itself), so any wrapped rollup group items should be unwrapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function moves tab-&gt;select, if any, to filesort-&gt;select</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on OOM </dd></dl>

</div>
</div>
<a id="ga7528c5e9d72db9a2ad7da0a9a8249820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7528c5e9d72db9a2ad7da0a9a8249820">&#9670;&nbsp;</a></span>adjust_access_methods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::adjust_access_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An utility function - apply heuristics and optimize access methods to tables. </p>
<dl class="section note"><dt>Note</dt><dd>Side effect - this function could set 'Impossible WHERE' zero result.</dd></dl>
<p>Currently this function can change REF to RANGE and ALL to INDEX scan if latter is considered to be better (not cost-based) than the former. </p><dl class="section note"><dt>Note</dt><dd>Side effect - this function could set 'Impossible WHERE' zero result. </dd></dl>

</div>
</div>
<a id="ga140c4ff912190f1c0f6279897103a720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140c4ff912190f1c0f6279897103a720">&#9670;&nbsp;</a></span>alloc_func_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::alloc_func_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an array of pointers to sum_functions to speed up sum_func calculation. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3745c0a56d93ab20bee91493e11bcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3745c0a56d93ab20bee91493e11bcf8">&#9670;&nbsp;</a></span>alloc_indirection_slices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::alloc_indirection_slices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab0385fefcc15abb1cf1eec240c394b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0385fefcc15abb1cf1eec240c394b69">&#9670;&nbsp;</a></span>alloc_jtab_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a>* alloc_jtab_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>table_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga25137692b43e77232e60ccc9e502fcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25137692b43e77232e60ccc9e502fcfa">&#9670;&nbsp;</a></span>alloc_qep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::alloc_qep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa0959185357c952da3da8a86ef979877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0959185357c952da3da8a86ef979877">&#9670;&nbsp;</a></span>alloc_ref_item_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::alloc_ref_item_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sliceno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a ref_item slice, assume that slice size is in ref_items[0]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd_arg</td><td>thread handler </td></tr>
    <tr><td class="paramname">sliceno</td><td>The slice number to allocate in JOIN::ref_items</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gad3c0a5624f789fb0bf0c5fc5ec057de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c0a5624f789fb0bf0c5fc5ec057de9">&#9670;&nbsp;</a></span>and_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> and_conditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend e1 by AND'ing e2 to the condition e1 points to. </p>
<p>The resulting condition is fixed. Requirement: the input Items must already have been fixed. This is a variant of and_items(); it is intended for use in the optimizer phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e1</td><td>Pointer to condition that will be extended with e2 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">e2</td><td>Condition that will extend e1</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error, in which case e1 remains unchanged </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d28b10dac195744ef3daaab70d84208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d28b10dac195744ef3daaab70d84208">&#9670;&nbsp;</a></span>and_with_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> QEP_shared_owner::and_with_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>add_cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend join_tab-&gt;cond by AND'ing add_cond to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">add_cond</td><td>The condition to AND with the existing cond for this JOIN_TAB</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a895f9d1ed62d02a455d1bf7c944c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a895f9d1ed62d02a455d1bf7c944c3f">&#9670;&nbsp;</a></span>attach_join_condition_to_nest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::attach_join_condition_to_nest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>first_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>last_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>join_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_sj_mat_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for JOIN::attach_join_conditions(). </p>
<p>Attaches bits of 'join_cond' to each table in the range [first_inner, last_tab], with proper guards. If 'sj_mat_cond' is true, we do not see first_inner (and tables on the same level of it) as inner to anything, as they're at the top from the POV of the materialization of the tmp table. So, if the SJ-mat nest is A LJ B, A will get a part of condition without any guard; B will get another part with a guard on A-&gt;found_match. It's like pushing a WHERE. </p>

</div>
</div>
<a id="gaaea10268473cae92c3bdbcf0ea4f97cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea10268473cae92c3bdbcf0ea4f97cc">&#9670;&nbsp;</a></span>attach_join_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::attach_join_conditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>last_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach outer join conditions to generated table conditions in an optimal way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_tab</td><td>- Last table that has been added to the current plan. Pre-condition: If this is the last inner table of an outer join operation, a join condition is attached to the first inner table of that outer join operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error.</dd></dl>
<p>Outer join conditions are attached to individual tables, but we can analyze those conditions only when reaching the last inner table of an outer join operation. Notice also that a table can be last within several outer join nests, hence the outer for() loop of this function.</p>
<p>Example: SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.a=t3.a) ON t1.a=t2.a</p>
<p>Table t3 is last both in the join nest (t2 - t3) and in (t1 - (t2 - t3)) Thus, join conditions for both join nests will be evaluated when reaching this table.</p>
<p>For each outer join operation processed, the join condition is split optimally over the inner tables of the outer join. The split-out conditions are later referred to as table conditions (but note that several table conditions stemming from different join operations may be combined into a composite table condition).</p>
<p>Example: Consider the above query once more. The predicate t1.a=t2.a can be evaluated when rows from t1 and t2 are ready, ie at table t2. The predicate t2.a=t3.a can be evaluated at table t3.</p>
<p>Each non-constant split-out table condition is guarded by a match variable that enables it only when a matching row is found for all the embedded outer join operations.</p>
<p>Each split-out table condition is guarded by a variable that turns the condition off just before a null-complemented row for the outer join operation is formed. Thus, the join condition will not be checked for the null-complemented row. </p>

</div>
</div>
<a id="gafe571c98d87a5062d82a0e8e66a128ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe571c98d87a5062d82a0e8e66a128ba">&#9670;&nbsp;</a></span>build_bitmap_for_nested_joins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> build_bitmap_for_nested_joins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>first_unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign each nested join structure a bit in nested_join_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td>List of tables </td></tr>
    <tr><td class="paramname">first_unused</td><td>Number of first unused bit in nested_join_map before the call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is called after simplify_joins(), when there are no redundant nested joins. We cannot have more nested joins in a query block than there are tables, so as long as the number of bits in nested_join_map is not less than the maximum number of tables in a query block, nested_join_map can never overflow.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>First unused bit in nested_join_map after the call. </dd></dl>

</div>
</div>
<a id="ga348b33d99b2bb2271c80442c0378852b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga348b33d99b2bb2271c80442c0378852b">&#9670;&nbsp;</a></span>build_equal_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> build_equal_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>retcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>inherited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>do_inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **&#160;</td>
          <td class="paramname"><em>cond_equal_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build multiple equalities for a WHERE condition and all join conditions that inherit these multiple equalities. </p>
<p>The function first applies the build_equal_items_for_cond function to build all multiple equalities for condition cond utilizing equalities referred through the parameter inherited. The extended set of equalities is returned in the structure referred by the cond_equal_ref parameter. After this the function calls itself recursively for all join conditions whose direct references can be found in join_list and who inherit directly the multiple equalities just having built.</p>
<dl class="section note"><dt>Note</dt><dd>The join condition used in an outer join operation inherits all equalities from the join condition of the embedding join, if there is any, or otherwise - from the where condition. This fact is not obvious, but presumably can be proved. Consider the following query: <div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> (t1,t2) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t1.a=t3.a AND t2.a=t4.a</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a;</div></div><!-- fragment --> If the join condition in the query inherits =(t1.a,t2.a), then we can build the multiple equality =(t1.a,t2.a,t3.a,t4.a) that infers the equality t3.a=t4.a. Although the join condition t1.a=t3.a AND t2.a=t4.a AND t3.a=t4.a is not equivalent to the one in the query the latter can be replaced by the former: the new query will return the same result set as the original one.</dd></dl>
<p>Interesting that multiple equality =(t1.a,t2.a,t3.a,t4.a) allows us to use t1.a=t3.a AND t3.a=t4.a under the join condition: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> (t1,t2) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t1.a=t3.a AND t3.a=t4.a</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a</div></div><!-- fragment --><p> This query equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> (t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t1.a=t3.a AND t3.a=t4.a),t2</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a</div></div><!-- fragment --><p> Similarly the original query can be rewritten to the query: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> (t1,t2) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t4.a AND t3.a=t4.a</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a</div></div><!-- fragment --><p> that is equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> (t2 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> (t3,t4)<a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t4.a AND t3.a=t4.a), t1</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a</div></div><!-- fragment --><p> Thus, applying equalities from the where condition we basically can get more freedom in performing join operations. Although we don't use this property now, it probably makes sense to use it in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>condition to build the multiple equalities for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retcond</td><td>Returned condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inherited</td><td>path to all inherited multiple equality items </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">do_inherit</td><td>whether or not to inherit equalities from other parts of the condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join tables that the condition refers to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_equal_ref</td><td>pointer to the structure to place built equalities in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gaa2cb02362e547839e5cdc6fa13fad054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2cb02362e547839e5cdc6fa13fad054">&#9670;&nbsp;</a></span>build_equal_items_for_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> build_equal_items_for_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>retcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>inherited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>do_inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all equality predicates in a condition by multiple equality items. </p>
<p>At each 'and' level the function detects items for equality predicates and replaces them by a set of multiple equality items of class Item_equal, taking into account inherited equalities from upper levels. If an equality predicate is used not in a conjunction it's just replaced by a multiple equality predicate. For each 'and' level the function set a pointer to the inherited multiple equalities in the cond_equal field of the associated object of the type Item_cond_and. The function also traverses the cond tree and for each field reference sets a pointer to the multiple equality item containing the field, if there is any. If this multiple equality equates fields to a constant the function replaces the field reference by the constant in the cases when the field is not of a string type or when the field reference is just an argument of a comparison predicate. The function also determines the maximum number of members in equality lists of each Item_cond_and object assigning it to thd-&gt;lex-&gt;current_select()-&gt;max_equal_elems.</p>
<dl class="section note"><dt>Note</dt><dd>Multiple equality predicate =(f1,..fn) is equivalent to the conjuction of f1=f2, .., fn-1=fn. It substitutes any inference from these equality predicates that is equivalent to the conjunction. Thus, =(a1,a2,a3) can substitute for ((a1=a3) AND (a2=a3) AND (a2=a1)) as it is equivalent to ((a1=a2) AND (a2=a3)). The function always makes a substitution of all equality predicates occurred in a conjunction for a minimal set of multiple equality predicates. This set can be considered as a canonical representation of the sub-conjunction of the equality predicates. E.g. (t1.a=t2.b AND t2.b&gt;5 AND t1.a=t3.c) is replaced by (=(t1.a,t2.b,t3.c) AND t2.b&gt;5), not by (=(t1.a,t2.b) AND =(t1.a,t3.c) AND t2.b&gt;5); while (t1.a=t2.b AND t2.b&gt;5 AND t3.c=t4.d) is replaced by (=(t1.a,t2.b) AND =(t3.c=t4.d) AND t2.b&gt;5), but if additionally =(t4.d,t2.b) is inherited, it will be replaced by (=(t1.a,t2.b,t3.c,t4.d) AND t2.b&gt;5)</dd></dl>
<p>The function performs the substitution in a recursive descent of the condition tree, passing to the next AND level a chain of multiple equality predicates which have been built at the upper levels. The Item_equal items built at the level are attached to other non-equality conjuncts as a sublist. The pointer to the inherited multiple equalities is saved in the and condition object (Item_cond_and). This chain allows us for any field reference occurence to easily find a multiple equality that must be held for this occurence. For each AND level we do the following:</p><ul>
<li>scan it for all equality predicate (=) items</li>
<li>join them into disjoint Item_equal() groups</li>
<li>process the included OR conditions recursively to do the same for lower AND levels.</li>
</ul>
<p>We need to do things in this order as lower AND levels need to know about all possible Item_equal objects in upper levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>condition(expression) where to make replacement </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retcond</td><td>returned condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inherited</td><td>path to all inherited multiple equality items </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">do_inherit</td><td>whether or not to inherit equalities from other parts of the condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gaa978828bfe7be091fb76e1c5da80d644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa978828bfe7be091fb76e1c5da80d644">&#9670;&nbsp;</a></span>calc_group_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_group_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calc how big buffer we need for comparing group entries. </p>

</div>
</div>
<a id="gaaf336d1a31135fd93a5564c5e090b50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf336d1a31135fd93a5564c5e090b50a">&#9670;&nbsp;</a></span>calc_join_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a> calc_join_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quick_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>join type according to quick select type used </dd></dl>

</div>
</div>
<a id="ga5f8a3668a5d5771061e14f5d87c30794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f8a3668a5d5771061e14f5d87c30794">&#9670;&nbsp;</a></span>calc_length_and_keyparts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_length_and_keyparts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>used_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> **&#160;</td>
          <td class="paramname"><em>chosen_keyuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>length_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>keyparts_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>dep_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>maybe_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate properties of ref key: key length, number of used key parts, dependency map, possibility of null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">keyuse</td><td>Array of keys to consider </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>join_tab to calculate ref parameters for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>number of the key to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">used_tables</td><td>tables read prior to this table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">chosen_keyuses</td><td>when given, this function will fill array with chosen keyuses </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length_out</td><td>calculated length of the ref </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keyparts_out</td><td>calculated number of used keyparts </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dep_map</td><td>when given, calculated dependency map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maybe_null</td><td>when given, calculated maybe_null property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff9e6d6a3acbc2b2799a8e28d132f06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff9e6d6a3acbc2b2799a8e28d132f06b">&#9670;&nbsp;</a></span>calc_used_field_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_used_field_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>needs_rowid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>p_used_fieldlength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find how much space the prevous read not const tables takes in cache. </p>

</div>
</div>
<a id="ga76ca5e962b784c066559515c5286e6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ca5e962b784c066559515c5286e6c5">&#9670;&nbsp;</a></span>calculate_materialization_costs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void calculate_materialization_costs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sj_nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSemijoin__mat__optimize.html">Semijoin_mat_optimize</a> *&#160;</td>
          <td class="paramname"><em>sjm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For {semijoin,subquery} materialization: calculates various cost information, based on a plan in join-&gt;best_positions covering the to-be-materialized query block and only this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>JOIN where plan can be found </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sj_nest</td><td>sj materialization nest (NULL if subquery materialization) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n_tables</td><td>number of to-be-materialized tables </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sjm</td><td>where computed costs will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>that this function modifies join-&gt;map2table, which has to be filled correctly later. </dd></dl>

</div>
</div>
<a id="ga68dccbbb65e6bd21dc9ed043f2e974d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68dccbbb65e6bd21dc9ed043f2e974d4">&#9670;&nbsp;</a></span>calculate_subquery_executions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_subquery_executions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem__subselect.html">Item_subselect</a> *&#160;</td>
          <td class="paramname"><em>subquery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates how many times a subquery will be executed as part of a query execution. </p>
<p>If it is a cacheable subquery, the estimate tells how many times the subquery will be executed if it is not cached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subquery</td><td>the Item that represents the subquery </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trace</td><td>optimizer trace context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times the subquery is expected to be executed </dd></dl>

</div>
</div>
<a id="gac401066634b96cf4a9e7309cad34414e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac401066634b96cf4a9e7309cad34414e">&#9670;&nbsp;</a></span>can_evaluate_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> can_evaluate_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a condition can be evaluated during constant folding. </p>
<p>It can be evaluated if it is constant during execution and not expensive to evaluate. If it contains a subquery, it should not be evaluated if the option OPTION_NO_SUBQUERY_DURING_OPTIMIZATION is active. </p>

</div>
</div>
<a id="ga58ae76202144e523704ebe6be47e2c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58ae76202144e523704ebe6be47e2c7f">&#9670;&nbsp;</a></span>can_switch_from_ref_to_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> can_switch_from_ref_to_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__spec_8h.html#ad747dc49681b256d83aa9a9e35375ded">enum_order</a>&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>recheck_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function to check whether it's better to use range than ref. </p>
<p>Heuristic: Switch from 'ref' to 'range' access if 'range' access can utilize more keyparts than 'ref' access. Conditions for doing switching:</p>
<p>1) Range access is possible 2) 'ref' access and 'range' access uses the same index 3) Used parts of key shouldn't have nullable parts &amp; ref_or_null isn't used. 4) 'ref' access depends on a constant, not a value read from a table earlier in the join sequence.</p>
<p>Rationale: if 'ref' depends on a value from another table, the join condition is not used to limit the rows read by 'range' access (that would require dynamic range - 'Range checked for each record'). In other words, if 'ref' depends on a value from another table, we have a query with conditions of the form</p>
<p>this_table.idx_col1 = other_table.col AND &lt;&lt;- used by 'ref' this_table.idx_col1 OP &lt;const&gt; AND &lt;&lt;- used by 'range' this_table.idx_col2 OP &lt;const&gt; AND ... &lt;&lt;- used by 'range'</p>
<p>and an index on (idx_col1,idx_col2,...). But the fact that 'range' access uses more keyparts does not mean that it is more selective than 'ref' access because these access types utilize different parts of the query condition. We therefore trust the cost based choice made by best_access_path() instead of forcing a heuristic choice here. 5) 'range' access uses more keyparts than 'ref' access 6) ORDER BY might make range better than table scan: Check possibility of range scan even if it was previously deemed unviable (for example when table scan was estimated to be cheaper). If yes, range-access should be chosen only for larger key length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>To re-run range optimizer. </td></tr>
    <tr><td class="paramname">tab</td><td>JOIN_TAB to check </td></tr>
    <tr><td class="paramname">ordering</td><td>Used as a parameter to call test_quick_select. </td></tr>
    <tr><td class="paramname">recheck_range</td><td>Check possibility of range scan even if it is currently unviable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Range is better than ref </dd>
<dd>
false Ref is better or switch isn't possible</dd></dl>

</div>
</div>
<a id="ga9cb4d89eb72721ed3cfee494d0a0ba26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb4d89eb72721ed3cfee494d0a0ba26">&#9670;&nbsp;</a></span>change_cond_ref_to_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> change_cond_ref_to_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classI__List.html">I_List</a>&lt; <a class="el" href="classCOND__CMP.html">COND_CMP</a> &gt; *&#160;</td>
          <td class="paramname"><em>save_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>and_father</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change field = field to field = const for each found field = const in the and_level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">save_list</td><td>saved list of COND_CMP </td></tr>
    <tr><td class="paramname">and_father</td><td>father of AND op </td></tr>
    <tr><td class="paramname">cond</td><td>Condition where fields are replaced with constant values </td></tr>
    <tr><td class="paramname">field</td><td>The field that will be substituted </td></tr>
    <tr><td class="paramname">value</td><td>The substitution value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga8c7ccb1a66664be06f1398f91b55b9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7ccb1a66664be06f1398f91b55b9d9">&#9670;&nbsp;</a></span>change_query_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::change_query_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__result__interceptor.html">Query_result_interceptor</a> *&#160;</td>
          <td class="paramname"><em>new_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__result__interceptor.html">Query_result_interceptor</a> *&#160;</td>
          <td class="paramname"><em>old_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the Query_result object of the query block. </p>
<p>If old_result is not used, forward the call to the current Query_result in case it is a wrapper around old_result.</p>
<p>Call prepare() on the new Query_result if we decide to use it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">new_result</td><td>New Query_result object </td></tr>
    <tr><td class="paramname">old_result</td><td>Old Query_result object (NULL to force change)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success </td></tr>
    <tr><td class="paramname">true</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23f004e1cb6ce6b40bd18635e8504015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f004e1cb6ce6b40bd18635e8504015">&#9670;&nbsp;</a></span>check_all_table_privileges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_dml::check_all_table_privileges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and check privileges for all tables in a DML statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if false </dd></dl>

</div>
</div>
<a id="ga6a6440d8645c9c66515254f7ae785d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6440d8645c9c66515254f7ae785d1d">&#9670;&nbsp;</a></span>check_column_privileges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::check_column_privileges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check privileges for all columns referenced from query block. </p>
<p>Check privileges for all columns referenced from this query block.</p>
<p>Also check privileges for referenced subqueries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error (insufficient privileges)</dd></dl>

</div>
</div>
<a id="ga7826a5beaf7a31c8b971a28919e3b4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7826a5beaf7a31c8b971a28919e3b4e7">&#9670;&nbsp;</a></span>check_equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *&#160;</td>
          <td class="paramname"><em>eq_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>equality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminate row equalities and form multiple equalities predicates. </p>
<p>This function checks whether the item is a simple equality i.e. the one that equates a field with another field or a constant (field=field_item or field=constant_item), or, a row equality. For a simple equality the function looks for a multiple equality in the lists referenced directly or indirectly by cond_equal inferring the given simple equality. If it doesn't find any, it builds/expands multiple equality that covers the predicate. Row equalities are eliminated substituted for conjunctive regular equalities which are treated in the same way as original equality predicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">item</td><td>predicate to process </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond_equal</td><td>multiple equalities that must hold together with the predicate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eq_list</td><td>results of conversions of row equalities that are not simple enough to form multiple equalities </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">equality</td><td>true if re-writing rules have been applied false otherwise, i.e. if the predicate is not an equality, or if the equality is neither a simple nor a row equality</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the equality was created by IN-&gt;EXISTS, it may be removed later by subquery materialization. So we don't mix this possibly temporary equality with others; if we let it go into a multiple-equality (Item_equal), then we could not remove it later. There is however an exception: if the outer expression is a constant, it is safe to leave the equality even in materialization; all it can do is preventing NULL/FALSE distinction but if such distinction mattered the equality would be in a triggered condition so we would not come to this function. And injecting constants is good because it makes the materialized table smaller. </dd></dl>

</div>
</div>
<a id="ga3bc4588ad768d8db29b298d7bb4f6dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bc4588ad768d8db29b298d7bb4f6dcf">&#9670;&nbsp;</a></span>check_locking_clause_access()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_locking_clause_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Query__Optimizer.html#gaade220b9879946408da6785ebea5bc62">Global_tables_list</a>&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs access check for the locking clause, if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Current session, used for checking access and raising error.</td></tr>
    <tr><td class="paramname">tables</td><td>Tables in the query's from clause.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>There was a locking clause and access was denied. An error has been raised.</td></tr>
    <tr><td class="paramname">false</td><td>There was no locking clause or access was allowed to it. This is always returned in an embedded build. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3dd35b938bbcf70868e079fb60e566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3dd35b938bbcf70868e079fb60e566d">&#9670;&nbsp;</a></span>check_privileges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_select::check_privileges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an authorization check for a prepared SELECT statement. </p>

<p>Implements <a class="el" href="classSql__cmd__dml.html#acefc10286d08e6d3c6269097b5079ec8">Sql_cmd_dml</a>.</p>

<p>Reimplemented in <a class="el" href="classSql__cmd__show__replica__status.html#a0dadccf2673796ec7752ca70ac6943da">Sql_cmd_show_replica_status</a>, <a class="el" href="classSql__cmd__show__replicas.html#ab2eb0aac9d17c9958cdd3d1295f85a58">Sql_cmd_show_replicas</a>, <a class="el" href="classSql__cmd__show__relaylog__events.html#ace8a4dfa0f2eb9327206dcb22a4af76f">Sql_cmd_show_relaylog_events</a>, <a class="el" href="classSql__cmd__show__processlist.html#acf11708242267254dd62a2ad1f52f03b">Sql_cmd_show_processlist</a>, <a class="el" href="classSql__cmd__show__master__status.html#a9a92e9e4ddcd1fd4e2b3dcd63e36e139">Sql_cmd_show_master_status</a>, <a class="el" href="classSql__cmd__show__grants.html#abac3eca3834a397fbebf3e7d9518639d">Sql_cmd_show_grants</a>, <a class="el" href="classSql__cmd__show__events.html#acb26ae62d7149f8440019328e39db652">Sql_cmd_show_events</a>, <a class="el" href="classSql__cmd__show__engine__status.html#a74b4baa4ffa54bc1e8b4ad12f305e7d0">Sql_cmd_show_engine_status</a>, <a class="el" href="classSql__cmd__show__engine__mutex.html#a27d286a51ee55b87ac51569cd7769931">Sql_cmd_show_engine_mutex</a>, <a class="el" href="classSql__cmd__show__engine__logs.html#ad809228c112f32d44bb1f513b13002b9">Sql_cmd_show_engine_logs</a>, <a class="el" href="classSql__cmd__show__databases.html#ac672811f3321ae7a95e5d90cb348a7f9">Sql_cmd_show_databases</a>, <a class="el" href="classSql__cmd__show__create__user.html#a6d6e41b052cefa1e74c8124210932dca">Sql_cmd_show_create_user</a>, <a class="el" href="classSql__cmd__show__create__trigger.html#a57f848331a4165d3d07fb46daaa0c812">Sql_cmd_show_create_trigger</a>, <a class="el" href="classSql__cmd__show__create__table.html#a5cdf2b4576487b7a21421a3a00e3cc50">Sql_cmd_show_create_table</a>, <a class="el" href="classSql__cmd__show__create__procedure.html#af5ec28701bbb9e017efd4f34d2f7a74a">Sql_cmd_show_create_procedure</a>, <a class="el" href="classSql__cmd__show__create__function.html#add8e6493b8df685f80264f231ecdef64">Sql_cmd_show_create_function</a>, <a class="el" href="classSql__cmd__show__create__event.html#a8003dd5ceabc022b74d02a4fd9932d8e">Sql_cmd_show_create_event</a>, <a class="el" href="classSql__cmd__show__create__database.html#a1a357b466dbf42d1c7dbd51d5400e507">Sql_cmd_show_create_database</a>, <a class="el" href="classSql__cmd__show__binlogs.html#aa4424c9bd390ca035d020a677a71911f">Sql_cmd_show_binlogs</a>, <a class="el" href="classSql__cmd__show__binlog__events.html#a2b7fc4b8cf90546a921bc65cbc970a89">Sql_cmd_show_binlog_events</a>, <a class="el" href="classSql__cmd__show__routine__code.html#a89f7a2f39a6742d382af0b7673410855">Sql_cmd_show_routine_code</a>, <a class="el" href="classSql__cmd__show__table__base.html#a16cb5b50583e67d921d09c96715355b4">Sql_cmd_show_table_base</a>, <a class="el" href="classSql__cmd__show__schema__base.html#a7b87c80b6c6348e2462cbdc2d721e44a">Sql_cmd_show_schema_base</a>, and <a class="el" href="classSql__cmd__show.html#acc740661885d1471c851ceb61bd8c32f">Sql_cmd_show</a>.</p>

</div>
</div>
<a id="gad0ad5c49654db58fe3be002e652ba5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0ad5c49654db58fe3be002e652ba5b3">&#9670;&nbsp;</a></span>check_privileges_for_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_privileges_for_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check privileges for column references in a JOIN expression. </p>
<p>Check privileges for all columns referenced from join expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>list of joined tables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error (insufficient privileges) </dd></dl>

</div>
</div>
<a id="ga05979f955bc1cecfc80d1ff7523b97df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05979f955bc1cecfc80d1ff7523b97df">&#9670;&nbsp;</a></span>check_privileges_for_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_privileges_for_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>privileges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check privileges for column references in an item list. </p>
<p>Check privileges for all columns referenced from an expression list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">items</td><td>list of items </td></tr>
    <tr><td class="paramname">privileges</td><td>the required privileges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error (insufficient privileges) </dd></dl>

</div>
</div>
<a id="ga92f406638ef7004ded904c6a95fae79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f406638ef7004ded904c6a95fae79b">&#9670;&nbsp;</a></span>check_privileges_for_subqueries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::check_privileges_for_subqueries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check privileges for column references in subqueries of a query block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error (insufficient privileges) </dd></dl>

</div>
</div>
<a id="ga52d7d1207abe68616dfe64e211bc3fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d7d1207abe68616dfe64e211bc3fa2">&#9670;&nbsp;</a></span>check_row_equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_row_equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>left_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__row.html">Item_row</a> *&#160;</td>
          <td class="paramname"><em>right_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *&#160;</td>
          <td class="paramname"><em>eq_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>simple_equality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert row equalities into a conjunction of regular equalities. </p>
<p>The function converts a row equality of the form (E1,...,En)=(E'1,...,E'n) into a list of equalities E1=E'1,...,En=E'n. For each of these equalities Ei=E'i the function checks whether it is a simple equality or a row equality. If it is a simple equality it is used to expand multiple equalities of cond_equal. If it is a row equality it converted to a sequence of equalities between row elements. If Ei=E'i is neither a simple equality nor a row equality the item for this predicate is added to eq_list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">left_row</td><td>left term of the row equality to be processed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">right_row</td><td>right term of the row equality to be processed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond_equal</td><td>multiple equalities that must hold together with the predicate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eq_list</td><td>results of conversions of row equalities that are not simple enough to form multiple equalities </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">simple_equality</td><td>true if the row equality is composed of only simple equalities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if conversion succeeded, true if any error. </dd></dl>

</div>
</div>
<a id="ga3560b97f2f3ef1f74be30da9ce2bfa80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3560b97f2f3ef1f74be30da9ce2bfa80">&#9670;&nbsp;</a></span>check_simple_equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_simple_equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>left_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>right_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>simple_equality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether an equality can be used to build multiple equalities. </p>
<p>This function first checks whether the equality (left_item=right_item) is a simple equality i.e. one that equates a field with another field or a constant (field=field_item or field=const_item). If this is the case the function looks for a multiple equality in the lists referenced directly or indirectly by cond_equal inferring the given simple equality. If it doesn't find any, it builds a multiple equality that covers the predicate, i.e. the predicate can be inferred from this multiple equality. The built multiple equality could be obtained in such a way: create a binary multiple equality equivalent to the predicate, then merge it, if possible, with one of old multiple equalities. This guarantees that the set of multiple equalities covering equality predicates will be minimal.</p>
<p>EXAMPLE: For the where condition </p><div class="fragment"><div class="line"><a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> a=b AND b=c AND</div><div class="line">      (b=2 OR f=e)</div></div><!-- fragment --><p> the check_equality will be called for the following equality predicates a=b, b=c, b=2 and f=e.</p><ul>
<li>For a=b it will be called with *cond_equal=(0,[]) and will transform cond_equal into (0,[Item_equal(a,b)]).</li>
<li>For b=c it will be called with *cond_equal=(0,[Item_equal(a,b)]) and will transform *cond_equal into CE=(0,[Item_equal(a,b,c)]).</li>
<li>For b=2 it will be called with *cond_equal=(ptr(CE),[]) and will transform *cond_equal into (ptr(CE),[Item_equal(2,a,b,c)]).</li>
<li>For f=e it will be called with *cond_equal=(ptr(CE), []) and will transform *cond_equal into (ptr(CE),[Item_equal(f,e)]).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Now only fields that have the same type definitions (verified by the Field::eq_def method) are placed to the same multiple equalities. Because of this some equality predicates are not eliminated and can be used in the constant propagation procedure. We could weaken the equality test as soon as at least one of the equal fields is to be equal to a constant. It would require a more complicated implementation: we would have to store, in general case, its own constant for each fields from the multiple equality. But at the same time it would allow us to get rid of constant propagation completely: it would be done by the call to build_equal_items_for_cond.</dd></dl>
<p>The implementation does not follow exactly the above rules to build a new multiple equality for the equality predicate. If it processes the equality of the form field1=field2, it looks for multiple equalities me1 containing field1 and me2 containing field2. If only one of them is found the function expands it with the lacking field. If multiple equalities for both fields are found they are merged. If both searches fail a new multiple equality containing just field1 and field2 is added to the existing multiple equalities. If the function processes the predicate of the form field1=const, it looks for a multiple equality containing field1. If found, the function checks the constant of the multiple equality. If the value is unknown, it is setup to const. Otherwise the value is compared with const and the evaluation of the equality predicate is performed. When expanding/merging equality predicates from the upper levels the function first copies them for the current level. It looks acceptable, as this happens rarely. The implementation without copying would be much more complicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">left_item</td><td>left term of the equality to be checked </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">right_item</td><td>right term of the equality to be checked </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">item</td><td>equality item if the equality originates from a condition predicate, 0 if the equality is the result of row elimination </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond_equal</td><td>multiple equalities that must hold together with the equality </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">simple_equality</td><td>true if the predicate is a simple equality predicate to be used for building multiple equalities false otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga114620bef79e173403342eb2968ec285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga114620bef79e173403342eb2968ec285">&#9670;&nbsp;</a></span>check_skip_records_in_range_qualification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_skip_records_in_range_qualification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index dive can be skipped if the following conditions are satisfied: F1) For a single table query: a) FORCE INDEX applies to a single index. </p>
<p>b) No subquery is present. c) Fulltext Index is not involved. d) No GROUP-BY or DISTINCT clause. e) No ORDER-BY clause.</p>
<p>F2) Not applicable to multi-table query.</p>
<p>F3) This optimization is not applicable to EXPLAIN queries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>JOIN_TAB object. </td></tr>
    <tr><td class="paramname">thd</td><td>THD object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf5426869c15b3f454986507ede09bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf5426869c15b3f454986507ede09bab">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga633799af14ae0a6e3abbac98b428c46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga633799af14ae0a6e3abbac98b428c46f">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup this JOIN. </p>
<p>Free resources of given join.</p>
<p>Not a full cleanup. reusable?</p>
<dl class="section note"><dt>Note</dt><dd>With subquery this function definitely will be called several times, but even for simple query it can be called several times. </dd></dl>

</div>
</div>
<a id="gae913870950feb0d927de9b53963f0a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae913870950feb0d927de9b53963f0a6a">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_TAB::cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up associated table after query execution, including resources. </p>
<p>Cleanup table of join operation. </p>

</div>
</div>
<a id="ga29c2491087beb6a3ad518e9926570e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c2491087beb6a3ad518e9926570e46">&#9670;&nbsp;</a></span>cleanup_item_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::cleanup_item_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga067d6da56e62bca3d59a1b4f03564abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga067d6da56e62bca3d59a1b4f03564abb">&#9670;&nbsp;</a></span>clear_corr_derived_tmp_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::clear_corr_derived_tmp_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empties all correlated materialized derived tables. </p>

</div>
</div>
<a id="ga2040e597275c664a217cbfaf89bd78ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2040e597275c664a217cbfaf89bd78ec">&#9670;&nbsp;</a></span>clear_sj_tmp_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::clear_sj_tmp_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all rows from all temp tables used by NL-semijoin runtime. </p>
<p>All rows must be removed from all temporary tables before every join re-execution. </p>

</div>
</div>
<a id="gacef71e4d47995d23cb99a76ef392eb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef71e4d47995d23cb99a76ef392eb2a">&#9670;&nbsp;</a></span>compare_costs_of_subquery_strategies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::compare_costs_of_subquery_strategies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="item__subselect_8h.html#a7c264705c6dd06393c82679a17dc58fa">Subquery_strategy</a> *&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells what is the cheapest between IN-&gt;EXISTS and subquery materialization, in terms of cost, for the subquery's JOIN. </p>
<p>Input:</p><ul>
<li>join-&gt;{best_positions,best_read,best_rowcount} must contain the execution plan of EXISTS (where 'join' is the subquery's JOIN)</li>
<li>join2-&gt;{best_positions,best_read,best_rowcount} must be correctly set (where 'join2' is the parent join, the grandparent join, etc). Output: join-&gt;{best_positions,best_read,best_rowcount} contain the cheapest execution plan (where 'join' is the subquery's JOIN).</li>
</ul>
<p>This plan choice has to happen before calling functions which set up execution structures, like JOIN::get_best_combination().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>chosen method (EXISTS or materialization) will be put here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success </dd></dl>

</div>
</div>
<a id="ga0208854e710ff5f8d6793f8812c9776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0208854e710ff5f8d6793f8812c9776f">&#9670;&nbsp;</a></span>compare_fields_by_table_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int compare_fields_by_table_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>field2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> **&#160;</td>
          <td class="paramname"><em>table_join_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare field items by table order in the execution plan. </p>
<p>field1 considered as better than field2 if the table containing field1 is accessed earlier than the table containing field2. The function finds out what of two fields is better according this criteria.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field1</td><td>first field item to compare </td></tr>
    <tr><td class="paramname">field2</td><td>second field item to compare </td></tr>
    <tr><td class="paramname">table_join_idx</td><td>index to tables determining table order</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if field1 is better than field2 </td></tr>
    <tr><td class="paramname">1</td><td>if field2 is better than field1 </td></tr>
    <tr><td class="paramname">0</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b453613ff2aebe1f7fd2f46474953cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b453613ff2aebe1f7fd2f46474953cd">&#9670;&nbsp;</a></span>const_expression_in_where()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> const_expression_in_where </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>comp_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>comp_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>const_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a field or an item is equal to a constant value in WHERE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>WHERE clause expression </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_item</td><td>Item to find in WHERE expression (if comp_field != NULL) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_field</td><td>Field to find in WHERE expression (if comp_item != NULL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">const_item</td><td>intermediate arg, set to Item pointer to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the field is a constant value in WHERE</dd></dl>
<dl class="section note"><dt>Note</dt><dd>comp_item and comp_field parameters are mutually exclusive. </dd></dl>

</div>
</div>
<a id="ga647c683a8a4fe8db606270f2a9c4e1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga647c683a8a4fe8db606270f2a9c4e1c9">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key::store_key_result</a> store_key::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets ignore truncation warnings mode and calls the real copy method </p>
<p>this function makes sure truncation warnings when preparing the key buffers don't end up as errors (because of an enclosing INSERT/UPDATE). </p>

</div>
</div>
<a id="ga03837179836dfc4291d28e7c1ab44ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03837179836dfc4291d28e7c1ab44ca9">&#9670;&nbsp;</a></span>copy_inner() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key::store_key_result</a> store_key_field::copy_inner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classstore__key.html#a72a836c14b2b1c4d23b102d9ab364771">store_key</a>.</p>

</div>
</div>
<a id="gaf1f61b04f1bdea3256f92050bf9bb521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f61b04f1bdea3256f92050bf9bb521">&#9670;&nbsp;</a></span>copy_inner() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key::store_key_result</a> store_key_item::copy_inner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classstore__key.html#a72a836c14b2b1c4d23b102d9ab364771">store_key</a>.</p>

<p>Reimplemented in <a class="el" href="group__Query__Optimizer.html#ga1a480457c43f6a2d73bd5d3d3766fdab">store_key_hash_item</a>.</p>

</div>
</div>
<a id="ga1a480457c43f6a2d73bd5d3d3766fdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a480457c43f6a2d73bd5d3d3766fdab">&#9670;&nbsp;</a></span>copy_inner() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key::store_key_result</a> store_key_hash_item::copy_inner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="group__Query__Optimizer.html#gaf1f61b04f1bdea3256f92050bf9bb521">store_key_item</a>.</p>

</div>
</div>
<a id="ga005d0cdbd93b1354f4f55746664a2df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga005d0cdbd93b1354f4f55746664a2df2">&#9670;&nbsp;</a></span>cost_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCost__model__server.html">Cost_model_server</a> * JOIN::cost_model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the cost model object to be used for this join. </p>
<dl class="section return"><dt>Returns</dt><dd>Cost model object for the join </dd></dl>

</div>
</div>
<a id="ga73711fd03f3d32c120a6cfcbb72cfbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73711fd03f3d32c120a6cfcbb72cfbe5">&#9670;&nbsp;</a></span>count_field_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void count_field_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reset_with_sum_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>save_sum_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update TMP_TABLE_PARAM with count of the different type of fields. </p>
<p>This function counts the number of fields, functions and sum functions (items with type SUM_FUNC_ITEM) for use by create_tmp_table() and stores it in the Temp_table_param object. It also resets and calculates the allow_group_via_temp_table property, which may have to be reverted if this function is called after deciding to use ROLLUP (see JOIN::optimize_rollup()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_lex</td><td>SELECT_LEX of query </td></tr>
    <tr><td class="paramname">param</td><td>Description of temp table </td></tr>
    <tr><td class="paramname">fields</td><td>List of fields to count </td></tr>
    <tr><td class="paramname">reset_with_sum_func</td><td>Whether to reset with_sum_func of func items </td></tr>
    <tr><td class="paramname">save_sum_fields</td><td>Count in the way create_tmp_table() expects when given the same parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga719cd05281dd8ccc4a1dfac47eeeac92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga719cd05281dd8ccc4a1dfac47eeeac92">&#9670;&nbsp;</a></span>create_access_paths_for_zero_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::create_access_paths_for_zero_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create access paths with the knowledge that there are going to be zero rows coming from tables (before aggregation); typically because we know that all of them would be filtered away by WHERE (e.g. </p>
<p>SELECT * FROM t1 WHERE 1=2). This will normally yield no output rows, but if we have implicit aggregation, it might yield a single one. </p>

</div>
</div>
<a id="ga5d32cd303d430b9aea224023f81366ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d32cd303d430b9aea224023f81366ae">&#9670;&nbsp;</a></span>create_keyuse_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a>* create_keyuse_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> **&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>outer_exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a keyuse array for a table with a primary key. </p>
<p>To be used when creating a materialized temporary table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer, for memory allocation </td></tr>
    <tr><td class="paramname">keyparts</td><td>Number of key parts in the primary key </td></tr>
    <tr><td class="paramname">fields</td><td>fields </td></tr>
    <tr><td class="paramname">outer_exprs</td><td>List of items used for key lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to created keyuse array, or NULL if error </dd></dl>

</div>
</div>
<a id="gab9b6ab09ca6fe0b8e9b32afeedc792a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b6ab09ca6fe0b8e9b32afeedc792a3">&#9670;&nbsp;</a></span>create_order_from_distinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a>* create_order_from_distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>skip_aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>convert_bit_fields_to_long</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>all_order_by_fields_used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an order list that consists of all non-const fields and items. </p>
<p>This is usable for e.g. converting DISTINCT into GROUP or ORDER BY.</p>
<p>Try to put the items in "order_list" first, to allow one to optimize away a later ORDER BY. </p>

</div>
</div>
<a id="ga3b518fb7975676afc7395b412e803368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b518fb7975676afc7395b412e803368">&#9670;&nbsp;</a></span>create_ref_for_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> create_ref_for_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>org_keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>used_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup a ref access for looking up rows via an index (a key). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join object being handled </td></tr>
    <tr><td class="paramname">j</td><td>The join_tab which will have the ref access populated </td></tr>
    <tr><td class="paramname">org_keyuse</td><td>First key part of (possibly multi-part) key </td></tr>
    <tr><td class="paramname">used_tables</td><td>Bitmap of available tables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<p>Given a Key_use structure that specifies the fields that can be used for index access, this function creates and set up the structure used for index look up via one of the access methods {JT_FT, JT_CONST, JT_REF_OR_NULL, JT_REF, JT_EQ_REF} for the plan operator 'j'. Generally the function sets up the structure j-&gt;ref (of type TABLE_REF), and the access method j-&gt;type.</p>
<dl class="section note"><dt>Note</dt><dd>We cannot setup fields used for ref access before we have sorted the items within multiple equalities according to the final order of the tables involved in the join operation. Currently, this occurs in </dd></dl>
<dl class="section see"><dt>See also</dt><dd>substitute_for_best_equal_field(). The exception is ref access for const tables, which are fixed before the greedy search planner is invoked. </dd></dl>

</div>
</div>
<a id="ga36219da5efa004452f343d3b329286e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36219da5efa004452f343d3b329286e8">&#9670;&nbsp;</a></span>create_sj_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a>* create_sj_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSJ__TMP__TABLE__TAB.html">SJ_TMP_TABLE_TAB</a> *&#160;</td>
          <td class="paramname"><em>first_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSJ__TMP__TABLE__TAB.html">SJ_TMP_TABLE_TAB</a> *&#160;</td>
          <td class="paramname"><em>last_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the support structures (NULL bits, row offsets, etc.) for a semijoin duplicate weedout table. </p>
<p>The object is allocated on the given THD's MEM_ROOT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the THD to allocate the object on </td></tr>
    <tr><td class="paramname">join</td><td>the JOIN that will own the temporary table (ie., has the responsibility to destroy it after use) </td></tr>
    <tr><td class="paramname">first_tab</td><td>first table in row key (inclusive) </td></tr>
    <tr><td class="paramname">last_tab</td><td>last table in row key (exclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab466b49a22220854ef8f11a2c4a2ae8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab466b49a22220854ef8f11a2c4a2ae8a">&#9670;&nbsp;</a></span>decide_subquery_strategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::decide_subquery_strategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides between EXISTS and materialization; performs last steps to set up the chosen strategy. </p>
<dl class="section return"><dt>Returns</dt><dd>'false' if no error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If UNION this is called on each contained JOIN. </dd></dl>

</div>
</div>
<a id="gac7a423667e0e552a7ae8609848ff43d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7a423667e0e552a7ae8609848ff43d7">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up and destroy join object. </p>

</div>
</div>
<a id="gae2581670e2e142b312e64ba314181980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2581670e2e142b312e64ba314181980">&#9670;&nbsp;</a></span>destroy_sj_tmp_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void destroy_sj_tmp_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaae977f888923f3443e09345a10bbee9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae977f888923f3443e09345a10bbee9a">&#9670;&nbsp;</a></span>duplicate_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> duplicate_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>first_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>possible_dup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an expression in ORDER BY or GROUP BY is a duplicate of a preceding expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_order</td><td>the first expression in the ORDER BY or GROUP BY clause </td></tr>
    <tr><td class="paramname">possible_dup</td><td>the expression that might be a duplicate of another expression preceding it the ORDER BY or GROUP BY clause</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if possible_dup is a duplicate, false otherwise </dd></dl>

</div>
</div>
<a id="gada415e1d087c014e9b8a22b39980bfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada415e1d087c014e9b8a22b39980bfea">&#9670;&nbsp;</a></span>effective_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> QEP_TAB::effective_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index used for a table in a QEP. </p>
<dl class="section return"><dt>Returns</dt><dd>the index used for a table in a QEP</dd></dl>
<p>The various access methods have different places where the index/key number is stored, so this function is needed to return the correct value.</p>
<dl class="section return"><dt>Returns</dt><dd>index number, or MAX_KEY if not applicable.</dd></dl>
<p>JT_SYSTEM and JT_ALL does not use an index, and will always return MAX_KEY.</p>
<p>JT_INDEX_MERGE supports more than one index. Hence MAX_KEY is returned and a further inspection is needed. </p>

</div>
</div>
<a id="ga9828b3ec4766a8dd7ae897244c827b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9828b3ec4766a8dd7ae897244c827b0e">&#9670;&nbsp;</a></span>eligible_secondary_storage_engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMYSQL__LEX__CSTRING.html">MYSQL_LEX_CSTRING</a> * Sql_cmd_select::eligible_secondary_storage_engine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this statement of a type and on a form that makes it eligible for execution in a secondary storage engine? </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the secondary storage engine, or nullptr if the statement is not eligible for execution in a secondary storage engine </dd></dl>

<p>Reimplemented from <a class="el" href="classSql__cmd.html#a0b3420712a4bef1f70827f022cc682fe">Sql_cmd</a>.</p>

</div>
</div>
<a id="ga0f4207baaf2253f1e31be14b072bb1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f4207baaf2253f1e31be14b072bb1fe">&#9670;&nbsp;</a></span>eliminate_item_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem.html">Item</a>* eliminate_item_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>upper_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__equal.html">Item_equal</a> *&#160;</td>
          <td class="paramname"><em>item_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate minimal set of simple equalities equivalent to a multiple equality. </p>
<p>The function retrieves the fields of the multiple equality item item_equal and for each field f:</p><ul>
<li>if item_equal contains const it generates the equality f=const_item;</li>
<li>otherwise, if f is not the first field, generates the equality f=item_equal-&gt;get_first(). All generated equality are added to the cond conjunction.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the session context </td></tr>
    <tr><td class="paramname">cond</td><td>condition to add the generated equality to </td></tr>
    <tr><td class="paramname">upper_levels</td><td>structure to access multiple equality of upper levels </td></tr>
    <tr><td class="paramname">item_equal</td><td>multiple equality to generate simple equality from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Before generating an equality function checks that it has not been generated for multiple equalities of the upper levels. E.g. for the following where condition WHERE a=5 AND ((a=b AND b=c) OR c&gt;4) the upper level AND condition will contain =(5,a), while the lower level AND condition will contain =(5,a,b,c). When splitting =(5,a,b,c) into a separate equality predicates we should omit 5=a, as we have it already in the upper level. The following where condition gives us a more complicated case: WHERE t1.a=t2.b AND t3.c=t4.d AND (t2.b=t3.c OR t4.e&gt;5 ...) AND ... Given the tables are accessed in the order t1-&gt;t2-&gt;t3-&gt;t4 for the selected query execution plan the lower level multiple equality =(t1.a,t2.b,t3.c,t4.d) formally should be converted to t1.a=t2.b AND t1.a=t3.c AND t1.a=t4.d. But t1.a=t2.a will be generated for the upper level. Also t3.c=t4.d will be generated there. So only t1.a=t3.c should be left in the lower level. If cond is equal to 0, then not more then one equality is generated and a pointer to it is returned as the result of the function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The condition with generated simple equalities or a pointer to the simple generated equality, if success.</li>
<li>0, otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad6581c041c0e0f1f0f681536e0ca35dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6581c041c0e0f1f0f681536e0ca35dc">&#9670;&nbsp;</a></span>eq_ref_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> eq_ref_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>start_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>cached_eq_ref_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>eq_ref_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the following expressions from ORDER BY and GROUP BY: Constant expressions <br />
Expression that only uses tables that are of type EQ_REF and the reference is in the ORDER list or if all refereed tables are of the above type. </p>
<p>In the following, the X field can be removed: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1,t2 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a <a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> t1.a,t2.X</div><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1,t2,t3 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a AND t2.b=t3.b <a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> t1.a,t3.X</div></div><!-- fragment --><p>These can't be optimized: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1,t2 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a <a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> t2.X,t1.a</div><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1,t2 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a AND t1.b=t2.b <a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> t1.a,t2.c</div><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1,t2 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a <a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> t2.b,t1.a</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>join object </td></tr>
    <tr><td class="paramname">start_order</td><td>clause being analyzed (ORDER BY, GROUP BY...) </td></tr>
    <tr><td class="paramname">tab</td><td>table </td></tr>
    <tr><td class="paramname">cached_eq_ref_tables</td><td>bitmap: bit Z is set if the table of map Z was already the subject of an eq_ref_table() call for the same clause; then the return value of this previous call can be found at bit Z of 'eq_ref_tables' </td></tr>
    <tr><td class="paramname">eq_ref_tables</td><td>see above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb541e941e7c4614ceb9eeddae48f9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb541e941e7c4614ceb9eeddae48f9dc">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf1351457ee30a4e67786117e50413541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1351457ee30a4e67786117e50413541">&#9670;&nbsp;</a></span>error_if_full_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> error_if_full_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give error if we some tables are done with a full join. </p>
<p>This is used by multi_table_update and multi_table_delete when running in safe mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error (full join used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80b09506dcb39946820202191577595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b09506dcb39946820202191577595b">&#9670;&nbsp;</a></span>estimate_rowcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::estimate_rowcount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the number of matched rows for each joined table. </p>
<p>Set up range scan for tables that have proper predicates.</p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga3dd34eb4762fa59c46d42cb74b915a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd34eb4762fa59c46d42cb74b915a86">&#9670;&nbsp;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_dml::execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a DML statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>Processing a statement goes through 6 phases (parsing is already done)</p><ul>
<li>Prelocking</li>
<li>Preparation</li>
<li>Locking of tables</li>
<li>Optimization</li>
<li>Execution or explain</li>
<li>Cleanup</li>
</ul>
<p>If the statement is already prepared, this step is skipped.</p>
<p>The queries handled by this function are:</p>
<p>SELECT INSERT ... SELECT INSERT ... VALUES REPLACE ... SELECT REPLACE ... VALUES UPDATE (single-table and multi-table) DELETE (single-table and multi-table) DO</p>

<p>Implements <a class="el" href="classSql__cmd.html#a213367b79b551296fbb7790f2a3732fb">Sql_cmd</a>.</p>

<p>Reimplemented in <a class="el" href="classSql__cmd__show__status.html#a1057900b600519da925311efbddc7b89">Sql_cmd_show_status</a>, <a class="el" href="classSql__cmd__show__noplan.html#a6ea641f640d1c1b6eac39ab12fb14a7b">Sql_cmd_show_noplan</a>, and <a class="el" href="classSql__cmd__show.html#a346b0d1a6242e036da75720bc03da67c">Sql_cmd_show</a>.</p>

</div>
</div>
<a id="gaefe316b62ad85228d8931a8474dee8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefe316b62ad85228d8931a8474dee8b3">&#9670;&nbsp;</a></span>execute_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_dml::execute_inner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inner parts of query optimization and execution. </p>
<p>Execute a DML statement.</p>
<p>Single-table DML operations needs to reimplement this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error</dd></dl>
<p>This is the default implementation for a DML statement and uses a nested-loop join processor per outer-most query block. The implementation is split in two: One for query expressions containing a single query block and one for query expressions containing multiple query blocks combined with UNION. </p>

<p>Reimplemented in <a class="el" href="classSql__cmd__show__warnings.html#af75b398072c8904e3b73d5ae8225d410">Sql_cmd_show_warnings</a>, <a class="el" href="classSql__cmd__show__replica__status.html#a09eda132adb4bfbeadc931b1152d029c">Sql_cmd_show_replica_status</a>, <a class="el" href="classSql__cmd__show__replicas.html#aa87be2d1e9f1a62224f8f455a2eccbc3">Sql_cmd_show_replicas</a>, <a class="el" href="classSql__cmd__show__relaylog__events.html#a46ef1d5cafad2b94f20bdfd2d9fed827">Sql_cmd_show_relaylog_events</a>, <a class="el" href="classSql__cmd__show__profiles.html#ae79cb3284716a85b3ee2249ffd9f9ff7">Sql_cmd_show_profiles</a>, <a class="el" href="classSql__cmd__show__processlist.html#a68e0b2fb94fb311f72493f6146782607">Sql_cmd_show_processlist</a>, <a class="el" href="classSql__cmd__show__privileges.html#a49ddd93956178a8854a03a4e5bfefd88">Sql_cmd_show_privileges</a>, <a class="el" href="classSql__cmd__show__master__status.html#a0dff4d374c49a54dadae1dc685e21aab">Sql_cmd_show_master_status</a>, <a class="el" href="classSql__cmd__show__grants.html#a7ae1fd32d2bb65b4b2ee956679140f75">Sql_cmd_show_grants</a>, <a class="el" href="classSql__cmd__show__errors.html#ac9e24dfe9e43b13f1e70c362c187a99f">Sql_cmd_show_errors</a>, <a class="el" href="classSql__cmd__show__engine__status.html#a0034544fb9f1b534c598f0db9b69409b">Sql_cmd_show_engine_status</a>, <a class="el" href="classSql__cmd__show__engine__mutex.html#a18ae316c02fe8fe8b657af82e2ffa1c6">Sql_cmd_show_engine_mutex</a>, <a class="el" href="classSql__cmd__show__engine__logs.html#a76395c5c4e90e3cfcefab4a5bc2b2d5b">Sql_cmd_show_engine_logs</a>, <a class="el" href="classSql__cmd__show__create__user.html#a85b44af0b5fa1998e0b60ae72bad7894">Sql_cmd_show_create_user</a>, <a class="el" href="classSql__cmd__show__create__trigger.html#af371325fc21ad7c7ebbc883742d47a27">Sql_cmd_show_create_trigger</a>, <a class="el" href="classSql__cmd__insert__values.html#a1079dc62da48db700370a503692dd93f">Sql_cmd_insert_values</a>, <a class="el" href="classSql__cmd__show__create__table.html#a7bbecdfec81249a27edf13b9cb67f713">Sql_cmd_show_create_table</a>, <a class="el" href="classSql__cmd__show__create__procedure.html#a9edbacaf0148dc57ac336f26e5b5af3a">Sql_cmd_show_create_procedure</a>, <a class="el" href="classSql__cmd__show__create__function.html#ae661eb06dba9d032dc97e951ce6fc85b">Sql_cmd_show_create_function</a>, <a class="el" href="classSql__cmd__show__create__event.html#a4664813fdb50e6483d3360903fd4d343">Sql_cmd_show_create_event</a>, <a class="el" href="classSql__cmd__show__create__database.html#a6d36d867fefabca69fb2aeba0f701a98">Sql_cmd_show_create_database</a>, <a class="el" href="classSql__cmd__show__binlogs.html#af68055f90e3c4318cbda8089b9896e68">Sql_cmd_show_binlogs</a>, <a class="el" href="classSql__cmd__show__binlog__events.html#ab67c15bf73aff6c65df6e440666b063d">Sql_cmd_show_binlog_events</a>, <a class="el" href="classSql__cmd__show__routine__code.html#a45ad9d522ec40ec42a6cf8af4b04cdcc">Sql_cmd_show_routine_code</a>, <a class="el" href="classSql__cmd__update.html#a9245c285239918178ac4bcdad7526512">Sql_cmd_update</a>, <a class="el" href="classSql__cmd__delete.html#a54b223372a73a9815649dcfbd8d1091e">Sql_cmd_delete</a>, and <a class="el" href="classSql__cmd__call.html#a49b6f147d1e050b1f517b03a4877e323">Sql_cmd_call</a>.</p>

</div>
</div>
<a id="gaea741e73aad45b858b391622a33273ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea741e73aad45b858b391622a33273ef">&#9670;&nbsp;</a></span>extract_const_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::extract_const_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract const tables based on row counts. </p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>This extraction must be done for each execution. Tables containing exactly zero or one rows are marked as const, but notice the additional constraints checked below. Tables that are extracted have their rows read before actual execution starts and are placed in the beginning of the join_tab array. Thus, they do not take part in join order optimization process, which can significantly reduce the optimization time. The data read from these tables can also be regarded as "constant" throughout query execution, hence the column values can be used for additional constant propagation and extraction of const tables based on eq-ref properties.</p>
<p>The tables are given the type JT_SYSTEM. </p>

</div>
</div>
<a id="gab4a152ded12d0566290c25dbc358f38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4a152ded12d0566290c25dbc358f38f">&#9670;&nbsp;</a></span>extract_func_dependent_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::extract_func_dependent_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract const tables based on functional dependencies. </p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>This extraction must be done for each execution.</p>
<p>Mark as const the tables that</p><ul>
<li>are functionally dependent on constant values, or</li>
<li>are inner tables of an outer join and contain exactly zero or one rows</li>
</ul>
<p>Tables that are extracted have their rows read before actual execution starts and are placed in the beginning of the join_tab array, just as described for JOIN::extract_const_tables().</p>
<p>The tables are given the type JT_CONST. </p>

</div>
</div>
<a id="gace5d28995814f1af3b17478b8af4b23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace5d28995814f1af3b17478b8af4b23f">&#9670;&nbsp;</a></span>finalize_derived_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::finalize_derived_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each materialized derived table/view, informs every TABLE of the key it will (not) use, segregates used keys from unused keys in TABLE::key_info, and eliminates unused keys. </p>

</div>
</div>
<a id="ga8618420be2a887d3506a097f490b1d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8618420be2a887d3506a097f490b1d14">&#9670;&nbsp;</a></span>finalize_table_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::finalize_table_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove redundant predicates and cache constant expressions. </p>
<p>Do a final round on pushed down table conditions and HAVING clause. Optimize them for faster execution by removing predicates being obsolete due to the access path selected for the table. Constant expressions are also cached to avoid evaluating them for each row being compared.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is run after conditions have been pushed down to individual tables, so transformation is applied to JOIN_TAB::condition and not to the WHERE condition. </dd></dl>

</div>
</div>
<a id="ga10df978ef681f041d62558e278876e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10df978ef681f041d62558e278876e95">&#9670;&nbsp;</a></span>find_eq_ref_candidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> find_eq_ref_candidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>sj_inner_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3f21fed3a20651b87cac72bbb304b33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f21fed3a20651b87cac72bbb304b33c">&#9670;&nbsp;</a></span>find_field_in_item_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> find_field_in_item_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for list_contains_unique_index. </p>
<p>Find a field reference in a dynamic list of Items. Finds a direct reference of the Field in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>The field to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>List&lt;Item&gt; *.The list to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>found </td></tr>
    <tr><td class="paramname">0</td><td>not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac97c3001abc54d7c0fd18d26601d4fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac97c3001abc54d7c0fd18d26601d4fdf">&#9670;&nbsp;</a></span>find_field_in_order_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> find_field_in_order_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for list_contains_unique_index. </p>
<p>Find a field reference in a list of ORDER structures. Finds a direct reference of the Field in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The field to search for. </td></tr>
    <tr><td class="paramname">data</td><td>ORDER *.The list to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>found </td></tr>
    <tr><td class="paramname">0</td><td>not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga874abd8fac03d08de3598b7ea65f4dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga874abd8fac03d08de3598b7ea65f4dd0">&#9670;&nbsp;</a></span>find_item_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__equal.html">Item_equal</a>* find_item_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>inherited_fl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the multiple equality predicate containing a field. </p>
<p>The function retrieves the multiple equalities accessed through the cond_equal structure from current level and up looking for an equality containing a field. It stops retrieval as soon as the equality is found and set up inherited_fl to true if it's found on upper levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond_equal</td><td>multiple equalities to search in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">item_field</td><td>field to look for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inherited_fl</td><td>set up to true if multiple equality is found on upper levels (not on current level of cond_equal)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Item_equal for the found multiple equality predicate if a success;</li>
<li>nullptr otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6685d7e8762b223a126002bb6a45a36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6685d7e8762b223a126002bb6a45a36d">&#9670;&nbsp;</a></span>find_shortest_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> find_shortest_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *&#160;</td>
          <td class="paramname"><em>usable_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find shortest key suitable for full table scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table to scan </td></tr>
    <tr><td class="paramname">usable_keys</td><td>Allowed keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As far as 1) clustered primary key entry data set is a set of all record fields (key fields and not key fields) and 2) secondary index entry data is a union of its key fields and primary key fields (at least InnoDB and its derivatives don't duplicate primary key fields there, even if the primary and the secondary keys have a common subset of key fields), then secondary index entry data is always a subset of primary key entry. Unfortunately, key_info[nr].key_length doesn't show the length of key/pointer pair but a sum of key field lengths only, thus we can't estimate index IO volume comparing only this key_length value of secondary keys and clustered PK. So, try secondary keys first, and choose PK only if there are no usable secondary covering keys or found best secondary key include all table fields (i.e. same as PK):</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>MAX_KEY no suitable key found key index otherwise </dd></dl>

</div>
</div>
<a id="ga9d8c5bf080cc0dc7eb7a5c8496cbd0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d8c5bf080cc0dc7eb7a5c8496cbd0f8">&#9670;&nbsp;</a></span>fold_condition_exec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> fold_condition_exec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>retcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html#ab74b339b7c522a3a7aa2b8e4e8123a1b">Item::cond_result</a> *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls fold_condition. </p>
<p>If that made the condition constant for execution, simplify and fold again. </p><dl class="section see"><dt>See also</dt><dd>fold_condition() for arguments. </dd></dl>

</div>
</div>
<a id="ga59080a3acd829efcf18fc56d51df215c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59080a3acd829efcf18fc56d51df215c">&#9670;&nbsp;</a></span>free_underlaid_joins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_underlaid_joins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free joins of subselect of this select. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">select</td><td>pointer to SELECT_LEX which subselects joins we will free</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c20a9b8d13f14275a4ee01f44f8cfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c20a9b8d13f14275a4ee01f44f8cfa2">&#9670;&nbsp;</a></span>fts_index_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::fts_index_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if FTS index only access is possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>pointer to JOIN_TAB structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index only access is possible, false otherwise. </dd></dl>

</div>
</div>
<a id="ga92bf64a03ec666f565627fbb48ba4677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bf64a03ec666f565627fbb48ba4677">&#9670;&nbsp;</a></span>generate_derived_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::generate_derived_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add keys to derived tables'/views' result tables in a list. </p>
<p>This function generates keys for all derived tables/views of the select_lex to which this join corresponds to with help of the TABLE_LIST:generate_keys function.</p>
<dl class="section return"><dt>Returns</dt><dd>false all keys were successfully added. </dd>
<dd>
true OOM error </dd></dl>

</div>
</div>
<a id="gae9c1cf0874f4bda777557d012148e059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c1cf0874f4bda777557d012148e059">&#9670;&nbsp;</a></span>get_best_combination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::get_best_combination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up JOIN_TAB structs according to the picked join order in best_positions. </p>
<p>This allocates execution structures so may be called only after we have the very final plan. It must be called after Optimize_table_order::fix_semijoin_strategies().</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<ul>
<li>create join-&gt;join_tab array and copy from existing JOIN_TABs in join order</li>
<li>create helper structs for materialized semi-join handling</li>
<li>finalize semi-join strategy choices</li>
<li>Number of intermediate tables "tmp_tables" is calculated.</li>
<li>"tables" and "primary_tables" are recalculated.</li>
<li>for full and index scans info of estimated # of records is updated.</li>
<li>in a helper function:<ul>
<li>all heuristics are applied and the final access method type is picked for each join_tab (only test_if_skip_sortorder() could override it)</li>
<li>AM consistency is ensured (e.g only range and index merge are allowed to have quick select set).</li>
<li>if "Impossible WHERE" is detected - appropriate zero_result_cause is set.</li>
</ul>
</li>
</ul>
<p>Notice that intermediate tables will not have a POSITION reference; and they will not have a TABLE reference before the final stages of code generation.</p>

</div>
</div>
<a id="ga67d1175177356bf1c9b05e9104d28c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d1175177356bf1c9b05e9104d28c5b">&#9670;&nbsp;</a></span>get_best_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__field.html">Item_field</a>* get_best_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the best field substitution for a given field. </p>
<p>If the field is member of a multiple equality, look up that equality and return the most appropriate field. Usually this is the equivalenced field belonging to the outer-most table in the join order, but </p><dl class="section see"><dt>See also</dt><dd>Item_field::get_subst_item() for details. Otherwise, return the same field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_field</td><td>The field that we are seeking a substitution for. </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substituted field. </dd></dl>

</div>
</div>
<a id="gae09e0947bd16c224381213ad74798e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae09e0947bd16c224381213ad74798e0a">&#9670;&nbsp;</a></span>get_current_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> * &gt; * JOIN::get_current_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the clone of fields_list which is appropriate for evaluating expressions at the current stage of execution; which stage is denoted by the value of current_ref_item_slice. </p>

</div>
</div>
<a id="gacd263bd63c9fcc617e0e879c765bb802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd263bd63c9fcc617e0e879c765bb802">&#9670;&nbsp;</a></span>get_index_for_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> get_index_for_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a key to apply single table UPDATE/DELETE by a given ORDER. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>Table to find a key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">limit</td><td>LIMIT clause parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_sort</td><td>true if filesort needed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reverse</td><td>true if the key is reversed again given ORDER (undefined if key == MAX_KEY)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>MAX_KEY if no key found (need_sort == true)</li>
<li>MAX_KEY if quick select result order is OK (need_sort == false)</li>
<li>key number (either index scan or quick select) (need_sort == false)</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Side effects:<ul>
<li>may deallocate or deallocate and replace select-&gt;quick;</li>
<li>may set table-&gt;quick_condition_rows and table-&gt;quick_rows[...] to table-&gt;file-&gt;stats.records. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2f287f864e757469de8894de45d49b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f287f864e757469de8894de45d49b0f">&#9670;&nbsp;</a></span>get_key_length_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__inttypes_8h.html#acbd4acd0d29e2d6c43104827f77d9cd2">uint32</a> get_key_length_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(end of group Query_Optimizer) </p>
<p>This function is used to get the key length of Item object on which one tmp field will be created during create_tmp_table. This function references KEY_PART_INFO::init_from_field().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>A inner item of outer join</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of a item to be as a key of a temp table </dd></dl>

</div>
</div>
<a id="ga8ef546408e2eb81836284e515a871fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef546408e2eb81836284e515a871fbd">&#9670;&nbsp;</a></span>get_max_execution_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> get_max_execution_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum execution time for a statement. </p>
<dl class="section return"><dt>Returns</dt><dd>Length of time in milliseconds.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A zero timeout means that no timeout should be applied to this particular statement. </dd></dl>

</div>
</div>
<a id="ga2593853e2e7906aae3ab807690db898b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2593853e2e7906aae3ab807690db898b">&#9670;&nbsp;</a></span>get_quick_record_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> get_quick_record_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns estimated number of rows that could be fetched by given access method. </p>
<p>The function calls the range optimizer to estimate the cost of the cheapest QUICK_* index access method to scan one or several of the 'keys' using the conditions 'select-&gt;cond'. The range optimizer compares several different types of 'quick select' methods (range scan, index merge, loose index scan) and selects the cheapest one.</p>
<p>If the best index access method is cheaper than a table- and an index scan, then the range optimizer also constructs the corresponding QUICK_* object and assigns it to select-&gt;quick. In most cases this is the QUICK_* object used at later (optimization and execution) phases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session that runs the query. </td></tr>
    <tr><td class="paramname">tab</td><td>JOIN_TAB of source table. </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of rows to select.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In case of valid range, a QUICK_SELECT_I object will be constructed and saved in select-&gt;quick.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Estimated number of result rows selected from 'tab'.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_POS_ERROR</td><td>For derived tables/views or if an error occur. </td></tr>
    <tr><td class="paramname">0</td><td>If impossible query (i.e. certainly no rows will be selected.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee0363af5ecbde624f02fbc38a695a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0363af5ecbde624f02fbc38a695a3b">&#9670;&nbsp;</a></span>get_sj_strategy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> QEP_TAB::get_sj_strategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>semijoin strategy for this table. </dd></dl>

</div>
</div>
<a id="gabc77304fe7c751bce4fa59ef52d91fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc77304fe7c751bce4fa59ef52d91fb0">&#9670;&nbsp;</a></span>get_sj_strategy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> JOIN_TAB::get_sj_strategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>semijoin strategy for this table. </dd></dl>

</div>
</div>
<a id="ga60338e02a4512db7d658add6f008fd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60338e02a4512db7d658add6f008fd2e">&#9670;&nbsp;</a></span>get_sort_by_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structTABLE.html">TABLE</a> * get_sort_by_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return table number if there is only one table in sort order and group and order is compatible, else return 0. </p>

</div>
</div>
<a id="ga34118cfe3438321eb175c855298cead0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34118cfe3438321eb175c855298cead0">&#9670;&nbsp;</a></span>get_store_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classstore__key.html">store_key</a> * get_store_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>used_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>key_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>maybe_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga496897de00e555d82e8826fd8ae55b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga496897de00e555d82e8826fd8ae55b9d">&#9670;&nbsp;</a></span>get_tmp_table_rec_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> get_tmp_table_rec_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gae77d58d476f44178e469e2cbe16e9e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77d58d476f44178e469e2cbe16e9e01">&#9670;&nbsp;</a></span>handle_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> handle_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLEX.html">LEX</a> *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__result.html">Query_result</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>added_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>removed_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle data manipulation query which is not represented by Sql_cmd_dml class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">lex</td><td>query to be processed </td></tr>
    <tr><td class="paramname">result</td><td>sink of result of query execution. may be protocol object (for passing result to a client), insert object, update object, delete object, etc. </td></tr>
    <tr><td class="paramname">added_options</td><td>additional options for detailed control over execution </td></tr>
    <tr><td class="paramname">removed_options</td><td>options that are not applicable for this command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>Processing a query goes through 5 phases (parsing is already done)</p><ul>
<li>Preparation</li>
<li>Locking of tables</li>
<li>Optimization</li>
<li>Execution or explain</li>
<li>Cleanup</li>
</ul>
<p>The statements handled by this function are:</p>
<p>CREATE TABLE with SELECT clause SHOW statements </p>

</div>
</div>
<a id="gac1988b091d27a7072e1d8343f079a43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1988b091d27a7072e1d8343f079a43a">&#9670;&nbsp;</a></span>has_not_null_predicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> has_not_null_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>not_null_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check all existing AND'ed predicates in 'cond' for an existing 'is not null 'not_null_item''-predicate. </p>
<p>A condition consisting of multiple AND'ed terms is recursively decomposed in the search for the specified not null predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to be checked. </td></tr>
    <tr><td class="paramname">not_null_item</td><td>The item in: 'is not null 'item'' to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 'is not null 'not_null_item'' is a predicate in the specified 'cond'. </dd></dl>

</div>
</div>
<a id="ga31a07bf891c57c62aad090896e118cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31a07bf891c57c62aad090896e118cd1">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>jt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the object from a JOIN_TAB. </p>

</div>
</div>
<a id="ga44c5164eb9405b18a16ca8a3ee339047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c5164eb9405b18a16ca8a3ee339047">&#9670;&nbsp;</a></span>init_join_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::init_join_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function that allocates appropriate join cache object and sets next_select function of previous tab. </p>
<p>A helper function that sets the right op type for join cache (BNL/BKA). </p>

</div>
</div>
<a id="ga5ceb1154cde60c27cf304af914f6b5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ceb1154cde60c27cf304af914f6b5ba">&#9670;&nbsp;</a></span>init_join_cond_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_TAB::init_join_cond_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pointer to the join condition of TABLE_LIST. </p>

</div>
</div>
<a id="gab5e5e43ef7fb8034403c346059f9cfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e5e43ef7fb8034403c346059f9cfa6">&#9670;&nbsp;</a></span>init_planner_arrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::init_planner_arrays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize scratch arrays for the join order optimization. </p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If something fails during initialization, JOIN::cleanup() will free anything that has been partially allocated and set up. Arrays are created in the execution mem_root, so they will be deleted automatically when the mem_root is re-initialized. </dd></dl>

</div>
</div>
<a id="gae22f3c04c1f8f32d744714cd2ab4332b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae22f3c04c1f8f32d744714cd2ab4332b">&#9670;&nbsp;</a></span>init_ref_access()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::init_ref_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize ref access for all tables that use it. </p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We cannot setup fields used for ref access before we have sorted the items within multiple equalities according to the final order of the tables involved in the join operation. Currently, this occurs in </dd></dl>
<dl class="section see"><dt>See also</dt><dd>substitute_for_best_equal_field(). </dd></dl>

</div>
</div>
<a id="ga2e622501615212f22ca3d4ab13d0fbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e622501615212f22ca3d4ab13d0fbb0">&#9670;&nbsp;</a></span>is_indexed_agg_distinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_indexed_agg_distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem__field.html">Item_field</a> *&gt; *&#160;</td>
          <td class="paramname"><em>out_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for the presence of AGGFN(DISTINCT a) queries that may be subject to loose index scan. </p>
<p>Check if the query is a subject to AGGFN(DISTINCT) using loose index scan (QUICK_GROUP_MIN_MAX_SELECT). Optionally (if out_args is supplied) will push the arguments of AGGFN(DISTINCT) to the list</p>
<p>Check for every COUNT(DISTINCT), AVG(DISTINCT) or SUM(DISTINCT). These can be resolved by Loose Index Scan as long as all the aggregate distinct functions refer to the same fields. Thus:</p>
<p>SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT b, a)... =&gt; can use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT a) ... =&gt; can use LIS SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT a) ... =&gt; cannot use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT b) ... =&gt; cannot use LIS etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>the join to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_args</td><td>Collect the arguments of the aggregate functions to a list. We don't worry about duplicates as these will be sorted out later in get_best_group_min_max.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>does the query qualify for indexed AGGFN(DISTINCT) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>it does </td></tr>
    <tr><td class="paramname">false</td><td>AGGFN(DISTINCT) must apply distinct in it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f3819a0b6a5459bd00c3333e836fc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f3819a0b6a5459bd00c3333e836fc2f">&#9670;&nbsp;</a></span>is_prefix_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_prefix_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this is a prefix index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramname">idx</td><td>index to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this is a prefix index </dd></dl>

</div>
</div>
<a id="ga30906cdf5fbe1016d2fbf9471747235d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30906cdf5fbe1016d2fbf9471747235d">&#9670;&nbsp;</a></span>is_ref_or_null_optimized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_ref_or_null_optimized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ref_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if REF_OR_NULL optimization will be used if the specified ref_key is used for REF-access to 'tab'. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>JT_REF_OR_NULL will be used </td></tr>
    <tr><td class="paramname">false</td><td>no JT_REF_OR_NULL access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43e80da3a71b87f39e4a6844bd59651e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43e80da3a71b87f39e4a6844bd59651e">&#9670;&nbsp;</a></span>is_show_cmd_using_system_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_show_cmd_using_system_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the statement is a SHOW command using INFORMATION_SCHEMA system views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread (session) context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if command uses INFORMATION_SCHEMA system view, false otherwise </dd></dl>

</div>
</div>
<a id="ga4a8d854a364ab749539a9363619acf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a8d854a364ab749539a9363619acf99">&#9670;&nbsp;</a></span>is_subkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_subkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a second key is the subkey of the first one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_part</td><td>First key parts </td></tr>
    <tr><td class="paramname">ref_key_part</td><td>Second key parts </td></tr>
    <tr><td class="paramname">ref_key_part_end</td><td>Last+1 part of the second key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Second key MUST be shorter than the first one.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>is a subkey </td></tr>
    <tr><td class="paramname">0</td><td>no sub key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a494ca0bf471a2068fdb8211df2ed1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a494ca0bf471a2068fdb8211df2ed1d">&#9670;&nbsp;</a></span>is_timer_applicable_to_statement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_timer_applicable_to_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether max statement time is applicable to statement or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread (session) context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if max statement time is applicable to statement </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a id="gaa62d47da29f3853e87b1069ee5c1ff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62d47da29f3853e87b1069ee5c1ff21">&#9670;&nbsp;</a></span>join_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::join_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release memory and, if possible, the open tables held by this execution plan (and nested plans). </p>
<p>Partially cleanup JOIN after it has executed: close index or rnd read (table cursors), free quick selects.</p>
<p>It's used to release some tables before the end of execution in order to increase concurrency and reduce memory consumption.</p>
<p>This function is called in the end of execution of a JOIN, before the used tables are unlocked and closed.</p>
<p>For a join that is resolved using a temporary table, the first sweep is performed against actual tables and an intermediate result is inserted into the temprorary table. The last sweep is performed against the temporary table. Therefore, the base tables and associated buffers used to fill the temporary table are no longer needed, and this function is called to free them.</p>
<p>For a join that is performed without a temporary table, this function is called after all rows are sent, but before EOF packet is sent.</p>
<p>For a simple SELECT with no subqueries this function performs a full cleanup of the JOIN and calls mysql_unlock_read_tables to free used base tables.</p>
<p>If a JOIN is executed for a subquery or if it has a subquery, we can't do the full cleanup and need to do a partial cleanup only.</p><ul>
<li>If a JOIN is not the top level join, we must not unlock the tables because the outer select may not have been evaluated yet, and we can't unlock only selected tables of a query.</li>
<li>Additionally, if this JOIN corresponds to a correlated subquery, we should not free quick selects and join buffers because they will be needed for the next execution of the correlated subquery.</li>
<li>However, if this is a JOIN for a [sub]select, which is not a correlated subquery itself, but has subqueries, we can free it fully and also free JOINs of all its subqueries. The exception is a subquery in SELECT list, e.g: <div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> a, (select max(b) from t1) group by c</div></div><!-- fragment --> This subquery will not be evaluated at first sweep and its value will not be inserted into the temporary table. Instead, it's evaluated when selecting from the temporary table. Therefore, it can't be freed here even though it's not correlated.</li>
</ul>

</div>
</div>
<a id="ga93fa24dcc32ac483c17625d748cc09d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93fa24dcc32ac483c17625d748cc09d9">&#9670;&nbsp;</a></span>list_contains_unique_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> list_contains_unique_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(*)(<a class="el" href="classField.html">Field</a> *, void *)&#160;</td>
          <td class="paramname"><em>find_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if GROUP BY/DISTINCT can be optimized away because the set is already known to be distinct. </p>
<p>Used in removing the GROUP BY/DISTINCT of the following types of statements: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9aa23a9880eca693f679c969556249925f">DISTINCT</a>] &lt;unique_key_cols&gt;... FROM &lt;single_table_ref&gt;</div><div class="line">  [GROUP BY &lt;unique_key_cols&gt;,...]</div></div><!-- fragment --><p>If (a,b,c is distinct) then &lt;any combination of a,b,c&gt;,{whatever} is also distinct</p>
<p>This function checks if all the key parts of any of the unique keys of the table are referenced by a list : either the select list through find_field_in_item_list or GROUP BY list through find_field_in_order_list. If the above holds and the key parts cannot contain NULLs then we can safely remove the GROUP BY/DISTINCT, as no result set can be more distinct than an unique key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>The join table to operate on. </td></tr>
    <tr><td class="paramname">find_func</td><td>function to iterate over the list and search for a field </td></tr>
    <tr><td class="paramname">data</td><td>data that's passed through to to find_func</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>found </td></tr>
    <tr><td class="paramname">0</td><td>not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that make_outerjoin_info() has been called in order for the check for outer tables to work. </dd></dl>

</div>
</div>
<a id="gada7f25e97254e2d750e0a4c342dff519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada7f25e97254e2d750e0a4c342dff519">&#9670;&nbsp;</a></span>make_cond_for_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem.html">Item</a>* make_cond_for_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>other_tbls_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9cb279aada05a574f0745fe7dc700389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb279aada05a574f0745fe7dc700389">&#9670;&nbsp;</a></span>make_cond_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* make_cond_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>used_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>exclude_expensive_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a condition that can be checked after reading given table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Current session. </td></tr>
    <tr><td class="paramname">cond</td><td>Condition to analyze </td></tr>
    <tr><td class="paramname">tables</td><td>Tables for which "current field values" are available </td></tr>
    <tr><td class="paramname">used_table</td><td>Table(s) that we are extracting the condition for (may also include PSEUDO_TABLE_BITS, and may be zero) </td></tr>
    <tr><td class="paramname">exclude_expensive_cond</td><td>Do not push expensive conditions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;&gt;NULL</td><td>Generated condition </td></tr>
    <tr><td class="paramname">=</td><td>NULL Already checked, OR error</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the condition that can be checked after reading the table(s) specified in <code>used_table</code>, given that current-field values for tables specified in <code>tables</code> bitmap are available. If <code>used_table</code> is 0, extract conditions for all tables in <code>tables</code>.</p>
<p>This function can be used to extract conditions relevant for a table in a join order. Together with its caller, it will ensure that all conditions are attached to the first table in the join order where all necessary fields are available, and it will also ensure that a given condition is attached to only one table. To accomplish this, first initialize <code>tables</code> to the empty set. Then, loop over all tables in the join order, set <code>used_table</code> to the bit representing the current table, accumulate <code>used_table</code> into the <code>tables</code> set, and call this function. To ensure correct handling of const expressions and outer references, add the const table map and OUTER_REF_TABLE_BIT to <code>used_table</code> for the first table. To ensure that random expressions are evaluated for the final table, add RAND_TABLE_BIT to <code>used_table</code> for the final table.</p>
<p>The function assumes that constant, inexpensive parts of the condition have already been checked. Constant, expensive parts will be attached to the first table in the join order, provided that the above call sequence is followed.</p>
<p>The call order will ensure that conditions covering tables in <code>tables</code> minus those in <code>used_table</code>, have already been checked.</p>
<p>The function takes into account that some parts of the condition are guaranteed to be true by employed 'ref' access methods (the code that does this is located at the end, search down for "EQ_FUNC").</p>
<dl class="section note"><dt>Note</dt><dd>make_cond_for_info_schema() uses an algorithm similar to make_cond_for_table(). </dd></dl>

</div>
</div>
<a id="gace7f2f6ab05ccb685726a77994db1c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace7f2f6ab05ccb685726a77994db1c2f">&#9670;&nbsp;</a></span>make_cond_remainder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem.html">Item</a>* make_cond_remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>exclude_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga411d49ad6ee9cee6b02f30d624022ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga411d49ad6ee9cee6b02f30d624022ae4">&#9670;&nbsp;</a></span>make_join_plan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::make_join_plan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate best possible join order and initialize the join structure. </p>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if error.</dd></dl>
<p>The JOIN object is populated with statistics about the query, and a plan with table order and access method selection is made.</p>
<p>The list of tables to be optimized is taken from select_lex-&gt;leaf_tables. JOIN::where_cond is also used in the optimization. As a side-effect, JOIN::keyuse_array is populated with key_use information.</p>
<p>Here is an overview of the logic of this function:</p>
<ul>
<li>Initialize JOIN data structures and setup basic dependencies between tables.</li>
<li>Update dependencies based on join information.</li>
<li>Make key descriptions (update_ref_and_keys()).</li>
<li>Pull out semi-join tables based on table dependencies.</li>
<li>Extract tables with zero or one rows as const tables.</li>
<li>Read contents of const tables, substitute columns from these tables with actual data. Also keep track of empty tables vs. one-row tables.</li>
<li>After const table extraction based on row count, more tables may have become functionally dependent. Extract these as const tables.</li>
<li>Add new sargable predicates based on retrieved const values.</li>
<li>Calculate number of rows to be retrieved from each table.</li>
<li>Calculate cost of potential semi-join materializations.</li>
<li>Calculate best possible join order based on available statistics.</li>
<li>Fill in remaining information for the generated join order. </li>
</ul>

</div>
</div>
<a id="ga27b74179b9a9207753aa3f93a9df4225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27b74179b9a9207753aa3f93a9df4225">&#9670;&nbsp;</a></span>make_join_readinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> make_join_readinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plan refinement stage: do various setup things for the executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join being processed </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>Don't use join buffering after table with this number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error (Out of memory)</dd></dl>
<p>Plan refinement stage: do various set ups for the executioner</p><ul>
<li>setup join buffering use</li>
<li>push index conditions</li>
<li>increment relevant counters</li>
<li>etc </li>
</ul>

</div>
</div>
<a id="ga1e200feaabd87014fd301f6fa6994754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e200feaabd87014fd301f6fa6994754">&#9670;&nbsp;</a></span>make_join_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> make_join_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separates the predicates in a join condition and pushes them to the join step where all involved tables are available in the join prefix. </p>
<p>ON clauses from JOIN expressions are also pushed to the most appropriate step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join object where predicates are pushed.</td></tr>
    <tr><td class="paramname">cond</td><td>Pointer to condition which may contain an arbitrary number of predicates, combined using AND, OR and XOR items. If NULL, equivalent to a predicate that returns true for all row combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Found impossible WHERE clause, or out-of-memory </td></tr>
    <tr><td class="paramname">false</td><td>Other </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c6d51becf5eba76fdbca3e38597322a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c6d51becf5eba76fdbca3e38597322a">&#9670;&nbsp;</a></span>make_outerjoin_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::make_outerjoin_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill in outer join related info for the execution plan structure. </p>
<p>For each outer join operation left after simplification of the original query the function set up the following pointers in the linear structure join-&gt;join_tab representing the selected execution plan. The first inner table t0 for the operation is set to refer to the last inner table tk through the field t0-&gt;last_inner. Any inner table ti for the operation are set to refer to the first inner table ti-&gt;first_inner. The first inner table t0 for the operation is set to refer to the first inner table of the embedding outer join operation, if there is any, through the field t0-&gt;first_upper. The on expression for the outer join operation is attached to the corresponding first inner table through the field t0-&gt;on_expr_ref. Here ti are structures of the JOIN_TAB type.</p>
<p>EXAMPLE. For the query: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1</div><div class="line">              <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="group__Query__Optimizer.html#gae61cb563ddbc36edfe43024c8a479190">JOIN</a></div><div class="line">              (t2, t3 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t4 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t3.a=t4.a)</div><div class="line">              <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> (t1.a=t2.a AND t1.b=t3.b)</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.c &gt; 5,</div></div><!-- fragment --><p>given the execution plan with the table order t1,t2,t3,t4 is selected, the following references will be set; t4-&gt;last_inner=[t4], t4-&gt;first_inner=[t4], t4-&gt;first_upper=[t2] t2-&gt;last_inner=[t4], t2-&gt;first_inner=t3-&gt;first_inner=[t2], on expression (t1.a=t2.a AND t1.b=t3.b) will be attached to t2-&gt;on_expr_ref, while t3.a=t4.a will be attached to *t4-&gt;on_expr_ref.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the simplification procedure has been already applied to the join query (see simplify_joins). This function can be called only after the execution plan has been chosen. </dd></dl>

</div>
</div>
<a id="ga9904341bd01f9e9aabc4d9b9f5123266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9904341bd01f9e9aabc4d9b9f5123266">&#9670;&nbsp;</a></span>make_sum_func_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::make_sum_func_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>before_group_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>recompute</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize 'sum_funcs' array with all Item_sum objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields</td><td>All items </td></tr>
    <tr><td class="paramname">before_group_by</td><td>Set to 1 if this is called before GROUP BY handling </td></tr>
    <tr><td class="paramname">recompute</td><td>Set to true if sum_funcs must be recomputed</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d12748a936ddf29bf434f926bff493b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d12748a936ddf29bf434f926bff493b">&#9670;&nbsp;</a></span>make_tmp_tables_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::make_tmp_tables_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init tmp tables usage info. </p>
<p>This function finalizes execution plan by taking following actions: .) tmp tables are created, but not instantiated (this is done during execution). QEP_TABs dedicated to tmp tables are filled appropriately. see JOIN::create_intermediate_table. .) prepare fields lists (fields, all_fields, ref_item_array slices) for each required stage of execution. These fields lists are set for tmp tables' tabs and for the tab of last table in the join. .) fill info for sorting/grouping/dups removal is prepared and saved to appropriate tabs. Here is an example: SELECT * from t1,t2 WHERE ... GROUP BY t1.f1 ORDER BY t2.f2, t1.f2 and lets assume that the table order in the plan is t1,t2. In this case optimizer will sort for group only the first table as the second one isn't mentioned in GROUP BY. The result will be materialized in tmp table. As filesort can't sort join optimizer will sort tmp table also. The first sorting (for group) is called simple as is doesn't require tmp table. The Filesort object for it is created here - in JOIN::create_intermediate_table. Filesort for the second case is created here, in JOIN::make_tmp_tables_info.</p>
<dl class="section note"><dt>Note</dt><dd>This function may change tmp_table_param.precomputed_group_by. This affects how create_tmp_table() treats aggregation functions, so count_field_types() must be called again to make sure this is taken into consideration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false - Ok true - Error </dd></dl>

</div>
</div>
<a id="ga0db5dc577ffd7662b800cc6307183c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db5dc577ffd7662b800cc6307183c2b">&#9670;&nbsp;</a></span>mark_const_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::mark_const_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move const tables first in the position array. </p>
<p>Increment the number of const tables and set same basic properties for the const table. A const table looked up by a key has type JT_CONST. A const table with a single row has type JT_SYSTEM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table that is designated as a const table </td></tr>
    <tr><td class="paramname">key</td><td>The key definition to use for this table (NULL if table scan) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e5943531e04254b574e4e0f9aa77b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5943531e04254b574e4e0f9aa77b82">&#9670;&nbsp;</a></span>only_eq_ref_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> only_eq_ref_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>cached_eq_ref_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>eq_ref_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>eq_ref_table() </dd></dl>

</div>
</div>
<a id="ga7f01afeabbc410693c8f98d4f3559cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f01afeabbc410693c8f98d4f3559cd5">&#9670;&nbsp;</a></span>optimize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimizes one query block into a query execution plan (QEP.) </p>
<p>This is the entry point to the query optimization phase. This phase applies both logical (equivalent) query rewrites, cost-based join optimization, and rule-based access path selection. Once an optimal plan is found, the member function creates/initializes all structures needed for query execution. The main optimization phases are outlined below:</p>
<ol type="1">
<li>Logical transformations:<ul>
<li>Outer to inner joins transformation.</li>
<li>Equality/constant propagation.</li>
<li>Partition pruning.</li>
<li>COUNT(*), MIN(), MAX() constant substitution in case of implicit grouping.</li>
<li>ORDER BY optimization.</li>
</ul>
</li>
<li>Perform cost-based optimization of table order and access path selection. See JOIN::make_join_plan()</li>
<li>Post-join order optimization:<ul>
<li>Create optimal table conditions from the where clause and the join conditions.</li>
<li>Inject outer-join guarding conditions.</li>
<li>Adjust data access methods after determining table condition (several times.)</li>
<li>Optimize ORDER BY/DISTINCT.</li>
</ul>
</li>
<li>Code generation<ul>
<li>Set data access functions.</li>
<li>Try to optimize away sorting/distinct.</li>
<li>Setup temporary table usage for grouping and/or sorting.</li>
</ul>
</li>
</ol>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Error, error code saved in member JOIN::error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae627edcb32cecc272357bb0d0d38c597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae627edcb32cecc272357bb0d0d38c597">&#9670;&nbsp;</a></span>optimize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize a query block and all inner query expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gab2e311ce93e412ea78a25b7016f91574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2e311ce93e412ea78a25b7016f91574">&#9670;&nbsp;</a></span>optimize_cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> optimize_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html#ab74b339b7c522a3a7aa2b8e4e8123a1b">Item::cond_result</a> *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize conditions by. </p>
<p>a) applying transitivity to build multiple equality predicates (MEP): if x=y and y=z the MEP x=y=z is built. b) apply constants where possible. If the value of x is known to be 42, x is replaced with a constant of value 42. By transitivity, this also applies to MEPs, so the MEP in a) will become 42=x=y=z. c) remove conditions that are always false or always true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cond</td><td>WHERE or HAVING condition to optimize </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_equal</td><td>The built multiple equalities </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join operations with join conditions = NULL: Called for HAVING condition </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_value</td><td>Not changed if cond was empty COND_TRUE if cond is always true COND_FALSE if cond is impossible COND_OK otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga56c2d0cf3f4b9f73f56a0d9d95a54507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c2d0cf3f4b9f73f56a0d9d95a54507">&#9670;&nbsp;</a></span>optimize_distinct_group_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::optimize_distinct_group_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimize DISTINCT, GROUP BY, ORDER BY clauses. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>ok </td></tr>
    <tr><td class="paramname">true</td><td>an error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga958fa96e63ffbd0291b04c7a39058bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga958fa96e63ffbd0291b04c7a39058bd5">&#9670;&nbsp;</a></span>optimize_fts_query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::optimize_fts_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function sets FT hints, initializes FT handlers and checks if FT index can be used as covered. </p>

</div>
</div>
<a id="ga7c982de3c6d0e121753053df9a743bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c982de3c6d0e121753053df9a743bd5">&#9670;&nbsp;</a></span>optimize_keyuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::optimize_keyuse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update some values in keyuse for faster choose_table_order() loop. </p>

</div>
</div>
<a id="gaac99b2256ee62ddd1a435289c2acb8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac99b2256ee62ddd1a435289c2acb8e2">&#9670;&nbsp;</a></span>optimize_rollup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::optimize_rollup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize rollup specification. </p>
<p>Allocate objects needed for rollup processing.</p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error. </dd></dl>

</div>
</div>
<a id="gac1005a29706ad2d0486b8445016b16be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1005a29706ad2d0486b8445016b16be">&#9670;&nbsp;</a></span>optimize_secondary_engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> optimize_secondary_engine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform query optimizations that are specific to a secondary storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the current session </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error, false on success </dd></dl>

</div>
</div>
<a id="ga2b0c1fe8bf704242bb61acaa40a81fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b0c1fe8bf704242bb61acaa40a81fb4">&#9670;&nbsp;</a></span>optimize_semijoin_nests_for_materialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> optimize_semijoin_nests_for_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimize semi-join nests that could be run with sj-materialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join to optimize semi-join nests for</td></tr>
  </table>
  </dd>
</dl>
<p>Optimize each of the semi-join nests that can be run with materialization. For each of the nests, we</p><ul>
<li>Generate the best join order for this "sub-join" and remember it;</li>
<li>Remember the sub-join execution cost (it's part of materialization cost);</li>
<li>Calculate other costs that will be incurred if we decide to use materialization strategy for this semi-join nest.</li>
</ul>
<p>All obtained information is saved and will be used by the main join optimization pass.</p>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>

</div>
</div>
<a id="ga3de853250ebf294ab84cf50d8f9234ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3de853250ebf294ab84cf50d8f9234ce">&#9670;&nbsp;</a></span>part_of_refkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem.html">Item</a>* part_of_refkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga817d27fe6f8590ac50498fca33ecd275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga817d27fe6f8590ac50498fca33ecd275">&#9670;&nbsp;</a></span>precheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_select::precheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an authorization precheck for an unprepared SELECT statement. </p>
<p>This function will check that we have some privileges to all involved tables of the query (and possibly to other entities). </p>

<p>Implements <a class="el" href="classSql__cmd__dml.html#a1d36019e4748a8f8acb05238e6c28fc3">Sql_cmd_dml</a>.</p>

<p>Reimplemented in <a class="el" href="classSql__cmd__show.html#ace0caf60485e06e7979eee7d3cd2ad41">Sql_cmd_show</a>.</p>

</div>
</div>
<a id="ga1fca8dbb532f59224d9ca897f3311e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fca8dbb532f59224d9ca897f3311e91">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_dml::prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-specific resolving (doesn't include LEX::prepare()) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Current THD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error </dd></dl>

<p>Reimplemented from <a class="el" href="classSql__cmd.html#a04696ad8e61d7ad60abc3d0269ddc94a">Sql_cmd</a>.</p>

</div>
</div>
<a id="gadb5671ceeb1b43091f690fc9968d4291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb5671ceeb1b43091f690fc9968d4291">&#9670;&nbsp;</a></span>prepare_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_select::prepare_inner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare a SELECT statement. </p>

<p>Implements <a class="el" href="classSql__cmd__dml.html#a50525b0a191564b816efb072c60c983d">Sql_cmd_dml</a>.</p>

</div>
</div>
<a id="gabed62f6e6cc8f6d042c806a154ea7137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed62f6e6cc8f6d042c806a154ea7137">&#9670;&nbsp;</a></span>prepare_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::prepare_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare join result. </p>
<p>Prepare join result prior to join execution or describing. Instantiate derived tables and get schema tables result if necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>true An error during derived or schema tables instantiation. false Ok </dd></dl>

</div>
</div>
<a id="gadfa02a9c5953372b94ac6edf44a5afef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa02a9c5953372b94ac6edf44a5afef">&#9670;&nbsp;</a></span>propagate_cond_constants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> propagate_cond_constants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classI__List.html">I_List</a>&lt; <a class="el" href="classCOND__CMP.html">COND_CMP</a> &gt; *&#160;</td>
          <td class="paramname"><em>save_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>and_father</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Propagate constant values in a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">save_list</td><td>saved list of COND_CMP </td></tr>
    <tr><td class="paramname">and_father</td><td>father of AND op </td></tr>
    <tr><td class="paramname">cond</td><td>Condition for which constant values are propagated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga740bdc7fe4c25e9c0b1612fea1d999f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga740bdc7fe4c25e9c0b1612fea1d999f5">&#9670;&nbsp;</a></span>propagate_dependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::propagate_dependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate dependencies between tables due to outer join relations. </p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd>
<dd>
false if success, true if error</dd></dl>
<p>Build transitive closure for relation 'to be dependent on'. This will speed up the plan search for many cases with outer joins, as well as allow us to catch illegal cross references. Warshall's algorithm is used to build the transitive closure. As we may restart the outer loop upto 'table_count' times, the complexity of the algorithm is O((number of tables)^3). However, most of the iterations will be shortcircuited when there are no dependencies to propagate. </p>

</div>
</div>
<a id="ga83205e07366599292b152f463e675776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83205e07366599292b152f463e675776">&#9670;&nbsp;</a></span>prune_table_partitions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::prune_table_partitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prune partitions for all tables of a join (query block). </p>
<p>Requires that tables have been locked.</p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gaec74b2258a6fa694f7c1e4cca9242b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec74b2258a6fa694f7c1e4cca9242b2f">&#9670;&nbsp;</a></span>pull_out_semijoin_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> pull_out_semijoin_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pull tables out of semi-join nests based on functional dependencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join where to do the semi-join table pullout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if successful, true if error (Out of memory)</dd></dl>
<p>Pull tables out of semi-join nests based on functional dependencies, ie. if a table is accessed via eq_ref(outer_tables). The function may be called several times, the caller is responsible for setting up proper key information that this function acts upon.</p>
<p>PRECONDITIONS When this function is called, the join may have several semi-join nests but it is guaranteed that one semi-join nest does not contain another. For functionally dependent tables to be pulled out, key information must have been calculated (see update_ref_and_keys()).</p>
<p>POSTCONDITIONS Tables that were pulled out are removed from the semi-join nest they belonged to and added to the parent join nest. For these tables, the used_tables and not_null_tables fields of the semi-join nest they belonged to will be adjusted. The semi-join nest is also marked as correlated, and sj_corr_tables and sj_depends_on are adjusted if necessary. Semi-join nests' sj_inner_tables is set equal to used_tables</p>
<p>NOTE Table pullout may make uncorrelated subquery correlated. Consider this example:</p>
<p>... WHERE oe IN (SELECT it1.primary_key WHERE p(it1, it2) ... )</p>
<p>here table it1 can be pulled out (we have it1.primary_key=oe which gives us functional dependency). Once it1 is pulled out, all references to it1 from p(it1, it2) become references to outside of the subquery and thus make the subquery (i.e. its semi-join nest) correlated. Making the subquery (i.e. its semi-join nest) correlated prevents us from using Materialization or LooseScan to execute it. </p>

</div>
</div>
<a id="ga5ededf725731bb0cfd5a3871181f496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ededf725731bb0cfd5a3871181f496e">&#9670;&nbsp;</a></span>push_index_cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::push_index_cond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to extract and push the index condition down to table handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tab</td><td>join_tab for table </td></tr>
    <tr><td class="paramname">keyno</td><td>Index for which extract and push the condition </td></tr>
    <tr><td class="paramname">trace_obj</td><td>trace object where information is to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c6a205591a47565a5e3c2244d0c74a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c6a205591a47565a5e3c2244d0c74a5">&#9670;&nbsp;</a></span>push_to_engines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::push_to_engines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle offloading of query parts to the underlying engines, when such is supported by their implementation. </p>
<p>Push (parts of) the query execution down to the storage engines if they can provide faster execution of the query, or part of it.</p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>The handler will inspect the QEP through the AQP (Abstract Query Plan) and extract from it whatever it might implement of pushed execution.</p>
<p>It is the responsibility of the handler to store any information it need for the later execution of pushed queries and conditions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Error, error code saved in member JOIN::error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga907897f1c70ca51d710d46da42645cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga907897f1c70ca51d710d46da42645cfc">&#9670;&nbsp;</a></span>qs_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_shared_owner::qs_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7b85110a470360e40530494669448f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b85110a470360e40530494669448f44">&#9670;&nbsp;</a></span>query_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQuery__result.html">Query_result</a> * Sql_cmd_dml::query_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the query result associated with a prepared query </dd></dl>

</div>
</div>
<a id="ga2098edca4505e2804c6c948550e2829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2098edca4505e2804c6c948550e2829b">&#9670;&nbsp;</a></span>reads_not_secondary_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reads_not_secondary_columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structLEX.html">LEX</a> *&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a query reads a column that is <em>not</em> available in the secondary engine (i.e. </p>
<p>a column defined with NOT SECONDARY).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lex</td><td>Parse tree descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one of the read columns is not in the secondary engine, false otherwise. </dd></dl>

</div>
</div>
<a id="ga27ebfbbca25d50293c45bac8ced7e75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27ebfbbca25d50293c45bac8ced7e75c">&#9670;&nbsp;</a></span>recalculate_deps_of_remaining_lateral_derived_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::recalculate_deps_of_remaining_lateral_derived_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>plan_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates JOIN::deps_of_remaining_lateral_derived_tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan_tables</td><td>map of all tables that the planner is processing (tables already in plan and tables to be added to plan) </td></tr>
    <tr><td class="paramname">idx</td><td>index of the table which the planner is currently considering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae85874c3c0521511d02daba0b891e17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae85874c3c0521511d02daba0b891e17b">&#9670;&nbsp;</a></span>reduce_cond_for_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem.html">Item</a>* reduce_cond_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>null_extended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove redundant predicates from condition, return the reduced condition. </p>
<p>A predicate of the form 'field = value' may be redundant if the (ref-) access choosen for the table use an index containing 'field', where 'value' is specified as (part of) its ref-key. This method remove such redundant predicates, thus reducing the condition, possibly eliminating it entirely.</p>
<p>If comparing 'values' against outer-joined tables, these are possibly 'null-extended'. Thus the usage of these values in the ref-key, is not sufficient anymore to guarantee that 'field = value' is 'TRUE'. The 'null_extended' argument hold the table_map of any such possibly null-extended tables which are excluded from the above 'reduce' logic.</p>
<p>Any tables referred in Item_func_trig_cond(FOUND_MATCH) conditions are aggregated into this null_extended table_map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition to be 'reduced'. </td></tr>
    <tr><td class="paramname">null_extended</td><td>table_map of possibly null-extended outer-tables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The condition with redundant predicates removed, possibly nullptr. </dd></dl>

</div>
</div>
<a id="gaef4f64b9b280796d9abe945b2eda94ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4f64b9b280796d9abe945b2eda94ac">&#9670;&nbsp;</a></span>refine_best_rowcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::refine_best_rowcount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine the best_rowcount estimation based on what happens after tables have been joined: LIMIT and type of result sink. </p>

</div>
</div>
<a id="gac512af3edf6254e3de69d6ae645e5d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac512af3edf6254e3de69d6ae645e5d31">&#9670;&nbsp;</a></span>remove_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a> * JOIN::remove_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>first_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>change_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>simple_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>group_by</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all constants and check if ORDER only contains simple expressions. </p>
<p>simple_order is set to 1 if sort_order only uses fields from head table and the head table is not a LEFT JOIN table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_order</td><td>List of SORT or GROUP order </td></tr>
    <tr><td class="paramname">cond</td><td>WHERE statement </td></tr>
    <tr><td class="paramname">change_list</td><td>Set to 1 if we should remove things from list. If this is not set, then only simple_order is calculated. </td></tr>
    <tr><td class="paramname">simple_order</td><td>Set to 1 if we are only using simple expressions </td></tr>
    <tr><td class="paramname">group_by</td><td>True if order represents a grouping operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new sort order </dd></dl>

</div>
</div>
<a id="gaf8c7623dfe6301253414f9155999c43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8c7623dfe6301253414f9155999c43b">&#9670;&nbsp;</a></span>remove_eq_conds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> remove_eq_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>retcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html#ab74b339b7c522a3a7aa2b8e4e8123a1b">Item::cond_result</a> *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes const and eq items. </p>
<p>Returns the new item, or nullptr if no condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>the condition to handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retcond</td><td>condition after const removal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_value</td><td>resulting value of the condition =COND_OK condition must be evaluated (e.g. field = constant) =COND_TRUE always true (e.g. 1 = 1) =COND_FALSE always false (e.g. 1 = 2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga0508bf7a0f0aa01ca757dd1ebdcdefb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0508bf7a0f0aa01ca757dd1ebdcdefb1">&#9670;&nbsp;</a></span>replace_from_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void store_key_field::replace_from_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>from_field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf09d537f6629efe192657db2e0205687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf09d537f6629efe192657db2e0205687">&#9670;&nbsp;</a></span>replace_index_subquery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::replace_index_subquery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this is a subquery that can be evaluated by index look-ups. </p>
<p>If so, change subquery engine to subselect_indexsubquery_engine.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>engine was changed </td></tr>
    <tr><td class="paramname">0</td><td>engine wasn't changed </td></tr>
    <tr><td class="paramname">-1</td><td>OOM or other error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4e09d71987062663db1836d651ec4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e09d71987062663db1836d651ec4d4">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the state of this join object so that it is ready for a new execution. </p>

</div>
</div>
<a id="ga3632047b55b1b225c609f0f9ff46250a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3632047b55b1b225c609f0f9ff46250a">&#9670;&nbsp;</a></span>reset_statement_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_statement_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate the timer associated with the statement that was executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread (session) context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa17a75373e1849b6c001db7c0022bb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17a75373e1849b6c001db7c0022bb54">&#9670;&nbsp;</a></span>restore_cmd_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_dml::restore_cmd_properties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore command properties before execution. </p>
<ul>
<li>Bind metadata for tables and fields</li>
<li>Restore clauses (e.g ORDER BY, GROUP BY) that were destroyed in last optimization. </li>
</ul>

<p>Reimplemented in <a class="el" href="classSql__cmd__insert__base.html#a2f945097fafa578602fcc8e26a061ab4">Sql_cmd_insert_base</a>.</p>

</div>
</div>
<a id="ga7d63fd61180432c250b2c474d55878b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d63fd61180432c250b2c474d55878b8">&#9670;&nbsp;</a></span>retry_with_secondary_engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> retry_with_secondary_engine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a query should be retried using a secondary storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the current session</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the statement should be retried in a secondary engine </td></tr>
    <tr><td class="paramname">false</td><td>if the statement should not be retried </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0283c484bf5fee7f5b6650d9e05020f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0283c484bf5fee7f5b6650d9e05020f7">&#9670;&nbsp;</a></span>revise_cache_usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void revise_cache_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga85d6643eaddcec99ec847250bbc2e01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85d6643eaddcec99ec847250bbc2e01a">&#9670;&nbsp;</a></span>save_cmd_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Sql_cmd_dml::save_cmd_properties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save command properties, such as prepared query details and table props. </p>

</div>
</div>
<a id="gaaaf7d0c085b6fa2c810619adfcc8cfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf7d0c085b6fa2c810619adfcc8cfd9">&#9670;&nbsp;</a></span>semijoin_types_allow_materialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void semijoin_types_allow_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sj_nest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if semijoin's compared types allow materialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sj_nest</td><td>Semi-join nest containing information about correlated expressions. Set nested_join-&gt;sjm.scan_allowed to true if MaterializeScan strategy allowed. Set nested_join-&gt;sjm.lookup_allowed to true if MaterializeLookup strategy allowed</td></tr>
  </table>
  </dd>
</dl>
<p>This is a temporary fix for BUG#36752.</p>
<p>There are two subquery materialization strategies for semijoin:</p>
<ol type="1">
<li><p class="startli">Materialize and do index lookups in the materialized table. See BUG#36752 for description of restrictions we need to put on the compared expressions.</p>
<p class="startli">In addition, since indexes are not supported for BLOB columns, this strategy can not be used if any of the columns in the materialized table will be BLOB/GEOMETRY columns. (Note that also columns for non-BLOB values that may be greater in size than CONVERT_IF_BIGGER_TO_BLOB, will be represented as BLOB columns.)</p>
</li>
<li>Materialize and then do a full scan of the materialized table. The same criteria as for MaterializeLookup are applied, except that BLOB/GEOMETRY columns are allowed. </li>
</ol>

</div>
</div>
<a id="gaeff952112cba4e545fff770e79158220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff952112cba4e545fff770e79158220">&#9670;&nbsp;</a></span>set_plan_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::set_plan_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html#a965b8cb3ded4b0e826a3cab5f7d88694">enum_plan_state</a>&#160;</td>
          <td class="paramname"><em>plan_state_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the plan's state of the JOIN. </p>
<p>This is always the final step of optimization; starting from this call, we expose the plan to other connections (via EXPLAIN CONNECTION) so the plan has to be final. QEP_TAB's quick_optim, condition_optim and keyread_optim are set here. </p>

</div>
</div>
<a id="ga61a9a63131b536315d16d122eed3102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a9a63131b536315d16d122eed3102a">&#9670;&nbsp;</a></span>set_prefix_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::set_prefix_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign set of available (prefix) tables to all tables in query block. </p>
<p>Also set added tables, ie the tables added in each JOIN_TAB compared to the previous JOIN_TAB. This function must be called for every query block after the table order has been determined. </p>

</div>
</div>
<a id="ga7ef0fb59d04cf7283ec4cf618aa578db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ef0fb59d04cf7283ec4cf618aa578db">&#9670;&nbsp;</a></span>set_query_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sql_cmd_dml::set_query_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQuery__result.html">Query_result</a> *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set query result object for this query statement. </p>

</div>
</div>
<a id="ga52d3829776ab95dee43086b5aa43b234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d3829776ab95dee43086b5aa43b234">&#9670;&nbsp;</a></span>set_semijoin_embedding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::set_semijoin_embedding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set semi-join embedding join nest pointers. </p>
<p>Set pointer to embedding semi-join nest for all semi-joined tables. This is the closest semi-join or anti-join nest. Note that this must be done for every table inside all semi-join nests, even for tables within outer join nests embedded in semi-join nests. A table can never be part of multiple semi-join nests, hence no ambiguities can ever occur. Note also that the pointer is not set for TABLE_LIST objects that are outer join nests within semi-join nests. </p>

</div>
</div>
<a id="gab7ec58d0faabade96e5378b0e5a1c2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ec58d0faabade96e5378b0e5a1c2c2">&#9670;&nbsp;</a></span>set_semijoin_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::set_semijoin_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the first_sj_inner_tab and last_sj_inner_tab fields for all tables inside the semijoin nests of the query. </p>

</div>
</div>
<a id="ga6887d6c5f56788688c7c727da969350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6887d6c5f56788688c7c727da969350c">&#9670;&nbsp;</a></span>set_statement_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> set_statement_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the time until the currently running statement is aborted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread (session) context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timer was armed. </dd></dl>
<p>whether timer can be set for the statement or not should be checked before calling set_statement_timer function.</p>

</div>
</div>
<a id="gaa0a217df3532c76cee211d7e65dd86d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a217df3532c76cee211d7e65dd86d0">&#9670;&nbsp;</a></span>set_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_TAB::set_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0c98e119d5015f0fc32f950b5c0fc86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c98e119d5015f0fc32f950b5c0fc86b">&#9670;&nbsp;</a></span>setup_join_buffering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_join_buffering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up join buffering for a specified table, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>joined table to check join buffer usage for </td></tr>
    <tr><td class="paramname">join</td><td>join for which the check is performed </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>don't use join buffering after table with this number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error. Currently, allocation errors for join cache objects are ignored, and regular execution is chosen silently.</dd></dl>
<p>The function finds out whether the table 'tab' can be joined using a join buffer. This check is performed after the best execution plan for 'join' has been chosen. If the function decides that a join buffer can be employed then it selects the most appropriate join cache type, which later will be instantiated by init_join_cache(). If it has already been decided to not use join buffering for this table, no action is taken.</p>
<p>Often it is already decided that join buffering will be used earlier in the optimization process, and this will also ensure that the most correct cost for the operation is calculated, and hence the probability of choosing an optimal join plan is higher. However, some join buffering decisions cannot currently be taken before this stage, hence we need this function to decide the most accurate join buffering strategy.</p>
<p>The result of the check and the type of the join buffer to be used depend on:</p><ul>
<li>the access method to access rows of the joined table</li>
<li>whether the join table is an inner table of an outer join or semi-join</li>
<li>the optimizer_switch settings for join buffering</li>
<li>the join 'options'. In any case join buffer is not used if the number of the joined table is greater than 'no_jbuf_after'.</li>
</ul>
<p>If block_nested_loop is turned on, and if all other criteria for using join buffering is fulfilled (see below), then join buffer is used for any join operation (inner join, outer join, semi-join) with 'JT_ALL' access method. In that case, a JOIN_CACHE_BNL type is always employed.</p>
<p>If an index is used to access rows of the joined table and batched_key_access is on, then a JOIN_CACHE_BKA type is employed.</p>
<p>If the function decides that a join buffer can be used to join the table 'tab' then it sets <code>tab-&gt;use_join_cache</code> to reflect the chosen algorithm.</p>
<dl class="section note"><dt>Note</dt><dd>For a nested outer join/semi-join, currently, we either use join buffers for all inner tables or for none of them.</dd></dl>
<pre class="fragment">      JOIN_TAB *first_tab= join-&gt;join_tab+join-&gt;const_tables;
      uint n_tables= i-join-&gt;const_tables;
      / *
        We normally put all preceding tables into the join buffer, except
        for the constant tables.
        If we're inside a semi-join materialization nest, e.g.

           outer_tbl1  outer_tbl2  ( inner_tbl1, inner_tbl2 ) ...
                                                     ^-- we're here

        then we need to put into the join buffer only the tables from
        within the nest.
      * /
      if (i &gt;= first_sjm_table &amp;&amp; i &lt; last_sjm_table)
      {
        n_tables= i - first_sjm_table; // will be &gt;0 if we got here
        first_tab= join-&gt;join_tab + first_sjm_table;
      }</pre> 
</div>
</div>
<a id="ga66fa6e0c548ce639a90994ae43b49ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66fa6e0c548ce639a90994ae43b49ef9">&#9670;&nbsp;</a></span>setup_semijoin_dups_elimination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_semijoin_dups_elimination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the strategies to eliminate semi-join duplicates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join to process </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>Do not use join buffering after the table with this number</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Out of memory error</td></tr>
  </table>
  </dd>
</dl>
<p>Setup the strategies to eliminate semi-join duplicates. At the moment there are 5 strategies:</p>
<ol type="1">
<li>DuplicateWeedout (use of temptable to remove duplicates based on rowids of row combinations)</li>
<li>FirstMatch (pick only the 1st matching row combination of inner tables)</li>
<li>LooseScan (scanning the sj-inner table in a way that groups duplicates together and picking the 1st one)</li>
<li>MaterializeLookup (Materialize inner tables, then setup a scan over outer correlated tables, lookup in materialized table)</li>
<li>MaterializeScan (Materialize inner tables, then setup a scan over materialized tables, perform lookup in outer tables)</li>
</ol>
<p>The join order has "duplicate-generating ranges", and every range is served by one strategy or a combination of FirstMatch with with some other strategy.</p>
<p>"Duplicate-generating range" is defined as a range within the join order that contains all of the inner tables of a semi-join. All ranges must be disjoint, if tables of several semi-joins are interleaved, then the ranges are joined together, which is equivalent to converting</p>
<p><code>SELECT ... WHERE oe1 IN (SELECT ie1 ...) AND oe2 IN (SELECT ie2 )</code></p>
<p>to</p>
<p><code>SELECT ... WHERE (oe1, oe2) IN (SELECT ie1, ie2 ... ...)</code>.</p>
<p>Applicability conditions are as follows:</p>
<dl class="section user"><dt>DuplicateWeedout strategy</dt><dd></dd></dl>
<div class="fragment"><div class="line">(ot|nt)*  [ it ((it|ot|nt)* (it|ot))]  (nt)*</div><div class="line">+------+  +=========================+  +---+</div><div class="line">  (1)                 (2)               (3)</div></div><!-- fragment --><ol type="1">
<li>Prefix of OuterTables (those that participate in IN-equality and/or are correlated with subquery) and outer Non-correlated tables.</li>
<li>The handled range. The range starts with the first sj-inner table, and covers all sj-inner and outer tables Within the range, Inner, Outer, outer non-correlated tables may follow in any order.</li>
<li>The suffix of outer non-correlated tables.</li>
</ol>
<dl class="section user"><dt>FirstMatch strategy</dt><dd></dd></dl>
<div class="fragment"><div class="line">(ot|nt)*  [ it (it)* ]  (nt)*</div><div class="line">+------+  +==========+  +---+</div><div class="line">  (1)          (2)        (3)</div></div><!-- fragment --><ol type="1">
<li>Prefix of outer correlated and non-correlated tables</li>
<li>The handled range, which may contain only inner tables.</li>
<li>The suffix of outer non-correlated tables.</li>
</ol>
<dl class="section user"><dt>LooseScan strategy</dt><dd></dd></dl>
<div class="fragment"><div class="line">(ot|ct|nt) [ loosescan_tbl (ot|nt|it)* it ]  (ot|nt)*</div><div class="line">+--------+   +===========+ +=============+   +------+</div><div class="line">   (1)           (2)          (3)              (4)</div></div><!-- fragment --><ol type="1">
<li>Prefix that may contain any outer tables. The prefix must contain all the non-trivially correlated outer tables. (non-trivially means that the correlation is not just through the IN-equality).</li>
<li>Inner table for which the LooseScan scan is performed. Notice that special requirements for existence of certain indexes apply to this table, <dl class="section see"><dt>See also</dt><dd>class Loose_scan_opt.</dd></dl>
</li>
<li>The remainder of the duplicate-generating range. It is served by application of FirstMatch strategy. Outer IN-correlated tables must be correlated to the LooseScan table but not to the inner tables in this range. (Currently, there can be no outer tables in this range because of implementation restrictions, <dl class="section see"><dt>See also</dt><dd>Optimize_table_order::advance_sj_state()).</dd></dl>
</li>
<li>The suffix of outer correlated and non-correlated tables.</li>
</ol>
<dl class="section user"><dt>MaterializeLookup strategy</dt><dd></dd></dl>
<div class="fragment"><div class="line">(ot|nt)*  [ it (it)* ]  (nt)*</div><div class="line">+------+  +==========+  +---+</div><div class="line">   (1)         (2)        (3)</div></div><!-- fragment --><ol type="1">
<li>Prefix of outer correlated and non-correlated tables.</li>
<li>The handled range, which may contain only inner tables. The inner tables are materialized in a temporary table that is later used as a lookup structure for the outer correlated tables.</li>
<li>The suffix of outer non-correlated tables.</li>
</ol>
<dl class="section user"><dt>MaterializeScan strategy</dt><dd></dd></dl>
<div class="fragment"><div class="line">(ot|nt)*  [ it (it)* ]  (ot|nt)*</div><div class="line">+------+  +==========+  +-----+</div><div class="line">   (1)         (2)         (3)</div></div><!-- fragment --><ol type="1">
<li>Prefix of outer correlated and non-correlated tables.</li>
<li>The handled range, which may contain only inner tables. The inner tables are materialized in a temporary table which is later used to setup a scan.</li>
<li>The suffix of outer correlated and non-correlated tables.</li>
</ol>
<p>Note that MaterializeLookup and MaterializeScan has overlap in their patterns. It may be possible to consolidate the materialization strategies into one.</p>
<p>The choice between the strategies is made by the join optimizer (see advance_sj_state() and fix_semijoin_strategies()). This function sets up all fields/structures/etc needed for execution except for setup/initialization of semi-join materialization which is done in setup_materialized_table(). </p>

</div>
</div>
<a id="gaa35fc9fd6c8f8961fb6b03d1efc74f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa35fc9fd6c8f8961fb6b03d1efc74f10">&#9670;&nbsp;</a></span>setup_semijoin_materialized_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::setup_semijoin_materialized_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>tableno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>inner_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>sjm_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the materialized table for a semi-join nest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>join_tab for the materialized semi-join table </td></tr>
    <tr><td class="paramname">tableno</td><td>table number of materialized table </td></tr>
    <tr><td class="paramname">inner_pos</td><td>information about the first inner table of the subquery </td></tr>
    <tr><td class="paramname">sjm_pos</td><td>information about the materialized semi-join table, to be filled with data.</td></tr>
  </table>
  </dd>
</dl>
<p>Setup execution structures for one semi-join materialization nest:</p><ul>
<li>Create the materialization temporary table, including TABLE_LIST object.</li>
<li>Create a list of Item_field objects per column in the temporary table.</li>
<li>Create a keyuse array describing index lookups into the table (for MaterializeLookup)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>False if OK, True if error </dd></dl>

</div>
</div>
<a id="gadbc980a72c17c8442fab87af085697d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc980a72c17c8442fab87af085697d4">&#9670;&nbsp;</a></span>simple_remove_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a>* simple_remove_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter out ORDER items those are equal to constants in WHERE. </p>
<p>This function is a limited version of remove_const() for use with non-JOIN statements (i.e. single-table UPDATE and DELETE).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Linked list of ORDER BY arguments. </td></tr>
    <tr><td class="paramname">where</td><td>Where condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new filtered ORDER list or NULL if whole list eliminated</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function overwrites input order list. </dd></dl>

</div>
</div>
<a id="ga683fa9f64c971af8a34e9711877a82ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga683fa9f64c971af8a34e9711877a82ee">&#9670;&nbsp;</a></span>sj_table_is_included()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sj_table_is_included </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac2c4cb376fec34447cf5df2b3d4c238a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c4cb376fec34447cf5df2b3d4c238a">&#9670;&nbsp;</a></span>sjm_query_block_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> QEP_TAB::sjm_query_block_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>query block id for an inner table of materialized semi-join, and 0 for all other tables. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>implementation is not efficient (loops over all tables) - use this function only in EXPLAIN. </dd></dl>

</div>
</div>
<a id="ga969165446a2bd1152d11e32c5a2e8d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga969165446a2bd1152d11e32c5a2e8d68">&#9670;&nbsp;</a></span>substitute_for_best_equal_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* substitute_for_best_equal_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> **&#160;</td>
          <td class="paramname"><em>table_join_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute every field reference in a condition by the best equal field and eliminate all multiple equality predicates. </p>
<p>The function retrieves the cond condition and for each encountered multiple equality predicate it sorts the field references in it according to the order of tables specified by the table_join_idx parameter. Then it eliminates the multiple equality predicate by replacing it with the conjunction of simple equality predicates equating every field from the multiple equality to the first field in it, or to the constant, if there is any. After this, the function retrieves all other conjuncted predicates and substitutes every field reference by the field reference to the first equal field or equal constant if there are any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the session context </td></tr>
    <tr><td class="paramname">cond</td><td>condition to process </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to take into consideration </td></tr>
    <tr><td class="paramname">table_join_idx</td><td>index to tables determining field preference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>At the first glance, a full sort of fields in multiple equality seems to be an overkill. Yet it's not the case due to possible new fields in multiple equality item of lower levels. We want the order in them to comply with the order of upper levels.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed condition, or NULL in case of error </dd></dl>

</div>
</div>
<a id="gaa95a062cdd785687a638e01d7ad85d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95a062cdd785687a638e01d7ad85d11">&#9670;&nbsp;</a></span>substitute_gc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> substitute_gc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>where_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute all expressions in the WHERE condition and ORDER/GROUP lists that match generated columns (GC) expressions with GC fields, if any. </p>
<p>This function does 3 things: 1) Creates list of all GC fields that are a part of a key and the GC expression is a function. All query tables are scanned. If there's no such fields, function exits. 2) By means of Item::compile() WHERE clause is transformed. </p><dl class="section see"><dt>See also</dt><dd>Item_func::gc_subst_transformer() for details. 3) If there's ORDER/GROUP BY clauses, this function tries to substitute expressions in these lists with GC too. It removes from the list of indexed GC all elements which index blocked by hints. This is done to reduce amount of further work. Next it goes through ORDER/GROUP BY list and matches the expression in it against GC expressions in indexed GC list. When a match is found, the expression is replaced with a new Item_field for the matched GC field. Also, this new field is added to the hidden part of all_fields list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">select_lex</td><td>the current select </td></tr>
    <tr><td class="paramname">where_cond</td><td>the WHERE condition, possibly NULL </td></tr>
    <tr><td class="paramname">group_list</td><td>the GROUP BY clause, possibly NULL </td></tr>
    <tr><td class="paramname">order</td><td>the ORDER BY clause, possibly NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the GROUP BY clause or the ORDER BY clause was changed, false otherwise </dd></dl>

</div>
</div>
<a id="ga110ac08d482c9821d4db6708b1a88bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga110ac08d482c9821d4db6708b1a88bf2">&#9670;&nbsp;</a></span>test_if_cheaper_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> test_if_cheaper_ordering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a>&#160;</td>
          <td class="paramname"><em>usable_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>new_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>new_key_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>new_select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>new_used_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>saved_best_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a cheaper access key than a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>NULL or JOIN_TAB of the accessed table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table if tab == NULL or tab-&gt;table() </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">usable_keys</td><td>Key map to find a cheaper key in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref_key</td><td>0 &lt;= key &lt; MAX_KEY - key number (hint) to start the search -1 - no key number provided </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_limit</td><td>LIMIT value, or HA_POS_ERROR if no limit </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_key</td><td>Key number if success, otherwise undefined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_key_direction</td><td>Return -1 (reverse) or +1 if success, otherwise undefined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_select_limit</td><td>Return adjusted LIMIT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_used_key_parts</td><td>NULL by default, otherwise return number of new_key prefix columns if success or undefined if the function fails </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saved_best_key_parts</td><td>NULL by default, otherwise preserve the value for further use in QUICK_SELECT_DESC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes into account table-&gt;quick_condition_rows statistic (that is calculated by JOIN::make_join_plan()). However, single table procedures such as mysql_update() and mysql_delete() never call JOIN::make_join_plan(), so they have to update it manually (</dd></dl>
<dl class="section see"><dt>See also</dt><dd>get_index_for_order()). This function resets bits in TABLE::quick_keys for indexes with mixed ASC/DESC keyparts as range scan doesn't support range reordering required for them. </dd></dl>

</div>
</div>
<a id="ga723b75a22f5be037a5769a6e39d4ee5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723b75a22f5be037a5769a6e39d4ee5b">&#9670;&nbsp;</a></span>test_if_equality_guarantees_uniqueness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> test_if_equality_guarantees_uniqueness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gae62e67db4efd171d1f741f1a41e0c82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae62e67db4efd171d1f741f1a41e0c82f">&#9670;&nbsp;</a></span>test_if_ft_index_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem__func__match.html">Item_func_match</a> * test_if_ft_index_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if ORDER BY is a single MATCH function(ORDER BY MATCH) and sort order is descending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>pointer to ORDER struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Pointer</td><td>to MATCH function if order is 'ORDER BY MATCH() DESC' </td></tr>
    <tr><td class="paramname">NULL</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54996e06c3934bd6ee3082e0b9c67e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54996e06c3934bd6ee3082e0b9c67e49">&#9670;&nbsp;</a></span>test_if_order_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_if_order_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>order_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>used_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>skip_quick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if one can use the key to resolve ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">order_src</td><td>Sort order </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>Index to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">used_key_parts</td><td>NULL by default, otherwise return value for used key parts. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">skip_quick</td><td>Whether found index can be used for backward range scans</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>used_key_parts is set to correct key parts used if return value != 0 (On other cases, used_key_part may be changed) Note that the value may actually be greater than the number of index key parts. This can happen for storage engines that have the primary key parts as a suffix for every secondary key.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>key is ok. </td></tr>
    <tr><td class="paramname">0</td><td>Key can't be used </td></tr>
    <tr><td class="paramname">-1</td><td>Reverse key can be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16f6a1f0bfeb420f0093002d4814c782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f6a1f0bfeb420f0093002d4814c782">&#9670;&nbsp;</a></span>test_if_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> test_if_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>left_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>right_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify redundant predicates. </p>
<p>Test if the equality predicate 'left_item = right_item' is redundant due to a REF-access already being set up on the table, where 'left_item' is part of the REF-key being used, and 'right_item' is equal to the key value specified for that field in the key. In such cases the predicate is known to be 'true' for any rows retrieved from that table. Thus it is redundant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_item</td><td>The Item_field possibly being part of A ref-KEY. </td></tr>
    <tr><td class="paramname">right_item</td><td>The equality value specified for 'left_item'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the predicate is redundant.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See comments in reduce_cond_for_table() about careful usage/modifications of test_if_ref(). </dd></dl>

</div>
</div>
<a id="gaeb3a8607d8a43fc5206c1449f09c470e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb3a8607d8a43fc5206c1449f09c470e">&#9670;&nbsp;</a></span>test_if_skip_sort_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> test_if_skip_sort_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classORDER__with__src.html">ORDER_with_src</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>no_changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>order_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if we can skip ordering by using an index. </p>
<p>If the current plan is to use an index that provides ordering, the plan will not be changed. Otherwise, if an index can be used, the JOIN_TAB / tab-&gt;select struct is changed to use the index.</p>
<p>The index must cover all fields in &lt;order&gt;, or it will not be considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>NULL or JOIN_TAB of the accessed table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_limit</td><td>LIMIT value, or HA_POS_ERROR if no limit </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">no_changes</td><td>No changes will be made to the query plan. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">map</td><td>Key_map of applicable indexes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">order_idx</td><td>Number of index selected, -1 if no applicable index found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function may change tmp_table_param.precomputed_group_by. This affects how create_tmp_table() treats aggregation functions, so count_field_types() must be called again to make sure this is taken into consideration.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>We have to use filesort to do the sorting </td></tr>
    <tr><td class="paramname">1</td><td>We can use an index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4c554fe46402549598f7d273ebb77bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c554fe46402549598f7d273ebb77bf">&#9670;&nbsp;</a></span>test_if_subkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> test_if_subkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classORDER__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>ref_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a> *&#160;</td>
          <td class="paramname"><em>usable_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if we can use one of the 'usable_keys' instead of 'ref' key for sorting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>The query block's order clause. </td></tr>
    <tr><td class="paramname">tab</td><td>Current JOIN_TAB. </td></tr>
    <tr><td class="paramname">ref</td><td>Number of key, used for WHERE clause </td></tr>
    <tr><td class="paramname">ref_key_parts</td><td>Index columns used for ref lookup. </td></tr>
    <tr><td class="paramname">usable_keys</td><td>Keys for testing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>MAX_KEY If we can't use other key</li>
<li>the number of found key Otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4d5a2e1822e2131fcfbe6501a8a97525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5a2e1822e2131fcfbe6501a8a97525">&#9670;&nbsp;</a></span>test_if_subpart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> test_if_subpart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 1 if second is a subpart of first argument. </p>
<p>If first parts has different direction, change it to second part (group is sorted like order) </p>

</div>
</div>
<a id="ga70e68fb1d5e464b534b0aa16efefb8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e68fb1d5e464b534b0aa16efefb8a0">&#9670;&nbsp;</a></span>test_skip_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::test_skip_sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an index could be used to replace filesort for ORDER BY/GROUP BY. </p>
<p>Investigate whether we may use an ordered index as part of either DISTINCT, GROUP BY or ORDER BY execution. An ordered index may be used for only the first of any of these terms to be executed. This is reflected in the order which we check for test_if_skip_sort_order() below. However we do not check for DISTINCT here, as it would have been transformed to a GROUP BY at this stage if it is a candidate for ordered index optimization. If a decision was made to use an ordered index, the availability if such an access path is stored in 'm_ordered_index_usage' for later use by 'execute' or 'explain' </p>

</div>
</div>
<a id="ga78a5dae85600d51fdc79def4ad5ff867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78a5dae85600d51fdc79def4ad5ff867">&#9670;&nbsp;</a></span>trace_indexes_added_group_distinct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trace_indexes_added_group_distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mysqld_8h.html#a272e3049a624991c7f3aa54091a7b201">Key_map</a>&#160;</td>
          <td class="paramname"><em>new_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print keys that were appended to join_tab-&gt;const_keys because they can be used for GROUP BY or DISTINCT to the optimizer trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>The optimizer trace context we're adding info to </td></tr>
    <tr><td class="paramname">join_tab</td><td>The table the indexes cover </td></tr>
    <tr><td class="paramname">new_keys</td><td>The keys that are considered useful because they can be used for GROUP BY or DISTINCT </td></tr>
    <tr><td class="paramname">cause</td><td>Zero-terminated string with reason for adding indexes to const_keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>add_group_and_distinct_keys() </dd></dl>

</div>
</div>
<a id="ga1c540754bd726695a5a7e36952136f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c540754bd726695a5a7e36952136f3d">&#9670;&nbsp;</a></span>trace_table_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trace_table_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>table_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to the optimizer trace information about dependencies between tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>optimizer trace </td></tr>
    <tr><td class="paramname">join_tabs</td><td>all JOIN_TABs of the join </td></tr>
    <tr><td class="paramname">table_count</td><td>how many JOIN_TABs in the 'join_tabs' array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaedc53770d0c83ac40c0a13e832af2612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc53770d0c83ac40c0a13e832af2612">&#9670;&nbsp;</a></span>type_conversion_status_to_store_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classstore__key.html#aaf0d1c720a5e918b4148b9aa5faa8ab5">store_key::store_key_result</a> type_conversion_status_to_store_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql_2field_8h.html#a3c413a12689e3e6ec053b6d7bc9ef160">type_conversion_status</a>&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga410e1c85b186cd5520a7d21930ead6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410e1c85b186cd5520a7d21930ead6e5">&#9670;&nbsp;</a></span>types_allow_materialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> types_allow_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two items are compatible wrt. </p>
<p>materialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td>Expression from outer query </td></tr>
    <tr><td class="paramname">inner</td><td>Expression from inner query</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If subquery types allow materialization. </td></tr>
    <tr><td class="paramname">false</td><td>Otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the purpose is similar to that of comparable_in_index(). </dd></dl>

</div>
</div>
<a id="ga2b3155cda5c5a0005811dc6d4d424fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b3155cda5c5a0005811dc6d4d424fa5">&#9670;&nbsp;</a></span>unplug_join_tabs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::unplug_join_tabs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gafb89e9019215d5e8a281afe0573a62b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb89e9019215d5e8a281afe0573a62b4">&#9670;&nbsp;</a></span>update_depend_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::update_depend_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the dependency map for the tables. </p>

</div>
</div>
<a id="ga78adac8cc612e1c973ce448594c5523e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78adac8cc612e1c973ce448594c5523e">&#9670;&nbsp;</a></span>update_depend_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::update_depend_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the dependency map for the sort order. </p>

</div>
</div>
<a id="gaeaa6edcfa6c4d934dd42d505d9de2fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa6edcfa6c4d934dd42d505d9de2fef">&#9670;&nbsp;</a></span>update_equalities_for_sjm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::update_equalities_for_sjm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update equalities and keyuse references after semi-join materialization strategy is chosen. </p>
<p>For each multiple equality that contains a field that is selected from a subquery, and that subquery is executed using a semi-join materialization strategy, add the corresponding column in the materialized temporary table to the equality. For each injected semi-join equality that is not converted to multiple equality, replace the reference to the expression selected from the subquery with the corresponding column in the temporary table.</p>
<p>This is needed to properly reflect the equalities that involve injected semi-join equalities when materialization strategy is chosen. </p><dl class="section see"><dt>See also</dt><dd>eliminate_item_equal() for how these equalities are used to generate correct equality predicates.</dd></dl>
<p>The MaterializeScan semi-join strategy requires some additional processing: All primary tables after the materialized temporary table must be inspected for keyuse objects that point to expressions from the subquery tables. These references must be replaced with references to corresponding columns in the materialized temporary table instead. Those primary tables using ref access will thus be made to depend on the materialized temporary table instead of the subquery tables.</p>
<p>Only the injected semi-join equalities need this treatment, other predicates will be handled correctly by the regular item substitution process.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, true if error </dd></dl>

</div>
</div>
<a id="gae84f052660af684b9f827e801c3daaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae84f052660af684b9f827e801c3daaf3">&#9670;&nbsp;</a></span>update_ref_and_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> update_ref_and_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__optimizer_8h.html#a1c9b0661f4bc37c76c806ebd03728330">Key_use_array</a> *&#160;</td>
          <td class="paramname"><em>keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>normal_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update keyuse array with all possible keys we can use to fetch rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>session context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keyuse</td><td>Put here ordered array of Key_use structures </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_tab</td><td>Array in table number order </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tables</td><td>Number of tables in join </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>WHERE condition (note that the function analyzes join_tab[i]-&gt;join_cond() too) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">normal_tables</td><td>Tables not inner w.r.t some outer join (ones for which we can make ref access based the WHERE clause) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_lex</td><td>current SELECT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sargables</td><td>Array of found sargable candidates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga185f5a9bf8b8825fa0ed29b1a3aacd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185f5a9bf8b8825fa0ed29b1a3aacd45">&#9670;&nbsp;</a></span>update_sargable_from_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::update_sargable_from_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSARGABLE__PARAM.html">SARGABLE_PARAM</a> *&#160;</td>
          <td class="paramname"><em>sargables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update info on indexes that can be used for search lookups as reading const tables may has added new sargable predicates. </p>

</div>
</div>
<a id="ga652bf7109dfbe0fdd7deb75c05c0a7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652bf7109dfbe0fdd7deb75c05c0a7a3">&#9670;&nbsp;</a></span>uses_index_fields_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> uses_index_fields_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>tbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>other_tbls_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if given expression only uses fields covered by index <em>keyno</em> in the table tbl. </p>
<p>The expression can use any fields in any other tables.</p>
<p>The expression is guaranteed not to be AND or OR - those constructs are handled outside of this function.</p>
<p>Restrict some function types from being pushed down to storage engine: a) Don't push down the triggered conditions. Nested outer joins execution code may need to evaluate a condition several times (both triggered and untriggered). TODO: Consider cloning the triggered condition and using the copies for:</p><ol type="1">
<li>push the first copy down, to have most restrictive index condition possible.</li>
<li>Put the second copy into tab-&gt;m_condition. b) Stored functions contain a statement that might start new operations (like DML statements) from within the storage engine. This does not work against all SEs. c) Subqueries might contain nested subqueries and involve more tables. TODO: ROY: CHECK THIS d) Do not push down internal functions of type DD_INTERNAL_FUNC. When ICP is enabled, pushing internal functions to storage engine for evaluation will open data-dictionary tables. In InnoDB storage engine this will result in situation like recursive latching of same page by the same thread. To avoid such situation, internal functions of type DD_INTERNAL_FUNC are not pushed to storage engine for evaluation.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Expression to check </td></tr>
    <tr><td class="paramname">tbl</td><td>The table having the index </td></tr>
    <tr><td class="paramname">keyno</td><td>The index number </td></tr>
    <tr><td class="paramname">other_tbls_ok</td><td>true &lt;=&gt; Fields of other non-const tables are allowed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if No, true if Yes </dd></dl>

</div>
</div>
<a id="ga523dd2f072c461823acd18472bd06193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523dd2f072c461823acd18472bd06193">&#9670;&nbsp;</a></span>validate_use_secondary_engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> validate_use_secondary_engine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structLEX.html">LEX</a> *&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates a query that uses the secondary engine. </p>
<p>No validations are done if query has not been prepared against the secondary engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lex</td><td>Parse tree descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if error, false otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad3716313e877e16afe545f6d944558c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3716313e877e16afe545f6d944558c0">&#9670;&nbsp;</a></span>antijoin_null_cond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* antijoin_null_cond = &quot;&lt;ANTIJOIN-<a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>&gt;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
