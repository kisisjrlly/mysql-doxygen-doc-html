<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/buf0buf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('buf0buf_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0buf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The database buffer pool high-level routines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0types_8h_source.html">mtr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0proc_8h_source.html">os0proc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0types_8h_source.html">page0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0rbt_8h_source.html">ut0rbt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf_8h_source.html">buf/buf.h</a>&quot;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &quot;buf0buf.ic&quot;</code><br />
</div>
<p><a href="buf0buf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines information we will fetch from each buffer pool.  <a href="structbuf__pool__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The occupied bytes of lists in all buffer pools.  <a href="structbuf__pools__list__size__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbuf__page__t.html">buf_page_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html">buf_block_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer control block structure.  <a href="structbuf__block__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHazardPointer.html">HazardPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "Hazard Pointer" class used to iterate over page lists inside the buffer pool.  <a href="classHazardPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlushHp.html">FlushHp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing buf_pool-&gt;flush_list hazard pointer.  <a href="classFlushHp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLRUHp.html">LRUHp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing buf_pool-&gt;LRU hazard pointer.  <a href="classLRUHp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLRUItr.html">LRUItr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special purpose iterators to be used when scanning the LRU list.  <a href="classLRUItr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__buddy__free__t.html">buf_buddy_free_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that is embedded in the free zip blocks.  <a href="structbuf__buddy__free__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer pool statistics structure.  <a href="structbuf__pool__stat__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__buddy__stat__t.html">buf_buddy_stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics of buddy blocks of a given size.  <a href="structbuf__buddy__stat__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer pool structure.  <a href="structbuf__pool__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheckInLRUList.html">CheckInLRUList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to validate the LRU list.  <a href="structCheckInLRUList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheckInFreeList.html">CheckInFreeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to validate the LRU list.  <a href="structCheckInFreeList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheckUnzipLRUAndLRUList.html">CheckUnzipLRUAndLRUList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a43a4f552119eafa1c0c2b71404c50ebe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a43a4f552119eafa1c0c2b71404c50ebe">BUF_POOL_WATCH_SIZE</a>&#160;&#160;&#160;(<a class="el" href="srv0srv_8cc.html#ad28cf2cf2828cfd8ac09b3c3dc109dd7">srv_n_purge_threads</a> + 1)</td></tr>
<tr class="memdesc:a43a4f552119eafa1c0c2b71404c50ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of concurrent buffer pool watches.  <a href="#a43a4f552119eafa1c0c2b71404c50ebe">More...</a><br /></td></tr>
<tr class="separator:a43a4f552119eafa1c0c2b71404c50ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94d525f40c93ef4c9e8151cc531adf1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac94d525f40c93ef4c9e8151cc531adf1">buf_page_get</a>(ID,  SIZE,  LA,  MTR)</td></tr>
<tr class="memdesc:ac94d525f40c93ef4c9e8151cc531adf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE! The following macros should be used instead of buf_page_get_gen, to improve debugging.  <a href="#ac94d525f40c93ef4c9e8151cc531adf1">More...</a><br /></td></tr>
<tr class="separator:ac94d525f40c93ef4c9e8151cc531adf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3563a2479f143e7c74c5ce14d14694"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8a3563a2479f143e7c74c5ce14d14694">buf_page_get_with_no_latch</a>(ID,  SIZE,  MTR)</td></tr>
<tr class="memdesc:a8a3563a2479f143e7c74c5ce14d14694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use these macros to bufferfix a page with no latching.  <a href="#a8a3563a2479f143e7c74c5ce14d14694">More...</a><br /></td></tr>
<tr class="separator:a8a3563a2479f143e7c74c5ce14d14694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825012ee2e6d2e64a0337bbc39228c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2825012ee2e6d2e64a0337bbc39228c4">buf_page_try_get</a>(page_id,  mtr)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#aba2805ff54abe4adb4a918c41a2f9ed0">buf_page_try_get_func</a>((page_id), __FILE__, __LINE__, mtr);</td></tr>
<tr class="memdesc:a2825012ee2e6d2e64a0337bbc39228c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tablespace id and page number tries to get that page.  <a href="#a2825012ee2e6d2e64a0337bbc39228c4">More...</a><br /></td></tr>
<tr class="separator:a2825012ee2e6d2e64a0337bbc39228c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992c7712a4353abf34bfafbe3a6431a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab992c7712a4353abf34bfafbe3a6431a">buf_block_buf_fix_inc</a>(b,  f,  l)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#aac193f180fc2dea1a6daf0a133e4977b">buf_block_buf_fix_inc_func</a>(f, l, b)</td></tr>
<tr class="memdesc:ab992c7712a4353abf34bfafbe3a6431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the bufferfix count.  <a href="#ab992c7712a4353abf34bfafbe3a6431a">More...</a><br /></td></tr>
<tr class="separator:ab992c7712a4353abf34bfafbe3a6431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b0bcde049a4c30e62ec696daa55dff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a78b0bcde049a4c30e62ec696daa55dff">buf_block_get_page_zip</a>(block)&#160;&#160;&#160;((block)-&gt;page.zip.data ? &amp;(block)-&gt;page.zip : <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr class="memdesc:a78b0bcde049a4c30e62ec696daa55dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the compressed page descriptor corresponding to an uncompressed page if applicable.  <a href="#a78b0bcde049a4c30e62ec696daa55dff">More...</a><br /></td></tr>
<tr class="separator:a78b0bcde049a4c30e62ec696daa55dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5f5e8e4d9cb004c7ea5fb3c4096934"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6a5f5e8e4d9cb004c7ea5fb3c4096934">buf_page_hash_get_s_locked</a>(b,  page_id,  l)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ab26100fa91e9f7db18e6390e10bffe94">RW_LOCK_S</a>)</td></tr>
<tr class="separator:a6a5f5e8e4d9cb004c7ea5fb3c4096934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7388557a086d8346ccafd08e0d234e84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7388557a086d8346ccafd08e0d234e84">buf_page_hash_get_x_locked</a>(b,  page_id,  l)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ad654c262f7dadd19609ea9e23cc02be4">RW_LOCK_X</a>)</td></tr>
<tr class="separator:a7388557a086d8346ccafd08e0d234e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d78b2ce6dac6dac0bfa5b49790b422"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad2d78b2ce6dac6dac0bfa5b49790b422">buf_page_hash_get</a>(b,  page_id)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0)</td></tr>
<tr class="separator:ad2d78b2ce6dac6dac0bfa5b49790b422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c2ac1c4618377fa1432ea64caebaef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a17c2ac1c4618377fa1432ea64caebaef">buf_page_get_also_watch</a>(b,  page_id)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="separator:a17c2ac1c4618377fa1432ea64caebaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1caf98837a48b5cc8cc0164946a11a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aec1caf98837a48b5cc8cc0164946a11a">buf_block_hash_get_s_locked</a>(b,  page_id,  l)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ab806a1ce0a4b83b733b9b97da5691f47">buf_block_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ab26100fa91e9f7db18e6390e10bffe94">RW_LOCK_S</a>)</td></tr>
<tr class="separator:aec1caf98837a48b5cc8cc0164946a11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ecf00408baca2e715a13185b57643b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad2ecf00408baca2e715a13185b57643b">buf_block_hash_get_x_locked</a>(b,  page_id,  l)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ab806a1ce0a4b83b733b9b97da5691f47">buf_block_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ad654c262f7dadd19609ea9e23cc02be4">RW_LOCK_X</a>)</td></tr>
<tr class="separator:ad2ecf00408baca2e715a13185b57643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3e94974cac1500f78a3cb08e68ab2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a02c3e94974cac1500f78a3cb08e68ab2">buf_block_hash_get</a>(b,  page_id)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ab806a1ce0a4b83b733b9b97da5691f47">buf_block_hash_get_locked</a>(b, page_id, <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0)</td></tr>
<tr class="separator:a02c3e94974cac1500f78a3cb08e68ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8164aaa09f898842fd978f6fd4797cfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8164aaa09f898842fd978f6fd4797cfc">BUF_PAGE_STATE_BITS</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a8164aaa09f898842fd978f6fd4797cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The common buffer control block structure for compressed and uncompressed frames.  <a href="#a8164aaa09f898842fd978f6fd4797cfc">More...</a><br /></td></tr>
<tr class="separator:a8164aaa09f898842fd978f6fd4797cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20f5c2f2899db5e3414580b07b50ed9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa20f5c2f2899db5e3414580b07b50ed9">buf_block_state_valid</a>(block)</td></tr>
<tr class="memdesc:aa20f5c2f2899db5e3414580b07b50ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a buf_block_t object is in a valid state.  <a href="#aa20f5c2f2899db5e3414580b07b50ed9">More...</a><br /></td></tr>
<tr class="separator:aa20f5c2f2899db5e3414580b07b50ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hash search fields</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These 5 fields may only be modified when: we are holding the appropriate x-latch in btr_search_latches[], and one of the following holds: (1) the block state is BUF_BLOCK_FILE_PAGE, and we are holding an s-latch or x-latch on buf_block_t::lock, or (2) buf_block_t::buf_fix_count == 0, or (3) the block state is BUF_BLOCK_REMOVE_HASH.</p>
<p>An exception to this is when we init or create a page in the buffer pool in buf0buf.cc.</p>
<p>Another exception for buf_pool_clear_hash_index() is that assigning block-&gt;index = NULL (and block-&gt;n_pointers = 0) is allowed whenever btr_search_own_all(RW_LOCK_X).</p>
<p>Another exception is that ha_insert_for_fold_func() may decrement n_pointers without holding the appropriate latch in btr_search_latches[]. Thus, n_pointers must be protected by atomic memory access.</p>
<p>This implies that the fields may be read without race condition whenever any of the following hold:</p><ul>
<li>the btr_search_latches[] s-latch or x-latch is being held, or</li>
<li>the block state is not BUF_BLOCK_FILE_PAGE or BUF_BLOCK_REMOVE_HASH, and holding some latch prevents the state from changing to that.</li>
</ul>
<p>Some use of assert_block_ahi_empty() or assert_block_ahi_valid() is prone to race conditions while buf_pool_clear_hash_index() is executing (the adaptive hash index is being disabled). Such use is explicitly commented. </p>
</div></td></tr>
<tr class="memitem:affa9940137a5129ae26401fec94405b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#affa9940137a5129ae26401fec94405b8">assert_block_ahi_empty</a>(block)&#160;&#160;&#160;<a class="el" href="ut0dbg_8h.html#ae7aed983dfe98ac872b5a9915fa778fa">ut_a</a>(<a class="el" href="os0atomic_8h.html#a54807a35ae74ff6aad36d34003ea6cd6">os_atomic_increment_ulint</a>(&amp;(block)-&gt;n_pointers, 0) == 0)</td></tr>
<tr class="separator:affa9940137a5129ae26401fec94405b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b955ddf5d5d81f383aa5224bfa0fc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a53b955ddf5d5d81f383aa5224bfa0fc8">assert_block_ahi_empty_on_init</a>(block)</td></tr>
<tr class="separator:a53b955ddf5d5d81f383aa5224bfa0fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29568fcc4b71168849c777ddf66af1f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a29568fcc4b71168849c777ddf66af1f1">assert_block_ahi_valid</a>(block)</td></tr>
<tr class="separator:a29568fcc4b71168849c777ddf66af1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acf241fbcf516b9cd38017fbf9a7d211b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acf241fbcf516b9cd38017fbf9a7d211b">BUF_POOL_ZIP_FOLD_PTR</a>(ptr)&#160;&#160;&#160;((ulint)(ptr) / UNIV_PAGE_SIZE)</td></tr>
<tr class="memdesc:acf241fbcf516b9cd38017fbf9a7d211b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the hash fold value for blocks in buf_pool-&gt;zip_hash.  <a href="#acf241fbcf516b9cd38017fbf9a7d211b">More...</a><br /></td></tr>
<tr class="separator:acf241fbcf516b9cd38017fbf9a7d211b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c028eac069f92725d6fef2d502c33bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9c028eac069f92725d6fef2d502c33bb">BUF_POOL_ZIP_FOLD</a>(b)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#acf241fbcf516b9cd38017fbf9a7d211b">BUF_POOL_ZIP_FOLD_PTR</a>((b)-&gt;frame)</td></tr>
<tr class="separator:a9c028eac069f92725d6fef2d502c33bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca27db7bba7c227b5a7b2f02ee5a8f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7ca27db7bba7c227b5a7b2f02ee5a8f0">BUF_POOL_ZIP_FOLD_BPAGE</a>(b)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a9c028eac069f92725d6fef2d502c33bb">BUF_POOL_ZIP_FOLD</a>((<a class="el" href="structbuf__block__t.html">buf_block_t</a> *)(b))</td></tr>
<tr class="separator:a7ca27db7bba7c227b5a7b2f02ee5a8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors for buffer pool mutexes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Use these instead of accessing buffer pool mutexes directly.</p>
</div></td></tr>
<tr class="memitem:a7134f85ae33367e8860b6814c0866ff5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7134f85ae33367e8860b6814c0866ff5">buf_flush_list_mutex_own</a>(b)&#160;&#160;&#160;<a class="el" href="ut0mutex_8h.html#a7eccf8a96f24ab7f4012bb203640cf17">mutex_own</a>(&amp;(b)-&gt;flush_list_mutex)</td></tr>
<tr class="memdesc:a7134f85ae33367e8860b6814c0866ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if flush list mutex is owned.  <a href="#a7134f85ae33367e8860b6814c0866ff5">More...</a><br /></td></tr>
<tr class="separator:a7134f85ae33367e8860b6814c0866ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095adbc797576159cfc092fb6bdedeb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a095adbc797576159cfc092fb6bdedeb2">buf_flush_list_mutex_enter</a>(b)</td></tr>
<tr class="memdesc:a095adbc797576159cfc092fb6bdedeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the flush list mutex.  <a href="#a095adbc797576159cfc092fb6bdedeb2">More...</a><br /></td></tr>
<tr class="separator:a095adbc797576159cfc092fb6bdedeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefd70716bf3351e09b6e52ea9ca6783"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aaefd70716bf3351e09b6e52ea9ca6783">buf_flush_list_mutex_exit</a>(b)</td></tr>
<tr class="memdesc:aaefd70716bf3351e09b6e52ea9ca6783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the flush list mutex.  <a href="#aaefd70716bf3351e09b6e52ea9ca6783">More...</a><br /></td></tr>
<tr class="separator:aaefd70716bf3351e09b6e52ea9ca6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aea2e675f73b98f3b0bd94736801400"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9aea2e675f73b98f3b0bd94736801400">buf_page_mutex_own</a>(b)&#160;&#160;&#160;(b)-&gt;mutex.is_owned()</td></tr>
<tr class="memdesc:a9aea2e675f73b98f3b0bd94736801400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if block-&gt;mutex is owned.  <a href="#a9aea2e675f73b98f3b0bd94736801400">More...</a><br /></td></tr>
<tr class="separator:a9aea2e675f73b98f3b0bd94736801400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b68e3f5394838fecf6b6b30ab96002"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a21b68e3f5394838fecf6b6b30ab96002">buf_page_mutex_enter</a>(b)</td></tr>
<tr class="memdesc:a21b68e3f5394838fecf6b6b30ab96002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the block-&gt;mutex.  <a href="#a21b68e3f5394838fecf6b6b30ab96002">More...</a><br /></td></tr>
<tr class="separator:a21b68e3f5394838fecf6b6b30ab96002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4f35eac88b4c16f4c2afab52f4d814"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aff4f35eac88b4c16f4c2afab52f4d814">buf_page_mutex_exit</a>(b)</td></tr>
<tr class="memdesc:aff4f35eac88b4c16f4c2afab52f4d814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the block-&gt;mutex.  <a href="#aff4f35eac88b4c16f4c2afab52f4d814">More...</a><br /></td></tr>
<tr class="separator:aff4f35eac88b4c16f4c2afab52f4d814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc687dbb182eb08cbea2596d9396bbc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adfc687dbb182eb08cbea2596d9396bbc">buf_page_hash_lock_get</a>(buf_pool,  page_id)&#160;&#160;&#160;<a class="el" href="hash0hash_8h.html#ac2c915b43186f53f8c63dfd22bf4562c">hash_get_lock</a>((buf_pool)-&gt;page_hash, (page_id).fold())</td></tr>
<tr class="memdesc:adfc687dbb182eb08cbea2596d9396bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get appropriate page_hash_lock.  <a href="#adfc687dbb182eb08cbea2596d9396bbc">More...</a><br /></td></tr>
<tr class="separator:adfc687dbb182eb08cbea2596d9396bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6d4151775f37fd5f6ef62eacd50a82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a1a6d4151775f37fd5f6ef62eacd50a82">buf_page_hash_lock_s_confirm</a>(hash_lock,  buf_pool,  page_id)&#160;&#160;&#160;<a class="el" href="hash0hash_8h.html#ad7cc516d6a4ded86ccbeb3f022dab7fa">hash_lock_s_confirm</a>(hash_lock, (buf_pool)-&gt;page_hash, (page_id).fold())</td></tr>
<tr class="memdesc:a1a6d4151775f37fd5f6ef62eacd50a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">If not appropriate page_hash_lock, relock until appropriate.  <a href="#a1a6d4151775f37fd5f6ef62eacd50a82">More...</a><br /></td></tr>
<tr class="separator:a1a6d4151775f37fd5f6ef62eacd50a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45032de9143fd6341267a268c615883"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad45032de9143fd6341267a268c615883">buf_page_hash_lock_x_confirm</a>(hash_lock,  buf_pool,  page_id)&#160;&#160;&#160;<a class="el" href="hash0hash_8h.html#a7781c17e02c67cc2254fbcc4ae3763c3">hash_lock_x_confirm</a>(hash_lock, (buf_pool)-&gt;page_hash, (page_id).fold())</td></tr>
<tr class="separator:ad45032de9143fd6341267a268c615883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad18c67b8b4469a4aab76260b0131750"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aad18c67b8b4469a4aab76260b0131750">buf_page_hash_lock_held_s</a>(buf_pool,  bpage)&#160;&#160;&#160;<a class="el" href="sync0rw_8cc.html#a7e7b5b80fccd18515f08dd868ffb1692">rw_lock_own</a>(<a class="el" href="buf0buf_8h.html#adfc687dbb182eb08cbea2596d9396bbc">buf_page_hash_lock_get</a>((buf_pool), (bpage)-&gt;<a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>), <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ab26100fa91e9f7db18e6390e10bffe94">RW_LOCK_S</a>)</td></tr>
<tr class="memdesc:aad18c67b8b4469a4aab76260b0131750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if page_hash lock is held in s-mode.  <a href="#aad18c67b8b4469a4aab76260b0131750">More...</a><br /></td></tr>
<tr class="separator:aad18c67b8b4469a4aab76260b0131750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f3b5c2625e8affaf21f10882e8a396"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a53f3b5c2625e8affaf21f10882e8a396">buf_page_hash_lock_held_x</a>(buf_pool,  bpage)&#160;&#160;&#160;<a class="el" href="sync0rw_8cc.html#a7e7b5b80fccd18515f08dd868ffb1692">rw_lock_own</a>(<a class="el" href="buf0buf_8h.html#adfc687dbb182eb08cbea2596d9396bbc">buf_page_hash_lock_get</a>((buf_pool), (bpage)-&gt;<a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>), <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ad654c262f7dadd19609ea9e23cc02be4">RW_LOCK_X</a>)</td></tr>
<tr class="memdesc:a53f3b5c2625e8affaf21f10882e8a396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if page_hash lock is held in x-mode.  <a href="#a53f3b5c2625e8affaf21f10882e8a396">More...</a><br /></td></tr>
<tr class="separator:a53f3b5c2625e8affaf21f10882e8a396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad955654caf86aaf4a515844c1efc46e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad955654caf86aaf4a515844c1efc46e3">buf_page_hash_lock_held_s_or_x</a>(buf_pool,  bpage)</td></tr>
<tr class="memdesc:ad955654caf86aaf4a515844c1efc46e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if page_hash lock is held in x or s-mode.  <a href="#ad955654caf86aaf4a515844c1efc46e3">More...</a><br /></td></tr>
<tr class="separator:ad955654caf86aaf4a515844c1efc46e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487b81cbd6e10fa77bc6be4975787aee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a487b81cbd6e10fa77bc6be4975787aee">buf_block_hash_lock_held_s</a>(buf_pool,  block)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#aad18c67b8b4469a4aab76260b0131750">buf_page_hash_lock_held_s</a>((buf_pool), &amp;(block)-&gt;<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="separator:a487b81cbd6e10fa77bc6be4975787aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d960d20e005f2e97129dfc594a30ca0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2d960d20e005f2e97129dfc594a30ca0">buf_block_hash_lock_held_x</a>(buf_pool,  block)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a53f3b5c2625e8affaf21f10882e8a396">buf_page_hash_lock_held_x</a>((buf_pool), &amp;(block)-&gt;<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="separator:a2d960d20e005f2e97129dfc594a30ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5ae7c089b73c806b1a2f99527ef8f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adb5ae7c089b73c806b1a2f99527ef8f9">buf_block_hash_lock_held_s_or_x</a>(buf_pool,  block)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ad955654caf86aaf4a515844c1efc46e3">buf_page_hash_lock_held_s_or_x</a>((buf_pool), &amp;(block)-&gt;<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="separator:adb5ae7c089b73c806b1a2f99527ef8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab8edfb8ad98167f82518879ade67dc8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> { <br />
&#160;&#160;<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aaa5d948d8c9ee109afa2f2b05672a3930">BUF_BLOCK_POOL_WATCH</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa21e9fab74d2c9e64609dd53570bdfaec">BUF_BLOCK_ZIP_PAGE</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa9135ba69991c7e4a4943f289de621509">BUF_BLOCK_ZIP_DIRTY</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c">BUF_BLOCK_NOT_USED</a>, 
<br />
&#160;&#160;<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aad5dffb35305e497c0afd120525221d18">BUF_BLOCK_READY_FOR_USE</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aaf26cdfc58e629f98cf27da284f6cf5f9">BUF_BLOCK_FILE_PAGE</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa7278567ff34beb6c693af5267611c4c7">BUF_BLOCK_MEMORY</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87">BUF_BLOCK_REMOVE_HASH</a>
<br />
 }<tr class="memdesc:ab8edfb8ad98167f82518879ade67dc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">States of a control block.  <a href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab8edfb8ad98167f82518879ade67dc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6098ccc0d0f4a65b3bdfcb0d430ba46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46">buf_page_print_flags</a> { <a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46a4de99c6b59acbd5c2aa46fd0632cb281">BUF_PAGE_PRINT_NO_CRASH</a> = 1, 
<a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46a476478124a1ec5bbf5faa153d2ff4763">BUF_PAGE_PRINT_NO_FULL</a> = 2
 }</td></tr>
<tr class="separator:aa6098ccc0d0f4a65b3bdfcb0d430ba46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modes for buf_page_get_gen</div></td></tr>
<tr class="memitem:aa4ef74186b9c9937976a7d022cfa12c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a> { <br />
&#160;&#160;<a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a1e23852820b9154316c7c06e2b7ba051">Page_fetch::NORMAL</a>, 
<a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7ae0740abfbc61bc2be0bfa78af61106ae">Page_fetch::SCAN</a>, 
<a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a3a90632a36734db3b6482458ab6197ae">Page_fetch::IF_IN_POOL</a>, 
<a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7aa3d31b8fe6ab7ba91ca6d2f934150826">Page_fetch::PEEK_IF_IN_POOL</a>, 
<br />
&#160;&#160;<a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a04e9d1744b4cb952e0c2021136069e86">Page_fetch::NO_LATCH</a>, 
<a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a7ff1c3a50401e64e0178615f364354eb">Page_fetch::IF_IN_POOL_OR_WATCH</a>, 
<a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7adfb541c10aa7ca324ca213508638d3f1">Page_fetch::POSSIBLY_FREED</a>
<br />
 }</td></tr>
<tr class="separator:aa4ef74186b9c9937976a7d022cfa12c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modes for buf_page_get_known_nowait</div></td></tr>
<tr class="memitem:a0056c362020ff9e840fb48cb94c3cdba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdba">Cache_hint</a> { <a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdbaa81e42709eb1489ed9631277fd401e145">Cache_hint::MAKE_YOUNG</a> = 51, 
<a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdbaaea4620022ddce35b312d7b4b01986f7a">Cache_hint::KEEP_OLD</a> = 52
 }</td></tr>
<tr class="separator:a0056c362020ff9e840fb48cb94c3cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ec7d5de1f91e878e799748d903fb71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a0ec7d5de1f91e878e799748d903fb71b">buf_pool_init</a> (ulint total_size, ulint n_instances)</td></tr>
<tr class="memdesc:a0ec7d5de1f91e878e799748d903fb71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the buffer pool.  <a href="#a0ec7d5de1f91e878e799748d903fb71b">More...</a><br /></td></tr>
<tr class="separator:a0ec7d5de1f91e878e799748d903fb71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3b9b346f49593dc6d435d4a88d6d7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7f3b9b346f49593dc6d435d4a88d6d7f">buf_pool_free_all</a> ()</td></tr>
<tr class="memdesc:a7f3b9b346f49593dc6d435d4a88d6d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the buffer pool at shutdown.  <a href="#a7f3b9b346f49593dc6d435d4a88d6d7f">More...</a><br /></td></tr>
<tr class="separator:a7f3b9b346f49593dc6d435d4a88d6d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca75ba503d2ad232adbff2b0585bc66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9ca75ba503d2ad232adbff2b0585bc66">buf_block_will_withdrawn</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a9ca75ba503d2ad232adbff2b0585bc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a block is intended to be withdrawn.  <a href="#a9ca75ba503d2ad232adbff2b0585bc66">More...</a><br /></td></tr>
<tr class="separator:a9ca75ba503d2ad232adbff2b0585bc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4f29f5614d709fd4fceb970ebd19be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2d4f29f5614d709fd4fceb970ebd19be">buf_frame_will_withdrawn</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr)</td></tr>
<tr class="memdesc:a2d4f29f5614d709fd4fceb970ebd19be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a frame is intended to be withdrawn.  <a href="#a2d4f29f5614d709fd4fceb970ebd19be">More...</a><br /></td></tr>
<tr class="separator:a2d4f29f5614d709fd4fceb970ebd19be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9781b154f5eb92bbc15d0c4538e46124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9781b154f5eb92bbc15d0c4538e46124">buf_resize_thread</a> ()</td></tr>
<tr class="memdesc:a9781b154f5eb92bbc15d0c4538e46124"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the thread for resizing buffer pool.  <a href="#a9781b154f5eb92bbc15d0c4538e46124">More...</a><br /></td></tr>
<tr class="separator:a9781b154f5eb92bbc15d0c4538e46124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee39fa7dde2fd24069257650c8c73e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2ee39fa7dde2fd24069257650c8c73e2">buf_pool_update_madvise</a> ()</td></tr>
<tr class="memdesc:a2ee39fa7dde2fd24069257650c8c73e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if innobase_should_madvise_buf_pool() value has changed since we've last check and if so, then updates buf_pool_should_madvise and calls madvise for all chunks in all srv_buf_pool_instances.  <a href="#a2ee39fa7dde2fd24069257650c8c73e2">More...</a><br /></td></tr>
<tr class="separator:a2ee39fa7dde2fd24069257650c8c73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bed44f93d9f9850ad30d4900164174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a42bed44f93d9f9850ad30d4900164174">buf_pool_clear_hash_index</a> (void)</td></tr>
<tr class="memdesc:a42bed44f93d9f9850ad30d4900164174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adaptive hash index on all pages in the buffer pool.  <a href="#a42bed44f93d9f9850ad30d4900164174">More...</a><br /></td></tr>
<tr class="separator:a42bed44f93d9f9850ad30d4900164174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23372a7fc86173052a9bfe927c9312b4"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a23372a7fc86173052a9bfe927c9312b4">buf_pool_get_curr_size</a> (void)</td></tr>
<tr class="memdesc:a23372a7fc86173052a9bfe927c9312b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current size of buffer buf_pool in bytes.  <a href="#a23372a7fc86173052a9bfe927c9312b4">More...</a><br /></td></tr>
<tr class="separator:a23372a7fc86173052a9bfe927c9312b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff3e4e95015baaa1740ff6098e6e164"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acff3e4e95015baaa1740ff6098e6e164">buf_pool_get_n_pages</a> (void)</td></tr>
<tr class="memdesc:acff3e4e95015baaa1740ff6098e6e164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current size of buffer buf_pool in frames.  <a href="#acff3e4e95015baaa1740ff6098e6e164">More...</a><br /></td></tr>
<tr class="separator:acff3e4e95015baaa1740ff6098e6e164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18483f39367e4be86099560cd0cb938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa18483f39367e4be86099560cd0cb938">buf_pool_get_oldest_modification_approx</a> (void)</td></tr>
<tr class="memdesc:aa18483f39367e4be86099560cd0cb938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smallest oldest_modification lsn among all of the earliest added pages in flush lists.  <a href="#aa18483f39367e4be86099560cd0cb938">More...</a><br /></td></tr>
<tr class="separator:aa18483f39367e4be86099560cd0cb938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274d89180ba0679ad7b31453f3dddbf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a274d89180ba0679ad7b31453f3dddbf6">buf_pool_get_oldest_modification_lwm</a> (void)</td></tr>
<tr class="memdesc:a274d89180ba0679ad7b31453f3dddbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a safe low watermark for oldest_modification.  <a href="#a274d89180ba0679ad7b31453f3dddbf6">More...</a><br /></td></tr>
<tr class="separator:a274d89180ba0679ad7b31453f3dddbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151abcd0889ef3034dda470c29fa1da8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a151abcd0889ef3034dda470c29fa1da8">buf_page_alloc_descriptor</a> (void)</td></tr>
<tr class="memdesc:a151abcd0889ef3034dda470c29fa1da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buf_page_t descriptor.  <a href="#a151abcd0889ef3034dda470c29fa1da8">More...</a><br /></td></tr>
<tr class="separator:a151abcd0889ef3034dda470c29fa1da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ded0d8f7e73903ef9aeb7fe4dd9b611"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5ded0d8f7e73903ef9aeb7fe4dd9b611">buf_page_free_descriptor</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a5ded0d8f7e73903ef9aeb7fe4dd9b611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a buf_page_t descriptor.  <a href="#a5ded0d8f7e73903ef9aeb7fe4dd9b611">More...</a><br /></td></tr>
<tr class="separator:a5ded0d8f7e73903ef9aeb7fe4dd9b611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbea556516137bbb04568f60d7811e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adbbea556516137bbb04568f60d7811e3">buf_block_alloc</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:adbbea556516137bbb04568f60d7811e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer block.  <a href="#adbbea556516137bbb04568f60d7811e3">More...</a><br /></td></tr>
<tr class="separator:adbbea556516137bbb04568f60d7811e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d8810e5f830e55bdf31da6b88972ea"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a58d8810e5f830e55bdf31da6b88972ea">buf_block_free</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a58d8810e5f830e55bdf31da6b88972ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a buffer block which does not contain a file page.  <a href="#a58d8810e5f830e55bdf31da6b88972ea">More...</a><br /></td></tr>
<tr class="separator:a58d8810e5f830e55bdf31da6b88972ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c8e79f9fad932a3f06f1edf84c2147"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a70c8e79f9fad932a3f06f1edf84c2147">buf_frame_copy</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, const <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *frame)</td></tr>
<tr class="memdesc:a70c8e79f9fad932a3f06f1edf84c2147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies contents of a buffer frame to a given buffer.  <a href="#a70c8e79f9fad932a3f06f1edf84c2147">More...</a><br /></td></tr>
<tr class="separator:a70c8e79f9fad932a3f06f1edf84c2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569b18490ab03d0b30a22dfd9f9fdb07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a569b18490ab03d0b30a22dfd9f9fdb07">buf_page_optimistic_get</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, uint64_t modify_clock, <a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a> fetch_mode, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a569b18490ab03d0b30a22dfd9f9fdb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general function used to get optimistic access to a database page.  <a href="#a569b18490ab03d0b30a22dfd9f9fdb07">More...</a><br /></td></tr>
<tr class="separator:a569b18490ab03d0b30a22dfd9f9fdb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c9e8bd857ceefd7ea974ab65c84a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab1c9e8bd857ceefd7ea974ab65c84a85">buf_page_get_known_nowait</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdba">Cache_hint</a> hint, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab1c9e8bd857ceefd7ea974ab65c84a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get access to a known database page, when no waiting can be done.  <a href="#ab1c9e8bd857ceefd7ea974ab65c84a85">More...</a><br /></td></tr>
<tr class="separator:ab1c9e8bd857ceefd7ea974ab65c84a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2805ff54abe4adb4a918c41a2f9ed0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aba2805ff54abe4adb4a918c41a2f9ed0">buf_page_try_get_func</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aba2805ff54abe4adb4a918c41a2f9ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tablespace id and page number tries to get that page.  <a href="#aba2805ff54abe4adb4a918c41a2f9ed0">More...</a><br /></td></tr>
<tr class="separator:aba2805ff54abe4adb4a918c41a2f9ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1b136191a6e34494318af4a7066b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7a1b136191a6e34494318af4a7066b64">buf_page_get_zip</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size)</td></tr>
<tr class="memdesc:a7a1b136191a6e34494318af4a7066b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read access to a compressed page (usually of type FIL_PAGE_TYPE_ZBLOB or FIL_PAGE_TYPE_ZBLOB2).  <a href="#a7a1b136191a6e34494318af4a7066b64">More...</a><br /></td></tr>
<tr class="separator:a7a1b136191a6e34494318af4a7066b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32111f6e94a1745e1750bcbfe96600f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a32111f6e94a1745e1750bcbfe96600f9">buf_page_get_gen</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *guess, <a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a> mode, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dirty_with_no_latch=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a32111f6e94a1745e1750bcbfe96600f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general function used to get access to a database page.  <a href="#a32111f6e94a1745e1750bcbfe96600f9">More...</a><br /></td></tr>
<tr class="separator:a32111f6e94a1745e1750bcbfe96600f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d8481358bda6d6826d9b997ce51c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a86d8481358bda6d6826d9b997ce51c16">buf_page_create</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a> rw_latch, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a86d8481358bda6d6826d9b997ce51c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a page to the buffer buf_pool.  <a href="#a86d8481358bda6d6826d9b997ce51c16">More...</a><br /></td></tr>
<tr class="separator:a86d8481358bda6d6826d9b997ce51c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce5d2fc2911e993640a50d360670592"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6ce5d2fc2911e993640a50d360670592">buf_page_release_zip</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a6ce5d2fc2911e993640a50d360670592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a compressed-only page acquired with buf_page_get_zip().  <a href="#a6ce5d2fc2911e993640a50d360670592">More...</a><br /></td></tr>
<tr class="separator:a6ce5d2fc2911e993640a50d360670592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a045569a1636618f36769cc39e18c60"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5a045569a1636618f36769cc39e18c60">buf_page_release_latch</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint rw_latch)</td></tr>
<tr class="memdesc:a5a045569a1636618f36769cc39e18c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a latch, if specified.  <a href="#a5a045569a1636618f36769cc39e18c60">More...</a><br /></td></tr>
<tr class="separator:a5a045569a1636618f36769cc39e18c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecef5e7084a885aa97d2aedb9a0fe6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3ecef5e7084a885aa97d2aedb9a0fe6e">buf_page_make_young</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a3ecef5e7084a885aa97d2aedb9a0fe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a page to the start of the buffer pool LRU list.  <a href="#a3ecef5e7084a885aa97d2aedb9a0fe6e">More...</a><br /></td></tr>
<tr class="separator:a3ecef5e7084a885aa97d2aedb9a0fe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce975aae00f09fe4f8d97d0b5fd2d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9ce975aae00f09fe4f8d97d0b5fd2d8f">buf_page_make_old</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a9ce975aae00f09fe4f8d97d0b5fd2d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moved a page to the end of the buffer pool LRU list so that it can be flushed out at the earliest.  <a href="#a9ce975aae00f09fe4f8d97d0b5fd2d8f">More...</a><br /></td></tr>
<tr class="separator:a9ce975aae00f09fe4f8d97d0b5fd2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da1bc96b9a28049d874d68d0ae61bc3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7da1bc96b9a28049d874d68d0ae61bc3">buf_page_peek</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a7da1bc96b9a28049d874d68d0ae61bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the page can be found in the buffer pool hash table.  <a href="#a7da1bc96b9a28049d874d68d0ae61bc3">More...</a><br /></td></tr>
<tr class="separator:a7da1bc96b9a28049d874d68d0ae61bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed26a402a24afefb51d6d7945647bd30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aed26a402a24afefb51d6d7945647bd30">buf_page_set_file_page_was_freed</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:aed26a402a24afefb51d6d7945647bd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets file_page_was_freed TRUE if the page is found in the buffer pool.  <a href="#aed26a402a24afefb51d6d7945647bd30">More...</a><br /></td></tr>
<tr class="separator:aed26a402a24afefb51d6d7945647bd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f64c5e7568dbfc7c7a868943f8c3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ae3f64c5e7568dbfc7c7a868943f8c3f7">buf_page_reset_file_page_was_freed</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:ae3f64c5e7568dbfc7c7a868943f8c3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets file_page_was_freed FALSE if the page is found in the buffer pool.  <a href="#ae3f64c5e7568dbfc7c7a868943f8c3f7">More...</a><br /></td></tr>
<tr class="separator:ae3f64c5e7568dbfc7c7a868943f8c3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ddc2d256f3d1821fce3f306ee61e62"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a68ddc2d256f3d1821fce3f306ee61e62">buf_page_get_freed_page_clock</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a68ddc2d256f3d1821fce3f306ee61e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the freed_page_clock of a buffer block.  <a href="#a68ddc2d256f3d1821fce3f306ee61e62">More...</a><br /></td></tr>
<tr class="separator:a68ddc2d256f3d1821fce3f306ee61e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6655833718a3258748ac2298522ca5d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af6655833718a3258748ac2298522ca5d">buf_block_get_freed_page_clock</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:af6655833718a3258748ac2298522ca5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the freed_page_clock of a buffer block.  <a href="#af6655833718a3258748ac2298522ca5d">More...</a><br /></td></tr>
<tr class="separator:af6655833718a3258748ac2298522ca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ffed634c26feb6e975600b553e48c5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a47ffed634c26feb6e975600b553e48c5">buf_page_peek_if_young</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a47ffed634c26feb6e975600b553e48c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells, for heuristics, if a block is still close enough to the MRU end of the LRU list meaning that it is not in danger of getting evicted and also implying that it has been accessed recently.  <a href="#a47ffed634c26feb6e975600b553e48c5">More...</a><br /></td></tr>
<tr class="separator:a47ffed634c26feb6e975600b553e48c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bcc2e01e4ffe6abf420008166b1062"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac8bcc2e01e4ffe6abf420008166b1062">buf_page_peek_if_too_old</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ac8bcc2e01e4ffe6abf420008166b1062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommends a move of a block to the start of the LRU list if there is danger of dropping from the buffer pool.  <a href="#ac8bcc2e01e4ffe6abf420008166b1062">More...</a><br /></td></tr>
<tr class="separator:ac8bcc2e01e4ffe6abf420008166b1062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df3bda5bcc128a66ddb88607f7aa7fc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5df3bda5bcc128a66ddb88607f7aa7fc">buf_page_get_newest_modification</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a5df3bda5bcc128a66ddb88607f7aa7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the youngest modification log sequence number for a frame.  <a href="#a5df3bda5bcc128a66ddb88607f7aa7fc">More...</a><br /></td></tr>
<tr class="separator:a5df3bda5bcc128a66ddb88607f7aa7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0fe6ab9881b94fe49c82d25dbe819a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aab0fe6ab9881b94fe49c82d25dbe819a">buf_block_modify_clock_inc</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:aab0fe6ab9881b94fe49c82d25dbe819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the modify clock.  <a href="#aab0fe6ab9881b94fe49c82d25dbe819a">More...</a><br /></td></tr>
<tr class="separator:aab0fe6ab9881b94fe49c82d25dbe819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753ac8867abc2d85156cccf714926bc6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a753ac8867abc2d85156cccf714926bc6">buf_block_get_modify_clock</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a753ac8867abc2d85156cccf714926bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the modify clock.  <a href="#a753ac8867abc2d85156cccf714926bc6">More...</a><br /></td></tr>
<tr class="separator:a753ac8867abc2d85156cccf714926bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac193f180fc2dea1a6daf0a133e4977b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aac193f180fc2dea1a6daf0a133e4977b">buf_block_buf_fix_inc_func</a> (const char *file, ulint line, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:aac193f180fc2dea1a6daf0a133e4977b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the bufferfix count.  <a href="#aac193f180fc2dea1a6daf0a133e4977b">More...</a><br /></td></tr>
<tr class="separator:aac193f180fc2dea1a6daf0a133e4977b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c883f056d7d3c54a5822c201d740c66"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4c883f056d7d3c54a5822c201d740c66">buf_block_fix</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a4c883f056d7d3c54a5822c201d740c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the bufferfix count.  <a href="#a4c883f056d7d3c54a5822c201d740c66">More...</a><br /></td></tr>
<tr class="separator:a4c883f056d7d3c54a5822c201d740c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf63abba3006f5fb7da5141a3bc9fd9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#afcf63abba3006f5fb7da5141a3bc9fd9">buf_block_fix</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:afcf63abba3006f5fb7da5141a3bc9fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the bufferfix count.  <a href="#afcf63abba3006f5fb7da5141a3bc9fd9">More...</a><br /></td></tr>
<tr class="separator:afcf63abba3006f5fb7da5141a3bc9fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab7e6bcd7b2f7b163bc40dd76b08b8c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3ab7e6bcd7b2f7b163bc40dd76b08b8c">buf_block_unfix</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a3ab7e6bcd7b2f7b163bc40dd76b08b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the bufferfix count.  <a href="#a3ab7e6bcd7b2f7b163bc40dd76b08b8c">More...</a><br /></td></tr>
<tr class="separator:a3ab7e6bcd7b2f7b163bc40dd76b08b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc7ec91ea2590cce4a1a90e7b51fee9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5bc7ec91ea2590cce4a1a90e7b51fee9">buf_block_unfix</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a5bc7ec91ea2590cce4a1a90e7b51fee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the bufferfix count.  <a href="#a5bc7ec91ea2590cce4a1a90e7b51fee9">More...</a><br /></td></tr>
<tr class="separator:a5bc7ec91ea2590cce4a1a90e7b51fee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753d780aa84a242710866eed7bcc32c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a753d780aa84a242710866eed7bcc32c0">buf_read_page_handle_error</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a753d780aa84a242710866eed7bcc32c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unfixes the page, unlatches the page, removes it from page_hash and removes it from LRU.  <a href="#a753d780aa84a242710866eed7bcc32c0">More...</a><br /></td></tr>
<tr class="separator:a753d780aa84a242710866eed7bcc32c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad3db5496a7456973ce1be9ec882910"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#afad3db5496a7456973ce1be9ec882910">buf_ptr_get_fsp_addr</a> (const void *ptr, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> *space, <a class="el" href="structfil__addr__t.html">fil_addr_t</a> *addr)</td></tr>
<tr class="memdesc:afad3db5496a7456973ce1be9ec882910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the space id, page offset, and byte offset within page of a pointer pointing to a buffer frame containing a file page.  <a href="#afad3db5496a7456973ce1be9ec882910">More...</a><br /></td></tr>
<tr class="separator:afad3db5496a7456973ce1be9ec882910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c62e03b3e645bd91b960dcfcc4cabc0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3c62e03b3e645bd91b960dcfcc4cabc0">buf_block_get_lock_hash_val</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a3c62e03b3e645bd91b960dcfcc4cabc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hash value of a block.  <a href="#a3c62e03b3e645bd91b960dcfcc4cabc0">More...</a><br /></td></tr>
<tr class="separator:a3c62e03b3e645bd91b960dcfcc4cabc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8239011f74f17732794942ff891bfbf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8239011f74f17732794942ff891bfbf3">buf_pool_contains_zip</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const void *data)</td></tr>
<tr class="memdesc:a8239011f74f17732794942ff891bfbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a block in the buffer pool that points to a given compressed page.  <a href="#a8239011f74f17732794942ff891bfbf3">More...</a><br /></td></tr>
<tr class="separator:a8239011f74f17732794942ff891bfbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ec477ed8bba5d447e069f5ac6d31b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aac0ec477ed8bba5d447e069f5ac6d31b">buf_frame_align</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr)</td></tr>
<tr class="separator:aac0ec477ed8bba5d447e069f5ac6d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fa041692f236bcd8e2fd5e0a575fbc"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab5fa041692f236bcd8e2fd5e0a575fbc">buf_validate</a> (void)</td></tr>
<tr class="memdesc:ab5fa041692f236bcd8e2fd5e0a575fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the buffer pool data structure.  <a href="#ab5fa041692f236bcd8e2fd5e0a575fbc">More...</a><br /></td></tr>
<tr class="separator:ab5fa041692f236bcd8e2fd5e0a575fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913c2499ec503eea58a7dbb0c6b93d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9913c2499ec503eea58a7dbb0c6b93d8">buf_print</a> (void)</td></tr>
<tr class="memdesc:a9913c2499ec503eea58a7dbb0c6b93d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of the buffer pool data structure.  <a href="#a9913c2499ec503eea58a7dbb0c6b93d8">More...</a><br /></td></tr>
<tr class="separator:a9913c2499ec503eea58a7dbb0c6b93d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feb3f11f6a58e81598bf92d7b435500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a0feb3f11f6a58e81598bf92d7b435500">buf_page_print</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *read_buf, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:a0feb3f11f6a58e81598bf92d7b435500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a page to stderr.  <a href="#a0feb3f11f6a58e81598bf92d7b435500">More...</a><br /></td></tr>
<tr class="separator:a0feb3f11f6a58e81598bf92d7b435500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532b24c23776dee3f4a4635e38417378"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a532b24c23776dee3f4a4635e38417378">buf_zip_decompress</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ibool check)</td></tr>
<tr class="memdesc:a532b24c23776dee3f4a4635e38417378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a block.  <a href="#a532b24c23776dee3f4a4635e38417378">More...</a><br /></td></tr>
<tr class="separator:a532b24c23776dee3f4a4635e38417378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb34869722879443008e408b4ae6eb8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8bb34869722879443008e408b4ae6eb8">buf_get_latched_pages_number</a> (void)</td></tr>
<tr class="memdesc:a8bb34869722879443008e408b4ae6eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of latched pages in the buffer pool.  <a href="#a8bb34869722879443008e408b4ae6eb8">More...</a><br /></td></tr>
<tr class="separator:a8bb34869722879443008e408b4ae6eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10701cd6691bc47c29bf117375fccc14"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a10701cd6691bc47c29bf117375fccc14">buf_get_n_pending_read_ios</a> (void)</td></tr>
<tr class="memdesc:a10701cd6691bc47c29bf117375fccc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pending buf pool read ios.  <a href="#a10701cd6691bc47c29bf117375fccc14">More...</a><br /></td></tr>
<tr class="separator:a10701cd6691bc47c29bf117375fccc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940342731a901c4a6171de07be118f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a940342731a901c4a6171de07be118f57">buf_print_io</a> (FILE *file)</td></tr>
<tr class="memdesc:a940342731a901c4a6171de07be118f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of the buffer i/o.  <a href="#a940342731a901c4a6171de07be118f57">More...</a><br /></td></tr>
<tr class="separator:a940342731a901c4a6171de07be118f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94add70baf8e2ee67299e346bbb47965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a94add70baf8e2ee67299e346bbb47965">buf_stats_get_pool_info</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint pool_id, <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *all_pool_info)</td></tr>
<tr class="memdesc:a94add70baf8e2ee67299e346bbb47965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect buffer pool stats information for a buffer pool.  <a href="#a94add70baf8e2ee67299e346bbb47965">More...</a><br /></td></tr>
<tr class="separator:a94add70baf8e2ee67299e346bbb47965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee530ab11507348f9c9e303341634b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adee530ab11507348f9c9e303341634b7">buf_get_modified_ratio_pct</a> (void)</td></tr>
<tr class="memdesc:adee530ab11507348f9c9e303341634b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool.  <a href="#adee530ab11507348f9c9e303341634b7">More...</a><br /></td></tr>
<tr class="separator:adee530ab11507348f9c9e303341634b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e1620a9a0c049c739b9e426bd7802e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac5e1620a9a0c049c739b9e426bd7802e">buf_refresh_io_stats_all</a> ()</td></tr>
<tr class="memdesc:ac5e1620a9a0c049c739b9e426bd7802e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh the statistics used to print per-second averages.  <a href="#ac5e1620a9a0c049c739b9e426bd7802e">More...</a><br /></td></tr>
<tr class="separator:ac5e1620a9a0c049c739b9e426bd7802e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cbbcf6846efae5345f9e560e02fe1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa4cbbcf6846efae5345f9e560e02fe1c">buf_must_be_all_freed</a> (void)</td></tr>
<tr class="memdesc:aa4cbbcf6846efae5345f9e560e02fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that all file pages in the buffer are in a replaceable state.  <a href="#aa4cbbcf6846efae5345f9e560e02fe1c">More...</a><br /></td></tr>
<tr class="separator:aa4cbbcf6846efae5345f9e560e02fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de522312135372e9204158db79f015"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab0de522312135372e9204158db79f015">buf_pool_check_no_pending_io</a> (void)</td></tr>
<tr class="memdesc:ab0de522312135372e9204158db79f015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that there currently are no pending i/o-operations for the buffer pool.  <a href="#ab0de522312135372e9204158db79f015">More...</a><br /></td></tr>
<tr class="separator:ab0de522312135372e9204158db79f015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cee70fe0ea742c8a909aaa3bce3f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad4cee70fe0ea742c8a909aaa3bce3f59">buf_pool_invalidate</a> (void)</td></tr>
<tr class="memdesc:ad4cee70fe0ea742c8a909aaa3bce3f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the file pages in the buffer pool when an archive recovery is completed.  <a href="#ad4cee70fe0ea742c8a909aaa3bce3f59">More...</a><br /></td></tr>
<tr class="separator:ad4cee70fe0ea742c8a909aaa3bce3f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53726080a6bcf5cd75f80580f5691ecc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a53726080a6bcf5cd75f80580f5691ecc">buf_block_dbg_add_level</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89">latch_level_t</a> level)</td></tr>
<tr class="memdesc:a53726080a6bcf5cd75f80580f5691ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds latch level info for the rw-lock protecting the buffer frame.  <a href="#a53726080a6bcf5cd75f80580f5691ecc">More...</a><br /></td></tr>
<tr class="separator:a53726080a6bcf5cd75f80580f5691ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a99189b090a1af68ff81b98b5418a0f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4a99189b090a1af68ff81b98b5418a0f">buf_page_get_state</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a4a99189b090a1af68ff81b98b5418a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of a block.  <a href="#a4a99189b090a1af68ff81b98b5418a0f">More...</a><br /></td></tr>
<tr class="separator:a4a99189b090a1af68ff81b98b5418a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256d09dc81942591a6d51ebcb7c16214"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a256d09dc81942591a6d51ebcb7c16214">buf_block_get_state</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a256d09dc81942591a6d51ebcb7c16214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of a block.  <a href="#a256d09dc81942591a6d51ebcb7c16214">More...</a><br /></td></tr>
<tr class="separator:a256d09dc81942591a6d51ebcb7c16214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ae1a9052817ce692827243ce970d3e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a38ae1a9052817ce692827243ce970d3e">buf_page_set_state</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> state)</td></tr>
<tr class="memdesc:a38ae1a9052817ce692827243ce970d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of a block.  <a href="#a38ae1a9052817ce692827243ce970d3e">More...</a><br /></td></tr>
<tr class="separator:a38ae1a9052817ce692827243ce970d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542cb040a75435f73008c7009d9a908b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a542cb040a75435f73008c7009d9a908b">buf_block_set_state</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> state)</td></tr>
<tr class="memdesc:a542cb040a75435f73008c7009d9a908b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state of a block.  <a href="#a542cb040a75435f73008c7009d9a908b">More...</a><br /></td></tr>
<tr class="separator:a542cb040a75435f73008c7009d9a908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c7553b7d927c907ca28aa41640e856"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ae7c7553b7d927c907ca28aa41640e856">buf_page_in_file</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ae7c7553b7d927c907ca28aa41640e856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a block is mapped to a tablespace.  <a href="#ae7c7553b7d927c907ca28aa41640e856">More...</a><br /></td></tr>
<tr class="separator:ae7c7553b7d927c907ca28aa41640e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7098349ef19391fcdeff149b55dac652"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7098349ef19391fcdeff149b55dac652">buf_page_belongs_to_unzip_LRU</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a7098349ef19391fcdeff149b55dac652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a block should be on unzip_LRU list.  <a href="#a7098349ef19391fcdeff149b55dac652">More...</a><br /></td></tr>
<tr class="separator:a7098349ef19391fcdeff149b55dac652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa5baa88e1ce986b7308ab72453ca0b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="buf0types_8h.html#a728dccae958dd22a0f7ddd16cf6e4f0a">BPageMutex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2fa5baa88e1ce986b7308ab72453ca0b">buf_page_get_mutex</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a2fa5baa88e1ce986b7308ab72453ca0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mutex of a block.  <a href="#a2fa5baa88e1ce986b7308ab72453ca0b">More...</a><br /></td></tr>
<tr class="separator:a2fa5baa88e1ce986b7308ab72453ca0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8e9065bf85e7b6806022c563129da1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9d8e9065bf85e7b6806022c563129da1">buf_page_get_flush_type</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a9d8e9065bf85e7b6806022c563129da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flush type of a page.  <a href="#a9d8e9065bf85e7b6806022c563129da1">More...</a><br /></td></tr>
<tr class="separator:a9d8e9065bf85e7b6806022c563129da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53437d54ec990de81e9644d3ee6c4337"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a53437d54ec990de81e9644d3ee6c4337">buf_page_set_flush_type</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:a53437d54ec990de81e9644d3ee6c4337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flush type of a page.  <a href="#a53437d54ec990de81e9644d3ee6c4337">More...</a><br /></td></tr>
<tr class="separator:a53437d54ec990de81e9644d3ee6c4337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb15cdb046edd4db173179de22266e71"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adb15cdb046edd4db173179de22266e71">buf_block_set_file_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:adb15cdb046edd4db173179de22266e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a block to a file page.  <a href="#adb15cdb046edd4db173179de22266e71">More...</a><br /></td></tr>
<tr class="separator:adb15cdb046edd4db173179de22266e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b510251a5c2ba00d420c57ff16c223"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a66b510251a5c2ba00d420c57ff16c223">buf_page_get_io_fix</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a66b510251a5c2ba00d420c57ff16c223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the io_fix state of a block.  <a href="#a66b510251a5c2ba00d420c57ff16c223">More...</a><br /></td></tr>
<tr class="separator:a66b510251a5c2ba00d420c57ff16c223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804b0c6399074d86f64a5db44f5e2799"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a804b0c6399074d86f64a5db44f5e2799">buf_block_get_io_fix</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a804b0c6399074d86f64a5db44f5e2799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the io_fix state of a block.  <a href="#a804b0c6399074d86f64a5db44f5e2799">More...</a><br /></td></tr>
<tr class="separator:a804b0c6399074d86f64a5db44f5e2799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a8f29ac35531394d5cc6abb4e7bc2a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab1a8f29ac35531394d5cc6abb4e7bc2a">buf_page_set_io_fix</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> io_fix)</td></tr>
<tr class="memdesc:ab1a8f29ac35531394d5cc6abb4e7bc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the io_fix state of a block.  <a href="#ab1a8f29ac35531394d5cc6abb4e7bc2a">More...</a><br /></td></tr>
<tr class="separator:ab1a8f29ac35531394d5cc6abb4e7bc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427515122e86a7b344f79896801f30cb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a427515122e86a7b344f79896801f30cb">buf_block_set_io_fix</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> io_fix)</td></tr>
<tr class="memdesc:a427515122e86a7b344f79896801f30cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the io_fix state of a block.  <a href="#a427515122e86a7b344f79896801f30cb">More...</a><br /></td></tr>
<tr class="separator:a427515122e86a7b344f79896801f30cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6d1173140eb14d5ca4a83a62d0f4a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aafc6d1173140eb14d5ca4a83a62d0f4a">buf_page_set_sticky</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:aafc6d1173140eb14d5ca4a83a62d0f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a block sticky.  <a href="#aafc6d1173140eb14d5ca4a83a62d0f4a">More...</a><br /></td></tr>
<tr class="separator:aafc6d1173140eb14d5ca4a83a62d0f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b8b75af8fa0ad4e4ebb7723ec8a215"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad9b8b75af8fa0ad4e4ebb7723ec8a215">buf_page_unset_sticky</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ad9b8b75af8fa0ad4e4ebb7723ec8a215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stickiness of a block.  <a href="#ad9b8b75af8fa0ad4e4ebb7723ec8a215">More...</a><br /></td></tr>
<tr class="separator:ad9b8b75af8fa0ad4e4ebb7723ec8a215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c37514bc246843091d871cea64e91a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a35c37514bc246843091d871cea64e91a">buf_page_can_relocate</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a35c37514bc246843091d871cea64e91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a buffer block can be relocated in memory.  <a href="#a35c37514bc246843091d871cea64e91a">More...</a><br /></td></tr>
<tr class="separator:a35c37514bc246843091d871cea64e91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4fc8bd9c50f18fd1a93658e94d3d87"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8d4fc8bd9c50f18fd1a93658e94d3d87">buf_page_is_old</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a8d4fc8bd9c50f18fd1a93658e94d3d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a block has been flagged old.  <a href="#a8d4fc8bd9c50f18fd1a93658e94d3d87">More...</a><br /></td></tr>
<tr class="separator:a8d4fc8bd9c50f18fd1a93658e94d3d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf46d5fc3b73bc26bf115615fb81d0d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acaf46d5fc3b73bc26bf115615fb81d0d">buf_page_set_old</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, ibool old)</td></tr>
<tr class="memdesc:acaf46d5fc3b73bc26bf115615fb81d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag a block old.  <a href="#acaf46d5fc3b73bc26bf115615fb81d0d">More...</a><br /></td></tr>
<tr class="separator:acaf46d5fc3b73bc26bf115615fb81d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8fef965c556246b887497dca782d2a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9e8fef965c556246b887497dca782d2a">buf_page_is_accessed</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a9e8fef965c556246b887497dca782d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the time of first access of a block in the buffer pool.  <a href="#a9e8fef965c556246b887497dca782d2a">More...</a><br /></td></tr>
<tr class="separator:a9e8fef965c556246b887497dca782d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cf52f3b3dfe8cfc91c77757b268034"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a68cf52f3b3dfe8cfc91c77757b268034">buf_page_set_accessed</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a68cf52f3b3dfe8cfc91c77757b268034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag a block accessed.  <a href="#a68cf52f3b3dfe8cfc91c77757b268034">More...</a><br /></td></tr>
<tr class="separator:a68cf52f3b3dfe8cfc91c77757b268034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae275396b7f480b0bf26e0b9f400a97a3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ae275396b7f480b0bf26e0b9f400a97a3">buf_page_get_block</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ae275396b7f480b0bf26e0b9f400a97a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buf_block_t handle of a buffered file block if an uncompressed page frame exists, or NULL.  <a href="#ae275396b7f480b0bf26e0b9f400a97a3">More...</a><br /></td></tr>
<tr class="separator:ae275396b7f480b0bf26e0b9f400a97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95db363e6bf7655c69a903397199b780"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a95db363e6bf7655c69a903397199b780">buf_block_get_frame</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a95db363e6bf7655c69a903397199b780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the memory frame of a block.  <a href="#a95db363e6bf7655c69a903397199b780">More...</a><br /></td></tr>
<tr class="separator:a95db363e6bf7655c69a903397199b780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e67247bf34c56e00cfe1915c47abf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac2e67247bf34c56e00cfe1915c47abf0">buf_block_from_ahi</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr)</td></tr>
<tr class="memdesc:ac2e67247bf34c56e00cfe1915c47abf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a buffer block from an adaptive hash index pointer.  <a href="#ac2e67247bf34c56e00cfe1915c47abf0">More...</a><br /></td></tr>
<tr class="separator:ac2e67247bf34c56e00cfe1915c47abf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0cbe211bba9dba91be1e38e584e18f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7c0cbe211bba9dba91be1e38e584e18f">buf_is_block_in_instance</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *ptr)</td></tr>
<tr class="memdesc:a7c0cbe211bba9dba91be1e38e584e18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if a block pointer points into one of currently used chunks of the buffer pool.  <a href="#a7c0cbe211bba9dba91be1e38e584e18f">More...</a><br /></td></tr>
<tr class="separator:a7c0cbe211bba9dba91be1e38e584e18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efca615726ffc1dfc6c2ed05612ccd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2efca615726ffc1dfc6c2ed05612ccd0">buf_page_init_for_read</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *err, ulint mode, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ibool unzip)</td></tr>
<tr class="memdesc:a2efca615726ffc1dfc6c2ed05612ccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits a page for read to the buffer buf_pool.  <a href="#a2efca615726ffc1dfc6c2ed05612ccd0">More...</a><br /></td></tr>
<tr class="separator:a2efca615726ffc1dfc6c2ed05612ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc2cc72f66548f1e67ad61e8e8769a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6fc2cc72f66548f1e67ad61e8e8769a1">buf_page_io_complete</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> evict)</td></tr>
<tr class="memdesc:a6fc2cc72f66548f1e67ad61e8e8769a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes an asynchronous read or write request of a file page to or from the buffer pool.  <a href="#a6fc2cc72f66548f1e67ad61e8e8769a1">More...</a><br /></td></tr>
<tr class="separator:a6fc2cc72f66548f1e67ad61e8e8769a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883be2e9c1c6795751c4b076708c7a32"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a883be2e9c1c6795751c4b076708c7a32">buf_pool_index</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a883be2e9c1c6795751c4b076708c7a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the index of a buffer pool to the buf_pool[] array.  <a href="#a883be2e9c1c6795751c4b076708c7a32">More...</a><br /></td></tr>
<tr class="separator:a883be2e9c1c6795751c4b076708c7a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803b791d0706583d685f7f9413da45d7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a803b791d0706583d685f7f9413da45d7">buf_pool_from_bpage</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a803b791d0706583d685f7f9413da45d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pool instance given a page instance.  <a href="#a803b791d0706583d685f7f9413da45d7">More...</a><br /></td></tr>
<tr class="separator:a803b791d0706583d685f7f9413da45d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499d41dc7d50849f883c2b06c07dbb02"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a499d41dc7d50849f883c2b06c07dbb02">buf_pool_from_block</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a499d41dc7d50849f883c2b06c07dbb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pool instance given a block instance.  <a href="#a499d41dc7d50849f883c2b06c07dbb02">More...</a><br /></td></tr>
<tr class="separator:a499d41dc7d50849f883c2b06c07dbb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb7f2dc1c41995e06c47526e8774c6c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acfb7f2dc1c41995e06c47526e8774c6c">buf_pool_get</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:acfb7f2dc1c41995e06c47526e8774c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pool instance given a page id.  <a href="#acfb7f2dc1c41995e06c47526e8774c6c">More...</a><br /></td></tr>
<tr class="separator:acfb7f2dc1c41995e06c47526e8774c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac71426ec4d18966a8fa309954653b5e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aac71426ec4d18966a8fa309954653b5e">buf_pool_from_array</a> (ulint <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:aac71426ec4d18966a8fa309954653b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer pool instance given its array index.  <a href="#aac71426ec4d18966a8fa309954653b5e">More...</a><br /></td></tr>
<tr class="separator:aac71426ec4d18966a8fa309954653b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b0eac921442eec0314115147c85a17"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa3b0eac921442eec0314115147c85a17">buf_page_hash_get_low</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:aa3b0eac921442eec0314115147c85a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control block of a file page, NULL if not found.  <a href="#aa3b0eac921442eec0314115147c85a17">More...</a><br /></td></tr>
<tr class="separator:aa3b0eac921442eec0314115147c85a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ee95652b3ae571a6e4274a08d9a2c7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> **lock, ulint <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> watch=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:ae6ee95652b3ae571a6e4274a08d9a2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control block of a file page, NULL if not found.  <a href="#ae6ee95652b3ae571a6e4274a08d9a2c7">More...</a><br /></td></tr>
<tr class="separator:ae6ee95652b3ae571a6e4274a08d9a2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806a1ce0a4b83b733b9b97da5691f47"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab806a1ce0a4b83b733b9b97da5691f47">buf_block_hash_get_locked</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> **lock, ulint <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>)</td></tr>
<tr class="memdesc:ab806a1ce0a4b83b733b9b97da5691f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control block of a file page, NULL if not found.  <a href="#ab806a1ce0a4b83b733b9b97da5691f47">More...</a><br /></td></tr>
<tr class="separator:ab806a1ce0a4b83b733b9b97da5691f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489d00ae3045b2d4207ba0eece8e966"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8489d00ae3045b2d4207ba0eece8e966">buf_get_free_list_len</a> (void)</td></tr>
<tr class="memdesc:a8489d00ae3045b2d4207ba0eece8e966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current length of the free list of buffer blocks.  <a href="#a8489d00ae3045b2d4207ba0eece8e966">More...</a><br /></td></tr>
<tr class="separator:a8489d00ae3045b2d4207ba0eece8e966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae799641f6fffb0ac145542154be08361"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ae799641f6fffb0ac145542154be08361">buf_pool_watch_is_sentinel</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ae799641f6fffb0ac145542154be08361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a block is a sentinel for a buffer pool watch.  <a href="#ae799641f6fffb0ac145542154be08361">More...</a><br /></td></tr>
<tr class="separator:ae799641f6fffb0ac145542154be08361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607741f6ab261487ea1e2efef4d7640e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a607741f6ab261487ea1e2efef4d7640e">buf_pool_watch_unset</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a607741f6ab261487ea1e2efef4d7640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop watching if the page has been read in.  <a href="#a607741f6ab261487ea1e2efef4d7640e">More...</a><br /></td></tr>
<tr class="separator:a607741f6ab261487ea1e2efef4d7640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b6dd3b80c03a713c7f160611d00455"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a35b6dd3b80c03a713c7f160611d00455">buf_pool_watch_occurred</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a35b6dd3b80c03a713c7f160611d00455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the page has been read in.  <a href="#a35b6dd3b80c03a713c7f160611d00455">More...</a><br /></td></tr>
<tr class="separator:a35b6dd3b80c03a713c7f160611d00455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7560004e8ceba1e2a2089bd67371bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#afc7560004e8ceba1e2a2089bd67371bd">buf_get_total_list_len</a> (ulint *LRU_len, ulint *free_len, ulint *flush_list_len)</td></tr>
<tr class="memdesc:afc7560004e8ceba1e2a2089bd67371bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total buffer pool statistics.  <a href="#afc7560004e8ceba1e2a2089bd67371bd">More...</a><br /></td></tr>
<tr class="separator:afc7560004e8ceba1e2a2089bd67371bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dd922a4f122cd1870fbc8cdec76620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af7dd922a4f122cd1870fbc8cdec76620">buf_get_total_list_size_in_bytes</a> (<a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *buf_pools_list_size)</td></tr>
<tr class="memdesc:af7dd922a4f122cd1870fbc8cdec76620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total list size in bytes from all buffer pools.  <a href="#af7dd922a4f122cd1870fbc8cdec76620">More...</a><br /></td></tr>
<tr class="separator:af7dd922a4f122cd1870fbc8cdec76620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451851befdfc82765a869314cdd073e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a451851befdfc82765a869314cdd073e6">buf_get_total_stat</a> (<a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *tot_stat)</td></tr>
<tr class="memdesc:a451851befdfc82765a869314cdd073e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total buffer pool statistics.  <a href="#a451851befdfc82765a869314cdd073e6">More...</a><br /></td></tr>
<tr class="separator:a451851befdfc82765a869314cdd073e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcde42037dc3ee66cfe5e74fad1c015"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adfcde42037dc3ee66cfe5e74fad1c015">buf_get_nth_chunk_block</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, ulint *chunk_size)</td></tr>
<tr class="memdesc:adfcde42037dc3ee66cfe5e74fad1c015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth chunk's buffer block in the specified buffer pool.  <a href="#adfcde42037dc3ee66cfe5e74fad1c015">More...</a><br /></td></tr>
<tr class="separator:adfcde42037dc3ee66cfe5e74fad1c015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce21ecd74468bc2e0e2a33cf5a2ca2a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3ce21ecd74468bc2e0e2a33cf5a2ca2a">buf_pool_size_align</a> (ulint size)</td></tr>
<tr class="memdesc:a3ce21ecd74468bc2e0e2a33cf5a2ca2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate aligned buffer pool size based on srv_buf_pool_chunk_unit, if needed.  <a href="#a3ce21ecd74468bc2e0e2a33cf5a2ca2a">More...</a><br /></td></tr>
<tr class="separator:a3ce21ecd74468bc2e0e2a33cf5a2ca2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc4c9f9a04819fb962432b2c0b8e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2fdc4c9f9a04819fb962432b2c0b8e8f">buf_pool_adjust_chunk_unit</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> size)</td></tr>
<tr class="memdesc:a2fdc4c9f9a04819fb962432b2c0b8e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the proposed chunk unit size so that it satisfies all invariants.  <a href="#a2fdc4c9f9a04819fb962432b2c0b8e8f">More...</a><br /></td></tr>
<tr class="separator:a2fdc4c9f9a04819fb962432b2c0b8e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eec07edc8c41c7b8d17b0053f28ffee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a1eec07edc8c41c7b8d17b0053f28ffee">buf_flush_update_zip_checksum</a> (<a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, ulint size, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> <a class="el" href="xcom__base_8cc.html#a0ce0765b958f7289d206f0c78bd105c7">lsn</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> skip_lsn_check)</td></tr>
<tr class="memdesc:a1eec07edc8c41c7b8d17b0053f28ffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the checksum of a page from compressed table and update the page.  <a href="#a1eec07edc8c41c7b8d17b0053f28ffee">More...</a><br /></td></tr>
<tr class="separator:a1eec07edc8c41c7b8d17b0053f28ffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c4d4c43ce1afcad91d6011e73f9b32"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a84c4d4c43ce1afcad91d6011e73f9b32">buf_get_withdraw_depth</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a84c4d4c43ce1afcad91d6011e73f9b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return how many more pages must be added to the withdraw list to reach the withdraw target of the currently ongoing buffer pool resize.  <a href="#a84c4d4c43ce1afcad91d6011e73f9b32">More...</a><br /></td></tr>
<tr class="separator:a84c4d4c43ce1afcad91d6011e73f9b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6664a53292fe81dc48dae70f935fe7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#abb6664a53292fe81dc48dae70f935fe7">buf_block_get_io_fix_unlocked</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:abb6664a53292fe81dc48dae70f935fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the io_fix state of a buffer block.  <a href="#abb6664a53292fe81dc48dae70f935fe7">More...</a><br /></td></tr>
<tr class="separator:abb6664a53292fe81dc48dae70f935fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb376da0136a9ced31021c6137359d6e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acb376da0136a9ced31021c6137359d6e">buf_page_get_io_fix_unlocked</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:acb376da0136a9ced31021c6137359d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the io_fix state of a buffer page.  <a href="#acb376da0136a9ced31021c6137359d6e">More...</a><br /></td></tr>
<tr class="separator:acb376da0136a9ced31021c6137359d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fefbabeb6b422a2baeae7758d16a7d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa7fefbabeb6b422a2baeae7758d16a7d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> &amp;buf_pool)</td></tr>
<tr class="memdesc:aa7fefbabeb6b422a2baeae7758d16a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given buf_pool_t object.  <a href="#aa7fefbabeb6b422a2baeae7758d16a7d">More...</a><br /></td></tr>
<tr class="separator:aa7fefbabeb6b422a2baeae7758d16a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaa795024d029f835357042f72ee0611a"><td class="memItemLeft" align="right" valign="top">constexpr ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aaa795024d029f835357042f72ee0611a">MAX_BUFFER_POOLS_BITS</a> = 6</td></tr>
<tr class="memdesc:aaa795024d029f835357042f72ee0611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits to representing a buffer pool ID.  <a href="#aaa795024d029f835357042f72ee0611a">More...</a><br /></td></tr>
<tr class="separator:aaa795024d029f835357042f72ee0611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93370087448a1c0e6a3054d13ca0fb81"><td class="memItemLeft" align="right" valign="top">constexpr ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a93370087448a1c0e6a3054d13ca0fb81">MAX_BUFFER_POOLS</a> = (1 &lt;&lt; <a class="el" href="buf0buf_8h.html#aaa795024d029f835357042f72ee0611a">MAX_BUFFER_POOLS_BITS</a>)</td></tr>
<tr class="memdesc:a93370087448a1c0e6a3054d13ca0fb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of buffer pools that can be defined.  <a href="#a93370087448a1c0e6a3054d13ca0fb81">More...</a><br /></td></tr>
<tr class="separator:a93370087448a1c0e6a3054d13ca0fb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ea539fcc36f30147cb4ee2f7917049"><td class="memItemLeft" align="right" valign="top">constexpr ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a55ea539fcc36f30147cb4ee2f7917049">MAX_PAGE_HASH_LOCKS</a> = 1024</td></tr>
<tr class="memdesc:a55ea539fcc36f30147cb4ee2f7917049"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of page_hash locks.  <a href="#a55ea539fcc36f30147cb4ee2f7917049">More...</a><br /></td></tr>
<tr class="separator:a55ea539fcc36f30147cb4ee2f7917049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdf9e142c6096556e3722d7c91b9065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3fdf9e142c6096556e3722d7c91b9065">buf_pool_ptr</a></td></tr>
<tr class="memdesc:a3fdf9e142c6096556e3722d7c91b9065"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer pools of the database.  <a href="#a3fdf9e142c6096556e3722d7c91b9065">More...</a><br /></td></tr>
<tr class="separator:a3fdf9e142c6096556e3722d7c91b9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer pool high-level routines. </p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="affa9940137a5129ae26401fec94405b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa9940137a5129ae26401fec94405b8">&#9670;&nbsp;</a></span>assert_block_ahi_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define assert_block_ahi_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0dbg_8h.html#ae7aed983dfe98ac872b5a9915fa778fa">ut_a</a>(<a class="el" href="os0atomic_8h.html#a54807a35ae74ff6aad36d34003ea6cd6">os_atomic_increment_ulint</a>(&amp;(block)-&gt;n_pointers, 0) == 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53b955ddf5d5d81f383aa5224bfa0fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b955ddf5d5d81f383aa5224bfa0fc8">&#9670;&nbsp;</a></span>assert_block_ahi_empty_on_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define assert_block_ahi_empty_on_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                               \</div><div class="line">    UNIV_MEM_VALID(&amp;(block)-&gt;n_pointers, <span class="keyword">sizeof</span>(block)-&gt;n_pointers); \</div><div class="line">    assert_block_ahi_empty(block);                                   \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
</div>
</div>
<a id="a29568fcc4b71168849c777ddf66af1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29568fcc4b71168849c777ddf66af1f1">&#9670;&nbsp;</a></span>assert_block_ahi_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define assert_block_ahi_valid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="ut0dbg_8h.html#ae7aed983dfe98ac872b5a9915fa778fa">ut_a</a>((block)-&gt;<a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a> ||              \</div><div class="line">       <a class="code" href="os0atomic_8h.html#a54807a35ae74ff6aad36d34003ea6cd6">os_atomic_increment_ulint</a>(&amp;(block)-&gt;n_pointers, 0) == 0)</div><div class="ttc" id="mysql_8cc_html_adfa69ae672499b1037123a1f17c5552b"><div class="ttname"><a href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></div><div class="ttdeci">char * index(const char *, int c)</div><div class="ttdef"><b>Definition:</b> mysql.cc:2928</div></div>
<div class="ttc" id="ut0dbg_8h_html_ae7aed983dfe98ac872b5a9915fa778fa"><div class="ttname"><a href="ut0dbg_8h.html#ae7aed983dfe98ac872b5a9915fa778fa">ut_a</a></div><div class="ttdeci">#define ut_a(EXPR)</div><div class="ttdoc">Abort execution if EXPR does not evaluate to nonzero. </div><div class="ttdef"><b>Definition:</b> ut0dbg.h:54</div></div>
<div class="ttc" id="os0atomic_8h_html_a54807a35ae74ff6aad36d34003ea6cd6"><div class="ttname"><a href="os0atomic_8h.html#a54807a35ae74ff6aad36d34003ea6cd6">os_atomic_increment_ulint</a></div><div class="ttdeci">#define os_atomic_increment_ulint(ptr, amount)</div><div class="ttdef"><b>Definition:</b> os0atomic.h:277</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab992c7712a4353abf34bfafbe3a6431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab992c7712a4353abf34bfafbe3a6431a">&#9670;&nbsp;</a></span>buf_block_buf_fix_inc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_buf_fix_inc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#aac193f180fc2dea1a6daf0a133e4977b">buf_block_buf_fix_inc_func</a>(f, l, b)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>block to bufferfix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>file name where requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>line number where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78b0bcde049a4c30e62ec696daa55dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b0bcde049a4c30e62ec696daa55dff">&#9670;&nbsp;</a></span>buf_block_get_page_zip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_get_page_zip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block</td><td>)</td>
          <td>&#160;&#160;&#160;((block)-&gt;page.zip.data ? &amp;(block)-&gt;page.zip : <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the compressed page descriptor corresponding to an uncompressed page if applicable. </p>

</div>
</div>
<a id="a02c3e94974cac1500f78a3cb08e68ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3e94974cac1500f78a3cb08e68ab2">&#9670;&nbsp;</a></span>buf_block_hash_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_hash_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ab806a1ce0a4b83b733b9b97da5691f47">buf_block_hash_get_locked</a>(b, page_id, <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec1caf98837a48b5cc8cc0164946a11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1caf98837a48b5cc8cc0164946a11a">&#9670;&nbsp;</a></span>buf_block_hash_get_s_locked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_hash_get_s_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ab806a1ce0a4b83b733b9b97da5691f47">buf_block_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ab26100fa91e9f7db18e6390e10bffe94">RW_LOCK_S</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2ecf00408baca2e715a13185b57643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ecf00408baca2e715a13185b57643b">&#9670;&nbsp;</a></span>buf_block_hash_get_x_locked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_hash_get_x_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ab806a1ce0a4b83b733b9b97da5691f47">buf_block_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ad654c262f7dadd19609ea9e23cc02be4">RW_LOCK_X</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a487b81cbd6e10fa77bc6be4975787aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487b81cbd6e10fa77bc6be4975787aee">&#9670;&nbsp;</a></span>buf_block_hash_lock_held_s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_hash_lock_held_s</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#aad18c67b8b4469a4aab76260b0131750">buf_page_hash_lock_held_s</a>((buf_pool), &amp;(block)-&gt;<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb5ae7c089b73c806b1a2f99527ef8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5ae7c089b73c806b1a2f99527ef8f9">&#9670;&nbsp;</a></span>buf_block_hash_lock_held_s_or_x</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_hash_lock_held_s_or_x</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ad955654caf86aaf4a515844c1efc46e3">buf_page_hash_lock_held_s_or_x</a>((buf_pool), &amp;(block)-&gt;<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d960d20e005f2e97129dfc594a30ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d960d20e005f2e97129dfc594a30ca0">&#9670;&nbsp;</a></span>buf_block_hash_lock_held_x</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_hash_lock_held_x</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a53f3b5c2625e8affaf21f10882e8a396">buf_page_hash_lock_held_x</a>((buf_pool), &amp;(block)-&gt;<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa20f5c2f2899db5e3414580b07b50ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20f5c2f2899db5e3414580b07b50ed9">&#9670;&nbsp;</a></span>buf_block_state_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_state_valid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="buf0buf_8h.html#a256d09dc81942591a6d51ebcb7c16214">buf_block_get_state</a>(block) &gt;= <a class="code" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c">BUF_BLOCK_NOT_USED</a> &amp;&amp; \</div><div class="line">   (<a class="code" href="buf0buf_8h.html#a256d09dc81942591a6d51ebcb7c16214">buf_block_get_state</a>(block) &lt;= <a class="code" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87">BUF_BLOCK_REMOVE_HASH</a>))</div><div class="ttc" id="buf0buf_8h_html_a256d09dc81942591a6d51ebcb7c16214"><div class="ttname"><a href="buf0buf_8h.html#a256d09dc81942591a6d51ebcb7c16214">buf_block_get_state</a></div><div class="ttdeci">UNIV_INLINE enum buf_page_state buf_block_get_state(const buf_block_t *block)</div><div class="ttdoc">Gets the state of a block. </div></div>
<div class="ttc" id="buf0buf_8h_html_ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87"><div class="ttname"><a href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87">BUF_BLOCK_REMOVE_HASH</a></div><div class="ttdoc">hash index should be removed before putting to the free list </div><div class="ttdef"><b>Definition:</b> buf0buf.h:145</div></div>
<div class="ttc" id="buf0buf_8h_html_ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c"><div class="ttname"><a href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c">BUF_BLOCK_NOT_USED</a></div><div class="ttdoc">is in the free list; must be after the BUF_BLOCK_ZIP_ constants for compressed-only pages ...</div><div class="ttdef"><b>Definition:</b> buf0buf.h:136</div></div>
</div><!-- fragment -->
<p>Check if a buf_block_t object is in a valid state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>buffer block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid </dd></dl>

</div>
</div>
<a id="a095adbc797576159cfc092fb6bdedeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095adbc797576159cfc092fb6bdedeb2">&#9670;&nbsp;</a></span>buf_flush_list_mutex_enter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_flush_list_mutex_enter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                   \</div><div class="line">    mutex_enter(&amp;(b)-&gt;flush_list_mutex); \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
<p>Acquire the flush list mutex. </p>

</div>
</div>
<a id="aaefd70716bf3351e09b6e52ea9ca6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefd70716bf3351e09b6e52ea9ca6783">&#9670;&nbsp;</a></span>buf_flush_list_mutex_exit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_flush_list_mutex_exit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                  \</div><div class="line">    mutex_exit(&amp;(b)-&gt;flush_list_mutex); \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
<p>Release the flush list mutex. </p>

</div>
</div>
<a id="a7134f85ae33367e8860b6814c0866ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7134f85ae33367e8860b6814c0866ff5">&#9670;&nbsp;</a></span>buf_flush_list_mutex_own</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_flush_list_mutex_own</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0mutex_8h.html#a7eccf8a96f24ab7f4012bb203640cf17">mutex_own</a>(&amp;(b)-&gt;flush_list_mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if flush list mutex is owned. </p>

</div>
</div>
<a id="ac94d525f40c93ef4c9e8151cc531adf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94d525f40c93ef4c9e8151cc531adf1">&#9670;&nbsp;</a></span>buf_page_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ID, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SIZE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MTR&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="buf0buf_8h.html#a32111f6e94a1745e1750bcbfe96600f9">buf_page_get_gen</a>(ID, SIZE, LA, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a1e23852820b9154316c7c06e2b7ba051">Page_fetch::NORMAL</a>, __FILE__, __LINE__, \</div><div class="line">                   MTR)</div><div class="ttc" id="buf0buf_8h_html_a32111f6e94a1745e1750bcbfe96600f9"><div class="ttname"><a href="buf0buf_8h.html#a32111f6e94a1745e1750bcbfe96600f9">buf_page_get_gen</a></div><div class="ttdeci">buf_block_t * buf_page_get_gen(const page_id_t &amp;page_id, const page_size_t &amp;page_size, ulint rw_latch, buf_block_t *guess, Page_fetch mode, const char *file, ulint line, mtr_t *mtr, bool dirty_with_no_latch=false)</div><div class="ttdoc">This is the general function used to get access to a database page. </div><div class="ttdef"><b>Definition:</b> buf0buf.cc:4149</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
<div class="ttc" id="buf0buf_8h_html_aa4ef74186b9c9937976a7d022cfa12c7a1e23852820b9154316c7c06e2b7ba051"><div class="ttname"><a href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a1e23852820b9154316c7c06e2b7ba051">Page_fetch::NORMAL</a></div><div class="ttdoc">Get always. </div></div>
</div><!-- fragment -->
<p>NOTE! The following macros should be used instead of buf_page_get_gen, to improve debugging. </p>
<p>Only values RW_S_LATCH and RW_X_LATCH are allowed in LA! </p>

</div>
</div>
<a id="a17c2ac1c4618377fa1432ea64caebaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c2ac1c4618377fa1432ea64caebaef">&#9670;&nbsp;</a></span>buf_page_get_also_watch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_get_also_watch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a3563a2479f143e7c74c5ce14d14694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3563a2479f143e7c74c5ce14d14694">&#9670;&nbsp;</a></span>buf_page_get_with_no_latch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_get_with_no_latch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ID, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SIZE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MTR&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="buf0buf_8h.html#a32111f6e94a1745e1750bcbfe96600f9">buf_page_get_gen</a>(ID, SIZE, <a class="code" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574a4adf9bec2a402a2534c53dbce89b9d6e">RW_NO_LATCH</a>, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a04e9d1744b4cb952e0c2021136069e86">Page_fetch::NO_LATCH</a>, \</div><div class="line">                   __FILE__, __LINE__, MTR)</div><div class="ttc" id="buf0buf_8h_html_a32111f6e94a1745e1750bcbfe96600f9"><div class="ttname"><a href="buf0buf_8h.html#a32111f6e94a1745e1750bcbfe96600f9">buf_page_get_gen</a></div><div class="ttdeci">buf_block_t * buf_page_get_gen(const page_id_t &amp;page_id, const page_size_t &amp;page_size, ulint rw_latch, buf_block_t *guess, Page_fetch mode, const char *file, ulint line, mtr_t *mtr, bool dirty_with_no_latch=false)</div><div class="ttdoc">This is the general function used to get access to a database page. </div><div class="ttdef"><b>Definition:</b> buf0buf.cc:4149</div></div>
<div class="ttc" id="sync0rw_8h_html_ac63f6bb2316c64592a2494595132e574a4adf9bec2a402a2534c53dbce89b9d6e"><div class="ttname"><a href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574a4adf9bec2a402a2534c53dbce89b9d6e">RW_NO_LATCH</a></div><div class="ttdef"><b>Definition:</b> sync0rw.h:139</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
<div class="ttc" id="buf0buf_8h_html_aa4ef74186b9c9937976a7d022cfa12c7a04e9d1744b4cb952e0c2021136069e86"><div class="ttname"><a href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7a04e9d1744b4cb952e0c2021136069e86">Page_fetch::NO_LATCH</a></div><div class="ttdoc">get and bufferfix, but set no latch; we have separated this case, because it is error-prone programmi...</div></div>
</div><!-- fragment -->
<p>Use these macros to bufferfix a page with no latching. </p>
<p>Remember not to read the contents of the page unless you know it is safe. Do not modify the contents of the page! We have separated this case, because it is error-prone programming not to set a latch, and it should be used with care. </p>

</div>
</div>
<a id="ad2d78b2ce6dac6dac0bfa5b49790b422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d78b2ce6dac6dac0bfa5b49790b422">&#9670;&nbsp;</a></span>buf_page_hash_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, <a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a5f5e8e4d9cb004c7ea5fb3c4096934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5f5e8e4d9cb004c7ea5fb3c4096934">&#9670;&nbsp;</a></span>buf_page_hash_get_s_locked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_get_s_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ab26100fa91e9f7db18e6390e10bffe94">RW_LOCK_S</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7388557a086d8346ccafd08e0d234e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7388557a086d8346ccafd08e0d234e84">&#9670;&nbsp;</a></span>buf_page_hash_get_x_locked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_get_x_locked</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#ae6ee95652b3ae571a6e4274a08d9a2c7">buf_page_hash_get_locked</a>(b, page_id, l, <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ad654c262f7dadd19609ea9e23cc02be4">RW_LOCK_X</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfc687dbb182eb08cbea2596d9396bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc687dbb182eb08cbea2596d9396bbc">&#9670;&nbsp;</a></span>buf_page_hash_lock_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="hash0hash_8h.html#ac2c915b43186f53f8c63dfd22bf4562c">hash_get_lock</a>((buf_pool)-&gt;page_hash, (page_id).fold())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get appropriate page_hash_lock. </p>

</div>
</div>
<a id="aad18c67b8b4469a4aab76260b0131750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad18c67b8b4469a4aab76260b0131750">&#9670;&nbsp;</a></span>buf_page_hash_lock_held_s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_held_s</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bpage&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="sync0rw_8cc.html#a7e7b5b80fccd18515f08dd868ffb1692">rw_lock_own</a>(<a class="el" href="buf0buf_8h.html#adfc687dbb182eb08cbea2596d9396bbc">buf_page_hash_lock_get</a>((buf_pool), (bpage)-&gt;<a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>), <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ab26100fa91e9f7db18e6390e10bffe94">RW_LOCK_S</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if page_hash lock is held in s-mode. </p>

</div>
</div>
<a id="ad955654caf86aaf4a515844c1efc46e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad955654caf86aaf4a515844c1efc46e3">&#9670;&nbsp;</a></span>buf_page_hash_lock_held_s_or_x</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_held_s_or_x</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bpage&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="buf0buf_8h.html#aad18c67b8b4469a4aab76260b0131750">buf_page_hash_lock_held_s</a>((buf_pool), (bpage)) ||    \</div><div class="line">   buf_page_hash_lock_held_x((buf_pool), (bpage)))</div><div class="ttc" id="buf0buf_8h_html_aad18c67b8b4469a4aab76260b0131750"><div class="ttname"><a href="buf0buf_8h.html#aad18c67b8b4469a4aab76260b0131750">buf_page_hash_lock_held_s</a></div><div class="ttdeci">#define buf_page_hash_lock_held_s(buf_pool, bpage)</div><div class="ttdoc">Test if page_hash lock is held in s-mode. </div><div class="ttdef"><b>Definition:</b> buf0buf.h:2091</div></div>
</div><!-- fragment -->
<p>Test if page_hash lock is held in x or s-mode. </p>

</div>
</div>
<a id="a53f3b5c2625e8affaf21f10882e8a396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f3b5c2625e8affaf21f10882e8a396">&#9670;&nbsp;</a></span>buf_page_hash_lock_held_x</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_held_x</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bpage&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="sync0rw_8cc.html#a7e7b5b80fccd18515f08dd868ffb1692">rw_lock_own</a>(<a class="el" href="buf0buf_8h.html#adfc687dbb182eb08cbea2596d9396bbc">buf_page_hash_lock_get</a>((buf_pool), (bpage)-&gt;<a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>), <a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89ad654c262f7dadd19609ea9e23cc02be4">RW_LOCK_X</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if page_hash lock is held in x-mode. </p>

</div>
</div>
<a id="a1a6d4151775f37fd5f6ef62eacd50a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6d4151775f37fd5f6ef62eacd50a82">&#9670;&nbsp;</a></span>buf_page_hash_lock_s_confirm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_s_confirm</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash_lock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="hash0hash_8h.html#ad7cc516d6a4ded86ccbeb3f022dab7fa">hash_lock_s_confirm</a>(hash_lock, (buf_pool)-&gt;page_hash, (page_id).fold())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If not appropriate page_hash_lock, relock until appropriate. </p>

</div>
</div>
<a id="ad45032de9143fd6341267a268c615883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45032de9143fd6341267a268c615883">&#9670;&nbsp;</a></span>buf_page_hash_lock_x_confirm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_x_confirm</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash_lock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="hash0hash_8h.html#a7781c17e02c67cc2254fbcc4ae3763c3">hash_lock_x_confirm</a>(hash_lock, (buf_pool)-&gt;page_hash, (page_id).fold())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21b68e3f5394838fecf6b6b30ab96002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b68e3f5394838fecf6b6b30ab96002">&#9670;&nbsp;</a></span>buf_page_mutex_enter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_mutex_enter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                          \</div><div class="line">    mutex_enter(&amp;(b)-&gt;<a class="code" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">mutex</a>);   \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="memcached_8c_html_a4acff8232e4aec9cd5c6dc200ac55ef3"><div class="ttname"><a href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">mutex</a></div><div class="ttdeci">pthread_mutex_t mutex</div><div class="ttdef"><b>Definition:</b> memcached.c:384</div></div>
</div><!-- fragment -->
<p>Acquire the block-&gt;mutex. </p>

</div>
</div>
<a id="aff4f35eac88b4c16f4c2afab52f4d814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4f35eac88b4c16f4c2afab52f4d814">&#9670;&nbsp;</a></span>buf_page_mutex_exit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_mutex_exit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                         \</div><div class="line">    (b)-&gt;<a class="code" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">mutex</a>.exit();         \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="memcached_8c_html_a4acff8232e4aec9cd5c6dc200ac55ef3"><div class="ttname"><a href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">mutex</a></div><div class="ttdeci">pthread_mutex_t mutex</div><div class="ttdef"><b>Definition:</b> memcached.c:384</div></div>
</div><!-- fragment -->
<p>Release the block-&gt;mutex. </p>

</div>
</div>
<a id="a9aea2e675f73b98f3b0bd94736801400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aea2e675f73b98f3b0bd94736801400">&#9670;&nbsp;</a></span>buf_page_mutex_own</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_mutex_own</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;(b)-&gt;mutex.is_owned()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if block-&gt;mutex is owned. </p>

</div>
</div>
<a id="a8164aaa09f898842fd978f6fd4797cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8164aaa09f898842fd978f6fd4797cfc">&#9670;&nbsp;</a></span>BUF_PAGE_STATE_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_PAGE_STATE_BITS&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The common buffer control block structure for compressed and uncompressed frames. </p>
<p>Number of bits used for buffer page states. </p>

</div>
</div>
<a id="a2825012ee2e6d2e64a0337bbc39228c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2825012ee2e6d2e64a0337bbc39228c4">&#9670;&nbsp;</a></span>buf_page_try_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_try_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#aba2805ff54abe4adb4a918c41a2f9ed0">buf_page_try_get_func</a>((page_id), __FILE__, __LINE__, mtr);</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a tablespace id and page number tries to get that page. </p>
<p>If the page is not in the buffer pool it is not loaded and NULL is returned. Suitable for using when holding the lock_sys latches (as it avoids deadlock). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the page if in buffer pool, NULL if not </dd></dl>

</div>
</div>
<a id="a43a4f552119eafa1c0c2b71404c50ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a4f552119eafa1c0c2b71404c50ebe">&#9670;&nbsp;</a></span>BUF_POOL_WATCH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_POOL_WATCH_SIZE&#160;&#160;&#160;(<a class="el" href="srv0srv_8cc.html#ad28cf2cf2828cfd8ac09b3c3dc109dd7">srv_n_purge_threads</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of concurrent buffer pool watches. </p>

</div>
</div>
<a id="a9c028eac069f92725d6fef2d502c33bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c028eac069f92725d6fef2d502c33bb">&#9670;&nbsp;</a></span>BUF_POOL_ZIP_FOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_POOL_ZIP_FOLD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#acf241fbcf516b9cd38017fbf9a7d211b">BUF_POOL_ZIP_FOLD_PTR</a>((b)-&gt;frame)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ca27db7bba7c227b5a7b2f02ee5a8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca27db7bba7c227b5a7b2f02ee5a8f0">&#9670;&nbsp;</a></span>BUF_POOL_ZIP_FOLD_BPAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_POOL_ZIP_FOLD_BPAGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a9c028eac069f92725d6fef2d502c33bb">BUF_POOL_ZIP_FOLD</a>((<a class="el" href="structbuf__block__t.html">buf_block_t</a> *)(b))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf241fbcf516b9cd38017fbf9a7d211b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf241fbcf516b9cd38017fbf9a7d211b">&#9670;&nbsp;</a></span>BUF_POOL_ZIP_FOLD_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_POOL_ZIP_FOLD_PTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;((ulint)(ptr) / UNIV_PAGE_SIZE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the hash fold value for blocks in buf_pool-&gt;zip_hash. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa6098ccc0d0f4a65b3bdfcb0d430ba46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6098ccc0d0f4a65b3bdfcb0d430ba46">&#9670;&nbsp;</a></span>buf_page_print_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46">buf_page_print_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa6098ccc0d0f4a65b3bdfcb0d430ba46a4de99c6b59acbd5c2aa46fd0632cb281"></a>BUF_PAGE_PRINT_NO_CRASH&#160;</td><td class="fielddoc"><p>Do not crash at the end of buf_page_print(). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6098ccc0d0f4a65b3bdfcb0d430ba46a476478124a1ec5bbf5faa153d2ff4763"></a>BUF_PAGE_PRINT_NO_FULL&#160;</td><td class="fielddoc"><p>Do not print the full page dump. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab8edfb8ad98167f82518879ade67dc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8edfb8ad98167f82518879ade67dc8a">&#9670;&nbsp;</a></span>buf_page_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>States of a control block. </p>
<dl class="section see"><dt>See also</dt><dd>buf_page_t</dd></dl>
<p>The enumeration values must be 0..7. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aaa5d948d8c9ee109afa2f2b05672a3930"></a>BUF_BLOCK_POOL_WATCH&#160;</td><td class="fielddoc"><p>a sentinel for the buffer pool watch, element of buf_pool-&gt;watch[] </p>
</td></tr>
<tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aa21e9fab74d2c9e64609dd53570bdfaec"></a>BUF_BLOCK_ZIP_PAGE&#160;</td><td class="fielddoc"><p>contains a clean compressed page </p>
</td></tr>
<tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aa9135ba69991c7e4a4943f289de621509"></a>BUF_BLOCK_ZIP_DIRTY&#160;</td><td class="fielddoc"><p>contains a compressed page that is in the buf_pool-&gt;flush_list </p>
</td></tr>
<tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c"></a>BUF_BLOCK_NOT_USED&#160;</td><td class="fielddoc"><p>is in the free list; must be after the BUF_BLOCK_ZIP_ constants for compressed-only pages </p>
<dl class="section see"><dt>See also</dt><dd>buf_block_state_valid() </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aad5dffb35305e497c0afd120525221d18"></a>BUF_BLOCK_READY_FOR_USE&#160;</td><td class="fielddoc"><p>when buf_LRU_get_free_block returns a block, it is in this state </p>
</td></tr>
<tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aaf26cdfc58e629f98cf27da284f6cf5f9"></a>BUF_BLOCK_FILE_PAGE&#160;</td><td class="fielddoc"><p>contains a buffered file page </p>
</td></tr>
<tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aa7278567ff34beb6c693af5267611c4c7"></a>BUF_BLOCK_MEMORY&#160;</td><td class="fielddoc"><p>contains some main memory object </p>
</td></tr>
<tr><td class="fieldname"><a id="ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87"></a>BUF_BLOCK_REMOVE_HASH&#160;</td><td class="fielddoc"><p>hash index should be removed before putting to the free list </p>
</td></tr>
</table>

</div>
</div>
<a id="a0056c362020ff9e840fb48cb94c3cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0056c362020ff9e840fb48cb94c3cdba">&#9670;&nbsp;</a></span>Cache_hint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdba">Cache_hint</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0056c362020ff9e840fb48cb94c3cdbaa81e42709eb1489ed9631277fd401e145"></a>MAKE_YOUNG&#160;</td><td class="fielddoc"><p>Move the block to the start of the LRU list if there is a danger that the block would drift out of the buffer pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0056c362020ff9e840fb48cb94c3cdbaaea4620022ddce35b312d7b4b01986f7a"></a>KEEP_OLD&#160;</td><td class="fielddoc"><p>Preserve the current LRU position of the block. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa4ef74186b9c9937976a7d022cfa12c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ef74186b9c9937976a7d022cfa12c7">&#9670;&nbsp;</a></span>Page_fetch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa4ef74186b9c9937976a7d022cfa12c7a1e23852820b9154316c7c06e2b7ba051"></a>NORMAL&#160;</td><td class="fielddoc"><p>Get always. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4ef74186b9c9937976a7d022cfa12c7ae0740abfbc61bc2be0bfa78af61106ae"></a>SCAN&#160;</td><td class="fielddoc"><p>Same as NORMAL, but hint that the fetch is part of a large scan. </p>
<p>Try not to flood the buffer pool with pages that may not be accessed again any time soon. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4ef74186b9c9937976a7d022cfa12c7a3a90632a36734db3b6482458ab6197ae"></a>IF_IN_POOL&#160;</td><td class="fielddoc"><p>get if in pool </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4ef74186b9c9937976a7d022cfa12c7aa3d31b8fe6ab7ba91ca6d2f934150826"></a>PEEK_IF_IN_POOL&#160;</td><td class="fielddoc"><p>get if in pool, do not make the block young in the LRU list </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4ef74186b9c9937976a7d022cfa12c7a04e9d1744b4cb952e0c2021136069e86"></a>NO_LATCH&#160;</td><td class="fielddoc"><p>get and bufferfix, but set no latch; we have separated this case, because it is error-prone programming not to set a latch, and it should be used with care </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4ef74186b9c9937976a7d022cfa12c7a7ff1c3a50401e64e0178615f364354eb"></a>IF_IN_POOL_OR_WATCH&#160;</td><td class="fielddoc"><p>Get the page only if it's in the buffer pool, if not then set a watch on the page. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4ef74186b9c9937976a7d022cfa12c7adfb541c10aa7ca324ca213508638d3f1"></a>POSSIBLY_FREED&#160;</td><td class="fielddoc"><p>Like Page_fetch::NORMAL, but do not mind if the file page has been freed. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adbbea556516137bbb04568f60d7811e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbea556516137bbb04568f60d7811e3">&#9670;&nbsp;</a></span>buf_block_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>own: the allocated block, in state BUF_BLOCK_MEMORY in: buffer pool instance, or NULL for round-robin selection of the buffer pool</dd>
<dd>
own: the allocated block, in state BUF_BLOCK_MEMORY </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance, or NULL for round-robin selection of the buffer pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac193f180fc2dea1a6daf0a133e4977b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac193f180fc2dea1a6daf0a133e4977b">&#9670;&nbsp;</a></span>buf_block_buf_fix_inc_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_buf_fix_inc_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>line </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>block to bufferfix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53726080a6bcf5cd75f80580f5691ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53726080a6bcf5cd75f80580f5691ecc">&#9670;&nbsp;</a></span>buf_block_dbg_add_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_dbg_add_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89">latch_level_t</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds latch level info for the rw-lock protecting the buffer frame. </p>
<p>This should be called in the debug version after a successful latching of a page if we know the latching order level of the acquired latch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer page where we have acquired latch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>latching order level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c883f056d7d3c54a5822c201d740c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c883f056d7d3c54a5822c201d740c66">&#9670;&nbsp;</a></span>buf_block_fix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>block to bufferfix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the count </dd></dl>

</div>
</div>
<a id="afcf63abba3006f5fb7da5141a3bc9fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf63abba3006f5fb7da5141a3bc9fd9">&#9670;&nbsp;</a></span>buf_block_fix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>block to bufferfix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the count </dd></dl>

</div>
</div>
<a id="a58d8810e5f830e55bdf31da6b88972ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d8810e5f830e55bdf31da6b88972ea">&#9670;&nbsp;</a></span>buf_block_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a buffer block which does not contain a file page. </p>
<p>in, own: block to be freed </p>

</div>
</div>
<a id="ac2e67247bf34c56e00cfe1915c47abf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e67247bf34c56e00cfe1915c47abf0">&#9670;&nbsp;</a></span>buf_block_from_ahi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_from_ahi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a buffer block from an adaptive hash index pointer. </p>
<p>This function does not return if the block is not identified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to within a page frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block, never NULL </dd></dl>

</div>
</div>
<a id="a95db363e6bf7655c69a903397199b780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95db363e6bf7655c69a903397199b780">&#9670;&nbsp;</a></span>buf_block_get_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a>* buf_block_get_frame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the memory frame of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the frame </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6655833718a3258748ac2298522ca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6655833718a3258748ac2298522ca5d">&#9670;&nbsp;</a></span>buf_block_get_freed_page_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_get_freed_page_clock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the freed_page_clock of a buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>freed_page_clock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a804b0c6399074d86f64a5db44f5e2799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804b0c6399074d86f64a5db44f5e2799">&#9670;&nbsp;</a></span>buf_block_get_io_fix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> buf_block_get_io_fix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the io_fix state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>io_fix state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb6664a53292fe81dc48dae70f935fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6664a53292fe81dc48dae70f935fe7">&#9670;&nbsp;</a></span>buf_block_get_io_fix_unlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> buf_block_get_io_fix_unlocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the io_fix state of a buffer block. </p>
<p>Does not assert that the buf_page_get_mutex() mutex is held, to be used in the cases where it is safe not to hold it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>pointer to the buffer block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>page io_fix state </dd></dl>

</div>
</div>
<a id="a3c62e03b3e645bd91b960dcfcc4cabc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c62e03b3e645bd91b960dcfcc4cabc0">&#9670;&nbsp;</a></span>buf_block_get_lock_hash_val()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_get_lock_hash_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the hash value of a block. </p>
<p>This can be used in searches in the lock hash table. </p><dl class="section return"><dt>Returns</dt><dd>lock hash value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a753ac8867abc2d85156cccf714926bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753ac8867abc2d85156cccf714926bc6">&#9670;&nbsp;</a></span>buf_block_get_modify_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE uint64_t buf_block_get_modify_clock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the modify clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>modify_clock value </dd></dl>

</div>
</div>
<a id="a256d09dc81942591a6d51ebcb7c16214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256d09dc81942591a6d51ebcb7c16214">&#9670;&nbsp;</a></span>buf_block_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> buf_block_get_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab806a1ce0a4b83b733b9b97da5691f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab806a1ce0a4b83b733b9b97da5691f47">&#9670;&nbsp;</a></span>buf_block_hash_get_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_hash_get_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> **&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the control block of a file page, NULL if not found. </p>
<p>If the block is found and lock is not NULL then the appropriate page_hash lock is acquired in the specified lock mode. Otherwise, mode value is ignored. It is up to the caller to release the lock. If the block is found and the lock is NULL then the page_hash lock is released by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>lock of the page hash acquired if bpage is found, NULL otherwise. If NULL is passed then the hash_lock is released by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_mode</td><td>RW_LOCK_X or RW_LOCK_S. Ignored if lock == NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL; if NULL, lock is also NULL. </dd></dl>

</div>
</div>
<a id="aab0fe6ab9881b94fe49c82d25dbe819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0fe6ab9881b94fe49c82d25dbe819a">&#9670;&nbsp;</a></span>buf_block_modify_clock_inc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_modify_clock_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the modify clock. </p>
<p>The caller must (1) own the buf_pool-&gt;mutex and block bufferfix count has to be zero, (2) own X or SX latch on the block-&gt;lock, or (3) operate on a thread-private temporary table </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb15cdb046edd4db173179de22266e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb15cdb046edd4db173179de22266e71">&#9670;&nbsp;</a></span>buf_block_set_file_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_set_file_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a block to a file page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>pointer to control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a427515122e86a7b344f79896801f30cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427515122e86a7b344f79896801f30cb">&#9670;&nbsp;</a></span>buf_block_set_io_fix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_set_io_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td>
          <td class="paramname"><em>io_fix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the io_fix state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_fix</td><td>io_fix state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a542cb040a75435f73008c7009d9a908b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542cb040a75435f73008c7009d9a908b">&#9670;&nbsp;</a></span>buf_block_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>pointer to control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ab7e6bcd7b2f7b163bc40dd76b08b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab7e6bcd7b2f7b163bc40dd76b08b8c">&#9670;&nbsp;</a></span>buf_block_unfix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_unfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>block to bufferunfix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remaining buffer-fix count </dd></dl>

</div>
</div>
<a id="a5bc7ec91ea2590cce4a1a90e7b51fee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc7ec91ea2590cce4a1a90e7b51fee9">&#9670;&nbsp;</a></span>buf_block_unfix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_unfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>block to bufferunfix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remaining buffer-fix count </dd></dl>

</div>
</div>
<a id="a9ca75ba503d2ad232adbff2b0585bc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca75ba503d2ad232adbff2b0585bc66">&#9670;&nbsp;</a></span>buf_block_will_withdrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_block_will_withdrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a block is intended to be withdrawn. </p>
<p>The caller must ensure that there was a sufficient memory barrier to read curr_size and old_size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>pointer to control block </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if will be withdrawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1eec07edc8c41c7b8d17b0053f28ffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eec07edc8c41c7b8d17b0053f28ffee">&#9670;&nbsp;</a></span>buf_flush_update_zip_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_update_zip_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>skip_lsn_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the checksum of a page from compressed table and update the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page</td><td>page to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>compressed page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn</td><td>LSN to stamp on the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_lsn_check</td><td>true to skip check for lsn (in DEBUG) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac0ec477ed8bba5d447e069f5ac6d31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0ec477ed8bba5d447e069f5ac6d31b">&#9670;&nbsp;</a></span>buf_frame_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a>* buf_frame_align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70c8e79f9fad932a3f06f1edf84c2147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c8e79f9fad932a3f06f1edf84c2147">&#9670;&nbsp;</a></span>buf_frame_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* buf_frame_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies contents of a buffer frame to a given buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>buffer to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>buffer frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buf </dd></dl>

</div>
</div>
<a id="a2d4f29f5614d709fd4fceb970ebd19be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4f29f5614d709fd4fceb970ebd19be">&#9670;&nbsp;</a></span>buf_frame_will_withdrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_frame_will_withdrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a frame is intended to be withdrawn. </p>
<p>The caller must ensure that there was a sufficient memory barrier to read curr_size and old_size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to a frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if will be withdrawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8489d00ae3045b2d4207ba0eece8e966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8489d00ae3045b2d4207ba0eece8e966">&#9670;&nbsp;</a></span>buf_get_free_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_get_free_list_len </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current length of the free list of buffer blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>length of the free list </dd></dl>

</div>
</div>
<a id="a8bb34869722879443008e408b4ae6eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb34869722879443008e408b4ae6eb8">&#9670;&nbsp;</a></span>buf_get_latched_pages_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_get_latched_pages_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of latched pages in the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of latched pages</dd></dl>
<p>Returns the number of latched pages in the buffer pool.</p>
<dl class="section return"><dt>Returns</dt><dd>number of latched pages </dd></dl>

</div>
</div>
<a id="adee530ab11507348f9c9e303341634b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee530ab11507348f9c9e303341634b7">&#9670;&nbsp;</a></span>buf_get_modified_ratio_pct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double buf_get_modified_ratio_pct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>modified page percentage ratio</dd></dl>
<p>Return the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool.</p>
<dl class="section return"><dt>Returns</dt><dd>modified page percentage ratio </dd></dl>

</div>
</div>
<a id="a10701cd6691bc47c29bf117375fccc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10701cd6691bc47c29bf117375fccc14">&#9670;&nbsp;</a></span>buf_get_n_pending_read_ios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_get_n_pending_read_ios </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of pending buf pool read ios. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pending read I/O operations </dd></dl>

</div>
</div>
<a id="adfcde42037dc3ee66cfe5e74fad1c015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcde42037dc3ee66cfe5e74fad1c015">&#9670;&nbsp;</a></span>buf_get_nth_chunk_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_get_nth_chunk_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nth chunk's buffer block in the specified buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>nth chunk in the buffer pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk_size</td><td>chunk_size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth chunk's buffer block. </dd></dl>

</div>
</div>
<a id="afc7560004e8ceba1e2a2089bd67371bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7560004e8ceba1e2a2089bd67371bd">&#9670;&nbsp;</a></span>buf_get_total_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_get_total_list_len </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>LRU_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>free_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>flush_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total buffer pool statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">LRU_len</td><td>Length of all lru lists </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">free_len</td><td>Length of all free lists </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flush_list_len</td><td>Length of all flush lists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7dd922a4f122cd1870fbc8cdec76620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7dd922a4f122cd1870fbc8cdec76620">&#9670;&nbsp;</a></span>buf_get_total_list_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_get_total_list_size_in_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pools_list_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total list size in bytes from all buffer pools. </p>
<p>out: list sizes in all buffer pools</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pools_list_size</td><td>out: list sizes in all buffer pools </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a451851befdfc82765a869314cdd073e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451851befdfc82765a869314cdd073e6">&#9670;&nbsp;</a></span>buf_get_total_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_get_total_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *&#160;</td>
          <td class="paramname"><em>tot_stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total buffer pool statistics. </p>
<p>out: buffer pool stats</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tot_stat</td><td>out: buffer pool stats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84c4d4c43ce1afcad91d6011e73f9b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c4d4c43ce1afcad91d6011e73f9b32">&#9670;&nbsp;</a></span>buf_get_withdraw_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_get_withdraw_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return how many more pages must be added to the withdraw list to reach the withdraw target of the currently ongoing buffer pool resize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>page count to be withdrawn or zero if the target is already achieved or if the buffer pool is not currently being resized. </dd></dl>

</div>
</div>
<a id="a7c0cbe211bba9dba91be1e38e584e18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0cbe211bba9dba91be1e38e584e18f">&#9670;&nbsp;</a></span>buf_is_block_in_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_is_block_in_instance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if a block pointer points into one of currently used chunks of the buffer pool. </p>
<p>This is useful if you stored the pointer some time ago, and want to dereference it now, and are afraid that buffer pool resize could free the memory pointed by it. Thus calling this function requires holding at least one of the latches which prevent freeing memory from buffer pool for the duration of the call and until you pin the block in some other way, as otherwise the result of this function might be obsolete by the time you dereference the block (an s-latch on buf_page_hash_lock_get for any bucket is enough). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>The buffer pool instance to search in. </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer which you want to check. This function will not dereference it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <code>block</code> points inside one of the chunks of the <code>buf_pool</code> </dd></dl>

</div>
</div>
<a id="aa4cbbcf6846efae5345f9e560e02fe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cbbcf6846efae5345f9e560e02fe1c">&#9670;&nbsp;</a></span>buf_must_be_all_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_must_be_all_freed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert that all file pages in the buffer are in a replaceable state. </p>
<p>Assert that all file pages in the buffer are in a replaceable state. </p>

</div>
</div>
<a id="a151abcd0889ef3034dda470c29fa1da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151abcd0889ef3034dda470c29fa1da8">&#9670;&nbsp;</a></span>buf_page_alloc_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_alloc_descriptor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buf_page_t descriptor. </p>
<p>This function must succeed. In case of failure we assert in this function. </p>

</div>
</div>
<a id="a7098349ef19391fcdeff149b55dac652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7098349ef19391fcdeff149b55dac652">&#9670;&nbsp;</a></span>buf_page_belongs_to_unzip_LRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_belongs_to_unzip_LRU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a block should be on unzip_LRU list. </p>
<dl class="section return"><dt>Returns</dt><dd>true if block belongs to unzip_LRU </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c37514bc246843091d871cea64e91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c37514bc246843091d871cea64e91a">&#9670;&nbsp;</a></span>buf_page_can_relocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool buf_page_can_relocate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a buffer block can be relocated in memory. </p>
<p>The block can be dirty, but it must not be I/O-fixed or bufferfixed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>control block being relocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86d8481358bda6d6826d9b997ce51c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d8481358bda6d6826d9b997ce51c16">&#9670;&nbsp;</a></span>buf_page_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a>&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a page to the buffer buf_pool. </p>
<p>The page is usually not read from a file even if it cannot be found in the buffer buf_pool. This is one of the functions which perform to a block a state transition NOT_USED =&gt; FILE_PAGE (the other is buf_page_get_gen). The page is latched by passed mtr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_SX_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block, page bufferfixed </dd></dl>

</div>
</div>
<a id="a5ded0d8f7e73903ef9aeb7fe4dd9b611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ded0d8f7e73903ef9aeb7fe4dd9b611">&#9670;&nbsp;</a></span>buf_page_free_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_free_descriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a buf_page_t descriptor. </p>
<p>in: bpage descriptor to free. </p>

</div>
</div>
<a id="ae275396b7f480b0bf26e0b9f400a97a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae275396b7f480b0bf26e0b9f400a97a3">&#9670;&nbsp;</a></span>buf_page_get_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_get_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the buf_block_t handle of a buffered file block if an uncompressed page frame exists, or NULL. </p>
<p>page frame exists, or NULL. The caller must hold either the appropriate hash lock in any mode, either the LRU list mutex. Note: even though bpage is not declared a const we don't update its value. It is safe to make this pure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block, or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>control block, or NULL </dd></dl>

</div>
</div>
<a id="a9d8e9065bf85e7b6806022c563129da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8e9065bf85e7b6806022c563129da1">&#9670;&nbsp;</a></span>buf_page_get_flush_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> buf_page_get_flush_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flush type of a page. </p>
<dl class="section return"><dt>Returns</dt><dd>flush type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68ddc2d256f3d1821fce3f306ee61e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ddc2d256f3d1821fce3f306ee61e62">&#9670;&nbsp;</a></span>buf_page_get_freed_page_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_page_get_freed_page_clock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the freed_page_clock of a buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>freed_page_clock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32111f6e94a1745e1750bcbfe96600f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32111f6e94a1745e1750bcbfe96600f9">&#9670;&nbsp;</a></span>buf_page_get_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_get_gen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dirty_with_no_latch</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the general function used to get access to a database page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guess</td><td>Guessed block or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Fetch mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirty_with_no_latch</td><td>Mark page as dirty even if page is being pinned without any latch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL </dd></dl>

</div>
</div>
<a id="a66b510251a5c2ba00d420c57ff16c223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b510251a5c2ba00d420c57ff16c223">&#9670;&nbsp;</a></span>buf_page_get_io_fix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> buf_page_get_io_fix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the io_fix state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>io_fix state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb376da0136a9ced31021c6137359d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb376da0136a9ced31021c6137359d6e">&#9670;&nbsp;</a></span>buf_page_get_io_fix_unlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> buf_page_get_io_fix_unlocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the io_fix state of a buffer page. </p>
<p>Does not assert that the buf_page_get_mutex() mutex is held, to be used in the cases where it is safe not to hold it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the buffer page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>page io_fix state </dd></dl>

</div>
</div>
<a id="ab1c9e8bd857ceefd7ea974ab65c84a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c9e8bd857ceefd7ea974ab65c84a85">&#9670;&nbsp;</a></span>buf_page_get_known_nowait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_get_known_nowait </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdba">Cache_hint</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to get access to a known database page, when no waiting can be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_S_LATCH or RW_X_LATCH. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>The known page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>Cache_hint::MAKE_YOUNG or Cache_hint::KEEP_OLD </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name from where it was called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line from where it was called. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction covering the fetch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>

</div>
</div>
<a id="a2fa5baa88e1ce986b7308ab72453ca0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa5baa88e1ce986b7308ab72453ca0b">&#9670;&nbsp;</a></span>buf_page_get_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="buf0types_8h.html#a728dccae958dd22a0f7ddd16cf6e4f0a">BPageMutex</a>* buf_page_get_mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mutex of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to mutex protecting bpage </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5df3bda5bcc128a66ddb88607f7aa7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df3bda5bcc128a66ddb88607f7aa7fc">&#9670;&nbsp;</a></span>buf_page_get_newest_modification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_page_get_newest_modification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the youngest modification log sequence number for a frame. </p>
<p>Returns zero if not file page or no modification occurred yet. </p><dl class="section return"><dt>Returns</dt><dd>newest modification to page in: block containing the page frame </dd></dl>

</div>
</div>
<a id="a4a99189b090a1af68ff81b98b5418a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a99189b090a1af68ff81b98b5418a0f">&#9670;&nbsp;</a></span>buf_page_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> buf_page_get_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>state in: pointer to the control block </dd></dl>

</div>
</div>
<a id="a7a1b136191a6e34494318af4a7066b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1b136191a6e34494318af4a7066b64">&#9670;&nbsp;</a></span>buf_page_get_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_get_zip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get read access to a compressed page (usually of type FIL_PAGE_TYPE_ZBLOB or FIL_PAGE_TYPE_ZBLOB2). </p>
<p>The page must be released with buf_page_release_zip(). NOTE: the page is not protected by any latch. Mutual exclusion has to be implemented at a higher level. In other words, all possible accesses to a given page through this function must be protected by the same set of mutexes or latches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block </dd></dl>

</div>
</div>
<a id="ae6ee95652b3ae571a6e4274a08d9a2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ee95652b3ae571a6e4274a08d9a2c7">&#9670;&nbsp;</a></span>buf_page_hash_get_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_hash_get_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> **&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>watch</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the control block of a file page, NULL if not found. </p>
<p>If the block is found and lock is not NULL then the appropriate page_hash lock is acquired in the specified lock mode. Otherwise, mode value is ignored. It is up to the caller to release the lock. If the block is found and the lock is NULL then the page_hash lock is released by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>lock of the page hash acquired if bpage is found, NULL otherwise. If NULL is passed then the hash_lock is released by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_mode</td><td>RW_LOCK_X or RW_LOCK_S. Ignored if lock == NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">watch</td><td>if true, return watch sentinel also. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the bpage or NULL; if NULL, lock is also NULL or a watch sentinel. </dd></dl>

</div>
</div>
<a id="aa3b0eac921442eec0314115147c85a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b0eac921442eec0314115147c85a17">&#9670;&nbsp;</a></span>buf_page_hash_get_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_hash_get_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the control block of a file page, NULL if not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>block, NULL if not found </dd></dl>

</div>
</div>
<a id="ae7c7553b7d927c907ca28aa41640e856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c7553b7d927c907ca28aa41640e856">&#9670;&nbsp;</a></span>buf_page_in_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool buf_page_in_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a block is mapped to a tablespace. </p>
<dl class="section return"><dt>Returns</dt><dd>true if mapped </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2efca615726ffc1dfc6c2ed05612ccd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efca615726ffc1dfc6c2ed05612ccd0">&#9670;&nbsp;</a></span>buf_page_init_for_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_init_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>unzip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inits a page for read to the buffer buf_pool. </p>
<p>If the page is (1) already in buf_pool, or (2) if we specify to read only ibuf pages and the page is not an ibuf page, or (3) if the space is deleted or being deleted, then this function does nothing. Sets the io_fix flag to BUF_IO_READ and sets a non-recursive exclusive lock on the buffer frame. The io-handler must take care that the flag is cleared and the lock released later. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>DB_SUCCESS or DB_TABLESPACE_DELETED </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>BUF_READ_IBUF_PAGES_ONLY, ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unzip</td><td>TRUE=request uncompressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL </dd></dl>

</div>
</div>
<a id="a6fc2cc72f66548f1e67ad61e8e8769a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc2cc72f66548f1e67ad61e8e8769a1">&#9670;&nbsp;</a></span>buf_page_io_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_io_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>evict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes an asynchronous read or write request of a file page to or from the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evict</td><td>whether or not to evict the page from LRU list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a id="a9e8fef965c556246b887497dca782d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8fef965c556246b887497dca782d2a">&#9670;&nbsp;</a></span>buf_page_is_accessed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE unsigned buf_page_is_accessed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the time of first access of a block in the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>ut_time_monotonic_ms() at the time of first access, 0 if not accessed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d4fc8bd9c50f18fd1a93658e94d3d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4fc8bd9c50f18fd1a93658e94d3d87">&#9670;&nbsp;</a></span>buf_page_is_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool buf_page_is_old </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a block has been flagged old. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if old </dd></dl>

</div>
</div>
<a id="a9ce975aae00f09fe4f8d97d0b5fd2d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce975aae00f09fe4f8d97d0b5fd2d8f">&#9670;&nbsp;</a></span>buf_page_make_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_page_make_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moved a page to the end of the buffer pool LRU list so that it can be flushed out at the earliest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer block of a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ecef5e7084a885aa97d2aedb9a0fe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecef5e7084a885aa97d2aedb9a0fe6e">&#9670;&nbsp;</a></span>buf_page_make_young()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_page_make_young </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a page to the start of the buffer pool LRU list. </p>
<p>This high-level function can be used to prevent an important page from slipping out of the buffer pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>buffer block of a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a569b18490ab03d0b30a22dfd9f9fdb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569b18490ab03d0b30a22dfd9f9fdb07">&#9670;&nbsp;</a></span>buf_page_optimistic_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_optimistic_get </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modify_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a>&#160;</td>
          <td class="paramname"><em>fetch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the general function used to get optimistic access to a database page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_S_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>Guessed block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify_clock</td><td>Modify clock value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fetch_mode</td><td>Fetch mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>

</div>
</div>
<a id="a7da1bc96b9a28049d874d68d0ae61bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da1bc96b9a28049d874d68d0ae61bc3">&#9670;&nbsp;</a></span>buf_page_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool buf_page_peek </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the page can be found in the buffer pool hash table. </p>
<p>NOTE that it is possible that the page is not yet read from disk, though. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if found in the page hash table </dd></dl>

</div>
</div>
<a id="ac8bcc2e01e4ffe6abf420008166b1062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bcc2e01e4ffe6abf420008166b1062">&#9670;&nbsp;</a></span>buf_page_peek_if_too_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool buf_page_peek_if_too_old </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recommends a move of a block to the start of the LRU list if there is danger of dropping from the buffer pool. </p>
<p>NOTE: does not reserve the LRU list mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>block to make younger </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if should be made younger </dd></dl>

</div>
</div>
<a id="a47ffed634c26feb6e975600b553e48c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ffed634c26feb6e975600b553e48c5">&#9670;&nbsp;</a></span>buf_page_peek_if_young()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool buf_page_peek_if_young </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells, for heuristics, if a block is still close enough to the MRU end of the LRU list meaning that it is not in danger of getting evicted and also implying that it has been accessed recently. </p>
<p>The page must be either buffer-fixed, either its page hash must be locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if block is close to MRU end of LRU </dd></dl>

</div>
</div>
<a id="a0feb3f11f6a58e81598bf92d7b435500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0feb3f11f6a58e81598bf92d7b435500">&#9670;&nbsp;</a></span>buf_page_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_page_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a page to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_buf</td><td>a database page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>0 or BUF_PAGE_PRINT_NO_CRASH or BUF_PAGE_PRINT_NO_FULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a045569a1636618f36769cc39e18c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a045569a1636618f36769cc39e18c60">&#9670;&nbsp;</a></span>buf_page_release_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_release_latch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a latch, if specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ce5d2fc2911e993640a50d360670592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce5d2fc2911e993640a50d360670592">&#9670;&nbsp;</a></span>buf_page_release_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_release_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a compressed-only page acquired with buf_page_get_zip(). </p>
<p>in: buffer block </p>

</div>
</div>
<a id="ae3f64c5e7568dbfc7c7a868943f8c3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f64c5e7568dbfc7c7a868943f8c3f7">&#9670;&nbsp;</a></span>buf_page_reset_file_page_was_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_reset_file_page_was_freed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets file_page_was_freed FALSE if the page is found in the buffer pool. </p>
<p>This function should be called when we free a file page and want the debug version to check that it is not accessed any more unless reallocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>control block if found in page hash table, otherwise NULL </dd></dl>

</div>
</div>
<a id="a68cf52f3b3dfe8cfc91c77757b268034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cf52f3b3dfe8cfc91c77757b268034">&#9670;&nbsp;</a></span>buf_page_set_accessed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_accessed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag a block accessed. </p>
<p>in/out: control block </p>

</div>
</div>
<a id="aed26a402a24afefb51d6d7945647bd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed26a402a24afefb51d6d7945647bd30">&#9670;&nbsp;</a></span>buf_page_set_file_page_was_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_set_file_page_was_freed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets file_page_was_freed TRUE if the page is found in the buffer pool. </p>
<p>This function should be called when we free a file page and want the debug version to check that it is not accessed any more unless reallocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>control block if found in page hash table, otherwise NULL </dd></dl>

</div>
</div>
<a id="a53437d54ec990de81e9644d3ee6c4337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53437d54ec990de81e9644d3ee6c4337">&#9670;&nbsp;</a></span>buf_page_set_flush_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_flush_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flush type of a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>flush type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1a8f29ac35531394d5cc6abb4e7bc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a8f29ac35531394d5cc6abb4e7bc2a">&#9670;&nbsp;</a></span>buf_page_set_io_fix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_io_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td>
          <td class="paramname"><em>io_fix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the io_fix state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_fix</td><td>io_fix state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaf46d5fc3b73bc26bf115615fb81d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf46d5fc3b73bc26bf115615fb81d0d">&#9670;&nbsp;</a></span>buf_page_set_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag a block old. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old</td><td>old </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38ae1a9052817ce692827243ce970d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ae1a9052817ce692827243ce970d3e">&#9670;&nbsp;</a></span>buf_page_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>pointer to control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafc6d1173140eb14d5ca4a83a62d0f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc6d1173140eb14d5ca4a83a62d0f4a">&#9670;&nbsp;</a></span>buf_page_set_sticky()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_sticky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a block sticky. </p>
<p>A sticky block implies that even after we release the buf_pool-&gt;LRU_list_mutex and the block-&gt;mutex: it cannot be removed from the flush_list the block descriptor cannot be relocated it cannot be removed from the LRU list Note that: the block can still change its position in the LRU list the next and previous pointers can change. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba2805ff54abe4adb4a918c41a2f9ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2805ff54abe4adb4a918c41a2f9ed0">&#9670;&nbsp;</a></span>buf_page_try_get_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_try_get_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a tablespace id and page number tries to get that page. </p>
<p>If the page is not in the buffer pool it is not loaded and NULL is returned. Suitable for using when holding the lock_sys latches (as it avoids deadlock). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a page or NULL </dd></dl>

</div>
</div>
<a id="ad9b8b75af8fa0ad4e4ebb7723ec8a215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b8b75af8fa0ad4e4ebb7723ec8a215">&#9670;&nbsp;</a></span>buf_page_unset_sticky()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_unset_sticky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes stickiness of a block. </p>
<p>in/out: control block </p>

</div>
</div>
<a id="a2fdc4c9f9a04819fb962432b2c0b8e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc4c9f9a04819fb962432b2c0b8e8f">&#9670;&nbsp;</a></span>buf_pool_adjust_chunk_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> buf_pool_adjust_chunk_unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the proposed chunk unit size so that it satisfies all invariants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>proposed size of buffer pool chunk unit in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjusted size which meets invariants </dd></dl>

</div>
</div>
<a id="ab0de522312135372e9204158db79f015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0de522312135372e9204158db79f015">&#9670;&nbsp;</a></span>buf_pool_check_no_pending_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_check_no_pending_io </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that there currently are no pending i/o-operations for the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pending i/o </dd></dl>

</div>
</div>
<a id="a42bed44f93d9f9850ad30d4900164174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bed44f93d9f9850ad30d4900164174">&#9670;&nbsp;</a></span>buf_pool_clear_hash_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_clear_hash_index </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adaptive hash index on all pages in the buffer pool. </p>

</div>
</div>
<a id="a8239011f74f17732794942ff891bfbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8239011f74f17732794942ff891bfbf3">&#9670;&nbsp;</a></span>buf_pool_contains_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_pool_contains_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a block in the buffer pool that points to a given compressed page. </p>
<p>Used only to confirm that buffer pool does not contain a given pointer, thus protected by zip_free_mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to compressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer block pointing to the compressed page, or NULL </dd></dl>

</div>
</div>
<a id="a7f3b9b346f49593dc6d435d4a88d6d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3b9b346f49593dc6d435d4a88d6d7f">&#9670;&nbsp;</a></span>buf_pool_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_free_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the buffer pool at shutdown. </p>
<p>This must not be invoked before freeing all mutexes.</p>
<p>Frees the buffer pool at shutdown. </p>

</div>
</div>
<a id="aac71426ec4d18966a8fa309954653b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac71426ec4d18966a8fa309954653b5e">&#9670;&nbsp;</a></span>buf_pool_from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_from_array </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer pool instance given its array index. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer pool in: array index to get buffer pool instance from </dd></dl>

</div>
</div>
<a id="a499d41dc7d50849f883c2b06c07dbb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499d41dc7d50849f883c2b06c07dbb02">&#9670;&nbsp;</a></span>buf_pool_from_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_from_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer pool instance given a block instance. </p>
<dl class="section return"><dt>Returns</dt><dd>buf_pool in: block </dd></dl>

</div>
</div>
<a id="a803b791d0706583d685f7f9413da45d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803b791d0706583d685f7f9413da45d7">&#9670;&nbsp;</a></span>buf_pool_from_bpage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_from_bpage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer pool instance given a page instance. </p>
<dl class="section return"><dt>Returns</dt><dd>buf_pool in: buffer pool page </dd></dl>

</div>
</div>
<a id="acfb7f2dc1c41995e06c47526e8774c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb7f2dc1c41995e06c47526e8774c6c">&#9670;&nbsp;</a></span>buf_pool_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer pool instance given a page id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer pool </dd></dl>

</div>
</div>
<a id="a23372a7fc86173052a9bfe927c9312b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23372a7fc86173052a9bfe927c9312b4">&#9670;&nbsp;</a></span>buf_pool_get_curr_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_pool_get_curr_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current size of buffer buf_pool in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>size in bytes </dd></dl>

</div>
</div>
<a id="acff3e4e95015baaa1740ff6098e6e164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff3e4e95015baaa1740ff6098e6e164">&#9670;&nbsp;</a></span>buf_pool_get_n_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_pool_get_n_pages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current size of buffer buf_pool in frames. </p>
<dl class="section return"><dt>Returns</dt><dd>size in pages </dd></dl>

</div>
</div>
<a id="aa18483f39367e4be86099560cd0cb938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18483f39367e4be86099560cd0cb938">&#9670;&nbsp;</a></span>buf_pool_get_oldest_modification_approx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_pool_get_oldest_modification_approx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the smallest oldest_modification lsn among all of the earliest added pages in flush lists. </p>
<p>In other words - takes the last dirty page from each flush list, and calculates minimum oldest_modification among all of them. Does not acquire global lock for the whole process, so the result might come from inconsistent view on flush lists.</p>
<dl class="section note"><dt>Note</dt><dd>Note that because of the relaxed order in each flush list, this functions no longer returns the smallest oldest_modification among all of the dirty pages. If you wanted to have a safe lsn, which is smaller than every oldest_modification, you would need to use another function: buf_pool_get_oldest_modification_lwm().</dd></dl>
<p>Returns zero if there were no dirty pages (flush lists were empty).</p>
<dl class="section return"><dt>Returns</dt><dd>minimum oldest_modification of last pages from flush lists, zero if flush lists were empty </dd></dl>

</div>
</div>
<a id="a274d89180ba0679ad7b31453f3dddbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274d89180ba0679ad7b31453f3dddbf6">&#9670;&nbsp;</a></span>buf_pool_get_oldest_modification_lwm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_pool_get_oldest_modification_lwm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a safe low watermark for oldest_modification. </p>
<p>It's guaranteed that there were no dirty pages with smaller oldest_modification in the whole flush lists.</p>
<p>Returns zero if flush lists were empty, be careful in such case, because taking the newest lsn is probably not a good idea. If you wanted to rely on some lsn in such case, you would need to follow pattern: </p><pre class="fragment">    dpa_lsn = log_buffer_dirty_pages_added_up_to_lsn(*log_sys);

    lwm_lsn = buf_pool_get_oldest_modification_lwm();

    if (lwm_lsn == 0) lwm_lsn = dpa_lsn;
</pre><p>The order is important to avoid race conditions.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It's guaranteed that the returned value will not be smaller than the last checkpoint lsn. It's not guaranteed that the returned value is the maximum possible. It's just the best effort for the low cost. It basically takes result of buf_pool_get_oldest_modification_approx() and subtracts maximum possible lag introduced by relaxed order in flush lists (srv_log_recent_closed_size).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>safe low watermark for oldest_modification of dirty pages, or zero if flush lists were empty; if non-zero, it is then guaranteed not to be at block boundary (and it points to lsn inside data fragment of block) </dd></dl>

</div>
</div>
<a id="a883be2e9c1c6795751c4b076708c7a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883be2e9c1c6795751c4b076708c7a32">&#9670;&nbsp;</a></span>buf_pool_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_pool_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the index of a buffer pool to the buf_pool[] array. </p>
<dl class="section return"><dt>Returns</dt><dd>the position of the buffer pool in buf_pool[] </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ec7d5de1f91e878e799748d903fb71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec7d5de1f91e878e799748d903fb71b">&#9670;&nbsp;</a></span>buf_pool_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> buf_pool_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>total_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">total_size</td><td>Size of the total pool in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_instances</td><td>Number of buffer pool instances to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if success, DB_ERROR if not enough memory or error </dd></dl>

</div>
</div>
<a id="ad4cee70fe0ea742c8a909aaa3bce3f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cee70fe0ea742c8a909aaa3bce3f59">&#9670;&nbsp;</a></span>buf_pool_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_invalidate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates the file pages in the buffer pool when an archive recovery is completed. </p>
<p>All the file pages buffered must be in a replaceable state when this function is called: not latched and not modified. </p>

</div>
</div>
<a id="a3ce21ecd74468bc2e0e2a33cf5a2ca2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce21ecd74468bc2e0e2a33cf5a2ca2a">&#9670;&nbsp;</a></span>buf_pool_size_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_pool_size_align </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate aligned buffer pool size based on srv_buf_pool_chunk_unit, if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>aligned size </dd></dl>

</div>
</div>
<a id="a2ee39fa7dde2fd24069257650c8c73e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee39fa7dde2fd24069257650c8c73e2">&#9670;&nbsp;</a></span>buf_pool_update_madvise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_update_madvise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if innobase_should_madvise_buf_pool() value has changed since we've last check and if so, then updates buf_pool_should_madvise and calls madvise for all chunks in all srv_buf_pool_instances. </p>
<dl class="section see"><dt>See also</dt><dd>buf_pool_should_madvise comment for a longer explanation. </dd></dl>

</div>
</div>
<a id="ae799641f6fffb0ac145542154be08361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae799641f6fffb0ac145542154be08361">&#9670;&nbsp;</a></span>buf_pool_watch_is_sentinel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_pool_watch_is_sentinel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a block is a sentinel for a buffer pool watch. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a sentinel for a buffer pool watch, false if not</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a sentinel for a buffer pool watch, false if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35b6dd3b80c03a713c7f160611d00455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b6dd3b80c03a713c7f160611d00455">&#9670;&nbsp;</a></span>buf_pool_watch_occurred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_pool_watch_occurred </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the page has been read in. </p>
<p>This may only be called after buf_pool_watch_set(same_page_id) has returned NULL and before invoking buf_pool_watch_unset(same_page_id). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the given page was not read in, true if it was </dd></dl>

</div>
</div>
<a id="a607741f6ab261487ea1e2efef4d7640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607741f6ab261487ea1e2efef4d7640e">&#9670;&nbsp;</a></span>buf_pool_watch_unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_watch_unset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop watching if the page has been read in. </p>
<p>buf_pool_watch_set(same_page_id) must have returned NULL before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9913c2499ec503eea58a7dbb0c6b93d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913c2499ec503eea58a7dbb0c6b93d8">&#9670;&nbsp;</a></span>buf_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of the buffer pool data structure. </p>
<p>Prints info of the buffer pool data structure. </p>

</div>
</div>
<a id="a940342731a901c4a6171de07be118f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940342731a901c4a6171de07be118f57">&#9670;&nbsp;</a></span>buf_print_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_print_io </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of the buffer i/o. </p>
<p>in: file where to print</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in/out: buffer where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad3db5496a7456973ce1be9ec882910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad3db5496a7456973ce1be9ec882910">&#9670;&nbsp;</a></span>buf_ptr_get_fsp_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_ptr_get_fsp_addr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__addr__t.html">fil_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the space id, page offset, and byte offset within page of a pointer pointing to a buffer frame containing a file page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to a buffer frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">space</td><td>space id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>page offset and byte offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a753d780aa84a242710866eed7bcc32c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753d780aa84a242710866eed7bcc32c0">&#9670;&nbsp;</a></span>buf_read_page_handle_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_read_page_handle_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unfixes the page, unlatches the page, removes it from page_hash and removes it from LRU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>pointer to the block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5e1620a9a0c049c739b9e426bd7802e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e1620a9a0c049c739b9e426bd7802e">&#9670;&nbsp;</a></span>buf_refresh_io_stats_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_refresh_io_stats_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh the statistics used to print per-second averages. </p>
<p>Refresh the statistics used to print per-second averages. </p>

</div>
</div>
<a id="a9781b154f5eb92bbc15d0c4538e46124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9781b154f5eb92bbc15d0c4538e46124">&#9670;&nbsp;</a></span>buf_resize_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_resize_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the thread for resizing buffer pool. </p>
<p>It waits for an event and when waked up either performs a resizing and sleeps again. </p>

</div>
</div>
<a id="a94add70baf8e2ee67299e346bbb47965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94add70baf8e2ee67299e346bbb47965">&#9670;&nbsp;</a></span>buf_stats_get_pool_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_stats_get_pool_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pool_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>all_pool_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect buffer pool stats information for a buffer pool. </p>
<p>Also record aggregated stats if there are more than one buffer pool in the server in/out: buffer pool info to fill</p>
<p>Also record aggregated stats if there are more than one buffer pool in the server </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
    <tr><td class="paramname">pool_id</td><td>in: buffer pool ID </td></tr>
    <tr><td class="paramname">all_pool_info</td><td>in/out: buffer pool info to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5fa041692f236bcd8e2fd5e0a575fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fa041692f236bcd8e2fd5e0a575fbc">&#9670;&nbsp;</a></span>buf_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the buffer pool data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>true</dd></dl>
<p>Validates the buffer pool data structure.</p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a532b24c23776dee3f4a4635e38417378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532b24c23776dee3f4a4635e38417378">&#9670;&nbsp;</a></span>buf_zip_decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_zip_decompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompress a block. </p>
<dl class="section return"><dt>Returns</dt><dd>true if successful in: TRUE=verify the page checksum</dd>
<dd>
true if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: block </td></tr>
    <tr><td class="paramname">check</td><td>in: TRUE=verify the page checksum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7fefbabeb6b422a2baeae7758d16a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fefbabeb6b422a2baeae7758d16a7d">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the given buf_pool_t object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>the buf_pool_t object to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3fdf9e142c6096556e3722d7c91b9065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdf9e142c6096556e3722d7c91b9065">&#9670;&nbsp;</a></span>buf_pool_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The buffer pools of the database. </p>

</div>
</div>
<a id="a93370087448a1c0e6a3054d13ca0fb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93370087448a1c0e6a3054d13ca0fb81">&#9670;&nbsp;</a></span>MAX_BUFFER_POOLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ulint MAX_BUFFER_POOLS = (1 &lt;&lt; <a class="el" href="buf0buf_8h.html#aaa795024d029f835357042f72ee0611a">MAX_BUFFER_POOLS_BITS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of buffer pools that can be defined. </p>

</div>
</div>
<a id="aaa795024d029f835357042f72ee0611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa795024d029f835357042f72ee0611a">&#9670;&nbsp;</a></span>MAX_BUFFER_POOLS_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ulint MAX_BUFFER_POOLS_BITS = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits to representing a buffer pool ID. </p>

</div>
</div>
<a id="a55ea539fcc36f30147cb4ee2f7917049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ea539fcc36f30147cb4ee2f7917049">&#9670;&nbsp;</a></span>MAX_PAGE_HASH_LOCKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ulint MAX_PAGE_HASH_LOCKS = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of page_hash locks. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="buf0buf_8h.html">buf0buf.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
