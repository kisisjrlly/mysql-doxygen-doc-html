<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/ut0new.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ut0new_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ut0new.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Instrumented memory allocator.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cerrno&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &quot;<a class="el" href="my__basename_8h_source.html">my_basename.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mysql__memory_8h_source.html">mysql/psi/mysql_memory.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="psi__base_8h_source.html">mysql/psi/psi_base.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="psi_2psi__memory_8h_source.html">mysql/psi/psi_memory.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0proc_8h_source.html">os0proc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0thread_8h_source.html">os0thread.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0cpu__cache_8h_source.html">ut0cpu_cache.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0ut_8h_source.html">ut0ut.h</a>&quot;</code><br />
</div>
<p><a href="ut0new_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structforce__constexpr.html">force_constexpr&lt; Value &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structut__new__pfx__t.html">ut_new_pfx_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that holds the necessary data for performance schema accounting.  <a href="structut__new__pfx__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__allocator.html">ut_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator class for allocating memory from inside std::* containers.  <a href="classut__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structut__allocator_1_1rebind.html">ut_allocator&lt; T &gt;::rebind&lt; U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaligned__memory.html">aligned_memory&lt; T_Type, T_Align_to &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to manage an object that is aligned to specified number of bytes.  <a href="classaligned__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaligned__pointer.html">aligned_pointer&lt; T_Type, T_Align_to &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages an object that is aligned to specified number of bytes.  <a href="classaligned__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaligned__array__pointer.html">aligned_array_pointer&lt; T_Type, T_Align_to &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages an array of objects.  <a href="classaligned__array__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceut"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceut.html">ut</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1739e1d08fde086cc8bc759c6919a67f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a1739e1d08fde086cc8bc759c6919a67f">OUT_OF_MEMORY_MSG</a></td></tr>
<tr class="memdesc:a1739e1d08fde086cc8bc759c6919a67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic memory allocation within InnoDB guidelines.  <a href="#a1739e1d08fde086cc8bc759c6919a67f">More...</a><br /></td></tr>
<tr class="separator:a1739e1d08fde086cc8bc759c6919a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f13dad3569c561b4bd3dc14565088"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a624f13dad3569c561b4bd3dc14565088">UT_NEW_THIS_FILE_PSI_INDEX</a>&#160;&#160;&#160;(<a class="el" href="structforce__constexpr.html">force_constexpr</a>&lt;<a class="el" href="ut0new_8h.html#a64f326d67141dd93e7c9227b0922309c">ut_new_get_key_by_file</a>(<a class="el" href="my__basename_8h.html#acadd8feb4d96c58a8fc775c9c4d47ccf">MY_BASENAME</a>)&gt;::<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="separator:a624f13dad3569c561b4bd3dc14565088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129676f3bf61e6b55bbbeba1cbd03dad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a></td></tr>
<tr class="separator:a129676f3bf61e6b55bbbeba1cbd03dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16c14ff16a206cac2e82251c47ecf00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#aa16c14ff16a206cac2e82251c47ecf00">UT_NEW</a>(expr,  <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:aa16c14ff16a206cac2e82251c47ecf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate, trace the allocation and construct an object.  <a href="#aa16c14ff16a206cac2e82251c47ecf00">More...</a><br /></td></tr>
<tr class="separator:aa16c14ff16a206cac2e82251c47ecf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42e1e702bb0e9b93c5d8a69c4529de1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#af42e1e702bb0e9b93c5d8a69c4529de1">UT_NEW_NOKEY</a>(expr)&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#aa16c14ff16a206cac2e82251c47ecf00">UT_NEW</a>(expr, <a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a>)</td></tr>
<tr class="memdesc:af42e1e702bb0e9b93c5d8a69c4529de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate, trace the allocation and construct an object.  <a href="#af42e1e702bb0e9b93c5d8a69c4529de1">More...</a><br /></td></tr>
<tr class="separator:af42e1e702bb0e9b93c5d8a69c4529de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6841186f98763c1bf39b020e13c6be96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a6841186f98763c1bf39b020e13c6be96">UT_DELETE</a>(ptr)&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#abbce22e571d4557da355db2edd739baa">ut_delete</a>(ptr)</td></tr>
<tr class="memdesc:a6841186f98763c1bf39b020e13c6be96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy, deallocate and trace the deallocation of an object created by UT_NEW() or UT_NEW_NOKEY().  <a href="#a6841186f98763c1bf39b020e13c6be96">More...</a><br /></td></tr>
<tr class="separator:a6841186f98763c1bf39b020e13c6be96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85496ca17cccf903a8a9a77f2c42ca6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a85496ca17cccf903a8a9a77f2c42ca6c">UT_NEW_ARRAY</a>(type,  n_elements,  <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)&#160;&#160;&#160;<a class="el" href="classut__allocator.html">ut_allocator</a>&lt;type&gt;(<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>).new_array(n_elements, <a class="el" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>)</td></tr>
<tr class="memdesc:a85496ca17cccf903a8a9a77f2c42ca6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and account 'n_elements' objects of type 'type'.  <a href="#a85496ca17cccf903a8a9a77f2c42ca6c">More...</a><br /></td></tr>
<tr class="separator:a85496ca17cccf903a8a9a77f2c42ca6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbcc05e19a524cbf489161d1b6de4b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#addbcc05e19a524cbf489161d1b6de4b8">UT_NEW_ARRAY_NOKEY</a>(type,  n_elements)&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#a85496ca17cccf903a8a9a77f2c42ca6c">UT_NEW_ARRAY</a>(type, n_elements, <a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a>)</td></tr>
<tr class="memdesc:addbcc05e19a524cbf489161d1b6de4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and account 'n_elements' objects of type 'type'.  <a href="#addbcc05e19a524cbf489161d1b6de4b8">More...</a><br /></td></tr>
<tr class="separator:addbcc05e19a524cbf489161d1b6de4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8292c9a0da25e284e0e8dfa34f62d6be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a8292c9a0da25e284e0e8dfa34f62d6be">UT_DELETE_ARRAY</a>(ptr)&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#a8c3eb64cfe8c1ae778b471bc7ebab1cd">ut_delete_array</a>(ptr)</td></tr>
<tr class="memdesc:a8292c9a0da25e284e0e8dfa34f62d6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy, deallocate and trace the deallocation of an array created by UT_NEW_ARRAY() or UT_NEW_ARRAY_NOKEY().  <a href="#a8292c9a0da25e284e0e8dfa34f62d6be">More...</a><br /></td></tr>
<tr class="separator:a8292c9a0da25e284e0e8dfa34f62d6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d6ebed995a5c5ba5a4f8d94be7bbfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#af0d6ebed995a5c5ba5a4f8d94be7bbfb">ut_malloc</a>(n_bytes,  <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:af0d6ebed995a5c5ba5a4f8d94be7bbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not use ut_malloc, ut_zalloc, ut_malloc_nokey, ut_zalloc_nokey, ut_zalloc_nokey_nofatal and ut_realloc when allocating memory for over-aligned types.  <a href="#af0d6ebed995a5c5ba5a4f8d94be7bbfb">More...</a><br /></td></tr>
<tr class="separator:af0d6ebed995a5c5ba5a4f8d94be7bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac125e874fd94703841bf515bc727bf0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ac125e874fd94703841bf515bc727bf0b">ut_zalloc</a>(n_bytes,  <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="separator:ac125e874fd94703841bf515bc727bf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b94db58d1171d908646dbaf2e97397"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#aa6b94db58d1171d908646dbaf2e97397">ut_malloc_nokey</a>(n_bytes)</td></tr>
<tr class="separator:aa6b94db58d1171d908646dbaf2e97397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b84cdac6755e3e61797e26339c13cb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a9b84cdac6755e3e61797e26339c13cb2">ut_zalloc_nokey</a>(n_bytes)</td></tr>
<tr class="separator:a9b84cdac6755e3e61797e26339c13cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c2e040d9180263b34d755438d20b57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a77c2e040d9180263b34d755438d20b57">ut_zalloc_nokey_nofatal</a>(n_bytes)</td></tr>
<tr class="separator:a77c2e040d9180263b34d755438d20b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9131f1a2300b8c13c692e1cddf79236e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a9131f1a2300b8c13c692e1cddf79236e">ut_realloc</a>(ptr,  n_bytes)</td></tr>
<tr class="separator:a9131f1a2300b8c13c692e1cddf79236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c4e94da599d8a7cac6fcd91e2e99b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ac2c4e94da599d8a7cac6fcd91e2e99b4">ut_free</a>(ptr)</td></tr>
<tr class="separator:ac2c4e94da599d8a7cac6fcd91e2e99b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa3064bc8c3aa6595f1052c2c86e52725"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceut.html#aa3064bc8c3aa6595f1052c2c86e52725">ut::ostringstream</a> = std::basic_ostringstream&lt; char, std::char_traits&lt; char &gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:aa3064bc8c3aa6595f1052c2c86e52725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of basic_ostringstream which uses ut_allocator.  <a href="namespaceut.html#aa3064bc8c3aa6595f1052c2c86e52725">More...</a><br /></td></tr>
<tr class="separator:aa3064bc8c3aa6595f1052c2c86e52725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7abb0ab07329e68a6ec29d191da1e58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7abb0ab07329e68a6ec29d191da1e58"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a> = std::vector&lt; T, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:aa7abb0ab07329e68a6ec29d191da1e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of vector which uses ut_allocator.  <a href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">More...</a><br /></td></tr>
<tr class="separator:aa7abb0ab07329e68a6ec29d191da1e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e3c76bd642fa7ee849018e0d6b0f7"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:a711e3c76bd642fa7ee849018e0d6b0f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceut.html#a711e3c76bd642fa7ee849018e0d6b0f7">ut::unordered_set</a> = std::unordered_set&lt; Key, <a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">std::hash</a>&lt; Key &gt;, std::equal_to&lt; Key &gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; Key &gt; &gt;</td></tr>
<tr class="separator:a711e3c76bd642fa7ee849018e0d6b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6c7a3aac76cb6bc467857b9bdd491764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a6c7a3aac76cb6bc467857b9bdd491764">ut_new_boot</a> ()</td></tr>
<tr class="memdesc:a6c7a3aac76cb6bc467857b9bdd491764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the internal objects needed for UT_NEW() to operate.  <a href="#a6c7a3aac76cb6bc467857b9bdd491764">More...</a><br /></td></tr>
<tr class="separator:a6c7a3aac76cb6bc467857b9bdd491764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bfcce53298814ade4eb85f03188b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a13bfcce53298814ade4eb85f03188b16">ut_new_boot_safe</a> ()</td></tr>
<tr class="memdesc:a13bfcce53298814ade4eb85f03188b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the internal objects needed for UT_NEW() to operate.  <a href="#a13bfcce53298814ade4eb85f03188b16">More...</a><br /></td></tr>
<tr class="separator:a13bfcce53298814ade4eb85f03188b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ae8b8d6eca98dd0f1c48d3aea86039"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a60ae8b8d6eca98dd0f1c48d3aea86039">ut_string_begins_with</a> (const char *a, const char *b, size_t b_len)</td></tr>
<tr class="memdesc:a60ae8b8d6eca98dd0f1c48d3aea86039"><td class="mdescLeft">&#160;</td><td class="mdescRight">gcc 5 fails to evalutate costexprs at compile time.  <a href="#a60ae8b8d6eca98dd0f1c48d3aea86039">More...</a><br /></td></tr>
<tr class="separator:a60ae8b8d6eca98dd0f1c48d3aea86039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c990ef556694529afd39ac8a3762bd"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ab9c990ef556694529afd39ac8a3762bd">ut_len_without_extension</a> (const char *file)</td></tr>
<tr class="memdesc:ab9c990ef556694529afd39ac8a3762bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the filename without its file extension.  <a href="#ab9c990ef556694529afd39ac8a3762bd">More...</a><br /></td></tr>
<tr class="separator:ab9c990ef556694529afd39ac8a3762bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46953cbccd97572bed01dff0c7c1754f"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a46953cbccd97572bed01dff0c7c1754f">ut_new_get_key_by_base_file</a> (const char *file, size_t len)</td></tr>
<tr class="memdesc:a46953cbccd97572bed01dff0c7c1754f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a memory key (registered with PFS), given the file name of the caller.  <a href="#a46953cbccd97572bed01dff0c7c1754f">More...</a><br /></td></tr>
<tr class="separator:a46953cbccd97572bed01dff0c7c1754f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f326d67141dd93e7c9227b0922309c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a64f326d67141dd93e7c9227b0922309c">ut_new_get_key_by_file</a> (const char *file)</td></tr>
<tr class="memdesc:a64f326d67141dd93e7c9227b0922309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a memory key (registered with PFS), given the file name of the caller.  <a href="#a64f326d67141dd93e7c9227b0922309c">More...</a><br /></td></tr>
<tr class="separator:a64f326d67141dd93e7c9227b0922309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8005365b107eccac21d94bec4ff8e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb8005365b107eccac21d94bec4ff8e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#aeb8005365b107eccac21d94bec4ff8e6">operator==</a> (const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeb8005365b107eccac21d94bec4ff8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two allocators of the same type.  <a href="#aeb8005365b107eccac21d94bec4ff8e6">More...</a><br /></td></tr>
<tr class="separator:aeb8005365b107eccac21d94bec4ff8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb89c145360577fc51060d21e8a9164"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fb89c145360577fc51060d21e8a9164"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a9fb89c145360577fc51060d21e8a9164">operator!=</a> (const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9fb89c145360577fc51060d21e8a9164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two allocators of the same type.  <a href="#a9fb89c145360577fc51060d21e8a9164">More...</a><br /></td></tr>
<tr class="separator:a9fb89c145360577fc51060d21e8a9164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbce22e571d4557da355db2edd739baa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbce22e571d4557da355db2edd739baa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#abbce22e571d4557da355db2edd739baa">ut_delete</a> (T *ptr)</td></tr>
<tr class="memdesc:abbce22e571d4557da355db2edd739baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and account object created by UT_NEW() or UT_NEW_NOKEY().  <a href="#abbce22e571d4557da355db2edd739baa">More...</a><br /></td></tr>
<tr class="separator:abbce22e571d4557da355db2edd739baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3eb64cfe8c1ae778b471bc7ebab1cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c3eb64cfe8c1ae778b471bc7ebab1cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a8c3eb64cfe8c1ae778b471bc7ebab1cd">ut_delete_array</a> (T *ptr)</td></tr>
<tr class="memdesc:a8c3eb64cfe8c1ae778b471bc7ebab1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and account objects created by UT_NEW_ARRAY() or UT_NEW_ARRAY_NOKEY().  <a href="#a8c3eb64cfe8c1ae778b471bc7ebab1cd">More...</a><br /></td></tr>
<tr class="separator:a8c3eb64cfe8c1ae778b471bc7ebab1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ebe4e318f5e71a5a56f2f004fd29be"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#af9ebe4e318f5e71a5a56f2f004fd29be">ut_align</a> (const void *ptr, ulint align_no)</td></tr>
<tr class="memdesc:af9ebe4e318f5e71a5a56f2f004fd29be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a forward declaration, which is because of the circular dependency between ut0new.h and ut0byte.h (going through univ.i and sync0types.h).  <a href="#af9ebe4e318f5e71a5a56f2f004fd29be">More...</a><br /></td></tr>
<tr class="separator:af9ebe4e318f5e71a5a56f2f004fd29be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a95cd4580a449808cb9ab70296322272f"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a95cd4580a449808cb9ab70296322272f">alloc_max_retries</a></td></tr>
<tr class="memdesc:a95cd4580a449808cb9ab70296322272f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of retries to allocate memory.  <a href="#a95cd4580a449808cb9ab70296322272f">More...</a><br /></td></tr>
<tr class="separator:a95cd4580a449808cb9ab70296322272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677794d11194506a7d723d565ad0264a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a677794d11194506a7d723d565ad0264a">mem_key_ahi</a></td></tr>
<tr class="memdesc:a677794d11194506a7d723d565ad0264a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keys for registering allocations with performance schema.  <a href="#a677794d11194506a7d723d565ad0264a">More...</a><br /></td></tr>
<tr class="separator:a677794d11194506a7d723d565ad0264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfa35bea3d6c792bb9553b4997a39b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a8bfa35bea3d6c792bb9553b4997a39b7">mem_key_archive</a></td></tr>
<tr class="separator:a8bfa35bea3d6c792bb9553b4997a39b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c19c1760ad493b3e1f76e7fe0374e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ab5c19c1760ad493b3e1f76e7fe0374e1">mem_key_buf_buf_pool</a></td></tr>
<tr class="separator:ab5c19c1760ad493b3e1f76e7fe0374e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259168aaea949acd8e4d42b62bd2e643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a259168aaea949acd8e4d42b62bd2e643">mem_key_buf_stat_per_index_t</a></td></tr>
<tr class="separator:a259168aaea949acd8e4d42b62bd2e643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade54e574ebb69d193945bedf32e0380d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ade54e574ebb69d193945bedf32e0380d">mem_key_clone</a></td></tr>
<tr class="memdesc:ade54e574ebb69d193945bedf32e0380d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory key for clone.  <a href="#ade54e574ebb69d193945bedf32e0380d">More...</a><br /></td></tr>
<tr class="separator:ade54e574ebb69d193945bedf32e0380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecabe9d9930f4b4230ef9fb4750f384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#aeecabe9d9930f4b4230ef9fb4750f384">mem_key_dict_stats_bg_recalc_pool_t</a></td></tr>
<tr class="separator:aeecabe9d9930f4b4230ef9fb4750f384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589f85f05edbd6394b4a78b51f0b347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a2589f85f05edbd6394b4a78b51f0b347">mem_key_dict_stats_index_map_t</a></td></tr>
<tr class="separator:a2589f85f05edbd6394b4a78b51f0b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a2e3a2142f613517aa49df9719b53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ae9a2e3a2142f613517aa49df9719b53d">mem_key_dict_stats_n_diff_on_level</a></td></tr>
<tr class="separator:ae9a2e3a2142f613517aa49df9719b53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4162ae3c244aabd337969949f81286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a1d4162ae3c244aabd337969949f81286">mem_key_redo_log_archive_queue_element</a></td></tr>
<tr class="separator:a1d4162ae3c244aabd337969949f81286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25de7f698d184c762ed999541c63a27f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a25de7f698d184c762ed999541c63a27f">mem_key_other</a></td></tr>
<tr class="separator:a25de7f698d184c762ed999541c63a27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a898fbb2ebd00d3f8d48a24f8c1789e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a8a898fbb2ebd00d3f8d48a24f8c1789e">mem_key_partitioning</a></td></tr>
<tr class="separator:a8a898fbb2ebd00d3f8d48a24f8c1789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987e10cacf3c33219b0166673b4dae9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a987e10cacf3c33219b0166673b4dae9b">mem_key_row_log_buf</a></td></tr>
<tr class="separator:a987e10cacf3c33219b0166673b4dae9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ce048d8991c029b7da9d44303be1d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a72ce048d8991c029b7da9d44303be1d2">mem_key_row_merge_sort</a></td></tr>
<tr class="separator:a72ce048d8991c029b7da9d44303be1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93006c6ff87e9d08a27b0f888ccae049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a93006c6ff87e9d08a27b0f888ccae049">mem_key_std</a></td></tr>
<tr class="separator:a93006c6ff87e9d08a27b0f888ccae049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db5a136d38de8803e5c7c36493669fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a9db5a136d38de8803e5c7c36493669fd">mem_key_trx_sys_t_rw_trx_ids</a></td></tr>
<tr class="separator:a9db5a136d38de8803e5c7c36493669fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ddf5a46c67294a44c80ca0650e12fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ad4ddf5a46c67294a44c80ca0650e12fb">mem_key_undo_spaces</a></td></tr>
<tr class="separator:ad4ddf5a46c67294a44c80ca0650e12fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5469d9a4e8f22f826803b86022abb20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#ad5469d9a4e8f22f826803b86022abb20">mem_key_ut_lock_free_hash_t</a></td></tr>
<tr class="separator:ad5469d9a4e8f22f826803b86022abb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f19e4e69597607029e26755d1acc163"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a8f19e4e69597607029e26755d1acc163">auto_event_names</a> []</td></tr>
<tr class="memdesc:a8f19e4e69597607029e26755d1acc163"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of filenames that allocate memory and are instrumented via PFS.  <a href="#a8f19e4e69597607029e26755d1acc163">More...</a><br /></td></tr>
<tr class="separator:a8f19e4e69597607029e26755d1acc163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0b6265ae38565cb31e3e6ed035ec03"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a9e0b6265ae38565cb31e3e6ed035ec03">n_auto</a> = UT_ARR_SIZE(<a class="el" href="ut0new_8h.html#a8f19e4e69597607029e26755d1acc163">auto_event_names</a>)</td></tr>
<tr class="separator:a9e0b6265ae38565cb31e3e6ed035ec03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e05213f87c25d7c056e17b895634d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a3e05213f87c25d7c056e17b895634d5e">auto_event_keys</a> [<a class="el" href="ut0new_8h.html#a9e0b6265ae38565cb31e3e6ed035ec03">n_auto</a>]</td></tr>
<tr class="separator:a3e05213f87c25d7c056e17b895634d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e648a4780a63858f6351d1dc75e0b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#gac776797cad060503b8a8c3d331517194">PSI_memory_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0new_8h.html#a28e648a4780a63858f6351d1dc75e0b3">pfs_info_auto</a> [<a class="el" href="ut0new_8h.html#a9e0b6265ae38565cb31e3e6ed035ec03">n_auto</a>]</td></tr>
<tr class="separator:a28e648a4780a63858f6351d1dc75e0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instrumented memory allocator. </p>
<p>Created May 26, 2014 Vasil Dimov </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1739e1d08fde086cc8bc759c6919a67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1739e1d08fde086cc8bc759c6919a67f">&#9670;&nbsp;</a></span>OUT_OF_MEMORY_MSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OUT_OF_MEMORY_MSG</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="stringliteral">&quot;Check if you should increase the swap file or ulimits of your&quot;</span>     \</div><div class="line">  <span class="stringliteral">&quot; operating system. Note that on most 32-bit computers the process&quot;</span> \</div><div class="line">  <span class="stringliteral">&quot; memory space is limited to 2 GB or 4 GB.&quot;</span></div></div><!-- fragment -->
<p>Dynamic memory allocation within InnoDB guidelines. </p>
<p>All dynamic (heap) memory allocations (malloc(3), strdup(3), etc, "new", various std:: containers that allocate memory internally), that are done within InnoDB are instrumented. This means that InnoDB uses a custom set of functions for allocating memory, rather than calling e.g. "new" directly.</p>
<p>Here follows a cheat sheet on what InnoDB functions to use whenever a standard one would have been used.</p>
<h2>Creating new objects with "new": </h2>
<p>Standard: new expression or new(std::nothrow) expression InnoDB, default instrumentation: UT_NEW_NOKEY(expression) InnoDB, custom instrumentation, preferred: UT_NEW(expression, key)</p>
<h2>Destroying objects, created with "new": </h2>
<p>Standard: delete ptr InnoDB: UT_DELETE(ptr)</p>
<h2>Creating new arrays with "new[]": </h2>
<p>Standard: new type[num] or new(std::nothrow) type[num] InnoDB, default instrumentation: UT_NEW_ARRAY_NOKEY(type, num) InnoDB, custom instrumentation, preferred: UT_NEW_ARRAY(type, num, key)</p>
<h2>Destroying arrays, created with "new[]": </h2>
<p>Standard: delete[] ptr InnoDB: UT_DELETE_ARRAY(ptr)</p>
<h2>Declaring a type with a std:: container, e.g. std::vector: </h2>
<p>Standard: std::vector&lt;t&gt; InnoDB: std::vector&lt;t, ut_allocator&lt;t&gt; &gt;</p>
<h2>Declaring objects of some std:: type: </h2>
<p>Standard: std::vector&lt;t&gt; v InnoDB, default instrumentation: std::vector&lt;t, ut_allocator&lt;t&gt; &gt; v InnoDB, custom instrumentation, preferred: std::vector&lt;t, ut_allocator&lt;t&gt; &gt; v(ut_allocator&lt;t&gt;(key))</p>
<p>Raw block allocation (as usual in C++, consider whether using "new" would </p><h2>not be more appropriate): </h2>
<p>Standard: malloc(num) InnoDB, default instrumentation: ut_malloc_nokey(num) InnoDB, custom instrumentation, preferred: ut_malloc(num, key)</p>
<h2>Raw block resize: </h2>
<p>Standard: realloc(ptr, new_size) InnoDB: ut_realloc(ptr, new_size)</p>
<h2>Raw block deallocation: </h2>
<p>Standard: free(ptr) InnoDB: ut_free(ptr)</p>
<p>Note: the expression passed to UT_NEW() or UT_NEW_NOKEY() must always end with (), thus: Standard: new int InnoDB: UT_NEW_NOKEY(int()) </p>

</div>
</div>
<a id="a6841186f98763c1bf39b020e13c6be96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6841186f98763c1bf39b020e13c6be96">&#9670;&nbsp;</a></span>UT_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#abbce22e571d4557da355db2edd739baa">ut_delete</a>(ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy, deallocate and trace the deallocation of an object created by UT_NEW() or UT_NEW_NOKEY(). </p>
<p>We can't instantiate ut_allocator without having the type of the object, thus we redirect this to a template function. </p>

</div>
</div>
<a id="a8292c9a0da25e284e0e8dfa34f62d6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8292c9a0da25e284e0e8dfa34f62d6be">&#9670;&nbsp;</a></span>UT_DELETE_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_DELETE_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#a8c3eb64cfe8c1ae778b471bc7ebab1cd">ut_delete_array</a>(ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy, deallocate and trace the deallocation of an array created by UT_NEW_ARRAY() or UT_NEW_ARRAY_NOKEY(). </p>
<p>We can't instantiate ut_allocator without having the type of the object, thus we redirect this to a template function. </p>

</div>
</div>
<a id="ac2c4e94da599d8a7cac6fcd91e2e99b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c4e94da599d8a7cac6fcd91e2e99b4">&#9670;&nbsp;</a></span>ut_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="classut__allocator.html">ut_allocator&lt;byte&gt;</a>(<a class="code" href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a>) \</div><div class="line">      .deallocate(reinterpret_cast&lt;byte *&gt;(ptr))</div><div class="ttc" id="classut__allocator_html"><div class="ttname"><a href="classut__allocator.html">ut_allocator</a></div><div class="ttdoc">Allocator class for allocating memory from inside std::* containers. </div><div class="ttdef"><b>Definition:</b> ut0new.h:572</div></div>
<div class="ttc" id="validate__password__imp_8cc_html_a70783ee23d454fee308d3efd6309af74"><div class="ttname"><a href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a></div><div class="ttdeci">#define PSI_NOT_INSTRUMENTED</div><div class="ttdef"><b>Definition:</b> validate_password_imp.cc:39</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af0d6ebed995a5c5ba5a4f8d94be7bbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d6ebed995a5c5ba5a4f8d94be7bbfb">&#9670;&nbsp;</a></span>ut_malloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_malloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_bytes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(<a class="code" href="classut__allocator.html">ut_allocator&lt;byte&gt;</a>(<a class="code" href="suite__stubs_8c.html#acd3d88da3c0e0313c3645ff34f62f542">key</a>).allocate( \</div><div class="line">      n_bytes, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>, <span class="keyword">false</span>, <span class="keyword">false</span>))</div><div class="ttc" id="classut__allocator_html"><div class="ttname"><a href="classut__allocator.html">ut_allocator</a></div><div class="ttdoc">Allocator class for allocating memory from inside std::* containers. </div><div class="ttdef"><b>Definition:</b> ut0new.h:572</div></div>
<div class="ttc" id="ut0new_8h_html_a129676f3bf61e6b55bbbeba1cbd03dad"><div class="ttname"><a href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a></div><div class="ttdeci">#define UT_NEW_THIS_FILE_PSI_KEY</div><div class="ttdef"><b>Definition:</b> ut0new.h:515</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
<div class="ttc" id="suite__stubs_8c_html_acd3d88da3c0e0313c3645ff34f62f542"><div class="ttname"><a href="suite__stubs_8c.html#acd3d88da3c0e0313c3645ff34f62f542">key</a></div><div class="ttdeci">static const char * key</div><div class="ttdef"><b>Definition:</b> suite_stubs.c:14</div></div>
</div><!-- fragment -->
<p>Do not use ut_malloc, ut_zalloc, ut_malloc_nokey, ut_zalloc_nokey, ut_zalloc_nokey_nofatal and ut_realloc when allocating memory for over-aligned types. </p>
<p>We have to use aligned_pointer instead, analogously to how we have to use aligned_alloc when working with the standard library to handle dynamic allocation for over-aligned types. These macros use ut_allocator to allocate raw memory (no type information is passed). This is why ut_allocator needs to be instantiated with the byte type. This has implications on the max alignment of the objects that are allocated using this API. ut_allocator returns memory aligned to alignof(std::max_align_t), similarly to library allocation functions. This value is 16 bytes on most x64 machines. A static_assert enforces this when using UT_NEW, however, since the ut_allocator template is instantiated with byte here the assert will not be hit if using alignment &gt;= alignof(std::max_align_t). Not meeting the alignment requirements for a type causes undefined behaviour. One should avoid using the macros below when writing new code in general, and try to remove them when refactoring existing code (in favor of using the UT_NEW). The reason behind this lies both in the undefined behaviour problem described above, and in the fact that standard C-like malloc use is discouraged in c++ (see CppCoreGuidelines - R.10: Avoid malloc() and free()). Using ut_malloc has the same problems as the standard library malloc. </p>

</div>
</div>
<a id="aa6b94db58d1171d908646dbaf2e97397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b94db58d1171d908646dbaf2e97397">&#9670;&nbsp;</a></span>ut_malloc_nokey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_malloc_nokey</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_bytes</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(                         \</div><div class="line">      ut_allocator&lt;byte&gt;(<a class="code" href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a>) \</div><div class="line">          .allocate(n_bytes, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>, <span class="keyword">false</span>, <span class="keyword">false</span>))</div><div class="ttc" id="validate__password__imp_8cc_html_a70783ee23d454fee308d3efd6309af74"><div class="ttname"><a href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a></div><div class="ttdeci">#define PSI_NOT_INSTRUMENTED</div><div class="ttdef"><b>Definition:</b> validate_password_imp.cc:39</div></div>
<div class="ttc" id="ut0new_8h_html_a129676f3bf61e6b55bbbeba1cbd03dad"><div class="ttname"><a href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a></div><div class="ttdeci">#define UT_NEW_THIS_FILE_PSI_KEY</div><div class="ttdef"><b>Definition:</b> ut0new.h:515</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa16c14ff16a206cac2e82251c47ecf00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16c14ff16a206cac2e82251c47ecf00">&#9670;&nbsp;</a></span>UT_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_NEW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* Placement new will return NULL and not attempt to construct an      \</span></div><div class="line"><span class="comment">  object if the passed in pointer is NULL, e.g. if allocate() has        \</span></div><div class="line"><span class="comment">  failed to allocate memory and has returned NULL. */</span>                    \</div><div class="line">  ::new (<a class="code" href="classut__allocator.html">ut_allocator</a>&lt;decltype(expr)&gt;(<a class="code" href="suite__stubs_8c.html#acd3d88da3c0e0313c3645ff34f62f542">key</a>).allocate(1, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="suite__stubs_8c.html#acd3d88da3c0e0313c3645ff34f62f542">key</a>, <span class="keyword">false</span>, \</div><div class="line">                                                    <span class="keyword">false</span>)) expr</div><div class="ttc" id="classut__allocator_html"><div class="ttname"><a href="classut__allocator.html">ut_allocator</a></div><div class="ttdoc">Allocator class for allocating memory from inside std::* containers. </div><div class="ttdef"><b>Definition:</b> ut0new.h:572</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
<div class="ttc" id="suite__stubs_8c_html_acd3d88da3c0e0313c3645ff34f62f542"><div class="ttname"><a href="suite__stubs_8c.html#acd3d88da3c0e0313c3645ff34f62f542">key</a></div><div class="ttdeci">static const char * key</div><div class="ttdef"><b>Definition:</b> suite_stubs.c:14</div></div>
</div><!-- fragment -->
<p>Allocate, trace the allocation and construct an object. </p>
<p>Use this macro instead of 'new' within InnoDB. For example: instead of Foo* f = new Foo(args); use: Foo* f = UT_NEW(Foo(args), mem_key_some); Upon failure to allocate the memory, this macro may return NULL. It will not throw exceptions. After successful allocation the returned pointer must be passed to UT_DELETE() when no longer needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expr</td><td>any expression that could follow "new" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>performance schema memory tracing key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the created object or NULL </dd></dl>

</div>
</div>
<a id="a85496ca17cccf903a8a9a77f2c42ca6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85496ca17cccf903a8a9a77f2c42ca6c">&#9670;&nbsp;</a></span>UT_NEW_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_NEW_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_elements, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="classut__allocator.html">ut_allocator</a>&lt;type&gt;(<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>).new_array(n_elements, <a class="el" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and account 'n_elements' objects of type 'type'. </p>
<p>Use this macro to allocate memory within InnoDB instead of 'new[]'. The returned pointer must be passed to UT_DELETE_ARRAY(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of objects being created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>number of objects to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>performance schema memory tracing key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first allocated object or NULL </dd></dl>

</div>
</div>
<a id="addbcc05e19a524cbf489161d1b6de4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbcc05e19a524cbf489161d1b6de4b8">&#9670;&nbsp;</a></span>UT_NEW_ARRAY_NOKEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_NEW_ARRAY_NOKEY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_elements&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#a85496ca17cccf903a8a9a77f2c42ca6c">UT_NEW_ARRAY</a>(type, n_elements, <a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and account 'n_elements' objects of type 'type'. </p>
<p>Use this macro to allocate memory within InnoDB instead of 'new[]' and instead of UT_NEW_ARRAY() when it is not feasible to create a dedicated key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of objects being created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_elements</td><td>number of objects to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first allocated object or NULL </dd></dl>

</div>
</div>
<a id="af42e1e702bb0e9b93c5d8a69c4529de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42e1e702bb0e9b93c5d8a69c4529de1">&#9670;&nbsp;</a></span>UT_NEW_NOKEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_NEW_NOKEY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0new_8h.html#aa16c14ff16a206cac2e82251c47ecf00">UT_NEW</a>(expr, <a class="el" href="group__psi__abi.html#ga4134fd776a0630d856a60c7ef69f9c8a">PSI_NOT_INSTRUMENTED</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate, trace the allocation and construct an object. </p>
<p>Use this macro instead of 'new' within InnoDB and instead of UT_NEW() when creating a dedicated memory key is not feasible. For example: instead of Foo* f = new Foo(args); use: Foo* f = UT_NEW_NOKEY(Foo(args)); Upon failure to allocate the memory, this macro may return NULL. It will not throw exceptions. After successful allocation the returned pointer must be passed to UT_DELETE() when no longer needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expr</td><td>any expression that could follow "new" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the created object or NULL </dd></dl>

</div>
</div>
<a id="a624f13dad3569c561b4bd3dc14565088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624f13dad3569c561b4bd3dc14565088">&#9670;&nbsp;</a></span>UT_NEW_THIS_FILE_PSI_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_NEW_THIS_FILE_PSI_INDEX&#160;&#160;&#160;(<a class="el" href="structforce__constexpr.html">force_constexpr</a>&lt;<a class="el" href="ut0new_8h.html#a64f326d67141dd93e7c9227b0922309c">ut_new_get_key_by_file</a>(<a class="el" href="my__basename_8h.html#acadd8feb4d96c58a8fc775c9c4d47ccf">MY_BASENAME</a>)&gt;::<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a129676f3bf61e6b55bbbeba1cbd03dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129676f3bf61e6b55bbbeba1cbd03dad">&#9670;&nbsp;</a></span>UT_NEW_THIS_FILE_PSI_KEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UT_NEW_THIS_FILE_PSI_KEY</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="ut0new_8h.html#a624f13dad3569c561b4bd3dc14565088">UT_NEW_THIS_FILE_PSI_INDEX</a> == -1 \</div><div class="line">       ? <a class="code" href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a>       \</div><div class="line">       : <a class="code" href="ut0new_8h.html#a3e05213f87c25d7c056e17b895634d5e">auto_event_keys</a>[<a class="code" href="ut0new_8h.html#a624f13dad3569c561b4bd3dc14565088">UT_NEW_THIS_FILE_PSI_INDEX</a>])</div><div class="ttc" id="ut0new_8h_html_a3e05213f87c25d7c056e17b895634d5e"><div class="ttname"><a href="ut0new_8h.html#a3e05213f87c25d7c056e17b895634d5e">auto_event_keys</a></div><div class="ttdeci">PSI_memory_key auto_event_keys[n_auto]</div></div>
<div class="ttc" id="validate__password__imp_8cc_html_a70783ee23d454fee308d3efd6309af74"><div class="ttname"><a href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a></div><div class="ttdeci">#define PSI_NOT_INSTRUMENTED</div><div class="ttdef"><b>Definition:</b> validate_password_imp.cc:39</div></div>
<div class="ttc" id="ut0new_8h_html_a624f13dad3569c561b4bd3dc14565088"><div class="ttname"><a href="ut0new_8h.html#a624f13dad3569c561b4bd3dc14565088">UT_NEW_THIS_FILE_PSI_INDEX</a></div><div class="ttdeci">#define UT_NEW_THIS_FILE_PSI_INDEX</div><div class="ttdef"><b>Definition:</b> ut0new.h:512</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9131f1a2300b8c13c692e1cddf79236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9131f1a2300b8c13c692e1cddf79236e">&#9670;&nbsp;</a></span>ut_realloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_realloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(<a class="code" href="classut__allocator.html">ut_allocator&lt;byte&gt;</a>(<a class="code" href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a>) \</div><div class="line">                          .reallocate(ptr, n_bytes, <a class="code" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>))</div><div class="ttc" id="classut__allocator_html"><div class="ttname"><a href="classut__allocator.html">ut_allocator</a></div><div class="ttdoc">Allocator class for allocating memory from inside std::* containers. </div><div class="ttdef"><b>Definition:</b> ut0new.h:572</div></div>
<div class="ttc" id="validate__password__imp_8cc_html_a70783ee23d454fee308d3efd6309af74"><div class="ttname"><a href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a></div><div class="ttdeci">#define PSI_NOT_INSTRUMENTED</div><div class="ttdef"><b>Definition:</b> validate_password_imp.cc:39</div></div>
<div class="ttc" id="ut0new_8h_html_a129676f3bf61e6b55bbbeba1cbd03dad"><div class="ttname"><a href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a></div><div class="ttdeci">#define UT_NEW_THIS_FILE_PSI_KEY</div><div class="ttdef"><b>Definition:</b> ut0new.h:515</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac125e874fd94703841bf515bc727bf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac125e874fd94703841bf515bc727bf0b">&#9670;&nbsp;</a></span>ut_zalloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_zalloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_bytes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(<a class="code" href="classut__allocator.html">ut_allocator&lt;byte&gt;</a>(<a class="code" href="suite__stubs_8c.html#acd3d88da3c0e0313c3645ff34f62f542">key</a>).allocate( \</div><div class="line">      n_bytes, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>, <span class="keyword">true</span>, <span class="keyword">false</span>))</div><div class="ttc" id="classut__allocator_html"><div class="ttname"><a href="classut__allocator.html">ut_allocator</a></div><div class="ttdoc">Allocator class for allocating memory from inside std::* containers. </div><div class="ttdef"><b>Definition:</b> ut0new.h:572</div></div>
<div class="ttc" id="ut0new_8h_html_a129676f3bf61e6b55bbbeba1cbd03dad"><div class="ttname"><a href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a></div><div class="ttdeci">#define UT_NEW_THIS_FILE_PSI_KEY</div><div class="ttdef"><b>Definition:</b> ut0new.h:515</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
<div class="ttc" id="suite__stubs_8c_html_acd3d88da3c0e0313c3645ff34f62f542"><div class="ttname"><a href="suite__stubs_8c.html#acd3d88da3c0e0313c3645ff34f62f542">key</a></div><div class="ttdeci">static const char * key</div><div class="ttdef"><b>Definition:</b> suite_stubs.c:14</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b84cdac6755e3e61797e26339c13cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b84cdac6755e3e61797e26339c13cb2">&#9670;&nbsp;</a></span>ut_zalloc_nokey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_zalloc_nokey</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_bytes</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(                         \</div><div class="line">      ut_allocator&lt;byte&gt;(<a class="code" href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a>) \</div><div class="line">          .allocate(n_bytes, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>, <span class="keyword">true</span>, <span class="keyword">false</span>))</div><div class="ttc" id="validate__password__imp_8cc_html_a70783ee23d454fee308d3efd6309af74"><div class="ttname"><a href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a></div><div class="ttdeci">#define PSI_NOT_INSTRUMENTED</div><div class="ttdef"><b>Definition:</b> validate_password_imp.cc:39</div></div>
<div class="ttc" id="ut0new_8h_html_a129676f3bf61e6b55bbbeba1cbd03dad"><div class="ttname"><a href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a></div><div class="ttdeci">#define UT_NEW_THIS_FILE_PSI_KEY</div><div class="ttdef"><b>Definition:</b> ut0new.h:515</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a77c2e040d9180263b34d755438d20b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c2e040d9180263b34d755438d20b57">&#9670;&nbsp;</a></span>ut_zalloc_nokey_nofatal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_zalloc_nokey_nofatal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_bytes</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(                         \</div><div class="line">      ut_allocator&lt;byte&gt;(<a class="code" href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a>) \</div><div class="line">          .set_oom_not_fatal()                 \</div><div class="line">          .allocate(n_bytes, <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a>, <span class="keyword">true</span>, <span class="keyword">false</span>))</div><div class="ttc" id="validate__password__imp_8cc_html_a70783ee23d454fee308d3efd6309af74"><div class="ttname"><a href="validate__password__imp_8cc.html#a70783ee23d454fee308d3efd6309af74">PSI_NOT_INSTRUMENTED</a></div><div class="ttdeci">#define PSI_NOT_INSTRUMENTED</div><div class="ttdef"><b>Definition:</b> validate_password_imp.cc:39</div></div>
<div class="ttc" id="ut0new_8h_html_a129676f3bf61e6b55bbbeba1cbd03dad"><div class="ttname"><a href="ut0new_8h.html#a129676f3bf61e6b55bbbeba1cbd03dad">UT_NEW_THIS_FILE_PSI_KEY</a></div><div class="ttdeci">#define UT_NEW_THIS_FILE_PSI_KEY</div><div class="ttdef"><b>Definition:</b> ut0new.h:515</div></div>
<div class="ttc" id="types_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9fb89c145360577fc51060d21e8a9164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb89c145360577fc51060d21e8a9164">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="rpl__rli_8h.html#a7762c4d9bacdce0c790e43bd8313fe72">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two allocators of the same type. </p>

</div>
</div>
<a id="aeb8005365b107eccac21d94bec4ff8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8005365b107eccac21d94bec4ff8e6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two allocators of the same type. </p>
<p>As long as the type of A1 and A2 is the same, a memory allocated by A1 could be freed by A2 even if the pfs mem key is different. </p>

</div>
</div>
<a id="af9ebe4e318f5e71a5a56f2f004fd29be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ebe4e318f5e71a5a56f2f004fd29be">&#9670;&nbsp;</a></span>ut_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* ut_align </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>align_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a forward declaration, which is because of the circular dependency between ut0new.h and ut0byte.h (going through univ.i and sync0types.h). </p>
<p>I've managed to observe problem when building MEB and this helps then. </p>

</div>
</div>
<a id="abbce22e571d4557da355db2edd739baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbce22e571d4557da355db2edd739baa">&#9670;&nbsp;</a></span>ut_delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy and account object created by UT_NEW() or UT_NEW_NOKEY(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>pointer to the object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c3eb64cfe8c1ae778b471bc7ebab1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3eb64cfe8c1ae778b471bc7ebab1cd">&#9670;&nbsp;</a></span>ut_delete_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_delete_array </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy and account objects created by UT_NEW_ARRAY() or UT_NEW_ARRAY_NOKEY(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ptr</td><td>pointer to the first object in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9c990ef556694529afd39ac8a3762bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c990ef556694529afd39ac8a3762bd">&#9670;&nbsp;</a></span>ut_len_without_extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t ut_len_without_extension </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the length of the filename without its file extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>filename, with extension but without directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length, in bytes </dd></dl>

</div>
</div>
<a id="a6c7a3aac76cb6bc467857b9bdd491764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7a3aac76cb6bc467857b9bdd491764">&#9670;&nbsp;</a></span>ut_new_boot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ut_new_boot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup the internal objects needed for UT_NEW() to operate. </p>
<p>This must be called before the first call to UT_NEW(). </p>

</div>
</div>
<a id="a13bfcce53298814ade4eb85f03188b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bfcce53298814ade4eb85f03188b16">&#9670;&nbsp;</a></span>ut_new_boot_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ut_new_boot_safe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup the internal objects needed for UT_NEW() to operate. </p>
<p>This must be called before the first call to UT_NEW(). This version of function might be called several times and it will simply skip all calls except the first one, during which the initialization will happen. </p>

</div>
</div>
<a id="a46953cbccd97572bed01dff0c7c1754f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46953cbccd97572bed01dff0c7c1754f">&#9670;&nbsp;</a></span>ut_new_get_key_by_base_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int ut_new_get_key_by_base_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a memory key (registered with PFS), given the file name of the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>portion of the filename - basename, with extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the filename to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index to registered memory key or -1 if not found </dd></dl>

</div>
</div>
<a id="a64f326d67141dd93e7c9227b0922309c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f326d67141dd93e7c9227b0922309c">&#9670;&nbsp;</a></span>ut_new_get_key_by_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int ut_new_get_key_by_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a memory key (registered with PFS), given the file name of the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>portion of the filename - basename, with extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index to memory key or -1 if not found </dd></dl>

</div>
</div>
<a id="a60ae8b8d6eca98dd0f1c48d3aea86039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ae8b8d6eca98dd0f1c48d3aea86039">&#9670;&nbsp;</a></span>ut_string_begins_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ut_string_begins_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gcc 5 fails to evalutate costexprs at compile time. </p>
<p>Compute whether a string begins with a given prefix, compile-time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first string, taken to be zero-terminated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second string (prefix to search for) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_len</td><td>length in bytes of second string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether b is a prefix of a </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a95cd4580a449808cb9ab70296322272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cd4580a449808cb9ab70296322272f">&#9670;&nbsp;</a></span>alloc_max_retries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t alloc_max_retries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of retries to allocate memory. </p>

</div>
</div>
<a id="a3e05213f87c25d7c056e17b895634d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e05213f87c25d7c056e17b895634d5e">&#9670;&nbsp;</a></span>auto_event_keys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> auto_event_keys[<a class="el" href="ut0new_8h.html#a9e0b6265ae38565cb31e3e6ed035ec03">n_auto</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f19e4e69597607029e26755d1acc163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f19e4e69597607029e26755d1acc163">&#9670;&nbsp;</a></span>auto_event_names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* auto_event_names[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of filenames that allocate memory and are instrumented via PFS. </p>

</div>
</div>
<a id="a677794d11194506a7d723d565ad0264a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677794d11194506a7d723d565ad0264a">&#9670;&nbsp;</a></span>mem_key_ahi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_ahi</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keys for registering allocations with performance schema. </p>
<p>Pointers to these variables are supplied to PFS code via the pfs_info[] array and the PFS code initializes them via PSI_MEMORY_CALL(register_memory)(). mem_key_other and mem_key_std are special in the following way. If the caller has not provided a key and the file name of the caller is unknown, then mem_key_std will be used. This happens only when called from within std::* containers. If the caller has not provided a key and the file name of the caller is known, but is not amongst the predefined names (see ut_new_boot()) then mem_key_other will be used. Generally this should not happen and if it happens then that means that the list of predefined names must be extended. Keep this list alphabetically sorted.</p>
<p>Keep this list alphabetically sorted. </p>

</div>
</div>
<a id="a8bfa35bea3d6c792bb9553b4997a39b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfa35bea3d6c792bb9553b4997a39b7">&#9670;&nbsp;</a></span>mem_key_archive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_archive</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5c19c1760ad493b3e1f76e7fe0374e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c19c1760ad493b3e1f76e7fe0374e1">&#9670;&nbsp;</a></span>mem_key_buf_buf_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_buf_buf_pool</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a259168aaea949acd8e4d42b62bd2e643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259168aaea949acd8e4d42b62bd2e643">&#9670;&nbsp;</a></span>mem_key_buf_stat_per_index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_buf_stat_per_index_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade54e574ebb69d193945bedf32e0380d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade54e574ebb69d193945bedf32e0380d">&#9670;&nbsp;</a></span>mem_key_clone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_clone</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory key for clone. </p>

</div>
</div>
<a id="aeecabe9d9930f4b4230ef9fb4750f384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecabe9d9930f4b4230ef9fb4750f384">&#9670;&nbsp;</a></span>mem_key_dict_stats_bg_recalc_pool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_dict_stats_bg_recalc_pool_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2589f85f05edbd6394b4a78b51f0b347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2589f85f05edbd6394b4a78b51f0b347">&#9670;&nbsp;</a></span>mem_key_dict_stats_index_map_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_dict_stats_index_map_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9a2e3a2142f613517aa49df9719b53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a2e3a2142f613517aa49df9719b53d">&#9670;&nbsp;</a></span>mem_key_dict_stats_n_diff_on_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_dict_stats_n_diff_on_level</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25de7f698d184c762ed999541c63a27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25de7f698d184c762ed999541c63a27f">&#9670;&nbsp;</a></span>mem_key_other</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_other</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a898fbb2ebd00d3f8d48a24f8c1789e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a898fbb2ebd00d3f8d48a24f8c1789e">&#9670;&nbsp;</a></span>mem_key_partitioning</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_partitioning</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d4162ae3c244aabd337969949f81286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4162ae3c244aabd337969949f81286">&#9670;&nbsp;</a></span>mem_key_redo_log_archive_queue_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_redo_log_archive_queue_element</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a987e10cacf3c33219b0166673b4dae9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987e10cacf3c33219b0166673b4dae9b">&#9670;&nbsp;</a></span>mem_key_row_log_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_row_log_buf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72ce048d8991c029b7da9d44303be1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ce048d8991c029b7da9d44303be1d2">&#9670;&nbsp;</a></span>mem_key_row_merge_sort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_row_merge_sort</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93006c6ff87e9d08a27b0f888ccae049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93006c6ff87e9d08a27b0f888ccae049">&#9670;&nbsp;</a></span>mem_key_std</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_std</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9db5a136d38de8803e5c7c36493669fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db5a136d38de8803e5c7c36493669fd">&#9670;&nbsp;</a></span>mem_key_trx_sys_t_rw_trx_ids</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_trx_sys_t_rw_trx_ids</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4ddf5a46c67294a44c80ca0650e12fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ddf5a46c67294a44c80ca0650e12fb">&#9670;&nbsp;</a></span>mem_key_undo_spaces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_undo_spaces</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5469d9a4e8f22f826803b86022abb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5469d9a4e8f22f826803b86022abb20">&#9670;&nbsp;</a></span>mem_key_ut_lock_free_hash_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> mem_key_ut_lock_free_hash_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e0b6265ae38565cb31e3e6ed035ec03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0b6265ae38565cb31e3e6ed035ec03">&#9670;&nbsp;</a></span>n_auto</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t n_auto = UT_ARR_SIZE(<a class="el" href="ut0new_8h.html#a8f19e4e69597607029e26755d1acc163">auto_event_names</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e648a4780a63858f6351d1dc75e0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e648a4780a63858f6351d1dc75e0b3">&#9670;&nbsp;</a></span>pfs_info_auto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#gac776797cad060503b8a8c3d331517194">PSI_memory_info</a> pfs_info_auto[<a class="el" href="ut0new_8h.html#a9e0b6265ae38565cb31e3e6ed035ec03">n_auto</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="ut0new_8h.html">ut0new.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
