<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/row/row0ins.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('row0ins_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">row0ins.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Insert into a table.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="current__thd_8h_source.html">current_thd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="data0data_8h_source.html">data0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dd_8h_source.html">dict0dd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eval0eval_8h_source.html">eval0eval.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fts0fts_8h_source.html">fts0fts.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fts0types_8h_source.html">fts0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="gis0geo_8h_source.html">gis0geo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lob0lob_8h_source.html">lob0lob.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="m__string_8h_source.html">m_string.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0ins_8h_source.html">row0ins.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0log_8h_source.html">row0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0sel_8h_source.html">row0sel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0rec_8h_source.html">trx0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="usr0sess_8h_source.html">usr0sess.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classib__dec__in__dtor.html">ib_dec_in_dtor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a599867cbcbfa45bcb4a597ad6185e160"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a599867cbcbfa45bcb4a597ad6185e160">row_ins_index_entry_big_rec</a>(trx,  e,  big,  ofs,  heap,  <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>,  thd)&#160;&#160;&#160;<a class="el" href="row0ins_8cc.html#a951f05d72f6c720a2ddb12fa691857bd">row_ins_index_entry_big_rec_func</a>(trx, e, big, ofs, heap, thd, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="separator:a599867cbcbfa45bcb4a597ad6185e160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af1f2605280087b2867fcebac1b890b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#af1f2605280087b2867fcebac1b890b0d">ins_node_create</a> (ulint ins_type, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:af1f2605280087b2867fcebac1b890b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an insert node struct.  <a href="#af1f2605280087b2867fcebac1b890b0d">More...</a><br /></td></tr>
<tr class="separator:af1f2605280087b2867fcebac1b890b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d18b2d6b41903799ec694cf05ca4fd4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a7d18b2d6b41903799ec694cf05ca4fd4">ins_node_create_entry_list</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node)</td></tr>
<tr class="memdesc:a7d18b2d6b41903799ec694cf05ca4fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an entry template for each index of a table.  <a href="#a7d18b2d6b41903799ec694cf05ca4fd4">More...</a><br /></td></tr>
<tr class="separator:a7d18b2d6b41903799ec694cf05ca4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af815065f5c7026722c8031c7f3824586"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#af815065f5c7026722c8031c7f3824586">row_ins_alloc_sys_fields</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node)</td></tr>
<tr class="memdesc:af815065f5c7026722c8031c7f3824586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds system field buffers to a row.  <a href="#af815065f5c7026722c8031c7f3824586">More...</a><br /></td></tr>
<tr class="separator:af815065f5c7026722c8031c7f3824586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e4b6225ce814f50b950fac862de004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#af3e4b6225ce814f50b950fac862de004">ins_node_set_new_row</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node, <a class="el" href="structdtuple__t.html">dtuple_t</a> *row)</td></tr>
<tr class="memdesc:af3e4b6225ce814f50b950fac862de004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new row to insert for an INS_DIRECT node.  <a href="#af3e4b6225ce814f50b950fac862de004">More...</a><br /></td></tr>
<tr class="separator:af3e4b6225ce814f50b950fac862de004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95122ebc220be72af86843a6b81d16cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a95122ebc220be72af86843a6b81d16cc">row_ins_sec_index_entry_by_modify</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, ulint mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *offsets_heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a95122ebc220be72af86843a6b81d16cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an insert operation by updating a delete-marked existing record in the index.  <a href="#a95122ebc220be72af86843a6b81d16cc">More...</a><br /></td></tr>
<tr class="separator:a95122ebc220be72af86843a6b81d16cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e566f24c9954fd7b54c9b6fb6257f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#ab0e566f24c9954fd7b54c9b6fb6257f1">row_ins_clust_index_entry_by_modify</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, ulint mode, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offsets_heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab0e566f24c9954fd7b54c9b6fb6257f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an insert operation by delete unmarking and updating a delete marked existing record in the index.  <a href="#ab0e566f24c9954fd7b54c9b6fb6257f1">More...</a><br /></td></tr>
<tr class="separator:ab0e566f24c9954fd7b54c9b6fb6257f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb202724c48a5577e7b9070d6830618"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a9cb202724c48a5577e7b9070d6830618">row_ins_cascade_ancestor_updates_table</a> (<a class="el" href="que0types_8h.html#a3509f9b5d79a0b309f8250593e46ed00">que_node_t</a> *node, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a9cb202724c48a5577e7b9070d6830618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if in a cascaded update/delete an ancestor node of node updates (not DELETE, but UPDATE) table.  <a href="#a9cb202724c48a5577e7b9070d6830618">More...</a><br /></td></tr>
<tr class="separator:a9cb202724c48a5577e7b9070d6830618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b6a46817daebff97b2c945dc01dd5"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#ace2b6a46817daebff97b2c945dc01dd5">row_ins_cascade_n_ancestors</a> (<a class="el" href="que0types_8h.html#a3509f9b5d79a0b309f8250593e46ed00">que_node_t</a> *node)</td></tr>
<tr class="memdesc:ace2b6a46817daebff97b2c945dc01dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ancestor UPDATE or DELETE nodes of a cascaded update/delete node.  <a href="#ace2b6a46817daebff97b2c945dc01dd5">More...</a><br /></td></tr>
<tr class="separator:ace2b6a46817daebff97b2c945dc01dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff26dd633322ded75500ae585252603"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a4ff26dd633322ded75500ae585252603">row_ins_cascade_calc_update_vec</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structtrx__t.html">trx_t</a> *trx, ibool *fts_col_affected)</td></tr>
<tr class="memdesc:a4ff26dd633322ded75500ae585252603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the update vector node-&gt;cascade-&gt;update for a child table in a cascaded update.  <a href="#a4ff26dd633322ded75500ae585252603">More...</a><br /></td></tr>
<tr class="separator:a4ff26dd633322ded75500ae585252603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132153bfa2162d8aac0e51708922682"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a3132153bfa2162d8aac0e51708922682">row_ins_set_detailed</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign)</td></tr>
<tr class="memdesc:a3132153bfa2162d8aac0e51708922682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set detailed error message associated with foreign key errors for the given transaction.  <a href="#a3132153bfa2162d8aac0e51708922682">More...</a><br /></td></tr>
<tr class="separator:a3132153bfa2162d8aac0e51708922682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6dc497b48c07053b224bba701b266f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a1c6dc497b48c07053b224bba701b266f">row_ins_foreign_trx_print</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a1c6dc497b48c07053b224bba701b266f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires dict_foreign_err_mutex, rewinds dict_foreign_err_file and displays information about the given transaction.  <a href="#a1c6dc497b48c07053b224bba701b266f">More...</a><br /></td></tr>
<tr class="separator:a1c6dc497b48c07053b224bba701b266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c955aa560ac4322e183bbcf85a2f568"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a1c955aa560ac4322e183bbcf85a2f568">row_ins_foreign_report_err</a> (const char *errstr, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>)</td></tr>
<tr class="memdesc:a1c955aa560ac4322e183bbcf85a2f568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a foreign key error associated with an update or a delete of a parent table index entry.  <a href="#a1c955aa560ac4322e183bbcf85a2f568">More...</a><br /></td></tr>
<tr class="separator:a1c955aa560ac4322e183bbcf85a2f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55627731abb1aa4f38288505a826a322"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a55627731abb1aa4f38288505a826a322">row_ins_foreign_report_add_err</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>)</td></tr>
<tr class="memdesc:a55627731abb1aa4f38288505a826a322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a foreign key error to dict_foreign_err_file when we are trying to add an index entry to a child table.  <a href="#a55627731abb1aa4f38288505a826a322">More...</a><br /></td></tr>
<tr class="separator:a55627731abb1aa4f38288505a826a322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afd6796d0bcafa8014133e40c33d42a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a5afd6796d0bcafa8014133e40c33d42a">row_ins_foreign_fill_virtual</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structupd__node__t.html">upd_node_t</a> *cascade, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *err)</td></tr>
<tr class="memdesc:a5afd6796d0bcafa8014133e40c33d42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill virtual column information in cascade node for the child table.  <a href="#a5afd6796d0bcafa8014133e40c33d42a">More...</a><br /></td></tr>
<tr class="separator:a5afd6796d0bcafa8014133e40c33d42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1f713481bd1d42b7244a39035d09e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__compiler_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a4c1f713481bd1d42b7244a39035d09e7">row_ins_foreign_check_on_constraint</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a4c1f713481bd1d42b7244a39035d09e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform referential actions or checks when a parent row is deleted or updated and the constraint had an ON DELETE or ON UPDATE condition which was not RESTRICT.  <a href="#a4c1f713481bd1d42b7244a39035d09e7">More...</a><br /></td></tr>
<tr class="separator:a4c1f713481bd1d42b7244a39035d09e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1772459ce62c67cd3dd123ed896eed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a0c1772459ce62c67cd3dd123ed896eed">row_ins_set_rec_lock</a> (<a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, ulint type, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a0c1772459ce62c67cd3dd123ed896eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lock on a record.  <a href="#a0c1772459ce62c67cd3dd123ed896eed">More...</a><br /></td></tr>
<tr class="separator:a0c1772459ce62c67cd3dd123ed896eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcad966ac982a98a25909e8b4965ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a5bcad966ac982a98a25909e8b4965ef6">row_ins_check_foreign_constraint</a> (ibool check_ref, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a5bcad966ac982a98a25909e8b4965ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if foreign key constraint fails for an index entry.  <a href="#a5bcad966ac982a98a25909e8b4965ef6">More...</a><br /></td></tr>
<tr class="separator:a5bcad966ac982a98a25909e8b4965ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826a411a9e0211a120467d1ffd10f572"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a826a411a9e0211a120467d1ffd10f572">row_ins_check_foreign_constraints</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a826a411a9e0211a120467d1ffd10f572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if foreign key constraints fail for an index entry.  <a href="#a826a411a9e0211a120467d1ffd10f572">More...</a><br /></td></tr>
<tr class="separator:a826a411a9e0211a120467d1ffd10f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588a8668c4a90abe6b241b83c541c351"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a588a8668c4a90abe6b241b83c541c351">row_ins_dupl_error_with_rec</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:a588a8668c4a90abe6b241b83c541c351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a unique key violation to rec would occur at the index entry insert.  <a href="#a588a8668c4a90abe6b241b83c541c351">More...</a><br /></td></tr>
<tr class="separator:a588a8668c4a90abe6b241b83c541c351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7754006c5f11c556f8ff95adb5af278a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a7754006c5f11c556f8ff95adb5af278a">row_allow_duplicates</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a7754006c5f11c556f8ff95adb5af278a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the query is REPLACE or ON DUPLICATE KEY UPDATE in which case duplicate values should be allowed (and further processed) instead of causing an error.  <a href="#a7754006c5f11c556f8ff95adb5af278a">More...</a><br /></td></tr>
<tr class="separator:a7754006c5f11c556f8ff95adb5af278a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4991e5f32cfebf602e3ffced76f9a61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#ad4991e5f32cfebf602e3ffced76f9a61">row_ins_scan_sec_index_for_duplicate</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> s_latch, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *offsets_heap)</td></tr>
<tr class="memdesc:ad4991e5f32cfebf602e3ffced76f9a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans a unique non-clustered index at a given index entry to determine whether a uniqueness violation has occurred for the key value of the entry.  <a href="#ad4991e5f32cfebf602e3ffced76f9a61">More...</a><br /></td></tr>
<tr class="separator:ad4991e5f32cfebf602e3ffced76f9a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74829dc6b4cdb1d78ef62836e62a1e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#ab74829dc6b4cdb1d78ef62836e62a1e9">row_ins_duplicate_online</a> (ulint n_uniq, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint *offsets)</td></tr>
<tr class="memdesc:ab74829dc6b4cdb1d78ef62836e62a1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for a duplicate when the table is being rebuilt online.  <a href="#ab74829dc6b4cdb1d78ef62836e62a1e9">More...</a><br /></td></tr>
<tr class="separator:ab74829dc6b4cdb1d78ef62836e62a1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ed2a6df0e886652cb4690061e3088d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a42ed2a6df0e886652cb4690061e3088d">row_ins_duplicate_error_in_clust_online</a> (ulint n_uniq, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap)</td></tr>
<tr class="memdesc:a42ed2a6df0e886652cb4690061e3088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for a duplicate when the table is being rebuilt online.  <a href="#a42ed2a6df0e886652cb4690061e3088d">More...</a><br /></td></tr>
<tr class="separator:a42ed2a6df0e886652cb4690061e3088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721038483c30190da01d4983426e1a0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a721038483c30190da01d4983426e1a0d">row_ins_duplicate_error_in_clust</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a721038483c30190da01d4983426e1a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a unique key violation error would occur at an index entry insert.  <a href="#a721038483c30190da01d4983426e1a0d">More...</a><br /></td></tr>
<tr class="separator:a721038483c30190da01d4983426e1a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0692e7c9f6e639e70527d39fb1b104f0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a0692e7c9f6e639e70527d39fb1b104f0">row_ins_must_modify_rec</a> (const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memdesc:a0692e7c9f6e639e70527d39fb1b104f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an index entry has long enough common prefix with an existing record so that the intended insert of the entry must be changed to a modify of the existing record.  <a href="#a0692e7c9f6e639e70527d39fb1b104f0">More...</a><br /></td></tr>
<tr class="separator:a0692e7c9f6e639e70527d39fb1b104f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951f05d72f6c720a2ddb12fa691857bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a951f05d72f6c720a2ddb12fa691857bd">row_ins_index_entry_big_rec_func</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *big_rec, ulint *offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a951f05d72f6c720a2ddb12fa691857bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the externally stored fields (off-page columns) of a clustered index entry.  <a href="#a951f05d72f6c720a2ddb12fa691857bd">More...</a><br /></td></tr>
<tr class="separator:a951f05d72f6c720a2ddb12fa691857bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8916958690bb6826949295733f4690cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a8916958690bb6826949295733f4690cb">row_ins_temp_prebuilt_tree_modified</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a8916958690bb6826949295733f4690cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all the prebuilts working on this temporary table.  <a href="#a8916958690bb6826949295733f4690cb">More...</a><br /></td></tr>
<tr class="separator:a8916958690bb6826949295733f4690cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1a6843152a30c486f8cdab878af159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a1f1a6843152a30c486f8cdab878af159">row_ins_clust_index_entry_low</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, ulint mode, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint n_uniq, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dup_chk_only)</td></tr>
<tr class="memdesc:a1f1a6843152a30c486f8cdab878af159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to insert an entry into a clustered index, ignoring foreign key constraints.  <a href="#a1f1a6843152a30c486f8cdab878af159">More...</a><br /></td></tr>
<tr class="separator:a1f1a6843152a30c486f8cdab878af159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d039a51cf040d81457dd82fc86db2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#af9d039a51cf040d81457dd82fc86db2e">row_ins_sorted_clust_index_entry</a> (ulint mode, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:af9d039a51cf040d81457dd82fc86db2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialized function meant for direct insertion to auto-generated clustered index based on cached position from last successful insert.  <a href="#af9d039a51cf040d81457dd82fc86db2e">More...</a><br /></td></tr>
<tr class="separator:af9d039a51cf040d81457dd82fc86db2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb30335cfd689bef6e440c1273bb6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a2aeb30335cfd689bef6e440c1273bb6b">row_ins_sec_mtr_start_and_check_if_aborted</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check, ulint search_mode)</td></tr>
<tr class="memdesc:a2aeb30335cfd689bef6e440c1273bb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a mini-transaction and check if the index will be dropped.  <a href="#a2aeb30335cfd689bef6e440c1273bb6b">More...</a><br /></td></tr>
<tr class="separator:a2aeb30335cfd689bef6e440c1273bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc2713f50d67428f560c036f53fe9f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a8cc2713f50d67428f560c036f53fe9f2">row_ins_sec_index_entry_low</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, ulint mode, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *offsets_heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dup_chk_only)</td></tr>
<tr class="memdesc:a8cc2713f50d67428f560c036f53fe9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to insert an entry into a secondary index.  <a href="#a8cc2713f50d67428f560c036f53fe9f2">More...</a><br /></td></tr>
<tr class="separator:a8cc2713f50d67428f560c036f53fe9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493242c78457f58ee63fbdb2be245dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a493242c78457f58ee63fbdb2be245dda">row_ins_clust_index_entry</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dup_chk_only)</td></tr>
<tr class="memdesc:a493242c78457f58ee63fbdb2be245dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an entry into a clustered index.  <a href="#a493242c78457f58ee63fbdb2be245dda">More...</a><br /></td></tr>
<tr class="separator:a493242c78457f58ee63fbdb2be245dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5633fd784e5e01aed1e4eb6d262341e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a5633fd784e5e01aed1e4eb6d262341e3">row_ins_sec_index_entry</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dup_chk_only)</td></tr>
<tr class="memdesc:a5633fd784e5e01aed1e4eb6d262341e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an entry into a secondary index.  <a href="#a5633fd784e5e01aed1e4eb6d262341e3">More...</a><br /></td></tr>
<tr class="separator:a5633fd784e5e01aed1e4eb6d262341e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad931ae4d03d6b07c060ab29e00645b36"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#ad931ae4d03d6b07c060ab29e00645b36">row_ins_sec_index_multi_value_entry</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, uint32_t &amp;multi_val_pos, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ad931ae4d03d6b07c060ab29e00645b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an entry into a secondary index, which is created for multi-value field.  <a href="#ad931ae4d03d6b07c060ab29e00645b36">More...</a><br /></td></tr>
<tr class="separator:ad931ae4d03d6b07c060ab29e00645b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd2fcd31120f10faa762c1079f715aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a0bd2fcd31120f10faa762c1079f715aa">row_ins_index_entry</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, uint32_t &amp;multi_val_pos, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a0bd2fcd31120f10faa762c1079f715aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an index entry to index.  <a href="#a0bd2fcd31120f10faa762c1079f715aa">More...</a><br /></td></tr>
<tr class="separator:a0bd2fcd31120f10faa762c1079f715aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d9d57a0e6956b1ebd23894d663585c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a11d9d57a0e6956b1ebd23894d663585c">row_ins_spatial_index_entry_set_mbr_field</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, const <a class="el" href="structdfield__t.html">dfield_t</a> *row_field, uint32_t *srid, const <a class="el" href="classdd_1_1Spatial__reference__system.html">dd::Spatial_reference_system</a> *srs)</td></tr>
<tr class="memdesc:a11d9d57a0e6956b1ebd23894d663585c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generate MBR (Minimum Bounding Box) for spatial objects and set it to spatial index field.  <a href="#a11d9d57a0e6956b1ebd23894d663585c">More...</a><br /></td></tr>
<tr class="separator:a11d9d57a0e6956b1ebd23894d663585c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22d9d699bd7a44b56a1359a62f0db68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#af22d9d699bd7a44b56a1359a62f0db68">row_ins_index_entry_set_vals</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *row)</td></tr>
<tr class="memdesc:af22d9d699bd7a44b56a1359a62f0db68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the values of the dtuple fields in entry from the values of appropriate columns in row.  <a href="#af22d9d699bd7a44b56a1359a62f0db68">More...</a><br /></td></tr>
<tr class="separator:af22d9d699bd7a44b56a1359a62f0db68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab968f6fd7479da4b9e5607480fa352a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#ab968f6fd7479da4b9e5607480fa352a3">row_ins_index_entry_step</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ab968f6fd7479da4b9e5607480fa352a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single index entry to the table.  <a href="#ab968f6fd7479da4b9e5607480fa352a3">More...</a><br /></td></tr>
<tr class="separator:ab968f6fd7479da4b9e5607480fa352a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae85262981ec83bbb2834801b3e33d41"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#aae85262981ec83bbb2834801b3e33d41">row_ins_alloc_row_id_step</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node)</td></tr>
<tr class="memdesc:aae85262981ec83bbb2834801b3e33d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a row id for row and inits the node-&gt;index field.  <a href="#aae85262981ec83bbb2834801b3e33d41">More...</a><br /></td></tr>
<tr class="separator:aae85262981ec83bbb2834801b3e33d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc41d8ba034f219333a5809bc6d0a0f1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#adc41d8ba034f219333a5809bc6d0a0f1">row_ins_get_row_from_values</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node)</td></tr>
<tr class="memdesc:adc41d8ba034f219333a5809bc6d0a0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a row to insert from the values list.  <a href="#adc41d8ba034f219333a5809bc6d0a0f1">More...</a><br /></td></tr>
<tr class="separator:adc41d8ba034f219333a5809bc6d0a0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af868b3e7fdbcce8080ee49d53eced1d8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#af868b3e7fdbcce8080ee49d53eced1d8">row_ins_get_row_from_select</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node)</td></tr>
<tr class="memdesc:af868b3e7fdbcce8080ee49d53eced1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a row to insert from the select list.  <a href="#af868b3e7fdbcce8080ee49d53eced1d8">More...</a><br /></td></tr>
<tr class="separator:af868b3e7fdbcce8080ee49d53eced1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86afb4d842f2235b79c9e0b2ea50931"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#ab86afb4d842f2235b79c9e0b2ea50931">row_ins</a> (<a class="el" href="structins__node__t.html">ins_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ab86afb4d842f2235b79c9e0b2ea50931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a row to a table.  <a href="#ab86afb4d842f2235b79c9e0b2ea50931">More...</a><br /></td></tr>
<tr class="separator:ab86afb4d842f2235b79c9e0b2ea50931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c42f8819ae8ae3d8a44098158bfd051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0ins_8cc.html#a1c42f8819ae8ae3d8a44098158bfd051">row_ins_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a1c42f8819ae8ae3d8a44098158bfd051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a row to a table.  <a href="#a1c42f8819ae8ae3d8a44098158bfd051">More...</a><br /></td></tr>
<tr class="separator:a1c42f8819ae8ae3d8a44098158bfd051"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Insert into a table. </p>
<p>Created 4/20/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a599867cbcbfa45bcb4a597ad6185e160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599867cbcbfa45bcb4a597ad6185e160">&#9670;&nbsp;</a></span>row_ins_index_entry_big_rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define row_ins_index_entry_big_rec</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">trx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">big, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ofs, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="row0ins_8cc.html#a951f05d72f6c720a2ddb12fa691857bd">row_ins_index_entry_big_rec_func</a>(trx, e, big, ofs, heap, thd, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af1f2605280087b2867fcebac1b890b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f2605280087b2867fcebac1b890b0d">&#9670;&nbsp;</a></span>ins_node_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structins__node__t.html">ins_node_t</a>* ins_node_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>ins_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an insert node struct. </p>
<dl class="section return"><dt>Returns</dt><dd>own: insert node struct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ins_type</td><td>in: INS_VALUES, ... </td></tr>
    <tr><td class="paramname">table</td><td>in: table where to insert </td></tr>
    <tr><td class="paramname">heap</td><td>in: mem heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d18b2d6b41903799ec694cf05ca4fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d18b2d6b41903799ec694cf05ca4fd4">&#9670;&nbsp;</a></span>ins_node_create_entry_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ins_node_create_entry_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an entry template for each index of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row insert node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3e4b6225ce814f50b950fac862de004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e4b6225ce814f50b950fac862de004">&#9670;&nbsp;</a></span>ins_node_set_new_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ins_node_set_new_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new row to insert for an INS_DIRECT node. </p>
<p>This function is only used if we have constructed the row separately, which is a rare case; this function is quite slow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: insert node </td></tr>
    <tr><td class="paramname">row</td><td>in: new row (or first row) for the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7754006c5f11c556f8ff95adb5af278a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7754006c5f11c556f8ff95adb5af278a">&#9670;&nbsp;</a></span>row_allow_duplicates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_allow_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the query is REPLACE or ON DUPLICATE KEY UPDATE in which case duplicate values should be allowed (and further processed) instead of causing an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>The query thread running the query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff duplicated values should be allowed </dd></dl>

</div>
</div>
<a id="ab86afb4d842f2235b79c9e0b2ea50931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86afb4d842f2235b79c9e0b2ea50931">&#9670;&nbsp;</a></span>row_ins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a row to a table. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row insert node </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae85262981ec83bbb2834801b3e33d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae85262981ec83bbb2834801b3e33d41">&#9670;&nbsp;</a></span>row_ins_alloc_row_id_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_ins_alloc_row_id_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a row id for row and inits the node-&gt;index field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row insert node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af815065f5c7026722c8031c7f3824586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af815065f5c7026722c8031c7f3824586">&#9670;&nbsp;</a></span>row_ins_alloc_sys_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_alloc_sys_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds system field buffers to a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: insert node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb202724c48a5577e7b9070d6830618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb202724c48a5577e7b9070d6830618">&#9670;&nbsp;</a></span>row_ins_cascade_ancestor_updates_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool row_ins_cascade_ancestor_updates_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="que0types_8h.html#a3509f9b5d79a0b309f8250593e46ed00">que_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if in a cascaded update/delete an ancestor node of node updates (not DELETE, but UPDATE) table. </p>
<dl class="section return"><dt>Returns</dt><dd>true if an ancestor updates table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: node in a query graph </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ff26dd633322ded75500ae585252603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff26dd633322ded75500ae585252603">&#9670;&nbsp;</a></span>row_ins_cascade_calc_update_vec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint row_ins_cascade_calc_update_vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>fts_col_affected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the update vector node-&gt;cascade-&gt;update for a child table in a cascaded update. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields in the calculated update vector; the value can also be 0 if no foreign key fields changed; the returned value is ULINT_UNDEFINED if the column type in the child table is too short to fit the new value in the parent table: that means the update fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: update node of the parent table </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign key constraint whose type is != 0 </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap to use as temporary storage </td></tr>
    <tr><td class="paramname">trx</td><td>in: update transaction </td></tr>
    <tr><td class="paramname">fts_col_affected</td><td>out: is FTS column affected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace2b6a46817daebff97b2c945dc01dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2b6a46817daebff97b2c945dc01dd5">&#9670;&nbsp;</a></span>row_ins_cascade_n_ancestors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint row_ins_cascade_n_ancestors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="que0types_8h.html#a3509f9b5d79a0b309f8250593e46ed00">que_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of ancestor UPDATE or DELETE nodes of a cascaded update/delete node. </p>
<dl class="section return"><dt>Returns</dt><dd>number of ancestors </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: node in a query graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bcad966ac982a98a25909e8b4965ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcad966ac982a98a25909e8b4965ef6">&#9670;&nbsp;</a></span>row_ins_check_foreign_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_check_foreign_constraint </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>check_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if foreign key constraint fails for an index entry. </p>
<p>Sets shared locks which lock either the success or the failure of the constraint. NOTE that the caller must have a shared latch on dict_operation_lock. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_NO_REFERENCED_ROW, or DB_ROW_IS_REFERENCED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check_ref</td><td>in: TRUE if we want to check that the referenced table is ok, FALSE if we want to check the foreign key table </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign constraint; NOTE that the tables mentioned in it must be in the dictionary cache if they exist at all </td></tr>
    <tr><td class="paramname">table</td><td>in: if check_ref is TRUE, then the foreign table, else the referenced table </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry for index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a826a411a9e0211a120467d1ffd10f572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826a411a9e0211a120467d1ffd10f572">&#9670;&nbsp;</a></span>row_ins_check_foreign_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_check_foreign_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if foreign key constraints fail for an index entry. </p>
<p>If index is not mentioned in any constraint, this function does nothing, Otherwise does searches to the indexes of referenced tables and sets shared locks which lock either the success or the failure of a constraint. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry for index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a493242c78457f58ee63fbdb2be245dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493242c78457f58ee63fbdb2be245dda">&#9670;&nbsp;</a></span>row_ins_clust_index_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_clust_index_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dup_chk_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an entry into a clustered index. </p>
<p>Tries first optimistic, then pessimistic descent down the tree. If the entry matches enough to a delete marked record, performs the insert by updating or delete unmarking the delete marked record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DUPLICATE_KEY, or some other error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: index entry to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">dup_chk_only</td><td>in: if true, just do duplicate check and return. don't execute actual insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0e566f24c9954fd7b54c9b6fb6257f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e566f24c9954fd7b54c9b6fb6257f1">&#9670;&nbsp;</a></span>row_ins_clust_index_entry_by_modify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_clust_index_entry_by_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an insert operation by delete unmarking and updating a delete marked existing record in the index. </p>
<p>This situation can occur if the delete marked record is kept in the index for consistent reads. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_FAIL, or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcur</td><td>in/out: a persistent cursor pointing to the clust_rec that is being modified. </td></tr>
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">mode</td><td>in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE, depending on whether mtr holds just a leaf latch or also a tree latch </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">offsets_heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: memory heap </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f1a6843152a30c486f8cdab878af159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1a6843152a30c486f8cdab878af159">&#9670;&nbsp;</a></span>row_ins_clust_index_entry_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_clust_index_entry_low </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_uniq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dup_chk_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to insert an entry into a clustered index, ignoring foreign key constraints. </p>
<p>If a record with the same unique key is found, the other record is necessarily marked deleted by a committed transaction, or a unique key violation error occurs. The delete marked record is then updated to an existing record, and we must write an undo log record on the delete marked record. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_LOCK_WAIT</td><td>on lock wait when !(flags &amp; BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">DB_FAIL</td><td>if retry with BTR_MODIFY_TREE is needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">mode</td><td>in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE, depending on whether we wish optimistic or pessimistic descent down the index tree </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">n_uniq</td><td>in: 0 or index-&gt;n_uniq </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: index entry to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread, or NULL if flags &amp; (BTR_NO_LOCKING_FLAG | BTR_NO_UNDO_LOG_FLAG) and a duplicate can't occur </td></tr>
    <tr><td class="paramname">dup_chk_only</td><td>in: if true, just do duplicate check and return. don't execute actual insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a588a8668c4a90abe6b241b83c541c351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588a8668c4a90abe6b241b83c541c351">&#9670;&nbsp;</a></span>row_ins_dupl_error_with_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool row_ins_dupl_error_with_rec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a unique key violation to rec would occur at the index entry insert. </p>
<dl class="section return"><dt>Returns</dt><dd>true if error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record; NOTE that we assume that the caller already has a record lock on the record! </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a721038483c30190da01d4983426e1a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721038483c30190da01d4983426e1a0d">&#9670;&nbsp;</a></span>row_ins_duplicate_error_in_clust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_duplicate_error_in_clust </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a unique key violation error would occur at an index entry insert. </p>
<p>Sets shared locks on possible duplicate records. Works only for a clustered index! </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>if no error </td></tr>
    <tr><td class="paramname">DB_DUPLICATE_KEY</td><td>if error, </td></tr>
    <tr><td class="paramname">DB_LOCK_WAIT</td><td>if we have to wait for a lock on a possible duplicate record </td></tr>
    <tr><td class="paramname">DB_SUCCESS_LOCKED_REC</td><td>if an exact match of the record was found in online table rebuild (flags &amp; (BTR_KEEP_SYS_FLAG | BTR_NO_LOCKING_FLAG)) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: B-tree cursor </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42ed2a6df0e886652cb4690061e3088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ed2a6df0e886652cb4690061e3088d">&#9670;&nbsp;</a></span>row_ins_duplicate_error_in_clust_online()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_duplicate_error_in_clust_online </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_uniq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for a duplicate when the table is being rebuilt online. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>when no duplicate is detected </td></tr>
    <tr><td class="paramname">DB_SUCCESS_LOCKED_REC</td><td>when rec is an exact match of entry or a newer version of entry (the entry should not be inserted) </td></tr>
    <tr><td class="paramname">DB_DUPLICATE_KEY</td><td>when entry is a duplicate of rec </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_uniq</td><td>in: offset of DB_TRX_ID </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry that is being inserted </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on insert position </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: heap for offsets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab74829dc6b4cdb1d78ef62836e62a1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74829dc6b4cdb1d78ef62836e62a1e9">&#9670;&nbsp;</a></span>row_ins_duplicate_online()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_duplicate_online </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_uniq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for a duplicate when the table is being rebuilt online. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_uniq</td><td>offset of DB_TRX_ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>entry being inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>clustered index record at insert position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>when no duplicate is detected </td></tr>
    <tr><td class="paramname">DB_SUCCESS_LOCKED_REC</td><td>when rec is an exact match of entry or a newer version of entry (the entry should not be inserted) </td></tr>
    <tr><td class="paramname">DB_DUPLICATE_KEY</td><td>when entry is a duplicate of rec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c1f713481bd1d42b7244a39035d09e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1f713481bd1d42b7244a39035d09e7">&#9670;&nbsp;</a></span>row_ins_foreign_check_on_constraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__compiler_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_foreign_check_on_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform referential actions or checks when a parent row is deleted or updated and the constraint had an ON DELETE or ON UPDATE condition which was not RESTRICT. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error code Disable inlining because of a bug in gcc8 which may lead to stack exhaustion. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread whose run_node is an update node </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign key constraint whose type is != 0 </td></tr>
    <tr><td class="paramname">pcur</td><td>in: cursor placed on a matching index record in the child table </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry in the parent table </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr holding the latch of pcur page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5afd6796d0bcafa8014133e40c33d42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afd6796d0bcafa8014133e40c33d42a">&#9670;&nbsp;</a></span>row_ins_foreign_fill_virtual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_foreign_fill_virtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>cascade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill virtual column information in cascade node for the child table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>current transaction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cascade</td><td>child update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>clustered rec of child table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index of child table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>parent update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">foreign</td><td>foreign key information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>error code. </td></tr>
  </table>
  </dd>
</dl>
<p>This can occur when there is a cascading delete or update after restart. </p>

</div>
</div>
<a id="a55627731abb1aa4f38288505a826a322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55627731abb1aa4f38288505a826a322">&#9670;&nbsp;</a></span>row_ins_foreign_report_add_err()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_foreign_report_add_err </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports a foreign key error to dict_foreign_err_file when we are trying to add an index entry to a child table. </p>
<p>Note that the adding may be the result of an update, too. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign key constraint </td></tr>
    <tr><td class="paramname">rec</td><td>in: a record in the parent table: it does not match entry because we have an error! </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry to insert in the child table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c955aa560ac4322e183bbcf85a2f568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c955aa560ac4322e183bbcf85a2f568">&#9670;&nbsp;</a></span>row_ins_foreign_report_err()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_foreign_report_err </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports a foreign key error associated with an update or a delete of a parent table index entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errstr</td><td>in: error string from the viewpoint of the parent table </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread whose run_node is an update node </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign key constraint </td></tr>
    <tr><td class="paramname">rec</td><td>in: a matching index record in the child table </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry in the parent table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c6dc497b48c07053b224bba701b266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6dc497b48c07053b224bba701b266f">&#9670;&nbsp;</a></span>row_ins_foreign_trx_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_foreign_trx_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires dict_foreign_err_mutex, rewinds dict_foreign_err_file and displays information about the given transaction. </p>
<p>The caller must release dict_foreign_err_mutex. </p>
<p>lock_number_of_rows_locked() requires global exclusive latch, and so does accessing trx_locks with trx-&gt;mutex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af868b3e7fdbcce8080ee49d53eced1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af868b3e7fdbcce8080ee49d53eced1d8">&#9670;&nbsp;</a></span>row_ins_get_row_from_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_ins_get_row_from_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a row to insert from the select list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row insert node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc41d8ba034f219333a5809bc6d0a0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc41d8ba034f219333a5809bc6d0a0f1">&#9670;&nbsp;</a></span>row_ins_get_row_from_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_ins_get_row_from_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a row to insert from the values list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row insert node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bd2fcd31120f10faa762c1079f715aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd2fcd31120f10faa762c1079f715aa">&#9670;&nbsp;</a></span>row_ins_index_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_index_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>multi_val_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an index entry to index. </p>
<p>Tries first optimistic, then pessimistic descent down the tree. If the entry matches enough to a delete marked record, performs the insert by updating or delete unmarking the delete marked record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index to insert the entry </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>entry to insert </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">multi_val_pos</td><td>if multi-value index, the start position to insert next multi-value data, and the returned value should be either 0 if all are done, or the position where the insert failed. So return value of 0 could be a bit ambiguous, however the return error can help to see which case it is </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DUPLICATE_KEY, or some other error code </dd></dl>

</div>
</div>
<a id="a951f05d72f6c720a2ddb12fa691857bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951f05d72f6c720a2ddb12fa691857bd">&#9670;&nbsp;</a></span>row_ins_index_entry_big_rec_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_index_entry_big_rec_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the externally stored fields (off-page columns) of a clustered index entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>current transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>index entry to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">big_rec</td><td>externally stored fields </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>rec_get_offsets() </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>client connection, or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td></td></tr>
    <tr><td class="paramname">DB_OUT_OF_FILE_SPACE</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af22d9d699bd7a44b56a1359a62f0db68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22d9d699bd7a44b56a1359a62f0db68">&#9670;&nbsp;</a></span>row_ins_index_entry_set_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_index_entry_set_vals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the values of the dtuple fields in entry from the values of appropriate columns in row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">entry</td><td>index entry to make </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if the set is successful </dd></dl>

</div>
</div>
<a id="ab968f6fd7479da4b9e5607480fa352a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab968f6fd7479da4b9e5607480fa352a3">&#9670;&nbsp;</a></span>row_ins_index_entry_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_index_entry_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single index entry to the table. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: row insert node </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0692e7c9f6e639e70527d39fb1b104f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0692e7c9f6e639e70527d39fb1b104f0">&#9670;&nbsp;</a></span>row_ins_must_modify_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool row_ins_must_modify_rec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an index entry has long enough common prefix with an existing record so that the intended insert of the entry must be changed to a modify of the existing record. </p>
<p>In the case of a clustered index, the prefix must be n_unique fields long. In the case of a secondary index, all fields must be equal. InnoDB never updates secondary index records in place, other than clearing or setting the delete-mark flag. We could be able to update the non-unique fields of a unique secondary index record by checking the cursor-&gt;up_match, but we do not do so, because it could have some locking implications. </p><dl class="section return"><dt>Returns</dt><dd>true if the existing record should be updated; false if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: B-tree cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4991e5f32cfebf602e3ffced76f9a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4991e5f32cfebf602e3ffced76f9a61">&#9670;&nbsp;</a></span>row_ins_scan_sec_index_for_duplicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_scan_sec_index_for_duplicate </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>s_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>offsets_heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans a unique non-clustered index at a given index entry to determine whether a uniqueness violation has occurred for the key value of the entry. </p>
<p>Set shared locks on possible duplicate records. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_DUPLICATE_KEY, or DB_LOCK_WAIT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">index</td><td>in: non-clustered unique index </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">s_latch</td><td>in: whether index-&gt;lock is being held </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">offsets_heap</td><td>in/out: memory heap that can be emptied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5633fd784e5e01aed1e4eb6d262341e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5633fd784e5e01aed1e4eb6d262341e3">&#9670;&nbsp;</a></span>row_ins_sec_index_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_sec_index_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dup_chk_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an entry into a secondary index. </p>
<p>Tries first optimistic, then pessimistic descent down the tree. If the entry matches enough to a delete marked record, performs the insert by updating or delete unmarking the delete marked record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DUPLICATE_KEY, or some other error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: index entry to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">dup_chk_only</td><td>in: if true, just do duplicate check and return. don't execute actual insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95122ebc220be72af86843a6b81d16cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95122ebc220be72af86843a6b81d16cc">&#9670;&nbsp;</a></span>row_ins_sec_index_entry_by_modify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_sec_index_entry_by_modify </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an insert operation by updating a delete-marked existing record in the index. </p>
<p>This situation can occur if the delete-marked record is kept in the index for consistent reads. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">mode</td><td>in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE, depending on whether mtr holds just a leaf latch or also a tree latch </td></tr>
    <tr><td class="paramname">cursor</td><td>in: B-tree cursor </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">offsets_heap</td><td>in/out: memory heap that can be emptied </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: memory heap </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cc2713f50d67428f560c036f53fe9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc2713f50d67428f560c036f53fe9f2">&#9670;&nbsp;</a></span>row_ins_sec_index_entry_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_sec_index_entry_low </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dup_chk_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to insert an entry into a secondary index. </p>
<p>If a record with exactly the same fields is found, the other record is necessarily marked deleted. It is then unmarked. Otherwise, the entry is just inserted to the index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>undo logging and locking flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>BTR_MODIFY_LEAF or BTR_MODIFY_TREE, depending on whether we wish optimistic or pessimistic descent down the index tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets_heap</td><td>memory heap that can be emptied </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>index entry to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>PAGE_MAX_TRX_ID during row_log_table_apply(), or trx_id when undo log is disabled during alter copy operation or 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dup_chk_only</td><td>TRUE, just do duplicate check and return. don't execute actual insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_LOCK_WAIT</td><td>on lock wait when !(flags &amp; BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">DB_FAIL</td><td>if retry with BTR_MODIFY_TREE is needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a id="ad931ae4d03d6b07c060ab29e00645b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad931ae4d03d6b07c060ab29e00645b36">&#9670;&nbsp;</a></span>row_ins_sec_index_multi_value_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_sec_index_multi_value_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>multi_val_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an entry into a secondary index, which is created for multi-value field. </p>
<p>For each value to be inserted, it tries first optimistic, then pessimistic descent down the tree. If the entry matches enough to a delete marked record, performs the insert by updating or delete unmarking the delete marked record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index which is for multi-value field </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>index entry to insert </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">multi_val_pos</td><td>the start position to insert next multi-value data, and the returned value should be either 0 if all are done, or the position where the insert failed. So return value of 0 could be a bit ambiguous, however the return error can help to see which case it is </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DUPLICATE_KEY, or some other error code </dd></dl>

</div>
</div>
<a id="a2aeb30335cfd689bef6e440c1273bb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeb30335cfd689bef6e440c1273bb6b">&#9670;&nbsp;</a></span>row_ins_sec_mtr_start_and_check_if_aborted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_ins_sec_mtr_start_and_check_if_aborted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>search_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a mini-transaction and check if the index will be dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check</td><td>Whether to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">search_mode</td><td>Flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index is to be dropped </dd></dl>

</div>
</div>
<a id="a3132153bfa2162d8aac0e51708922682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3132153bfa2162d8aac0e51708922682">&#9670;&nbsp;</a></span>row_ins_set_detailed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_set_detailed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set detailed error message associated with foreign key errors for the given transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign key constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c1772459ce62c67cd3dd123ed896eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1772459ce62c67cd3dd123ed896eed">&#9670;&nbsp;</a></span>row_ins_set_rec_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_set_rec_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a lock on a record. </p>
<p>Used in locking possible duplicate key records and also in checking foreign key constraints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>requested lock type: LOCK_S or LOCK_X mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP type lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, or error code </dd></dl>

</div>
</div>
<a id="af9d039a51cf040d81457dd82fc86db2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d039a51cf040d81457dd82fc86db2e">&#9670;&nbsp;</a></span>row_ins_sorted_clust_index_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_ins_sorted_clust_index_entry </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a specialized function meant for direct insertion to auto-generated clustered index based on cached position from last successful insert. </p>
<p>To be used when data is sorted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>BTR_MODIFY_LEAF or BTR_MODIFY_TREE. depending on whether we wish optimistic or pessimistic descent down the index tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>index entry to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a id="a11d9d57a0e6956b1ebd23894d663585c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d9d57a0e6956b1ebd23894d663585c">&#9670;&nbsp;</a></span>row_ins_spatial_index_entry_set_mbr_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_spatial_index_entry_set_mbr_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>row_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>srid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Spatial__reference__system.html">dd::Spatial_reference_system</a> *&#160;</td>
          <td class="paramname"><em>srs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function generate MBR (Minimum Bounding Box) for spatial objects and set it to spatial index field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in/out: mbr field </td></tr>
    <tr><td class="paramname">row_field</td><td>in: row field </td></tr>
    <tr><td class="paramname">srid</td><td>in/out: spatial reference id </td></tr>
    <tr><td class="paramname">srs</td><td>in: SRS of row_field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c42f8819ae8ae3d8a44098158bfd051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c42f8819ae8ae3d8a44098158bfd051">&#9670;&nbsp;</a></span>row_ins_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* row_ins_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a row to a table. </p>
<p>This is a high-level function used in SQL execution graphs. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8916958690bb6826949295733f4690cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8916958690bb6826949295733f4690cb">&#9670;&nbsp;</a></span>row_ins_temp_prebuilt_tree_modified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_ins_temp_prebuilt_tree_modified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update all the prebuilts working on this temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>dict_table_t for the table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_4dd6d22ab21a818a66544a670705c483.html">row</a></li><li class="navelem"><a class="el" href="row0ins_8cc.html">row0ins.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
