<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/dict0dict.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dict0dict_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dict0dict.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data dictionary system.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;set&gt;</code><br />
<code>#include &lt;deque&gt;</code><br />
<code>#include &quot;<a class="el" href="data0data_8h_source.html">data0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="data0type_8h_source.html">data0type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict_8h_source.html">dict/dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0fsp_8h_source.html">fsp0fsp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0sysspace_8h_source.html">fsp0sysspace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0types_8h_source.html">rem0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="object__id_8h_source.html">sql/dd/object_id.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0new_8h_source.html">ut0new.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0rnd_8h_source.html">ut0rnd.h</a>&quot;</code><br />
<code>#include &quot;dict0dict.ic&quot;</code><br />
</div>
<p><a href="dict0dict_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__sys__t.html">dict_sys_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__persist__t.html">dict_persist_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for persisting dynamic metadata of data dictionary.  <a href="structdict__persist__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDTableBuffer.html">DDTableBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the mysql.innodb_dynamic_metadata used to buffer the persistent dynamic metadata.  <a href="classDDTableBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a618168d3c16fcf6d9174b43907d1492c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a618168d3c16fcf6d9174b43907d1492c">DICT_HEAP_SIZE</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:a618168d3c16fcf6d9174b43907d1492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">initial memory heap size when \ creating a table or index object  <a href="#a618168d3c16fcf6d9174b43907d1492c">More...</a><br /></td></tr>
<tr class="separator:a618168d3c16fcf6d9174b43907d1492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be951de2c67a0782db3d5ce137f5a04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a7be951de2c67a0782db3d5ce137f5a04">dict_table_skip_corrupt_index</a>(<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="separator:a7be951de2c67a0782db3d5ce137f5a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5e00868dd761d41aafd9647c8e6750"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1a5e00868dd761d41aafd9647c8e6750">dict_table_next_uncorrupted_index</a>(<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="separator:a1a5e00868dd761d41aafd9647c8e6750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7227a5ba3c90ba9ca2bcb0dbbc7c66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5f7227a5ba3c90ba9ca2bcb0dbbc7c66">BIG_ROW_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a5f7227a5ba3c90ba9ca2bcb0dbbc7c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb5792cd6068ffb0d5e274d853c2bd5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5eb5792cd6068ffb0d5e274d853c2bd5">DICT_INDEX_SPATIAL_NODEPTR_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a5eb5792cd6068ffb0d5e274d853c2bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of fields in the nonleaf page of spatial index, except the page no field.  <a href="#a5eb5792cd6068ffb0d5e274d853c2bd5">More...</a><br /></td></tr>
<tr class="separator:a5eb5792cd6068ffb0d5e274d853c2bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca606358fb7a110d5646b4381c5e36d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#adca606358fb7a110d5646b4381c5e36d">MAX_NUM_FK_COLUMNS</a>&#160;&#160;&#160;500</td></tr>
<tr class="memdesc:adca606358fb7a110d5646b4381c5e36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of columns in a foreign key constraint.  <a href="#adca606358fb7a110d5646b4381c5e36d">More...</a><br /></td></tr>
<tr class="separator:adca606358fb7a110d5646b4381c5e36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad37e188831074bcf7fdae6bd963a1599"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599">dict_table_op_t</a> { <a class="el" href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599aca5dacda41b8d55d5015945d1ff28818">DICT_TABLE_OP_NORMAL</a> = 0, 
<a class="el" href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599afc38fb5b824eeff6802c98f34534e940">DICT_TABLE_OP_DROP_ORPHAN</a>, 
<a class="el" href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599ada7c6b8846b2a27c2a4d0a0fec8cc5e5">DICT_TABLE_OP_LOAD_TABLESPACE</a>
 }<tr class="memdesc:ad37e188831074bcf7fdae6bd963a1599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation to perform when opening a table.  <a href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad37e188831074bcf7fdae6bd963a1599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d4b1626b1bf4ea2e8d645210d4d476"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476">check_name</a> { <a class="el" href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476a806731b0fba64e973a80e13d43987fa4">CHECK_ALL_COMPLETE</a>, 
<a class="el" href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476a372fee1255c20c9a4a206b057b279cf8">CHECK_ABORTED_OK</a>, 
<a class="el" href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476a87cff9b1eefd118223ee33c69348e78a">CHECK_PARTIAL_OK</a>
 }<tr class="memdesc:a96d4b1626b1bf4ea2e8d645210d4d476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether and when to allow temporary index names.  <a href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a96d4b1626b1bf4ea2e8d645210d4d476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a06b911af9a8049bb19f4f701ecd08064"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a06b911af9a8049bb19f4f701ecd08064">dict_get_db_name_len</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="memdesc:a06b911af9a8049bb19f4f701ecd08064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the database name length in a table name.  <a href="#a06b911af9a8049bb19f4f701ecd08064">More...</a><br /></td></tr>
<tr class="separator:a06b911af9a8049bb19f4f701ecd08064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4458ebcd1a2943f7d122ed1badc964e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a4458ebcd1a2943f7d122ed1badc964e7">dict_foreign_free</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign)</td></tr>
<tr class="memdesc:a4458ebcd1a2943f7d122ed1badc964e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a foreign key struct.  <a href="#a4458ebcd1a2943f7d122ed1badc964e7">More...</a><br /></td></tr>
<tr class="separator:a4458ebcd1a2943f7d122ed1badc964e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f552c54e180ca58368c8b67c4961ad"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a09f552c54e180ca58368c8b67c4961ad">dict_table_get_highest_foreign_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a09f552c54e180ca58368c8b67c4961ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest [number] for foreign key constraints of the table.  <a href="#a09f552c54e180ca58368c8b67c4961ad">More...</a><br /></td></tr>
<tr class="separator:a09f552c54e180ca58368c8b67c4961ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9bd94fd5c39b012b78c179e3f6336d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a3b9bd94fd5c39b012b78c179e3f6336d">dict_remove_db_name</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="memdesc:a3b9bd94fd5c39b012b78c179e3f6336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end of table name where we have removed dbname and '/'.  <a href="#a3b9bd94fd5c39b012b78c179e3f6336d">More...</a><br /></td></tr>
<tr class="separator:a3b9bd94fd5c39b012b78c179e3f6336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d923a0efd8786f3f21a026c89bcee1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a2d923a0efd8786f3f21a026c89bcee1f">dict_table_close</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ibool dict_locked, ibool try_drop)</td></tr>
<tr class="memdesc:a2d923a0efd8786f3f21a026c89bcee1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the count of open handles to a table.  <a href="#a2d923a0efd8786f3f21a026c89bcee1f">More...</a><br /></td></tr>
<tr class="separator:a2d923a0efd8786f3f21a026c89bcee1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c514f3985e99bc04eef58c65d3638b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a58c514f3985e99bc04eef58c65d3638b">dict_table_close_and_drop</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a58c514f3985e99bc04eef58c65d3638b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the only open handle to a table and drops a table while assuring that dict_sys-&gt;mutex is held the whole time.  <a href="#a58c514f3985e99bc04eef58c65d3638b">More...</a><br /></td></tr>
<tr class="separator:a58c514f3985e99bc04eef58c65d3638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047c7e1b181bcd0caed7d4b66d641626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a047c7e1b181bcd0caed7d4b66d641626">dict_init</a> (void)</td></tr>
<tr class="memdesc:a047c7e1b181bcd0caed7d4b66d641626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits the data dictionary module.  <a href="#a047c7e1b181bcd0caed7d4b66d641626">More...</a><br /></td></tr>
<tr class="separator:a047c7e1b181bcd0caed7d4b66d641626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba7e509db4f0987778c5cf7e042f961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a2ba7e509db4f0987778c5cf7e042f961">dict_close</a> (void)</td></tr>
<tr class="memdesc:a2ba7e509db4f0987778c5cf7e042f961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the data dictionary module.  <a href="#a2ba7e509db4f0987778c5cf7e042f961">More...</a><br /></td></tr>
<tr class="separator:a2ba7e509db4f0987778c5cf7e042f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5625204b6cf879690f2f9ecdd8966d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5625204b6cf879690f2f9ecdd8966d09">dict_persist_init</a> (void)</td></tr>
<tr class="memdesc:a5625204b6cf879690f2f9ecdd8966d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits the structure for persisting dynamic metadata.  <a href="#a5625204b6cf879690f2f9ecdd8966d09">More...</a><br /></td></tr>
<tr class="separator:a5625204b6cf879690f2f9ecdd8966d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349be868adf860eb3eebe9b46647a724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a349be868adf860eb3eebe9b46647a724">dict_persist_close</a> (void)</td></tr>
<tr class="memdesc:a349be868adf860eb3eebe9b46647a724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the structure.  <a href="#a349be868adf860eb3eebe9b46647a724">More...</a><br /></td></tr>
<tr class="separator:a349be868adf860eb3eebe9b46647a724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fe59fa3a891b4e558e8b4d444c3f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a79fe59fa3a891b4e558e8b4d444c3f25">dict_table_persist_to_dd_table_buffer</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a79fe59fa3a891b4e558e8b4d444c3f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write back the dirty persistent dynamic metadata of the table to DDTableBuffer.  <a href="#a79fe59fa3a891b4e558e8b4d444c3f25">More...</a><br /></td></tr>
<tr class="separator:a79fe59fa3a891b4e558e8b4d444c3f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b85c4c87665434f757416b0e6be12c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a7b85c4c87665434f757416b0e6be12c7">dict_table_read_dynamic_metadata</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *<a class="el" href="test__sql__9__sessions_8cc.html#ac242a6dca06b33213957c913bd72414c">buffer</a>, ulint size, <a class="el" href="classPersistentTableMetadata.html">PersistentTableMetadata</a> *<a class="el" href="persisted__variable_8cc.html#a17632c4b396fac52c8df4d4f83af6923">metadata</a>)</td></tr>
<tr class="memdesc:a7b85c4c87665434f757416b0e6be12c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read persistent dynamic metadata stored in a buffer.  <a href="#a7b85c4c87665434f757416b0e6be12c7">More...</a><br /></td></tr>
<tr class="separator:a7b85c4c87665434f757416b0e6be12c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd3deedb0926c622f16b35012ecc807"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5dd3deedb0926c622f16b35012ecc807">dict_max_field_len_store_undo</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col)</td></tr>
<tr class="memdesc:a5dd3deedb0926c622f16b35012ecc807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine bytes of column prefix to be stored in the undo log.  <a href="#a5dd3deedb0926c622f16b35012ecc807">More...</a><br /></td></tr>
<tr class="separator:a5dd3deedb0926c622f16b35012ecc807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f793c7b0e7d08dac7eec58dc3045a5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa1f793c7b0e7d08dac7eec58dc3045a5">dict_max_v_field_len_store_undo</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint col_no)</td></tr>
<tr class="memdesc:aa1f793c7b0e7d08dac7eec58dc3045a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine maximum bytes of a virtual column need to be stored in the undo log.  <a href="#aa1f793c7b0e7d08dac7eec58dc3045a5">More...</a><br /></td></tr>
<tr class="separator:aa1f793c7b0e7d08dac7eec58dc3045a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb9148e31efa842b6e20f717054d9b7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aceb9148e31efa842b6e20f717054d9b7">dict_col_get_no</a> (const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col)</td></tr>
<tr class="memdesc:aceb9148e31efa842b6e20f717054d9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the column number.  <a href="#aceb9148e31efa842b6e20f717054d9b7">More...</a><br /></td></tr>
<tr class="separator:aceb9148e31efa842b6e20f717054d9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cafa5b24026495a733be5359d3b6e6b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a4cafa5b24026495a733be5359d3b6e6b">dict_col_get_clust_pos</a> (const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index)</td></tr>
<tr class="memdesc:a4cafa5b24026495a733be5359d3b6e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the column position in the clustered index.  <a href="#a4cafa5b24026495a733be5359d3b6e6b">More...</a><br /></td></tr>
<tr class="separator:a4cafa5b24026495a733be5359d3b6e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2776a4bb2759bae3616d43cddaf0eff"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#af2776a4bb2759bae3616d43cddaf0eff">dict_col_get_index_pos</a> (const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:af2776a4bb2759bae3616d43cddaf0eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the column position in the given index.  <a href="#af2776a4bb2759bae3616d43cddaf0eff">More...</a><br /></td></tr>
<tr class="separator:af2776a4bb2759bae3616d43cddaf0eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6262e8669671dde295696071ad7e3711"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a6262e8669671dde295696071ad7e3711">dict_col_name_is_reserved</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="memdesc:a6262e8669671dde295696071ad7e3711"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given column name is reserved for InnoDB system columns, return TRUE.  <a href="#a6262e8669671dde295696071ad7e3711">More...</a><br /></td></tr>
<tr class="separator:a6262e8669671dde295696071ad7e3711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4556c3398489ad92461d6bef6e3025ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a4556c3398489ad92461d6bef6e3025ce">dict_table_autoinc_lock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a4556c3398489ad92461d6bef6e3025ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the autoinc lock.  <a href="#a4556c3398489ad92461d6bef6e3025ce">More...</a><br /></td></tr>
<tr class="separator:a4556c3398489ad92461d6bef6e3025ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699e23bef40a36ccaded0fda98e6fbe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a699e23bef40a36ccaded0fda98e6fbe7">dict_table_autoinc_initialize</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ib_uint64_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a699e23bef40a36ccaded0fda98e6fbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally set the autoinc counter.  <a href="#a699e23bef40a36ccaded0fda98e6fbe7">More...</a><br /></td></tr>
<tr class="separator:a699e23bef40a36ccaded0fda98e6fbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810c4bcd773aee77e1bcf477d102af75"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a810c4bcd773aee77e1bcf477d102af75">dict_table_autoinc_read</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a810c4bcd773aee77e1bcf477d102af75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next autoinc value (== autoinc counter value), 0 if not yet initialized.  <a href="#a810c4bcd773aee77e1bcf477d102af75">More...</a><br /></td></tr>
<tr class="separator:a810c4bcd773aee77e1bcf477d102af75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4760f51731a8c5c3c0545ea47294a2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ae4760f51731a8c5c3c0545ea47294a2d">dict_table_autoinc_update_if_greater</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ib_uint64_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:ae4760f51731a8c5c3c0545ea47294a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the autoinc counter if the value supplied is greater than the current value.  <a href="#ae4760f51731a8c5c3c0545ea47294a2d">More...</a><br /></td></tr>
<tr class="separator:ae4760f51731a8c5c3c0545ea47294a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6229492d88f02c167679204097c9dc20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a6229492d88f02c167679204097c9dc20">dict_table_autoinc_unlock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a6229492d88f02c167679204097c9dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the autoinc lock.  <a href="#a6229492d88f02c167679204097c9dc20">More...</a><br /></td></tr>
<tr class="separator:a6229492d88f02c167679204097c9dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7758866ffad7ee17f05c6fb8dce7909c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a7758866ffad7ee17f05c6fb8dce7909c">dict_table_autoinc_persisted_update</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ib_uint64_t autoinc)</td></tr>
<tr class="memdesc:a7758866ffad7ee17f05c6fb8dce7909c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the persisted autoinc counter to specified one, we should hold autoinc_persisted_mutex.  <a href="#a7758866ffad7ee17f05c6fb8dce7909c">More...</a><br /></td></tr>
<tr class="separator:a7758866ffad7ee17f05c6fb8dce7909c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257d96ba7e350b0eec6210a119dd1ab6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a257d96ba7e350b0eec6210a119dd1ab6">dict_table_autoinc_set_col_pos</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint <a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)</td></tr>
<tr class="memdesc:a257d96ba7e350b0eec6210a119dd1ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the column position of autoinc column in clustered index for a table.  <a href="#a257d96ba7e350b0eec6210a119dd1ab6">More...</a><br /></td></tr>
<tr class="separator:a257d96ba7e350b0eec6210a119dd1ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2d0623456d144d44aaa6eb1603dde6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#abd2d0623456d144d44aaa6eb1603dde6">dict_table_autoinc_log</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, uint64_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:abd2d0623456d144d44aaa6eb1603dde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write redo logs for autoinc counter that is to be inserted, or to update some existing smaller one to bigger.  <a href="#abd2d0623456d144d44aaa6eb1603dde6">More...</a><br /></td></tr>
<tr class="separator:abd2d0623456d144d44aaa6eb1603dde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bdbdc3606119a8d33abe776bbd8eb7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad2bdbdc3606119a8d33abe776bbd8eb7">dict_table_has_autoinc_col</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:ad2bdbdc3606119a8d33abe776bbd8eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a table has an autoinc counter column.  <a href="#ad2bdbdc3606119a8d33abe776bbd8eb7">More...</a><br /></td></tr>
<tr class="separator:ad2bdbdc3606119a8d33abe776bbd8eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd5dd1790c77670d7eb93dd7375ca98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#acbd5dd1790c77670d7eb93dd7375ca98">dict_table_add_system_columns</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:acbd5dd1790c77670d7eb93dd7375ca98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds system columns to a table object.  <a href="#acbd5dd1790c77670d7eb93dd7375ca98">More...</a><br /></td></tr>
<tr class="separator:acbd5dd1790c77670d7eb93dd7375ca98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5d60969e4ea074a2acc49d71c1895f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#acf5d60969e4ea074a2acc49d71c1895f">dict_table_set_big_rows</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:acf5d60969e4ea074a2acc49d71c1895f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark if table has big rows.  <a href="#acf5d60969e4ea074a2acc49d71c1895f">More...</a><br /></td></tr>
<tr class="separator:acf5d60969e4ea074a2acc49d71c1895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215aca0021933ba836c3a7cdc783677e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a215aca0021933ba836c3a7cdc783677e">dict_table_add_to_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ibool can_be_evicted, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a215aca0021933ba836c3a7cdc783677e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a table object to the dictionary cache.  <a href="#a215aca0021933ba836c3a7cdc783677e">More...</a><br /></td></tr>
<tr class="separator:a215aca0021933ba836c3a7cdc783677e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee058e08dcafa661c882f9b6b7fbe00b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aee058e08dcafa661c882f9b6b7fbe00b">dict_table_remove_from_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:aee058e08dcafa661c882f9b6b7fbe00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a table object from the dictionary cache.  <a href="#aee058e08dcafa661c882f9b6b7fbe00b">More...</a><br /></td></tr>
<tr class="separator:aee058e08dcafa661c882f9b6b7fbe00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1290fbd353890c87caa83f9c13a62d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1290fbd353890c87caa83f9c13a62d2d">dict_partitioned_table_remove_from_cache</a> (const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="memdesc:a1290fbd353890c87caa83f9c13a62d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to invalidate an entry from the dict cache, for a partitioned table, if any table found.  <a href="#a1290fbd353890c87caa83f9c13a62d2d">More...</a><br /></td></tr>
<tr class="separator:a1290fbd353890c87caa83f9c13a62d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f84bd0906f8e993d2d0c74c1dbc055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a90f84bd0906f8e993d2d0c74c1dbc055">dict_table_remove_from_cache_debug</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lru_evict)</td></tr>
<tr class="memdesc:a90f84bd0906f8e993d2d0c74c1dbc055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a table object from the dictionary cache, for debug purpose.  <a href="#a90f84bd0906f8e993d2d0c74c1dbc055">More...</a><br /></td></tr>
<tr class="separator:a90f84bd0906f8e993d2d0c74c1dbc055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab103b93381b8141ce2e96786165af0a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ab103b93381b8141ce2e96786165af0a8">dict_table_rename_in_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char *new_name, ibool rename_also_foreigns)</td></tr>
<tr class="memdesc:ab103b93381b8141ce2e96786165af0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames a table object.  <a href="#ab103b93381b8141ce2e96786165af0a8">More...</a><br /></td></tr>
<tr class="separator:ab103b93381b8141ce2e96786165af0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cae32c3f5a0876a844f524afcdbb74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a50cae32c3f5a0876a844f524afcdbb74">dict_index_remove_from_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a50cae32c3f5a0876a844f524afcdbb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an index from the dictionary cache.  <a href="#a50cae32c3f5a0876a844f524afcdbb74">More...</a><br /></td></tr>
<tr class="separator:a50cae32c3f5a0876a844f524afcdbb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0191e8cf294b9fe56410d942052ac1b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a0191e8cf294b9fe56410d942052ac1b3">dict_table_change_id_in_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a> <a class="el" href="xcom__base_8h.html#a5da3ef7104f59e0ee072fe82cf3fb706">new_id</a>)</td></tr>
<tr class="memdesc:a0191e8cf294b9fe56410d942052ac1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the id of a table object in the dictionary cache.  <a href="#a0191e8cf294b9fe56410d942052ac1b3">More...</a><br /></td></tr>
<tr class="separator:a0191e8cf294b9fe56410d942052ac1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22fd834facc15bd6930f2458530c347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ab22fd834facc15bd6930f2458530c347">dict_foreign_remove_from_cache</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign)</td></tr>
<tr class="memdesc:ab22fd834facc15bd6930f2458530c347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a foreign constraint struct from the dictionary cache.  <a href="#ab22fd834facc15bd6930f2458530c347">More...</a><br /></td></tr>
<tr class="separator:ab22fd834facc15bd6930f2458530c347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0e53c3d72e1c1cd8dd77fbc01b642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a9bc0e53c3d72e1c1cd8dd77fbc01b642">dict_foreign_add_to_cache</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, const char **col_names, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_charsets, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> can_free_fk, <a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a> ignore_err)</td></tr>
<tr class="memdesc:a9bc0e53c3d72e1c1cd8dd77fbc01b642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a foreign key constraint object to the dictionary cache.  <a href="#a9bc0e53c3d72e1c1cd8dd77fbc01b642">More...</a><br /></td></tr>
<tr class="separator:a9bc0e53c3d72e1c1cd8dd77fbc01b642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb312e354c9f49b250de7f5d4ab8791"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a2bb312e354c9f49b250de7f5d4ab8791">dict_table_is_referenced_by_foreign_key</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a2bb312e354c9f49b250de7f5d4ab8791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a table is referenced by foreign keys.  <a href="#a2bb312e354c9f49b250de7f5d4ab8791">More...</a><br /></td></tr>
<tr class="separator:a2bb312e354c9f49b250de7f5d4ab8791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7472782cb399248af641efe572dbd25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ab7472782cb399248af641efe572dbd25">dict_foreign_replace_index</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char **col_names, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:ab7472782cb399248af641efe572dbd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the index passed in with another equivalent index in the foreign key lists of the table.  <a href="#ab7472782cb399248af641efe572dbd25">More...</a><br /></td></tr>
<tr class="separator:ab7472782cb399248af641efe572dbd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41351d480e889a949b052e63d7fd2155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a41351d480e889a949b052e63d7fd2155">dict_table_open_on_name</a> (const char *table_name, ibool dict_locked, ibool try_drop, <a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a> ignore_err)</td></tr>
<tr class="memdesc:a41351d480e889a949b052e63d7fd2155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a table object and increments its open handle count.  <a href="#a41351d480e889a949b052e63d7fd2155">More...</a><br /></td></tr>
<tr class="separator:a41351d480e889a949b052e63d7fd2155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa2971d57c8fbc67ed014d1f9312681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a0fa2971d57c8fbc67ed014d1f9312681">dict_foreign_find_index</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char **col_names, const char **columns, ulint n_cols, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *types_idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_charsets, ulint check_null)</td></tr>
<tr class="memdesc:a0fa2971d57c8fbc67ed014d1f9312681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an index whose first fields are the columns in the array, in the same order and is not marked for deletion and is not the same as types_idx.  <a href="#a0fa2971d57c8fbc67ed014d1f9312681">More...</a><br /></td></tr>
<tr class="separator:a0fa2971d57c8fbc67ed014d1f9312681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603d4def7151df6008aacc0b2ca8a1e1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a603d4def7151df6008aacc0b2ca8a1e1">dict_table_get_v_col_name</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint col_nr)</td></tr>
<tr class="memdesc:a603d4def7151df6008aacc0b2ca8a1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a virtual column's name.  <a href="#a603d4def7151df6008aacc0b2ca8a1e1">More...</a><br /></td></tr>
<tr class="separator:a603d4def7151df6008aacc0b2ca8a1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ce2800fb70a5cffb298fba8721f195"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a84ce2800fb70a5cffb298fba8721f195">dict_table_has_column</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char *col_name, ulint col_nr=0)</td></tr>
<tr class="memdesc:a84ce2800fb70a5cffb298fba8721f195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table has a given (non_virtual) column.  <a href="#a84ce2800fb70a5cffb298fba8721f195">More...</a><br /></td></tr>
<tr class="separator:a84ce2800fb70a5cffb298fba8721f195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c806b5428c187b203fc0e75aadc6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a89c806b5428c187b203fc0e75aadc6d5">dict_print_info_on_foreign_key_in_create_format</a> (FILE *file, <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign, ibool add_newline)</td></tr>
<tr class="memdesc:a89c806b5428c187b203fc0e75aadc6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs info on a foreign key of a table in a format suitable for CREATE TABLE.  <a href="#a89c806b5428c187b203fc0e75aadc6d5">More...</a><br /></td></tr>
<tr class="separator:a89c806b5428c187b203fc0e75aadc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d4970c0ae48119a08a81dcca1ff9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a15d4970c0ae48119a08a81dcca1ff9bf">dict_foreign_qualify_index</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char **col_names, const char **columns, ulint n_cols, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *types_idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_charsets, ulint check_null)</td></tr>
<tr class="memdesc:a15d4970c0ae48119a08a81dcca1ff9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an index whose first fields are the columns in the array, in the same order and is not marked for deletion and is not the same as types_idx.  <a href="#a15d4970c0ae48119a08a81dcca1ff9bf">More...</a><br /></td></tr>
<tr class="separator:a15d4970c0ae48119a08a81dcca1ff9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd53e9e0be149b65f042e6580ef7aaae"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#acd53e9e0be149b65f042e6580ef7aaae">dict_index_is_auto_gen_clust</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:acd53e9e0be149b65f042e6580ef7aaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if index is auto-generated clustered index.  <a href="#acd53e9e0be149b65f042e6580ef7aaae">More...</a><br /></td></tr>
<tr class="separator:acd53e9e0be149b65f042e6580ef7aaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaded5a4fccfd3a5709b6cc9df983acb7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aaded5a4fccfd3a5709b6cc9df983acb7">dict_index_is_unique</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:aaded5a4fccfd3a5709b6cc9df983acb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the index is unique.  <a href="#aaded5a4fccfd3a5709b6cc9df983acb7">More...</a><br /></td></tr>
<tr class="separator:aaded5a4fccfd3a5709b6cc9df983acb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16844309ee400bd7f9f52e366d9d3454"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a16844309ee400bd7f9f52e366d9d3454">dict_index_is_spatial</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a16844309ee400bd7f9f52e366d9d3454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the index is a Spatial Index.  <a href="#a16844309ee400bd7f9f52e366d9d3454">More...</a><br /></td></tr>
<tr class="separator:a16844309ee400bd7f9f52e366d9d3454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5dad5a9701b333d7224d47b96f9010"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ada5dad5a9701b333d7224d47b96f9010">dict_index_has_virtual</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:ada5dad5a9701b333d7224d47b96f9010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the index contains a virtual column.  <a href="#ada5dad5a9701b333d7224d47b96f9010">More...</a><br /></td></tr>
<tr class="separator:ada5dad5a9701b333d7224d47b96f9010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96abd248d0da48b42b8dc5afcf71c6b9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a96abd248d0da48b42b8dc5afcf71c6b9">dict_index_is_ibuf</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a96abd248d0da48b42b8dc5afcf71c6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the index is the insert buffer tree.  <a href="#a96abd248d0da48b42b8dc5afcf71c6b9">More...</a><br /></td></tr>
<tr class="separator:a96abd248d0da48b42b8dc5afcf71c6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc86f9b1b987ea2f307f1505db6d5f6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a0bc86f9b1b987ea2f307f1505db6d5f6">dict_index_has_desc</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a0bc86f9b1b987ea2f307f1505db6d5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the index consists of descending columns only.  <a href="#a0bc86f9b1b987ea2f307f1505db6d5f6">More...</a><br /></td></tr>
<tr class="separator:a0bc86f9b1b987ea2f307f1505db6d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f679c6c3418fd3a2426131ec7c2a93"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a94f679c6c3418fd3a2426131ec7c2a93">dict_index_is_sec_or_ibuf</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a94f679c6c3418fd3a2426131ec7c2a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the index is a secondary index or the insert buffer tree.  <a href="#a94f679c6c3418fd3a2426131ec7c2a93">More...</a><br /></td></tr>
<tr class="separator:a94f679c6c3418fd3a2426131ec7c2a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63682f9ca158da7b1f9bd9fb03e170d3"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a63682f9ca158da7b1f9bd9fb03e170d3">dict_table_get_all_fts_indexes</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structib__vector__t.html">ib_vector_t</a> *indexes)</td></tr>
<tr class="memdesc:a63682f9ca158da7b1f9bd9fb03e170d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the FTS indexes on a table.  <a href="#a63682f9ca158da7b1f9bd9fb03e170d3">More...</a><br /></td></tr>
<tr class="separator:a63682f9ca158da7b1f9bd9fb03e170d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fdd5d2ee9d560bef7d3cedcdb74ca2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a70fdd5d2ee9d560bef7d3cedcdb74ca2">dict_table_get_n_tot_u_cols</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="separator:a70fdd5d2ee9d560bef7d3cedcdb74ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11595ad706917a335b47a6734105077c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a11595ad706917a335b47a6734105077c">dict_table_get_n_v_cols</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a11595ad706917a335b47a6734105077c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of virtual columns in a table in the dictionary cache.  <a href="#a11595ad706917a335b47a6734105077c">More...</a><br /></td></tr>
<tr class="separator:a11595ad706917a335b47a6734105077c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ad387c85d045ac4f8c7b74eaf9df3d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a45ad387c85d045ac4f8c7b74eaf9df3d">dict_table_has_indexed_v_cols</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a45ad387c85d045ac4f8c7b74eaf9df3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a table has indexed virtual columns.  <a href="#a45ad387c85d045ac4f8c7b74eaf9df3d">More...</a><br /></td></tr>
<tr class="separator:a45ad387c85d045ac4f8c7b74eaf9df3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed48b92a7b200136b50a2daf8160c4a0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aed48b92a7b200136b50a2daf8160c4a0">dict_table_get_n_rows</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:aed48b92a7b200136b50a2daf8160c4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the approximately estimated number of rows in the table.  <a href="#aed48b92a7b200136b50a2daf8160c4a0">More...</a><br /></td></tr>
<tr class="separator:aed48b92a7b200136b50a2daf8160c4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db7ed4886637b827211934ba6429781"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a9db7ed4886637b827211934ba6429781">dict_table_n_rows_inc</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a9db7ed4886637b827211934ba6429781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of rows in the table by one.  <a href="#a9db7ed4886637b827211934ba6429781">More...</a><br /></td></tr>
<tr class="separator:a9db7ed4886637b827211934ba6429781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab9d56517abf5aa197f0effd485f858"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1ab9d56517abf5aa197f0effd485f858">dict_table_n_rows_dec</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a1ab9d56517abf5aa197f0effd485f858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the number of rows in the table by one.  <a href="#a1ab9d56517abf5aa197f0effd485f858">More...</a><br /></td></tr>
<tr class="separator:a1ab9d56517abf5aa197f0effd485f858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcd69a7fa04517678a1b68f97048003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__v__col__t.html">dict_v_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aefcd69a7fa04517678a1b68f97048003">dict_table_get_nth_v_col_mysql</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint col_nr)</td></tr>
<tr class="memdesc:aefcd69a7fa04517678a1b68f97048003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nth virtual column according to its original MySQL table position.  <a href="#aefcd69a7fa04517678a1b68f97048003">More...</a><br /></td></tr>
<tr class="separator:aefcd69a7fa04517678a1b68f97048003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495ddc5f7f28813dc2cbcb21fe165d8f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdict__v__col__t.html">dict_v_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a495ddc5f7f28813dc2cbcb21fe165d8f">dict_table_get_nth_v_col</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint <a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)</td></tr>
<tr class="memdesc:a495ddc5f7f28813dc2cbcb21fe165d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the nth virtual column of a table.  <a href="#a495ddc5f7f28813dc2cbcb21fe165d8f">More...</a><br /></td></tr>
<tr class="separator:a495ddc5f7f28813dc2cbcb21fe165d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a07438085b78a25a4ca3a654ab95e0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa7a07438085b78a25a4ca3a654ab95e0">dict_table_get_sys_col_no</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint sys)</td></tr>
<tr class="memdesc:aa7a07438085b78a25a4ca3a654ab95e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the given system column number of a table.  <a href="#aa7a07438085b78a25a4ca3a654ab95e0">More...</a><br /></td></tr>
<tr class="separator:aa7a07438085b78a25a4ca3a654ab95e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb24172dd54a082038c4f7c6aff7ce6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#afeb24172dd54a082038c4f7c6aff7ce6">dict_table_is_comp</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:afeb24172dd54a082038c4f7c6aff7ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the table uses the compact page format.  <a href="#afeb24172dd54a082038c4f7c6aff7ce6">More...</a><br /></td></tr>
<tr class="separator:afeb24172dd54a082038c4f7c6aff7ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76e62b02b7c8267837a724ee71a5c73"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa76e62b02b7c8267837a724ee71a5c73">dict_table_has_atomic_blobs</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:aa76e62b02b7c8267837a724ee71a5c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a table uses atomic BLOBs (no locally stored prefix).  <a href="#aa76e62b02b7c8267837a724ee71a5c73">More...</a><br /></td></tr>
<tr class="separator:aa76e62b02b7c8267837a724ee71a5c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8497bac4fc023f3182725cd696de130"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad8497bac4fc023f3182725cd696de130">dict_tf_set</a> (uint32_t *<a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="rem0types_8h.html#a9b18c9be596083dfcd337b11972f1c1e">rec_format_t</a> format, uint32_t zip_ssize, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_data_dir, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> shared_space)</td></tr>
<tr class="memdesc:ad8497bac4fc023f3182725cd696de130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the various values in a dict_table_t::flags pointer.  <a href="#ad8497bac4fc023f3182725cd696de130">More...</a><br /></td></tr>
<tr class="separator:ad8497bac4fc023f3182725cd696de130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96efe7a27819dee0949d5af50b2ea06a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a96efe7a27819dee0949d5af50b2ea06a">dict_tf_init</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> compact, ulint zip_ssize, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> atomic_blobs, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> data_dir, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> shared_space)</td></tr>
<tr class="memdesc:a96efe7a27819dee0949d5af50b2ea06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a dict_table_t::flags pointer.  <a href="#a96efe7a27819dee0949d5af50b2ea06a">More...</a><br /></td></tr>
<tr class="separator:a96efe7a27819dee0949d5af50b2ea06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff395441ca0c0c0a38890b6279b6ce4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1ff395441ca0c0c0a38890b6279b6ce4">dict_tf_to_fsp_flags</a> (uint32_t table_flags)</td></tr>
<tr class="memdesc:a1ff395441ca0c0c0a38890b6279b6ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 32 bit integer table flags to the 32 bit FSP Flags.  <a href="#a1ff395441ca0c0c0a38890b6279b6ce4">More...</a><br /></td></tr>
<tr class="separator:a1ff395441ca0c0c0a38890b6279b6ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae48995f6252b6137db697fccab0bd79"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="classpage__size__t.html">page_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aae48995f6252b6137db697fccab0bd79">dict_tf_get_page_size</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:aae48995f6252b6137db697fccab0bd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the page size info from table flags.  <a href="#aae48995f6252b6137db697fccab0bd79">More...</a><br /></td></tr>
<tr class="separator:aae48995f6252b6137db697fccab0bd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010eb6ef71e5661c3a7ed5064aa390c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a010eb6ef71e5661c3a7ed5064aa390c3">dict_table_extent_size</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a010eb6ef71e5661c3a7ed5064aa390c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the extent size (in pages) for the given table.  <a href="#a010eb6ef71e5661c3a7ed5064aa390c3">More...</a><br /></td></tr>
<tr class="separator:a010eb6ef71e5661c3a7ed5064aa390c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b0a62aa0830f3ae32c1696d7d7c429"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="classpage__size__t.html">page_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ac2b0a62aa0830f3ae32c1696d7d7c429">dict_table_page_size</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:ac2b0a62aa0830f3ae32c1696d7d7c429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the table page size.  <a href="#ac2b0a62aa0830f3ae32c1696d7d7c429">More...</a><br /></td></tr>
<tr class="separator:ac2b0a62aa0830f3ae32c1696d7d7c429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a14af44950ae0a52cb6fbb0b96fe72"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a02a14af44950ae0a52cb6fbb0b96fe72">dict_table_x_lock_indexes</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a02a14af44950ae0a52cb6fbb0b96fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain exclusive locks on all index trees of the table.  <a href="#a02a14af44950ae0a52cb6fbb0b96fe72">More...</a><br /></td></tr>
<tr class="separator:a02a14af44950ae0a52cb6fbb0b96fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd362138ce7c587e00dab59ea943d63"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a6cd362138ce7c587e00dab59ea943d63">dict_table_x_unlock_indexes</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a6cd362138ce7c587e00dab59ea943d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the exclusive locks on all index tree.  <a href="#a6cd362138ce7c587e00dab59ea943d63">More...</a><br /></td></tr>
<tr class="separator:a6cd362138ce7c587e00dab59ea943d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797e361e55268f546239b0256aaa971d"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a797e361e55268f546239b0256aaa971d">dict_table_col_in_clustered_key</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a797e361e55268f546239b0256aaa971d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a column is in the ordering columns of the clustered index of a table.  <a href="#a797e361e55268f546239b0256aaa971d">More...</a><br /></td></tr>
<tr class="separator:a797e361e55268f546239b0256aaa971d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa46249ead572b05272e5c5b99fac07"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#acaa46249ead572b05272e5c5b99fac07">dict_table_has_fts_index</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:acaa46249ead572b05272e5c5b99fac07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table has an FTS index.  <a href="#acaa46249ead572b05272e5c5b99fac07">More...</a><br /></td></tr>
<tr class="separator:acaa46249ead572b05272e5c5b99fac07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e125ce275e8acec996bb7187919a1b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a9e125ce275e8acec996bb7187919a1b8">dict_table_copy_v_types</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a9e125ce275e8acec996bb7187919a1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies types of virtual columns contained in table to tuple and sets all fields of the tuple to the SQL NULL value.  <a href="#a9e125ce275e8acec996bb7187919a1b8">More...</a><br /></td></tr>
<tr class="separator:a9e125ce275e8acec996bb7187919a1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db504f10796a76e4bd6292d7550e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa7db504f10796a76e4bd6292d7550e23">dict_table_copy_types</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:aa7db504f10796a76e4bd6292d7550e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies types of columns contained in table to tuple and sets all fields of the tuple to the SQL NULL value.  <a href="#aa7db504f10796a76e4bd6292d7550e23">More...</a><br /></td></tr>
<tr class="separator:aa7db504f10796a76e4bd6292d7550e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44b48b7ad1ec5524521777dab831525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ae44b48b7ad1ec5524521777dab831525">dict_table_wait_for_bg_threads_to_exit</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint <a class="el" href="suite__stubs_8h.html#a1edc302ee73481d4acd4a9de0b3ec795">delay</a>)</td></tr>
<tr class="separator:ae44b48b7ad1ec5524521777dab831525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f01f004e218abe927f03348bc12f230"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a2f01f004e218abe927f03348bc12f230">dict_index_find</a> (const <a class="el" href="classindex__id__t.html">index_id_t</a> &amp;<a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>)</td></tr>
<tr class="memdesc:a2f01f004e218abe927f03348bc12f230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an index.  <a href="#a2f01f004e218abe927f03348bc12f230">More...</a><br /></td></tr>
<tr class="separator:a2f01f004e218abe927f03348bc12f230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dbb700be89f9b4239e87d859c414fa"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa5dbb700be89f9b4239e87d859c414fa">dict_make_room_in_cache</a> (ulint max_tables, ulint pct_check)</td></tr>
<tr class="memdesc:aa5dbb700be89f9b4239e87d859c414fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make room in the table cache by evicting an unused table.  <a href="#aa5dbb700be89f9b4239e87d859c414fa">More...</a><br /></td></tr>
<tr class="separator:aa5dbb700be89f9b4239e87d859c414fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96c46ccfb96933a4b12105acf12d3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad96c46ccfb96933a4b12105acf12d3f2">dict_index_add_to_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, ibool strict)</td></tr>
<tr class="memdesc:ad96c46ccfb96933a4b12105acf12d3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an index to the dictionary cache.  <a href="#ad96c46ccfb96933a4b12105acf12d3f2">More...</a><br /></td></tr>
<tr class="separator:ad96c46ccfb96933a4b12105acf12d3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c513183157a387fa4056b6ef66af2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a65c513183157a387fa4056b6ef66af2f">dict_index_remove_from_v_col_list</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a65c513183157a387fa4056b6ef66af2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the virtual column's index list before index is being freed.  <a href="#a65c513183157a387fa4056b6ef66af2f">More...</a><br /></td></tr>
<tr class="separator:a65c513183157a387fa4056b6ef66af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ad80e2bbe1389b280666c22b467be0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a19ad80e2bbe1389b280666c22b467be0">dict_index_add_to_cache_w_vcol</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdict__add__v__col__t.html">dict_add_v_col_t</a> *add_v, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, ibool strict)</td></tr>
<tr class="memdesc:a19ad80e2bbe1389b280666c22b467be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an index to the dictionary cache, with possible indexing newly added column.  <a href="#a19ad80e2bbe1389b280666c22b467be0">More...</a><br /></td></tr>
<tr class="separator:a19ad80e2bbe1389b280666c22b467be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbac8d4dac47946d21ca041625e3688"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aadbac8d4dac47946d21ca041625e3688">dict_index_get_n_fields</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:aadbac8d4dac47946d21ca041625e3688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of fields in the internal representation of an index, including fields added by the dictionary system.  <a href="#aadbac8d4dac47946d21ca041625e3688">More...</a><br /></td></tr>
<tr class="separator:aadbac8d4dac47946d21ca041625e3688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1d995804ac51f68b7cbeabe63feb82"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1b1d995804ac51f68b7cbeabe63feb82">dict_index_get_n_unique</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a1b1d995804ac51f68b7cbeabe63feb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of fields in the internal representation of an index that uniquely determine the position of an index entry in the index, if we do not take multiversioning into account: in the B-tree use the value returned by dict_index_get_n_unique_in_tree.  <a href="#a1b1d995804ac51f68b7cbeabe63feb82">More...</a><br /></td></tr>
<tr class="separator:a1b1d995804ac51f68b7cbeabe63feb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a3e8de23728eddfa983a65fbfba8d6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#af4a3e8de23728eddfa983a65fbfba8d6">dict_index_get_n_unique_in_tree</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:af4a3e8de23728eddfa983a65fbfba8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of fields in the internal representation of an index which uniquely determine the position of an index entry in the index, if we also take multiversioning into account.  <a href="#af4a3e8de23728eddfa983a65fbfba8d6">More...</a><br /></td></tr>
<tr class="separator:af4a3e8de23728eddfa983a65fbfba8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838aa2c93954be5d86c42e2864ab053a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a838aa2c93954be5d86c42e2864ab053a">dict_index_get_n_unique_in_tree_nonleaf</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a838aa2c93954be5d86c42e2864ab053a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of fields on nonleaf page level in the internal representation of an index which uniquely determine the position of an index entry in the index, if we also take multiversioning into account.  <a href="#a838aa2c93954be5d86c42e2864ab053a">More...</a><br /></td></tr>
<tr class="separator:a838aa2c93954be5d86c42e2864ab053a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcbb97b15f8d67fe47e1f7a0546f0b3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#acfcbb97b15f8d67fe47e1f7a0546f0b3">dict_index_get_n_ordering_defined_by_user</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:acfcbb97b15f8d67fe47e1f7a0546f0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of user-defined ordering fields in the index.  <a href="#acfcbb97b15f8d67fe47e1f7a0546f0b3">More...</a><br /></td></tr>
<tr class="separator:acfcbb97b15f8d67fe47e1f7a0546f0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64916377b4b0f082999ddd5427f9771"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad64916377b4b0f082999ddd5427f9771">dict_index_contains_col_or_prefix</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_virtual)</td></tr>
<tr class="memdesc:ad64916377b4b0f082999ddd5427f9771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the index contains a column or a prefix of that column.  <a href="#ad64916377b4b0f082999ddd5427f9771">More...</a><br /></td></tr>
<tr class="separator:ad64916377b4b0f082999ddd5427f9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aef9d2775c4f43c1fd5b29807b3b8b6"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a7aef9d2775c4f43c1fd5b29807b3b8b6">dict_index_get_nth_field_pos</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index2, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a7aef9d2775c4f43c1fd5b29807b3b8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for a matching field in an index.  <a href="#a7aef9d2775c4f43c1fd5b29807b3b8b6">More...</a><br /></td></tr>
<tr class="separator:a7aef9d2775c4f43c1fd5b29807b3b8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d9a33a3b22e3721253efa027dd3fd7"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad1d9a33a3b22e3721253efa027dd3fd7">dict_table_get_nth_col_pos</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:ad1d9a33a3b22e3721253efa027dd3fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for non-virtual column n position in the clustered index.  <a href="#ad1d9a33a3b22e3721253efa027dd3fd7">More...</a><br /></td></tr>
<tr class="separator:ad1d9a33a3b22e3721253efa027dd3fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1216310eb143d1b7cb7fc508b7343327"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1216310eb143d1b7cb7fc508b7343327">dict_table_mysql_pos_to_innodb</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a1216310eb143d1b7cb7fc508b7343327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the innodb column position for a non-virtual column according to its original MySQL table position n.  <a href="#a1216310eb143d1b7cb7fc508b7343327">More...</a><br /></td></tr>
<tr class="separator:a1216310eb143d1b7cb7fc508b7343327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cb9582603ebbc3a03d6c69829399c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a93cb9582603ebbc3a03d6c69829399c8">dict_index_copy_types</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint n_fields)</td></tr>
<tr class="memdesc:a93cb9582603ebbc3a03d6c69829399c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies types of fields contained in index to tuple.  <a href="#a93cb9582603ebbc3a03d6c69829399c8">More...</a><br /></td></tr>
<tr class="separator:a93cb9582603ebbc3a03d6c69829399c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5a964ff08ffef8afbd8c33f11fed8d"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#abd5a964ff08ffef8afbd8c33f11fed8d">dict_index_check_search_tuple</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:abd5a964ff08ffef8afbd8c33f11fed8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a tuple has n_fields_cmp value in a sensible range, so that no comparison can occur with the page number field in a node pointer.  <a href="#abd5a964ff08ffef8afbd8c33f11fed8d">More...</a><br /></td></tr>
<tr class="separator:abd5a964ff08ffef8afbd8c33f11fed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad364830ec539d0e23ab72712e3a441a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad364830ec539d0e23ab72712e3a441a4">dict_table_check_for_dup_indexes</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, enum <a class="el" href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476">check_name</a> check)</td></tr>
<tr class="memdesc:ad364830ec539d0e23ab72712e3a441a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for duplicate index entries in a table [using the index name].  <a href="#ad364830ec539d0e23ab72712e3a441a4">More...</a><br /></td></tr>
<tr class="separator:ad364830ec539d0e23ab72712e3a441a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d42641281fd397af442083d63d35ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#af6d42641281fd397af442083d63d35ea">dict_table_is_compressed_temporary</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:af6d42641281fd397af442083d63d35ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a table is a temporary table with compressed row format, we should always expect false.  <a href="#af6d42641281fd397af442083d63d35ea">More...</a><br /></td></tr>
<tr class="separator:af6d42641281fd397af442083d63d35ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e3474ac452722f6f3a64d13e1737f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a81e3474ac452722f6f3a64d13e1737f2">dict_index_build_node_ptr</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, ulint level)</td></tr>
<tr class="memdesc:a81e3474ac452722f6f3a64d13e1737f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a node pointer out of a physical record and a page number.  <a href="#a81e3474ac452722f6f3a64d13e1737f2">More...</a><br /></td></tr>
<tr class="separator:a81e3474ac452722f6f3a64d13e1737f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82236b70c3a89b04920db7f49d8423cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a82236b70c3a89b04920db7f49d8423cf">dict_index_copy_rec_order_prefix</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint *n_fields, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> **buf, size_t *<a class="el" href="create__def_8cc.html#a83a426bc389379d92979b5248e18877c">buf_size</a>)</td></tr>
<tr class="memdesc:a82236b70c3a89b04920db7f49d8423cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies an initial segment of a physical record, long enough to specify an index entry uniquely.  <a href="#a82236b70c3a89b04920db7f49d8423cf">More...</a><br /></td></tr>
<tr class="separator:a82236b70c3a89b04920db7f49d8423cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3887358bf453aae4ec4a5ad05f678bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a3887358bf453aae4ec4a5ad05f678bb6">dict_index_build_data_tuple</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint n_fields, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a3887358bf453aae4ec4a5ad05f678bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a typed data tuple out of a physical record.  <a href="#a3887358bf453aae4ec4a5ad05f678bb6">More...</a><br /></td></tr>
<tr class="separator:a3887358bf453aae4ec4a5ad05f678bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2c41c869382dbe51a62c7882fe7932"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aca2c41c869382dbe51a62c7882fe7932">dict_index_get_space</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:aca2c41c869382dbe51a62c7882fe7932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the space id of the root of the index tree.  <a href="#aca2c41c869382dbe51a62c7882fe7932">More...</a><br /></td></tr>
<tr class="separator:aca2c41c869382dbe51a62c7882fe7932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178655631c2da40803e1303f75640c83"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a178655631c2da40803e1303f75640c83">dict_index_set_space</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space)</td></tr>
<tr class="memdesc:a178655631c2da40803e1303f75640c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the space id of the root of the index tree.  <a href="#a178655631c2da40803e1303f75640c83">More...</a><br /></td></tr>
<tr class="separator:a178655631c2da40803e1303f75640c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1561d551ba9b708facb18a89130f837f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1561d551ba9b708facb18a89130f837f">dict_index_get_page</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *tree)</td></tr>
<tr class="memdesc:a1561d551ba9b708facb18a89130f837f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the page number of the root of the index tree.  <a href="#a1561d551ba9b708facb18a89130f837f">More...</a><br /></td></tr>
<tr class="separator:a1561d551ba9b708facb18a89130f837f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f40100335feb168a333d55f2b50f46"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad6f40100335feb168a333d55f2b50f46">dict_index_get_lock</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:ad6f40100335feb168a333d55f2b50f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the read-write lock of the index tree.  <a href="#ad6f40100335feb168a333d55f2b50f46">More...</a><br /></td></tr>
<tr class="separator:ad6f40100335feb168a333d55f2b50f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25184187ad1da100d6895b7731741aa1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a25184187ad1da100d6895b7731741aa1">dict_index_get_space_reserve</a> (void)</td></tr>
<tr class="memdesc:a25184187ad1da100d6895b7731741aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns free space reserved for future updates of records.  <a href="#a25184187ad1da100d6895b7731741aa1">More...</a><br /></td></tr>
<tr class="separator:a25184187ad1da100d6895b7731741aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2165017527251996bd9a4f61847a895"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="dict0mem_8h.html#aa03dcafce31c230a892131b994e2379b">online_index_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa2165017527251996bd9a4f61847a895">dict_index_get_online_status</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:aa2165017527251996bd9a4f61847a895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the status of online index creation.  <a href="#aa2165017527251996bd9a4f61847a895">More...</a><br /></td></tr>
<tr class="separator:aa2165017527251996bd9a4f61847a895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c721f5a0e8349003a79a1408294a317"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a4c721f5a0e8349003a79a1408294a317">dict_index_set_online_status</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, enum <a class="el" href="dict0mem_8h.html#aa03dcafce31c230a892131b994e2379b">online_index_status</a> <a class="el" href="mysql_8cc.html#a1025e6cbbd3179d2d91b9b4afb8f8efc">status</a>)</td></tr>
<tr class="memdesc:a4c721f5a0e8349003a79a1408294a317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the status of online index creation.  <a href="#a4c721f5a0e8349003a79a1408294a317">More...</a><br /></td></tr>
<tr class="separator:a4c721f5a0e8349003a79a1408294a317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbc5eab483c1f89ffe2208855f3f9b7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#afcbc5eab483c1f89ffe2208855f3f9b7">dict_index_is_online_ddl</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:afcbc5eab483c1f89ffe2208855f3f9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a secondary index is being or has been created online, or if the table is being rebuilt online, allowing concurrent modifications to the table.  <a href="#afcbc5eab483c1f89ffe2208855f3f9b7">More...</a><br /></td></tr>
<tr class="separator:afcbc5eab483c1f89ffe2208855f3f9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adead7407c0ee0863352d2ea6d4ebc4bc"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#adead7407c0ee0863352d2ea6d4ebc4bc">dict_index_calc_min_rec_len</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:adead7407c0ee0863352d2ea6d4ebc4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum record length in an index.  <a href="#adead7407c0ee0863352d2ea6d4ebc4bc">More...</a><br /></td></tr>
<tr class="separator:adead7407c0ee0863352d2ea6d4ebc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a92c8c0baf91abdb10ad1018aabeeda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a9a92c8c0baf91abdb10ad1018aabeeda">dict_mutex_enter_for_mysql</a> (void)</td></tr>
<tr class="memdesc:a9a92c8c0baf91abdb10ad1018aabeeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves the dictionary system mutex for MySQL.  <a href="#a9a92c8c0baf91abdb10ad1018aabeeda">More...</a><br /></td></tr>
<tr class="separator:a9a92c8c0baf91abdb10ad1018aabeeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da4da7d57e573205d70db315bb35059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a1da4da7d57e573205d70db315bb35059">dict_mutex_exit_for_mysql</a> (void)</td></tr>
<tr class="memdesc:a1da4da7d57e573205d70db315bb35059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the dictionary system mutex for MySQL.  <a href="#a1da4da7d57e573205d70db315bb35059">More...</a><br /></td></tr>
<tr class="separator:a1da4da7d57e573205d70db315bb35059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea7e3f600763f1ec8ada4c88f7a806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a7fea7e3f600763f1ec8ada4c88f7a806">dict_table_stats_latch_create</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> enabled)</td></tr>
<tr class="memdesc:a7fea7e3f600763f1ec8ada4c88f7a806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dict_table_t's stats latch or delay for lazy creation.  <a href="#a7fea7e3f600763f1ec8ada4c88f7a806">More...</a><br /></td></tr>
<tr class="separator:a7fea7e3f600763f1ec8ada4c88f7a806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428c4723fd38a1e83223604d42b7b8ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a428c4723fd38a1e83223604d42b7b8ab">dict_table_stats_latch_destroy</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a428c4723fd38a1e83223604d42b7b8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a dict_table_t's stats latch.  <a href="#a428c4723fd38a1e83223604d42b7b8ab">More...</a><br /></td></tr>
<tr class="separator:a428c4723fd38a1e83223604d42b7b8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938a0f110db72710173e9c7d05f7b3e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a938a0f110db72710173e9c7d05f7b3e6">dict_table_stats_lock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint latch_mode)</td></tr>
<tr class="memdesc:a938a0f110db72710173e9c7d05f7b3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the appropriate latch to protect a given table's statistics.  <a href="#a938a0f110db72710173e9c7d05f7b3e6">More...</a><br /></td></tr>
<tr class="separator:a938a0f110db72710173e9c7d05f7b3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89442a48c8aa6af63265a00fb9f0d708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a89442a48c8aa6af63265a00fb9f0d708">dict_table_stats_unlock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint latch_mode)</td></tr>
<tr class="memdesc:a89442a48c8aa6af63265a00fb9f0d708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the latch that has been locked by dict_table_stats_lock().  <a href="#a89442a48c8aa6af63265a00fb9f0d708">More...</a><br /></td></tr>
<tr class="separator:a89442a48c8aa6af63265a00fb9f0d708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470227bec9c1779310c07a084f96df26"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a470227bec9c1779310c07a084f96df26">dict_tables_have_same_db</a> (const char *name1, const char *name2)</td></tr>
<tr class="memdesc:a470227bec9c1779310c07a084f96df26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the database name in two table names is the same.  <a href="#a470227bec9c1779310c07a084f96df26">More...</a><br /></td></tr>
<tr class="separator:a470227bec9c1779310c07a084f96df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36312cc400aa52913fed4f3c85a497f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a36312cc400aa52913fed4f3c85a497f8">dict_table_get_index_on_name</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> committed=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:a36312cc400aa52913fed4f3c85a497f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an index by name.  <a href="#a36312cc400aa52913fed4f3c85a497f8">More...</a><br /></td></tr>
<tr class="separator:a36312cc400aa52913fed4f3c85a497f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb97122de57a9075cf1f29225f4e3130"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aeb97122de57a9075cf1f29225f4e3130">dict_table_get_index_on_name</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> committed=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:aeb97122de57a9075cf1f29225f4e3130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an index by name.  <a href="#aeb97122de57a9075cf1f29225f4e3130">More...</a><br /></td></tr>
<tr class="separator:aeb97122de57a9075cf1f29225f4e3130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4385f247a9ebe9e190b54ae4c890cbe5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a4385f247a9ebe9e190b54ae4c890cbe5">dict_table_is_fts_column</a> (<a class="el" href="structib__vector__t.html">ib_vector_t</a> *indexes, ulint col_no, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_virtual)</td></tr>
<tr class="separator:a4385f247a9ebe9e190b54ae4c890cbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3e541f152dbe753f6559b4b370e610"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aac3e541f152dbe753f6559b4b370e610">dict_table_prevent_eviction</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:aac3e541f152dbe753f6559b4b370e610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent table eviction by moving a table to the non-LRU list from the LRU list if it is not already there.  <a href="#aac3e541f152dbe753f6559b4b370e610">More...</a><br /></td></tr>
<tr class="separator:aac3e541f152dbe753f6559b4b370e610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b10bccd65ab1541acf76874739505c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ae8b10bccd65ab1541acf76874739505c">dict_table_allow_eviction</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:ae8b10bccd65ab1541acf76874739505c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the table to be evicted by moving a table to the LRU list from the non-LRU list if it is not already there.  <a href="#ae8b10bccd65ab1541acf76874739505c">More...</a><br /></td></tr>
<tr class="separator:ae8b10bccd65ab1541acf76874739505c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f10eb5d5e910775206e21b6cd54689"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a70f10eb5d5e910775206e21b6cd54689">dict_table_ddl_acquire</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a70f10eb5d5e910775206e21b6cd54689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move this table to non-LRU list for DDL operations if it's currently not there.  <a href="#a70f10eb5d5e910775206e21b6cd54689">More...</a><br /></td></tr>
<tr class="separator:a70f10eb5d5e910775206e21b6cd54689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0bfabd1d7de19db4adc7f877ac6520"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a0f0bfabd1d7de19db4adc7f877ac6520">dict_table_ddl_release</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a0f0bfabd1d7de19db4adc7f877ac6520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move this table to LRU list after DDL operations if it was moved to non-LRU list.  <a href="#a0f0bfabd1d7de19db4adc7f877ac6520">More...</a><br /></td></tr>
<tr class="separator:a0f0bfabd1d7de19db4adc7f877ac6520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfb54b5eea94a36619fd87f702b6324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a4bfb54b5eea94a36619fd87f702b6324">dict_table_move_from_lru_to_non_lru</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a4bfb54b5eea94a36619fd87f702b6324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a table to the non LRU end of the LRU list.  <a href="#a4bfb54b5eea94a36619fd87f702b6324">More...</a><br /></td></tr>
<tr class="separator:a4bfb54b5eea94a36619fd87f702b6324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b5e7c188e636667f0bef65daee7229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a40b5e7c188e636667f0bef65daee7229">dict_table_move_from_non_lru_to_lru</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a40b5e7c188e636667f0bef65daee7229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a table to the LRU end from the non LRU list.  <a href="#a40b5e7c188e636667f0bef65daee7229">More...</a><br /></td></tr>
<tr class="separator:a40b5e7c188e636667f0bef65daee7229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc7d36ebddeb0aa1694f2059966c95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5cc7d36ebddeb0aa1694f2059966c95c">dict_move_to_mru</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a5cc7d36ebddeb0aa1694f2059966c95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the most recently used segment of the LRU list.  <a href="#a5cc7d36ebddeb0aa1694f2059966c95c">More...</a><br /></td></tr>
<tr class="separator:a5cc7d36ebddeb0aa1694f2059966c95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545403277a762437a4d4dc76f69a0440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a545403277a762437a4d4dc76f69a0440">dict_ind_init</a> (void)</td></tr>
<tr class="memdesc:a545403277a762437a4d4dc76f69a0440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits dict_ind_redundant.  <a href="#a545403277a762437a4d4dc76f69a0440">More...</a><br /></td></tr>
<tr class="separator:a545403277a762437a4d4dc76f69a0440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb45aa94e3494dcfabfd1cf055548c23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#adb45aa94e3494dcfabfd1cf055548c23">dict_fs2utf8</a> (const char *db_and_table, char *db_utf8, size_t db_utf8_size, char *table_utf8, size_t table_utf8_size)</td></tr>
<tr class="memdesc:adb45aa94e3494dcfabfd1cf055548c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a database and table name from filesystem encoding (e.g.  <a href="#adb45aa94e3494dcfabfd1cf055548c23">More...</a><br /></td></tr>
<tr class="separator:adb45aa94e3494dcfabfd1cf055548c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680b8f92809a401a7ed2a639a0a36296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a680b8f92809a401a7ed2a639a0a36296">dict_resize</a> ()</td></tr>
<tr class="memdesc:a680b8f92809a401a7ed2a639a0a36296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the hash tables besed on the current buffer pool size.  <a href="#a680b8f92809a401a7ed2a639a0a36296">More...</a><br /></td></tr>
<tr class="separator:a680b8f92809a401a7ed2a639a0a36296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3421570f26455402b131132912b79f34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a3421570f26455402b131132912b79f34">dict_table_mark_dirty</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a3421570f26455402b131132912b79f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the dirty_status of a table as METADATA_DIRTY, and add it to the dirty_dict_tables list if necessary.  <a href="#a3421570f26455402b131132912b79f34">More...</a><br /></td></tr>
<tr class="separator:a3421570f26455402b131132912b79f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863d66fc7dd0c29ebef61c49a56fd7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a863d66fc7dd0c29ebef61c49a56fd7a9">dict_set_corrupted</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>) UNIV_COLD</td></tr>
<tr class="memdesc:a863d66fc7dd0c29ebef61c49a56fd7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags an index corrupted in the data dictionary cache only.  <a href="#a863d66fc7dd0c29ebef61c49a56fd7a9">More...</a><br /></td></tr>
<tr class="separator:a863d66fc7dd0c29ebef61c49a56fd7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0a27f5d69091934c4fa34a789b101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ae2b0a27f5d69091934c4fa34a789b101">dict_table_load_dynamic_metadata</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:ae2b0a27f5d69091934c4fa34a789b101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is any latest persistent dynamic metadata recorded in DDTableBuffer table of the specific table.  <a href="#ae2b0a27f5d69091934c4fa34a789b101">More...</a><br /></td></tr>
<tr class="separator:ae2b0a27f5d69091934c4fa34a789b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab2239c47b02298cb7a7473e1e04feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#afab2239c47b02298cb7a7473e1e04feb">dict_persist_to_dd_table_buffer</a> ()</td></tr>
<tr class="memdesc:afab2239c47b02298cb7a7473e1e04feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any table has any dirty persistent data, if so write dirty persistent data of table to mysql.innodb_dynamic_metadata accordingly.  <a href="#afab2239c47b02298cb7a7473e1e04feb">More...</a><br /></td></tr>
<tr class="separator:afab2239c47b02298cb7a7473e1e04feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822caee6af5816145582073d3ea7a035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a822caee6af5816145582073d3ea7a035">dict_table_apply_dynamic_metadata</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="classPersistentTableMetadata.html">PersistentTableMetadata</a> *<a class="el" href="persisted__variable_8cc.html#a17632c4b396fac52c8df4d4f83af6923">metadata</a>)</td></tr>
<tr class="memdesc:a822caee6af5816145582073d3ea7a035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the persistent dynamic metadata read from redo logs or DDTableBuffer to corresponding table during recovery.  <a href="#a822caee6af5816145582073d3ea7a035">More...</a><br /></td></tr>
<tr class="separator:a822caee6af5816145582073d3ea7a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5812b710d47d31827d328de9497fa366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5812b710d47d31827d328de9497fa366">dict_index_set_merge_threshold</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint merge_threshold)</td></tr>
<tr class="memdesc:a5812b710d47d31827d328de9497fa366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets merge_threshold in the SYS_INDEXES.  <a href="#a5812b710d47d31827d328de9497fa366">More...</a><br /></td></tr>
<tr class="separator:a5812b710d47d31827d328de9497fa366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dd5b87bc893cce378fc9357076133c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a68dd5b87bc893cce378fc9357076133c">dict_set_merge_threshold_all_debug</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> merge_threshold_all)</td></tr>
<tr class="memdesc:a68dd5b87bc893cce378fc9357076133c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets merge_threshold for all indexes in dictionary cache for debug.  <a href="#a68dd5b87bc893cce378fc9357076133c">More...</a><br /></td></tr>
<tr class="separator:a68dd5b87bc893cce378fc9357076133c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58cc13b5a9233c46526c2ba2b8be0ea"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ae58cc13b5a9233c46526c2ba2b8be0ea">dict_tf_is_valid</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:ae58cc13b5a9233c46526c2ba2b8be0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the table flags.  <a href="#ae58cc13b5a9233c46526c2ba2b8be0ea">More...</a><br /></td></tr>
<tr class="separator:ae58cc13b5a9233c46526c2ba2b8be0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2768e24cb2b67587725e956e720e58cc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a2768e24cb2b67587725e956e720e58cc">dict_tf2_is_valid</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, uint32_t flags2)</td></tr>
<tr class="memdesc:a2768e24cb2b67587725e956e720e58cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate both table flags and table flags2 and make sure they are compatible.  <a href="#a2768e24cb2b67587725e956e720e58cc">More...</a><br /></td></tr>
<tr class="separator:a2768e24cb2b67587725e956e720e58cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f8634691e40cc161b8c09eac9a470e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ac0f8634691e40cc161b8c09eac9a470e">dict_table_is_discarded</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:ac0f8634691e40cc161b8c09eac9a470e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the tablespace for the table has been discarded.  <a href="#ac0f8634691e40cc161b8c09eac9a470e">More...</a><br /></td></tr>
<tr class="separator:ac0f8634691e40cc161b8c09eac9a470e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98167c3c3772439a718780f49b9e6167"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a98167c3c3772439a718780f49b9e6167">dict_table_is_table_buffer</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a98167c3c3772439a718780f49b9e6167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the table is DDTableBuffer.  <a href="#a98167c3c3772439a718780f49b9e6167">More...</a><br /></td></tr>
<tr class="separator:a98167c3c3772439a718780f49b9e6167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadadd762fb6bdc532a078d5348b4bd0e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aadadd762fb6bdc532a078d5348b4bd0e">dict_table_in_shared_tablespace</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:aadadd762fb6bdc532a078d5348b4bd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table is in a shared tablespace (System or General).  <a href="#aadadd762fb6bdc532a078d5348b4bd0e">More...</a><br /></td></tr>
<tr class="separator:aadadd762fb6bdc532a078d5348b4bd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c87bbda5e0443a10bd433a1f9316e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#adb1c87bbda5e0443a10bd433a1f9316e">dict_table_is_locking_disabled</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:adb1c87bbda5e0443a10bd433a1f9316e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether locking is disabled for this table.  <a href="#adb1c87bbda5e0443a10bd433a1f9316e">More...</a><br /></td></tr>
<tr class="separator:adb1c87bbda5e0443a10bd433a1f9316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf4523b5ad67f24f1f482d74b685ed3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#afdf4523b5ad67f24f1f482d74b685ed3">dict_disable_redo_if_temporary</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:afdf4523b5ad67f24f1f482d74b685ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn-off redo-logging if temporary table.  <a href="#afdf4523b5ad67f24f1f482d74b685ed3">More...</a><br /></td></tr>
<tr class="separator:afdf4523b5ad67f24f1f482d74b685ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06055532ed1bb098508dca8466cf0d76"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="trx0types_8h.html#a3f6397f57064f579d2c5d68884ba44e0">row_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a06055532ed1bb098508dca8466cf0d76">dict_table_get_next_table_sess_row_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a06055532ed1bb098508dca8466cf0d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get table session row-id and increment the row-id counter for next use.  <a href="#a06055532ed1bb098508dca8466cf0d76">More...</a><br /></td></tr>
<tr class="separator:a06055532ed1bb098508dca8466cf0d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2071e8a4b4ace0780851d674913fb7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a8f2071e8a4b4ace0780851d674913fb7">dict_table_get_next_table_sess_trx_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a8f2071e8a4b4ace0780851d674913fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get table session trx-id and increment the trx-id counter for next use.  <a href="#a8f2071e8a4b4ace0780851d674913fb7">More...</a><br /></td></tr>
<tr class="separator:a8f2071e8a4b4ace0780851d674913fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b879a4e1c0bb3d724254462feb15b21"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a3b879a4e1c0bb3d724254462feb15b21">dict_table_get_curr_table_sess_trx_id</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a3b879a4e1c0bb3d724254462feb15b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current session trx-id.  <a href="#a3b879a4e1c0bb3d724254462feb15b21">More...</a><br /></td></tr>
<tr class="separator:a3b879a4e1c0bb3d724254462feb15b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88b092de7509f57263863ab0952e435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ac88b092de7509f57263863ab0952e435">dict_index_zip_success</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:ac88b092de7509f57263863ab0952e435"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called whenever a page is successfully compressed.  <a href="#ac88b092de7509f57263863ab0952e435">More...</a><br /></td></tr>
<tr class="separator:ac88b092de7509f57263863ab0952e435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d494ca6cb4255061dfe571a6b791f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a9d494ca6cb4255061dfe571a6b791f22">dict_index_zip_failure</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a9d494ca6cb4255061dfe571a6b791f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called whenever a page compression attempt fails.  <a href="#a9d494ca6cb4255061dfe571a6b791f22">More...</a><br /></td></tr>
<tr class="separator:a9d494ca6cb4255061dfe571a6b791f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c2ae13ec31983373ae1975ef788957"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ac3c2ae13ec31983373ae1975ef788957">dict_index_zip_pad_optimal_page_size</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:ac3c2ae13ec31983373ae1975ef788957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the optimal page size, for which page will likely compress.  <a href="#ac3c2ae13ec31983373ae1975ef788957">More...</a><br /></td></tr>
<tr class="separator:ac3c2ae13ec31983373ae1975ef788957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0039ab13ce5eae4eb1f44585f93852b1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a0039ab13ce5eae4eb1f44585f93852b1">dict_tf_to_row_format_string</a> (uint32_t table_flag)</td></tr>
<tr class="memdesc:a0039ab13ce5eae4eb1f44585f93852b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert table flag to row format string.  <a href="#a0039ab13ce5eae4eb1f44585f93852b1">More...</a><br /></td></tr>
<tr class="separator:a0039ab13ce5eae4eb1f44585f93852b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608858864003abeb0fb38381a5e1add4"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a608858864003abeb0fb38381a5e1add4">dict_index_node_ptr_max_size</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a608858864003abeb0fb38381a5e1add4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum size of the node pointer record.  <a href="#a608858864003abeb0fb38381a5e1add4">More...</a><br /></td></tr>
<tr class="separator:a608858864003abeb0fb38381a5e1add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fc1d882c647412901764072155fbe4"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a54fc1d882c647412901764072155fbe4">dict_table_get_index_on_first_col</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint col_index)</td></tr>
<tr class="memdesc:a54fc1d882c647412901764072155fbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index by first field of the index.  <a href="#a54fc1d882c647412901764072155fbe4">More...</a><br /></td></tr>
<tr class="separator:a54fc1d882c647412901764072155fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7604db6c69e41636ddceb44e00bbe8c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa7604db6c69e41636ddceb44e00bbe8c">dict_table_encode_n_col</a> (ulint n_col, ulint n_v_col)</td></tr>
<tr class="memdesc:aa7604db6c69e41636ddceb44e00bbe8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">encode number of columns and number of virtual columns in one 4 bytes value.  <a href="#aa7604db6c69e41636ddceb44e00bbe8c">More...</a><br /></td></tr>
<tr class="separator:aa7604db6c69e41636ddceb44e00bbe8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e30fe2a05f008b3e1953b19fa76d19"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a61e30fe2a05f008b3e1953b19fa76d19">dict_table_decode_n_col</a> (uint32_t encoded, uint32_t *n_col, uint32_t *n_v_col)</td></tr>
<tr class="memdesc:a61e30fe2a05f008b3e1953b19fa76d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode number of virtual and non-virtual columns in one 4 bytes value.  <a href="#a61e30fe2a05f008b3e1953b19fa76d19">More...</a><br /></td></tr>
<tr class="separator:a61e30fe2a05f008b3e1953b19fa76d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf48a13275e44b899a2a4a6f3177850d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aaf48a13275e44b899a2a4a6f3177850d">dict_free_vc_templ</a> (<a class="el" href="structdict__vcol__templ__t.html">dict_vcol_templ_t</a> *vc_templ)</td></tr>
<tr class="memdesc:aaf48a13275e44b899a2a4a6f3177850d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the virtual column template.  <a href="#aaf48a13275e44b899a2a4a6f3177850d">More...</a><br /></td></tr>
<tr class="separator:aaf48a13275e44b899a2a4a6f3177850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285275bc97480ce7f158971772b698c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5285275bc97480ce7f158971772b698c">dict_table_get_v_col_name_mysql</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint col_nr)</td></tr>
<tr class="memdesc:a5285275bc97480ce7f158971772b698c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a virtual column's name according to its original MySQL table position.  <a href="#a5285275bc97480ce7f158971772b698c">More...</a><br /></td></tr>
<tr class="separator:a5285275bc97480ce7f158971772b698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0863b7dc172e4cb9906c3ec68d86d11"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ad0863b7dc172e4cb9906c3ec68d86d11">dict_table_have_virtual_index</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:ad0863b7dc172e4cb9906c3ec68d86d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the table have virtual index.  <a href="#ad0863b7dc172e4cb9906c3ec68d86d11">More...</a><br /></td></tr>
<tr class="separator:ad0863b7dc172e4cb9906c3ec68d86d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f00af9ae5b2649c83e95ba644129e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#ab15f00af9ae5b2649c83e95ba644129e">dict_sdi_get_index</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> tablespace_id)</td></tr>
<tr class="memdesc:ab15f00af9ae5b2649c83e95ba644129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve in-memory index for SDI table.  <a href="#ab15f00af9ae5b2649c83e95ba644129e">More...</a><br /></td></tr>
<tr class="separator:ab15f00af9ae5b2649c83e95ba644129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4a17264630948643509158144fc8ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5a4a17264630948643509158144fc8ff">dict_sdi_get_table</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> tablespace_id, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_locked, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_create)</td></tr>
<tr class="memdesc:a5a4a17264630948643509158144fc8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve in-memory table object for SDI table.  <a href="#a5a4a17264630948643509158144fc8ff">More...</a><br /></td></tr>
<tr class="separator:a5a4a17264630948643509158144fc8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5cf1e16d99673a7512bbd738e49b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a7b5cf1e16d99673a7512bbd738e49b36">dict_sdi_remove_from_cache</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id, <a class="el" href="structdict__table__t.html">dict_table_t</a> *sdi_table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_locked)</td></tr>
<tr class="memdesc:a7b5cf1e16d99673a7512bbd738e49b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the SDI table from table cache.  <a href="#a7b5cf1e16d99673a7512bbd738e49b36">More...</a><br /></td></tr>
<tr class="separator:a7b5cf1e16d99673a7512bbd738e49b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a766867dc79946528d7dcc4bcc3cf9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a58a766867dc79946528d7dcc4bcc3cf9">dict_index_is_sdi</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a58a766867dc79946528d7dcc4bcc3cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the index is SDI index.  <a href="#a58a766867dc79946528d7dcc4bcc3cf9">More...</a><br /></td></tr>
<tr class="separator:a58a766867dc79946528d7dcc4bcc3cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658d5dc2b146fd312965d86d3925645b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a658d5dc2b146fd312965d86d3925645b">dict_table_is_sdi</a> (uint64_t table_id)</td></tr>
<tr class="memdesc:a658d5dc2b146fd312965d86d3925645b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an table id belongs SDI table.  <a href="#a658d5dc2b146fd312965d86d3925645b">More...</a><br /></td></tr>
<tr class="separator:a658d5dc2b146fd312965d86d3925645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a5e28ba7d67c5b96987811d35221e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a86a5e28ba7d67c5b96987811d35221e4">dict_sdi_close_table</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a86a5e28ba7d67c5b96987811d35221e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close SDI table.  <a href="#a86a5e28ba7d67c5b96987811d35221e4">More...</a><br /></td></tr>
<tr class="separator:a86a5e28ba7d67c5b96987811d35221e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068a35ebced17aba4e864a670f50a3b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a068a35ebced17aba4e864a670f50a3b1">dd_sdi_acquire_exclusive_mdl</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id, <a class="el" href="classMDL__ticket.html">MDL_ticket</a> **sdi_mdl)</td></tr>
<tr class="memdesc:a068a35ebced17aba4e864a670f50a3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire exclusive MDL on SDI tables.  <a href="#a068a35ebced17aba4e864a670f50a3b1">More...</a><br /></td></tr>
<tr class="separator:a068a35ebced17aba4e864a670f50a3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77f2a23a1bddc5595081f1b93b2ab26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#af77f2a23a1bddc5595081f1b93b2ab26">dd_sdi_acquire_shared_mdl</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id, <a class="el" href="classMDL__ticket.html">MDL_ticket</a> **sdi_mdl)</td></tr>
<tr class="memdesc:af77f2a23a1bddc5595081f1b93b2ab26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire shared MDL on SDI tables.  <a href="#af77f2a23a1bddc5595081f1b93b2ab26">More...</a><br /></td></tr>
<tr class="separator:af77f2a23a1bddc5595081f1b93b2ab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9084ec58b734f47f0940b7e83b385b51"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a9084ec58b734f47f0940b7e83b385b51">dict_table_is_partition</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a9084ec58b734f47f0940b7e83b385b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the dict_table_t is a partition.  <a href="#a9084ec58b734f47f0940b7e83b385b51">More...</a><br /></td></tr>
<tr class="separator:a9084ec58b734f47f0940b7e83b385b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f468ec90c2acddd3057f541de965526"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a3f468ec90c2acddd3057f541de965526">dict_allocate_mem_intrinsic_cache</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a3f468ec90c2acddd3057f541de965526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for intrinsic cache elements in the index.  <a href="#a3f468ec90c2acddd3057f541de965526">More...</a><br /></td></tr>
<tr class="separator:a3f468ec90c2acddd3057f541de965526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f37e12ac5d68ceaa751f248f3c593c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a5f37e12ac5d68ceaa751f248f3c593c1">dict_upgrade_evict_tables_cache</a> ()</td></tr>
<tr class="memdesc:a5f37e12ac5d68ceaa751f248f3c593c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict all tables that are loaded for applying purge.  <a href="#a5f37e12ac5d68ceaa751f248f3c593c1">More...</a><br /></td></tr>
<tr class="separator:a5f37e12ac5d68ceaa751f248f3c593c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f771d7fdbec90778be84c82ebbabb62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a6f771d7fdbec90778be84c82ebbabb62">dict_table_is_system</a> (<a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a> table_id)</td></tr>
<tr class="separator:a6f771d7fdbec90778be84c82ebbabb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625714c4b06daadd3438719737dfea3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a625714c4b06daadd3438719737dfea3d">dict_sys_table_id_build</a> ()</td></tr>
<tr class="memdesc:a625714c4b06daadd3438719737dfea3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the table_id array of SYS_* tables.  <a href="#a625714c4b06daadd3438719737dfea3d">More...</a><br /></td></tr>
<tr class="separator:a625714c4b06daadd3438719737dfea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0732ecc0e35fbc0658ea7733d249656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#aa0732ecc0e35fbc0658ea7733d249656">dict_table_change_id_sys_tables</a> ()</td></tr>
<tr class="memdesc:aa0732ecc0e35fbc0658ea7733d249656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the table_id of SYS_* tables if they have been created after an earlier upgrade.  <a href="#aa0732ecc0e35fbc0658ea7733d249656">More...</a><br /></td></tr>
<tr class="separator:aa0732ecc0e35fbc0658ea7733d249656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc1e21c1e5137d055affd1acbe1808"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#abffc1e21c1e5137d055affd1acbe1808">dict_table_get_datadir</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:abffc1e21c1e5137d055affd1acbe1808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tablespace data directory if set, otherwise empty string.  <a href="#abffc1e21c1e5137d055affd1acbe1808">More...</a><br /></td></tr>
<tr class="separator:abffc1e21c1e5137d055affd1acbe1808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c03c1c0c28384c08b381067361a84e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a72c03c1c0c28384c08b381067361a84e">dict_set_compression</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const char *algorithm)</td></tr>
<tr class="memdesc:a72c03c1c0c28384c08b381067361a84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the compression type for the tablespace of a table.  <a href="#a72c03c1c0c28384c08b381067361a84e">More...</a><br /></td></tr>
<tr class="separator:a72c03c1c0c28384c08b381067361a84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a60b90ad886cc69ff15315694fbd1eaee"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a60b90ad886cc69ff15315694fbd1eaee">SDI_VERSION</a> = 1</td></tr>
<tr class="memdesc:a60b90ad886cc69ff15315694fbd1eaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDI version.  <a href="#a60b90ad886cc69ff15315694fbd1eaee">More...</a><br /></td></tr>
<tr class="separator:a60b90ad886cc69ff15315694fbd1eaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f11204c7263dead39ca57c419de657"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a96f11204c7263dead39ca57c419de657">SYSTEM_TABLE_SPACE</a> = <a class="el" href="trx0types_8h.html#ad30d6802ba5017c3db592827e1c90b03">TRX_SYS_SPACE</a></td></tr>
<tr class="memdesc:a96f11204c7263dead39ca57c419de657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space id of system tablespace.  <a href="#a96f11204c7263dead39ca57c419de657">More...</a><br /></td></tr>
<tr class="separator:a96f11204c7263dead39ca57c419de657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec24ab0a32d423b164b07c9b75efaab"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a6ec24ab0a32d423b164b07c9b75efaab">dict_foreign_err_file</a></td></tr>
<tr class="separator:a6ec24ab0a32d423b164b07c9b75efaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46914897b15bb9b3b8b967b2a2602e5a"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a46914897b15bb9b3b8b967b2a2602e5a">dict_foreign_err_mutex</a></td></tr>
<tr class="separator:a46914897b15bb9b3b8b967b2a2602e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9def99724e81248120f5c58eaa14dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__sys__t.html">dict_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#af9def99724e81248120f5c58eaa14dc2">dict_sys</a></td></tr>
<tr class="memdesc:af9def99724e81248120f5c58eaa14dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the dictionary system  <a href="#af9def99724e81248120f5c58eaa14dc2">More...</a><br /></td></tr>
<tr class="separator:af9def99724e81248120f5c58eaa14dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0d20c61722131666bc819ac4072cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a3d0d20c61722131666bc819ac4072cff">dict_operation_lock</a></td></tr>
<tr class="memdesc:a3d0d20c61722131666bc819ac4072cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">the data dictionary rw-latch protecting dict_sys  <a href="#a3d0d20c61722131666bc819ac4072cff">More...</a><br /></td></tr>
<tr class="separator:a3d0d20c61722131666bc819ac4072cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485b103be6b18c0bf9a08df4fc5f3c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__persist__t.html">dict_persist_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a4485b103be6b18c0bf9a08df4fc5f3c0">dict_persist</a></td></tr>
<tr class="memdesc:a4485b103be6b18c0bf9a08df4fc5f3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the dictionary persisting structure  <a href="#a4485b103be6b18c0bf9a08df4fc5f3c0">More...</a><br /></td></tr>
<tr class="separator:a4485b103be6b18c0bf9a08df4fc5f3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89825a6bd9d1aa7ab16bc6418745478e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8h.html#a89825a6bd9d1aa7ab16bc6418745478e">dict_ind_redundant</a></td></tr>
<tr class="memdesc:a89825a6bd9d1aa7ab16bc6418745478e"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy index for ROW_FORMAT=REDUNDANT supremum and infimum records  <a href="#a89825a6bd9d1aa7ab16bc6418745478e">More...</a><br /></td></tr>
<tr class="separator:a89825a6bd9d1aa7ab16bc6418745478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data dictionary system. </p>
<p>Created 1/8/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5f7227a5ba3c90ba9ca2bcb0dbbc7c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7227a5ba3c90ba9ca2bcb0dbbc7c66">&#9670;&nbsp;</a></span>BIG_ROW_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIG_ROW_SIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a618168d3c16fcf6d9174b43907d1492c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618168d3c16fcf6d9174b43907d1492c">&#9670;&nbsp;</a></span>DICT_HEAP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DICT_HEAP_SIZE&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initial memory heap size when \ creating a table or index object </p>

</div>
</div>
<a id="a5eb5792cd6068ffb0d5e274d853c2bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb5792cd6068ffb0d5e274d853c2bd5">&#9670;&nbsp;</a></span>DICT_INDEX_SPATIAL_NODEPTR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DICT_INDEX_SPATIAL_NODEPTR_SIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of fields in the nonleaf page of spatial index, except the page no field. </p>

</div>
</div>
<a id="a1a5e00868dd761d41aafd9647c8e6750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5e00868dd761d41aafd9647c8e6750">&#9670;&nbsp;</a></span>dict_table_next_uncorrupted_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dict_table_next_uncorrupted_index</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                           \</div><div class="line">    index = <a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>-&gt;next();                       \</div><div class="line">    dict_table_skip_corrupt_index(<a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>);        \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="mysql_8cc_html_adfa69ae672499b1037123a1f17c5552b"><div class="ttname"><a href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></div><div class="ttdeci">char * index(const char *, int c)</div><div class="ttdef"><b>Definition:</b> mysql.cc:2928</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7be951de2c67a0782db3d5ce137f5a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be951de2c67a0782db3d5ce137f5a04">&#9670;&nbsp;</a></span>dict_table_skip_corrupt_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dict_table_skip_corrupt_index</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a> &amp;&amp; <a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>-&gt;is_corrupted()) {   \</div><div class="line">    index = <a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>-&gt;next();                   \</div><div class="line">  }</div><div class="ttc" id="mysql_8cc_html_adfa69ae672499b1037123a1f17c5552b"><div class="ttname"><a href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></div><div class="ttdeci">char * index(const char *, int c)</div><div class="ttdef"><b>Definition:</b> mysql.cc:2928</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adca606358fb7a110d5646b4381c5e36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca606358fb7a110d5646b4381c5e36d">&#9670;&nbsp;</a></span>MAX_NUM_FK_COLUMNS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_NUM_FK_COLUMNS&#160;&#160;&#160;500</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of columns in a foreign key constraint. </p>
<p>Please Note MySQL has a much lower limit on the number of columns allowed in a foreign key constraint </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a96d4b1626b1bf4ea2e8d645210d4d476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d4b1626b1bf4ea2e8d645210d4d476">&#9670;&nbsp;</a></span>check_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476">check_name</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether and when to allow temporary index names. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a96d4b1626b1bf4ea2e8d645210d4d476a806731b0fba64e973a80e13d43987fa4"></a>CHECK_ALL_COMPLETE&#160;</td><td class="fielddoc"><p>Require all indexes to be complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="a96d4b1626b1bf4ea2e8d645210d4d476a372fee1255c20c9a4a206b057b279cf8"></a>CHECK_ABORTED_OK&#160;</td><td class="fielddoc"><p>Allow aborted online index creation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a96d4b1626b1bf4ea2e8d645210d4d476a87cff9b1eefd118223ee33c69348e78a"></a>CHECK_PARTIAL_OK&#160;</td><td class="fielddoc"><p>Allow partial indexes to exist. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad37e188831074bcf7fdae6bd963a1599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37e188831074bcf7fdae6bd963a1599">&#9670;&nbsp;</a></span>dict_table_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599">dict_table_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation to perform when opening a table. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad37e188831074bcf7fdae6bd963a1599aca5dacda41b8d55d5015945d1ff28818"></a>DICT_TABLE_OP_NORMAL&#160;</td><td class="fielddoc"><p>Expect the tablespace to exist. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad37e188831074bcf7fdae6bd963a1599afc38fb5b824eeff6802c98f34534e940"></a>DICT_TABLE_OP_DROP_ORPHAN&#160;</td><td class="fielddoc"><p>Drop any orphan indexes after an aborted online index creation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad37e188831074bcf7fdae6bd963a1599ada7c6b8846b2a27c2a4d0a0fec8cc5e5"></a>DICT_TABLE_OP_LOAD_TABLESPACE&#160;</td><td class="fielddoc"><p>Silently load the tablespace if it does not exist, and do not load the definitions of incomplete indexes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a068a35ebced17aba4e864a670f50a3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068a35ebced17aba4e864a670f50a3b1">&#9670;&nbsp;</a></span>dd_sdi_acquire_exclusive_mdl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dd_sdi_acquire_exclusive_mdl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> **&#160;</td>
          <td class="paramname"><em>sdi_mdl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire exclusive MDL on SDI tables. </p>
<p>This is acquired to prevent concurrent DROP table/tablespace when there is purge happening on SDI table records. Purge will acquired shared MDL on SDI table.</p>
<p>Exclusive MDL is transactional(released on trx commit). So for successful acquistion, there should be valid thd with trx associated.</p>
<p>Acquistion order of SDI MDL and SDI table has to be in same order:</p>
<ol type="1">
<li>dd_sdi_acquire_exclusive_mdl</li>
<li>row_drop_table_from_cache()/innodb_drop_tablespace() -&gt;dict_sdi_remove_from_cache()-&gt;dd_table_open_on_id()</li>
</ol>
<p>In purge:</p>
<ol type="1">
<li>dd_sdi_acquire_shared_mdl</li>
<li>dd_table_open_on_id()</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>server thread instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>InnoDB tablespace id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sdi_mdl</td><td>MDL ticket on SDI table </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_LOCK_WAIT_TIMEOUT</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af77f2a23a1bddc5595081f1b93b2ab26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77f2a23a1bddc5595081f1b93b2ab26">&#9670;&nbsp;</a></span>dd_sdi_acquire_shared_mdl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dd_sdi_acquire_shared_mdl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> **&#160;</td>
          <td class="paramname"><em>sdi_mdl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire shared MDL on SDI tables. </p>
<p>This is acquired by purge to prevent concurrent DROP table/tablespace. DROP table/tablespace will acquire exclusive MDL on SDI table</p>
<p>Acquistion order of SDI MDL and SDI table has to be in same order:</p>
<ol type="1">
<li>dd_sdi_acquire_exclusive_mdl</li>
<li>row_drop_table_from_cache()/innodb_drop_tablespace() -&gt;dict_sdi_remove_from_cache()-&gt;dd_table_open_on_id()</li>
</ol>
<p>In purge:</p>
<ol type="1">
<li>dd_sdi_acquire_shared_mdl</li>
<li>dd_table_open_on_id()</li>
</ol>
<p>MDL should be released by caller </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>server thread instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>InnoDB tablespace id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sdi_mdl</td><td>MDL ticket on SDI table </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_LOCK_WAIT_TIMEOUT</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f468ec90c2acddd3057f541de965526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f468ec90c2acddd3057f541de965526">&#9670;&nbsp;</a></span>dict_allocate_mem_intrinsic_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_allocate_mem_intrinsic_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for intrinsic cache elements in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ba7e509db4f0987778c5cf7e042f961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba7e509db4f0987778c5cf7e042f961">&#9670;&nbsp;</a></span>dict_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the data dictionary module. </p>

</div>
</div>
<a id="a4cafa5b24026495a733be5359d3b6e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cafa5b24026495a733be5359d3b6e6b">&#9670;&nbsp;</a></span>dict_col_get_clust_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_col_get_clust_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the column position in the clustered index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>in: table column </td></tr>
    <tr><td class="paramname">clust_index</td><td>in: clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2776a4bb2759bae3616d43cddaf0eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2776a4bb2759bae3616d43cddaf0eff">&#9670;&nbsp;</a></span>dict_col_get_index_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_col_get_index_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the column position in the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>table column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index to be searched for column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of column in the given index. </dd></dl>

</div>
</div>
<a id="aceb9148e31efa842b6e20f717054d9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb9148e31efa842b6e20f717054d9b7">&#9670;&nbsp;</a></span>dict_col_get_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_col_get_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the column number. </p>
<dl class="section return"><dt>Returns</dt><dd>col-&gt;ind, table column position (starting from 0) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>in: column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6262e8669671dde295696071ad7e3711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6262e8669671dde295696071ad7e3711">&#9670;&nbsp;</a></span>dict_col_name_is_reserved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool dict_col_name_is_reserved </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the given column name is reserved for InnoDB system columns, return TRUE. </p>
<dl class="section return"><dt>Returns</dt><dd>true if name is reserved </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: column name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdf4523b5ad67f24f1f482d74b685ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf4523b5ad67f24f1f482d74b685ed3">&#9670;&nbsp;</a></span>dict_disable_redo_if_temporary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_disable_redo_if_temporary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn-off redo-logging if temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>Table to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bc0e53c3d72e1c1cd8dd77fbc01b642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc0e53c3d72e1c1cd8dd77fbc01b642">&#9670;&nbsp;</a></span>dict_foreign_add_to_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_foreign_add_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>check_charsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>can_free_fk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a>&#160;</td>
          <td class="paramname"><em>ignore_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a foreign key constraint object to the dictionary cache. </p>
<p>May free the object if there already is an object with the same identifier in. At least one of foreign table or referenced table must already be in the dictionary cache! </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>May free the object if there already is an object with the same identifier in. At least one of the foreign table and the referenced table must already be in the dictionary cache! </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foreign</td><td>in, own: foreign key constraint </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use foreign-&gt;foreign_table-&gt;col_names </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charset compatibility </td></tr>
    <tr><td class="paramname">can_free_fk</td><td>in: whether free existing FK </td></tr>
    <tr><td class="paramname">ignore_err</td><td>in: error to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fa2971d57c8fbc67ed014d1f9312681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa2971d57c8fbc67ed014d1f9312681">&#9670;&nbsp;</a></span>dict_foreign_find_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_foreign_find_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>types_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>check_charsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>check_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to find an index whose first fields are the columns in the array, in the same order and is not marked for deletion and is not the same as types_idx. </p>
<dl class="section return"><dt>Returns</dt><dd>matching index, NULL if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use table-&gt;col_names </td></tr>
    <tr><td class="paramname">columns</td><td>in: array of column names </td></tr>
    <tr><td class="paramname">n_cols</td><td>in: number of columns </td></tr>
    <tr><td class="paramname">types_idx</td><td>in: NULL or an index whose types the column types must match </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charsets. only has an effect if types_idx != NULL </td></tr>
    <tr><td class="paramname">check_null</td><td>in: nonzero if none of the columns must be declared NOT NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4458ebcd1a2943f7d122ed1badc964e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4458ebcd1a2943f7d122ed1badc964e7">&#9670;&nbsp;</a></span>dict_foreign_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dict_foreign_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a foreign key struct. </p>
<p>in, own: foreign key struct</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foreign</td><td>in, own: foreign key struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15d4970c0ae48119a08a81dcca1ff9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d4970c0ae48119a08a81dcca1ff9bf">&#9670;&nbsp;</a></span>dict_foreign_qualify_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_foreign_qualify_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>types_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>check_charsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>check_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to find an index whose first fields are the columns in the array, in the same order and is not marked for deletion and is not the same as types_idx. </p>
<dl class="section return"><dt>Returns</dt><dd>matching index, NULL if not found</dd></dl>
<p>Tries to find an index whose first fields are the columns in the array, in the same order and is not marked for deletion and is not the same as types_idx.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the index qualifies, otherwise false </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use table-&gt;col_names </td></tr>
    <tr><td class="paramname">columns</td><td>in: array of column names </td></tr>
    <tr><td class="paramname">n_cols</td><td>in: number of columns </td></tr>
    <tr><td class="paramname">index</td><td>in: index to check </td></tr>
    <tr><td class="paramname">types_idx</td><td>in: NULL or an index whose types the column types must match </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charsets. only has an effect if types_idx != NULL </td></tr>
    <tr><td class="paramname">check_null</td><td>in: nonzero if none of the columns must be declared NOT NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab22fd834facc15bd6930f2458530c347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22fd834facc15bd6930f2458530c347">&#9670;&nbsp;</a></span>dict_foreign_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_foreign_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a foreign constraint struct from the dictionary cache. </p>
<p>in, own: foreign constraint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foreign</td><td>in, own: foreign constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7472782cb399248af641efe572dbd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7472782cb399248af641efe572dbd25">&#9670;&nbsp;</a></span>dict_foreign_replace_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_foreign_replace_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the index passed in with another equivalent index in the foreign key lists of the table. </p>
<dl class="section return"><dt>Returns</dt><dd>whether all replacements were found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use table-&gt;col_names </td></tr>
    <tr><td class="paramname">index</td><td>in: index to be replaced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf48a13275e44b899a2a4a6f3177850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf48a13275e44b899a2a4a6f3177850d">&#9670;&nbsp;</a></span>dict_free_vc_templ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_free_vc_templ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__vcol__templ__t.html">dict_vcol_templ_t</a> *&#160;</td>
          <td class="paramname"><em>vc_templ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the virtual column template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vc_templ</td><td>virtual column template </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb45aa94e3494dcfabfd1cf055548c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb45aa94e3494dcfabfd1cf055548c23">&#9670;&nbsp;</a></span>dict_fs2utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_fs2utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_and_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>db_utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>db_utf8_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>table_utf8_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a database and table name from filesystem encoding (e.g. </p>
<p>"@code d@i1b/a@q1b@1Kc @endcode", same format as used in dict_table_t::name) in two strings in UTF8 encoding (e.g. dцb and aюbØc). The output buffers must be at least MAX_DB_UTF8_LEN and MAX_TABLE_UTF8_LEN bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">db_and_table</td><td>database and table names, e.g. "@code d@i1b/a@q1b@1Kc @endcode" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">db_utf8</td><td>database name, e.g. dцb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">db_utf8_size</td><td>dbname_utf8 size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">table_utf8</td><td>table name, e.g. aюbØc </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_utf8_size</td><td>table_utf8 size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06b911af9a8049bb19f4f701ecd08064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b911af9a8049bb19f4f701ecd08064">&#9670;&nbsp;</a></span>dict_get_db_name_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_get_db_name_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the database name length in a table name. </p>
<dl class="section return"><dt>Returns</dt><dd>database name length </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name in the form dbname '/' tablename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a545403277a762437a4d4dc76f69a0440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545403277a762437a4d4dc76f69a0440">&#9670;&nbsp;</a></span>dict_ind_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_ind_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inits dict_ind_redundant. </p>

</div>
</div>
<a id="ad96c46ccfb96933a4b12105acf12d3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96c46ccfb96933a4b12105acf12d3f2">&#9670;&nbsp;</a></span>dict_index_add_to_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_index_add_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>strict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an index to the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table on which the index is </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index; NOTE! The index memory object is freed in this function! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_no</td><td>root page number of the index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>TRUE=refuse to create the index if records could be too big to fit in an B-tree page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_TOO_BIG_RECORD, or DB_CORRUPTION </dd></dl>

</div>
</div>
<a id="a19ad80e2bbe1389b280666c22b467be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ad80e2bbe1389b280666c22b467be0">&#9670;&nbsp;</a></span>dict_index_add_to_cache_w_vcol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_index_add_to_cache_w_vcol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__add__v__col__t.html">dict_add_v_col_t</a> *&#160;</td>
          <td class="paramname"><em>add_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>strict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an index to the dictionary cache, with possible indexing newly added column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table on which the index is </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index; NOTE! The index memory object is freed in this function! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_v</td><td>new virtual column that being added along with an add index call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_no</td><td>root page number of the index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>TRUE=refuse to create the index if records could be too big to fit in an B-tree page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_TOO_BIG_RECORD, or DB_CORRUPTION </dd></dl>

</div>
</div>
<a id="a3887358bf453aae4ec4a5ad05f678bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3887358bf453aae4ec4a5ad05f678bb6">&#9670;&nbsp;</a></span>dict_index_build_data_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* dict_index_build_data_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a typed data tuple out of a physical record. </p>
<dl class="section return"><dt>Returns</dt><dd>own: data tuple </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">rec</td><td>in: record for which to build data tuple </td></tr>
    <tr><td class="paramname">n_fields</td><td>in: number of data fields </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where tuple created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81e3474ac452722f6f3a64d13e1737f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e3474ac452722f6f3a64d13e1737f2">&#9670;&nbsp;</a></span>dict_index_build_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* dict_index_build_node_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a node pointer out of a physical record and a page number. </p>
<dl class="section return"><dt>Returns</dt><dd>own: node pointer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record for which to build node pointer </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number to put in node pointer </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where pointer created </td></tr>
    <tr><td class="paramname">level</td><td>in: level of rec in tree: 0 means leaf level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adead7407c0ee0863352d2ea6d4ebc4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adead7407c0ee0863352d2ea6d4ebc4bc">&#9670;&nbsp;</a></span>dict_index_calc_min_rec_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_index_calc_min_rec_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the minimum record length in an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd5a964ff08ffef8afbd8c33f11fed8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5a964ff08ffef8afbd8c33f11fed8d">&#9670;&nbsp;</a></span>dict_index_check_search_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool dict_index_check_search_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a tuple has n_fields_cmp value in a sensible range, so that no comparison can occur with the page number field in a node pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple used in a search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64916377b4b0f082999ddd5427f9771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64916377b4b0f082999ddd5427f9771">&#9670;&nbsp;</a></span>dict_index_contains_col_or_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool dict_index_contains_col_or_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_virtual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the index contains a column or a prefix of that column. </p>
<dl class="section return"><dt>Returns</dt><dd>true if contains the column or its prefix</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>column number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_virtual</td><td>whether it is a virtual col </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contains the column or its prefix </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">n</td><td>in: column number </td></tr>
    <tr><td class="paramname">is_virtual</td><td>in: whether it is a virtual col </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82236b70c3a89b04920db7f49d8423cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82236b70c3a89b04920db7f49d8423cf">&#9670;&nbsp;</a></span>dict_index_copy_rec_order_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* dict_index_copy_rec_order_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies an initial segment of a physical record, long enough to specify an index entry uniquely. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the prefix record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record for which to copy prefix </td></tr>
    <tr><td class="paramname">n_fields</td><td>out: number of fields copied </td></tr>
    <tr><td class="paramname">buf</td><td>in/out: memory buffer for the copied prefix, or NULL </td></tr>
    <tr><td class="paramname">buf_size</td><td>in/out: buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93cb9582603ebbc3a03d6c69829399c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cb9582603ebbc3a03d6c69829399c8">&#9670;&nbsp;</a></span>dict_index_copy_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_copy_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies types of fields contained in index to tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tuple</td><td>Data tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_fields</td><td>Number of field types to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f01f004e218abe927f03348bc12f230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f01f004e218abe927f03348bc12f230">&#9670;&nbsp;</a></span>dict_index_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_index_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classindex__id__t.html">index_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>index identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index or NULL if not found </dd></dl>

</div>
</div>
<a id="ad6f40100335feb168a333d55f2b50f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f40100335feb168a333d55f2b50f46">&#9670;&nbsp;</a></span>dict_index_get_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structrw__lock__t.html">rw_lock_t</a>* dict_index_get_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the read-write lock of the index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>read-write lock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadbac8d4dac47946d21ca041625e3688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbac8d4dac47946d21ca041625e3688">&#9670;&nbsp;</a></span>dict_index_get_n_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_get_n_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of fields in the internal representation of an index, including fields added by the dictionary system. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: an internal representation of index (in the dictionary cache) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcbb97b15f8d67fe47e1f7a0546f0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcbb97b15f8d67fe47e1f7a0546f0b3">&#9670;&nbsp;</a></span>dict_index_get_n_ordering_defined_by_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_get_n_ordering_defined_by_user </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of user-defined ordering fields in the index. </p>
<p>In the internal representation we add the row id to the ordering fields to make all indexes unique, but this function returns the number of fields the user defined in the index as ordering fields. </p><dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: an internal representation of index (in the dictionary cache) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1d995804ac51f68b7cbeabe63feb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1d995804ac51f68b7cbeabe63feb82">&#9670;&nbsp;</a></span>dict_index_get_n_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_get_n_unique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of fields in the internal representation of an index that uniquely determine the position of an index entry in the index, if we do not take multiversioning into account: in the B-tree use the value returned by dict_index_get_n_unique_in_tree. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: an internal representation of index (in the dictionary cache) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4a3e8de23728eddfa983a65fbfba8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a3e8de23728eddfa983a65fbfba8d6">&#9670;&nbsp;</a></span>dict_index_get_n_unique_in_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_get_n_unique_in_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of fields in the internal representation of an index which uniquely determine the position of an index entry in the index, if we also take multiversioning into account. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: an internal representation of index (in the dictionary cache) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838aa2c93954be5d86c42e2864ab053a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838aa2c93954be5d86c42e2864ab053a">&#9670;&nbsp;</a></span>dict_index_get_n_unique_in_tree_nonleaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE uint16_t dict_index_get_n_unique_in_tree_nonleaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of fields on nonleaf page level in the internal representation of an index which uniquely determine the position of an index entry in the index, if we also take multiversioning into account. </p>
<p>Note, it doesn't include page no field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>

</div>
</div>
<a id="a7aef9d2775c4f43c1fd5b29807b3b8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aef9d2775c4f43c1fd5b29807b3b8b6">&#9670;&nbsp;</a></span>dict_index_get_nth_field_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_index_get_nth_field_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for a matching field in an index. </p>
<p>The column has to be the same. The column in index must be complete, or must contain a prefix longer than the column in index2. That is, we must be able to construct the prefix in index2 from the prefix in index. </p><dl class="section return"><dt>Returns</dt><dd>position in internal representation of the index; ULINT_UNDEFINED if not contained </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index from which to search </td></tr>
    <tr><td class="paramname">index2</td><td>in: index </td></tr>
    <tr><td class="paramname">n</td><td>in: field number in index2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2165017527251996bd9a4f61847a895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2165017527251996bd9a4f61847a895">&#9670;&nbsp;</a></span>dict_index_get_online_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="dict0mem_8h.html#aa03dcafce31c230a892131b994e2379b">online_index_status</a> dict_index_get_online_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the status of online index creation. </p>
<dl class="section return"><dt>Returns</dt><dd>the status </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1561d551ba9b708facb18a89130f837f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1561d551ba9b708facb18a89130f837f">&#9670;&nbsp;</a></span>dict_index_get_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> dict_index_get_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the page number of the root of the index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca2c41c869382dbe51a62c7882fe7932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2c41c869382dbe51a62c7882fe7932">&#9670;&nbsp;</a></span>dict_index_get_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> dict_index_get_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the space id of the root of the index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>space id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25184187ad1da100d6895b7731741aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25184187ad1da100d6895b7731741aa1">&#9670;&nbsp;</a></span>dict_index_get_space_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_get_space_reserve </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns free space reserved for future updates of records. </p>
<p>This is relevant only in the case of many consecutive inserts, as updates which make the records bigger might fragment the index. </p><dl class="section return"><dt>Returns</dt><dd>number of free bytes on page, reserved for updates </dd></dl>

</div>
</div>
<a id="a0bc86f9b1b987ea2f307f1505db6d5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc86f9b1b987ea2f307f1505db6d5f6">&#9670;&nbsp;</a></span>dict_index_has_desc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_index_has_desc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the index consists of descending columns only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if index has any descending column </td></tr>
    <tr><td class="paramname">false</td><td>if index has only ascending columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada5dad5a9701b333d7224d47b96f9010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5dad5a9701b333d7224d47b96f9010">&#9670;&nbsp;</a></span>dict_index_has_virtual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_has_virtual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the index contains a virtual column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero for index on virtual column, zero for other indexes </dd></dl>

</div>
</div>
<a id="acd53e9e0be149b65f042e6580ef7aaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd53e9e0be149b65f042e6580ef7aaae">&#9670;&nbsp;</a></span>dict_index_is_auto_gen_clust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_index_is_auto_gen_clust </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if index is auto-generated clustered index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is auto-generated clustered index. </dd></dl>

</div>
</div>
<a id="a96abd248d0da48b42b8dc5afcf71c6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96abd248d0da48b42b8dc5afcf71c6b9">&#9670;&nbsp;</a></span>dict_index_is_ibuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_is_ibuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the index is the insert buffer tree. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero for insert buffer, zero for other indexes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcbc5eab483c1f89ffe2208855f3f9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbc5eab483c1f89ffe2208855f3f9b7">&#9670;&nbsp;</a></span>dict_index_is_online_ddl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_index_is_online_ddl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a secondary index is being or has been created online, or if the table is being rebuilt online, allowing concurrent modifications to the table. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the index is being or has been built online, or if this is a clustered index and the table is being or has been rebuilt online </td></tr>
    <tr><td class="paramname">false</td><td>if the index has been created or the table has been rebuilt completely </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58a766867dc79946528d7dcc4bcc3cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a766867dc79946528d7dcc4bcc3cf9">&#9670;&nbsp;</a></span>dict_index_is_sdi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_index_is_sdi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the index is SDI index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>in-memory index structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is SDI index else false </dd></dl>

</div>
</div>
<a id="a94f679c6c3418fd3a2426131ec7c2a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f679c6c3418fd3a2426131ec7c2a93">&#9670;&nbsp;</a></span>dict_index_is_sec_or_ibuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_is_sec_or_ibuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the index is a secondary index or the insert buffer tree. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero for insert buffer, zero for other indexes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16844309ee400bd7f9f52e366d9d3454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16844309ee400bd7f9f52e366d9d3454">&#9670;&nbsp;</a></span>dict_index_is_spatial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_is_spatial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the index is a Spatial Index. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero for Spatial Index, zero for other indexes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaded5a4fccfd3a5709b6cc9df983acb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaded5a4fccfd3a5709b6cc9df983acb7">&#9670;&nbsp;</a></span>dict_index_is_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_index_is_unique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the index is unique. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero for unique index, zero for other indexes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a608858864003abeb0fb38381a5e1add4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608858864003abeb0fb38381a5e1add4">&#9670;&nbsp;</a></span>dict_index_node_ptr_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_index_node_ptr_max_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return maximum size of the node pointer record. </p>
<dl class="section return"><dt>Returns</dt><dd>maximum size of the record in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50cae32c3f5a0876a844f524afcdbb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cae32c3f5a0876a844f524afcdbb74">&#9670;&nbsp;</a></span>dict_index_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an index from the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table whose index to remove </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index to remove, this object is destroyed and must not be accessed by the caller afterwards</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">index</td><td>in, own: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65c513183157a387fa4056b6ef66af2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c513183157a387fa4056b6ef66af2f">&#9670;&nbsp;</a></span>dict_index_remove_from_v_col_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_remove_from_v_col_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the virtual column's index list before index is being freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index being freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5812b710d47d31827d328de9497fa366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5812b710d47d31827d328de9497fa366">&#9670;&nbsp;</a></span>dict_index_set_merge_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_set_merge_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>merge_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets merge_threshold in the SYS_INDEXES. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">merge_threshold</td><td>value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c721f5a0e8349003a79a1408294a317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c721f5a0e8349003a79a1408294a317">&#9670;&nbsp;</a></span>dict_index_set_online_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_index_set_online_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="dict0mem_8h.html#aa03dcafce31c230a892131b994e2379b">online_index_status</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the status of online index creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a178655631c2da40803e1303f75640c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178655631c2da40803e1303f75640c83">&#9670;&nbsp;</a></span>dict_index_set_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_index_set_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the space id of the root of the index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d494ca6cb4255061dfe571a6b791f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d494ca6cb4255061dfe571a6b791f22">&#9670;&nbsp;</a></span>dict_index_zip_failure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_zip_failure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called whenever a page compression attempt fails. </p>
<p>Updates the compression padding information. in/out: index to be updated.</p>
<p>Updates the compression padding information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in/out: index to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c2ae13ec31983373ae1975ef788957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c2ae13ec31983373ae1975ef788957">&#9670;&nbsp;</a></span>dict_index_zip_pad_optimal_page_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_index_zip_pad_optimal_page_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the optimal page size, for which page will likely compress. </p>
<dl class="section return"><dt>Returns</dt><dd>page size beyond which page may not compress</dd>
<dd>
page size beyond which page might not compress </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index for which page size is requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac88b092de7509f57263863ab0952e435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88b092de7509f57263863ab0952e435">&#9670;&nbsp;</a></span>dict_index_zip_success()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_zip_success </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called whenever a page is successfully compressed. </p>
<p>Updates the compression padding information. in/out: index to be updated.</p>
<p>Updates the compression padding information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in/out: index to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a047c7e1b181bcd0caed7d4b66d641626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047c7e1b181bcd0caed7d4b66d641626">&#9670;&nbsp;</a></span>dict_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inits the data dictionary module. </p>

</div>
</div>
<a id="aa5dbb700be89f9b4239e87d859c414fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dbb700be89f9b4239e87d859c414fa">&#9670;&nbsp;</a></span>dict_make_room_in_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_make_room_in_cache </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pct_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make room in the table cache by evicting an unused table. </p>
<p>The unused table should not be part of FK relationship and currently not used in any user transaction. There is no guarantee that it will remove a table. </p><dl class="section return"><dt>Returns</dt><dd>number of tables evicted. in: max percent to check</dd></dl>
<p>The unused table should not be part of FK relationship and currently not used in any user transaction. There is no guarantee that it will remove a table. </p><dl class="section return"><dt>Returns</dt><dd>number of tables evicted. If the number of tables in the dict_LRU is less than max_tables it will not do anything. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_tables</td><td>in: max tables allowed in cache </td></tr>
    <tr><td class="paramname">pct_check</td><td>in: max percent to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dd3deedb0926c622f16b35012ecc807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd3deedb0926c622f16b35012ecc807">&#9670;&nbsp;</a></span>dict_max_field_len_store_undo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_max_field_len_store_undo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine bytes of column prefix to be stored in the undo log. </p>
<p>Please note that if !dict_table_has_atomic_blobs(table), no prefix needs to be stored in the undo log. </p><dl class="section return"><dt>Returns</dt><dd>bytes of column prefix to be stored in the undo log </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col</td><td>in: column which index prefix is based on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1f793c7b0e7d08dac7eec58dc3045a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f793c7b0e7d08dac7eec58dc3045a5">&#9670;&nbsp;</a></span>dict_max_v_field_len_store_undo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_max_v_field_len_store_undo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine maximum bytes of a virtual column need to be stored in the undo log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>dict_table_t for the table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_no</td><td>virtual column number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum bytes of virtual column to be stored in the undo log </dd></dl>

</div>
</div>
<a id="a5cc7d36ebddeb0aa1694f2059966c95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc7d36ebddeb0aa1694f2059966c95c">&#9670;&nbsp;</a></span>dict_move_to_mru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_move_to_mru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move to the most recently used segment of the LRU list. </p>
<p>in: table to move to MRU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to move to MRU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a92c8c0baf91abdb10ad1018aabeeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a92c8c0baf91abdb10ad1018aabeeda">&#9670;&nbsp;</a></span>dict_mutex_enter_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_mutex_enter_for_mysql </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves the dictionary system mutex for MySQL. </p>

</div>
</div>
<a id="a1da4da7d57e573205d70db315bb35059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da4da7d57e573205d70db315bb35059">&#9670;&nbsp;</a></span>dict_mutex_exit_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_mutex_exit_for_mysql </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the dictionary system mutex for MySQL. </p>

</div>
</div>
<a id="a1290fbd353890c87caa83f9c13a62d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1290fbd353890c87caa83f9c13a62d2d">&#9670;&nbsp;</a></span>dict_partitioned_table_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_partitioned_table_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to invalidate an entry from the dict cache, for a partitioned table, if any table found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Table name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a349be868adf860eb3eebe9b46647a724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349be868adf860eb3eebe9b46647a724">&#9670;&nbsp;</a></span>dict_persist_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_persist_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the structure. </p>

</div>
</div>
<a id="a5625204b6cf879690f2f9ecdd8966d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5625204b6cf879690f2f9ecdd8966d09">&#9670;&nbsp;</a></span>dict_persist_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_persist_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inits the structure for persisting dynamic metadata. </p>

</div>
</div>
<a id="afab2239c47b02298cb7a7473e1e04feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab2239c47b02298cb7a7473e1e04feb">&#9670;&nbsp;</a></span>dict_persist_to_dd_table_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_persist_to_dd_table_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if any table has any dirty persistent data, if so write dirty persistent data of table to mysql.innodb_dynamic_metadata accordingly. </p>

</div>
</div>
<a id="a89c806b5428c187b203fc0e75aadc6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c806b5428c187b203fc0e75aadc6d5">&#9670;&nbsp;</a></span>dict_print_info_on_foreign_key_in_create_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_print_info_on_foreign_key_in_create_format </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>add_newline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs info on a foreign key of a table in a format suitable for CREATE TABLE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File where to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>Transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">foreign</td><td>Foreign key constraint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_newline</td><td>Whether to add a newline </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9bd94fd5c39b012b78c179e3f6336d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9bd94fd5c39b012b78c179e3f6336d">&#9670;&nbsp;</a></span>dict_remove_db_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_remove_db_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the end of table name where we have removed dbname and '/'. </p>
<dl class="section return"><dt>Returns</dt><dd>table name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name in the form dbname '/' tablename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a680b8f92809a401a7ed2a639a0a36296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680b8f92809a401a7ed2a639a0a36296">&#9670;&nbsp;</a></span>dict_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_resize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the hash tables besed on the current buffer pool size. </p>

</div>
</div>
<a id="a86a5e28ba7d67c5b96987811d35221e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a5e28ba7d67c5b96987811d35221e4">&#9670;&nbsp;</a></span>dict_sdi_close_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_sdi_close_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close SDI table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the in-meory SDI table object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab15f00af9ae5b2649c83e95ba644129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15f00af9ae5b2649c83e95ba644129e">&#9670;&nbsp;</a></span>dict_sdi_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_sdi_get_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>tablespace_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve in-memory index for SDI table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tablespace_id</td><td>innodb tablespace ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dict_index_t structure or NULL </dd></dl>

</div>
</div>
<a id="a5a4a17264630948643509158144fc8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4a17264630948643509158144fc8ff">&#9670;&nbsp;</a></span>dict_sdi_get_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__table__t.html">dict_table_t</a>* dict_sdi_get_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>tablespace_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dict_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_create</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve in-memory table object for SDI table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tablespace_id</td><td>innodb tablespace ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dict_locked</td><td>true if dict_sys mutex is acquired </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_create</td><td>true when creating SDI Index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dict_table_t structure </dd></dl>

</div>
</div>
<a id="a7b5cf1e16d99673a7512bbd738e49b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5cf1e16d99673a7512bbd738e49b36">&#9670;&nbsp;</a></span>dict_sdi_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_sdi_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>sdi_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dict_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the SDI table from table cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>InnoDB tablespace ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdi_table</td><td>SDI table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dict_locked</td><td>true if dict_sys mutex acquired </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72c03c1c0c28384c08b381067361a84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c03c1c0c28384c08b381067361a84e">&#9670;&nbsp;</a></span>dict_set_compression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_set_compression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the compression type for the tablespace of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>The table that should be compressed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algorithm</td><td>Text representation of the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="a863d66fc7dd0c29ebef61c49a56fd7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863d66fc7dd0c29ebef61c49a56fd7a9">&#9670;&nbsp;</a></span>dict_set_corrupted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_set_corrupted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags an index corrupted in the data dictionary cache only. </p>
<p>This is used to mark a corrupted index when index's own dictionary is corrupted, and we would force to load such index for repair purpose. Besides, we have to write a redo log. We don't want to hold dict_sys-&gt;mutex here, so that we can set index as corrupted in some low-level functions. We would only set the flags from not corrupted to corrupted when server is running, so it should be safe to set it directly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index, must not be NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68dd5b87bc893cce378fc9357076133c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dd5b87bc893cce378fc9357076133c">&#9670;&nbsp;</a></span>dict_set_merge_threshold_all_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_set_merge_threshold_all_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>merge_threshold_all</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets merge_threshold for all indexes in dictionary cache for debug. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">merge_threshold_all</td><td>value to set for all indexes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a625714c4b06daadd3438719737dfea3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625714c4b06daadd3438719737dfea3d">&#9670;&nbsp;</a></span>dict_sys_table_id_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_sys_table_id_build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the table_id array of SYS_* tables. </p>
<p>This array is used to determine if a table is InnoDB SYSTEM table or not. </p><dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

</div>
</div>
<a id="acbd5dd1790c77670d7eb93dd7375ca98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd5dd1790c77670d7eb93dd7375ca98">&#9670;&nbsp;</a></span>dict_table_add_system_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_add_system_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds system columns to a table object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Temporary heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a215aca0021933ba836c3a7cdc783677e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215aca0021933ba836c3a7cdc783677e">&#9670;&nbsp;</a></span>dict_table_add_to_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_add_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>can_be_evicted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a table object to the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">can_be_evicted</td><td>true if can be evicted </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>temporary heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8b10bccd65ab1541acf76874739505c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b10bccd65ab1541acf76874739505c">&#9670;&nbsp;</a></span>dict_table_allow_eviction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_allow_eviction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow the table to be evicted by moving a table to the LRU list from the non-LRU list if it is not already there. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>InnoDB table object can be evicted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a822caee6af5816145582073d3ea7a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822caee6af5816145582073d3ea7a035">&#9670;&nbsp;</a></span>dict_table_apply_dynamic_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_apply_dynamic_metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPersistentTableMetadata.html">PersistentTableMetadata</a> *&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the persistent dynamic metadata read from redo logs or DDTableBuffer to corresponding table during recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata</td><td>structure of persistent metadata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we do apply something to the in-memory table object, otherwise false </dd></dl>

</div>
</div>
<a id="a699e23bef40a36ccaded0fda98e6fbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699e23bef40a36ccaded0fda98e6fbe7">&#9670;&nbsp;</a></span>dict_table_autoinc_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_autoinc_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally set the autoinc counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Next value to assign to a row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4556c3398489ad92461d6bef6e3025ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4556c3398489ad92461d6bef6e3025ce">&#9670;&nbsp;</a></span>dict_table_autoinc_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_autoinc_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the autoinc lock. </p>
<p>in/out: table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd2d0623456d144d44aaa6eb1603dde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2d0623456d144d44aaa6eb1603dde6">&#9670;&nbsp;</a></span>dict_table_autoinc_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_autoinc_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write redo logs for autoinc counter that is to be inserted, or to update some existing smaller one to bigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>InnoDB table object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>AUTOINC counter to log </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7758866ffad7ee17f05c6fb8dce7909c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7758866ffad7ee17f05c6fb8dce7909c">&#9670;&nbsp;</a></span>dict_table_autoinc_persisted_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_autoinc_persisted_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>autoinc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the persisted autoinc counter to specified one, we should hold autoinc_persisted_mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoinc</td><td>set autoinc_persisted to this value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a810c4bcd773aee77e1bcf477d102af75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810c4bcd773aee77e1bcf477d102af75">&#9670;&nbsp;</a></span>dict_table_autoinc_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_autoinc_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the next autoinc value (== autoinc counter value), 0 if not yet initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>value for a new row, or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a257d96ba7e350b0eec6210a119dd1ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257d96ba7e350b0eec6210a119dd1ab6">&#9670;&nbsp;</a></span>dict_table_autoinc_set_col_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_autoinc_set_col_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the column position of autoinc column in clustered index for a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>column position in table definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6229492d88f02c167679204097c9dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6229492d88f02c167679204097c9dc20">&#9670;&nbsp;</a></span>dict_table_autoinc_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_autoinc_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the autoinc lock. </p>
<p>in/out: table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4760f51731a8c5c3c0545ea47294a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4760f51731a8c5c3c0545ea47294a2d">&#9670;&nbsp;</a></span>dict_table_autoinc_update_if_greater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_autoinc_update_if_greater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the autoinc counter if the value supplied is greater than the current value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value which was assigned to a row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0191e8cf294b9fe56410d942052ac1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0191e8cf294b9fe56410d942052ac1b3">&#9670;&nbsp;</a></span>dict_table_change_id_in_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_change_id_in_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the id of a table object in the dictionary cache. </p>
<p>This is used in DISCARD TABLESPACE. in: new id to set</p>
<p>This is used in DISCARD TABLESPACE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table object already in cache </td></tr>
    <tr><td class="paramname">new_id</td><td>in: new id to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0732ecc0e35fbc0658ea7733d249656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0732ecc0e35fbc0658ea7733d249656">&#9670;&nbsp;</a></span>dict_table_change_id_sys_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_change_id_sys_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the table_id of SYS_* tables if they have been created after an earlier upgrade. </p>
<p>This will update the table_id by adding DICT_MAX_DD_TABLES </p>

</div>
</div>
<a id="ad364830ec539d0e23ab72712e3a441a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad364830ec539d0e23ab72712e3a441a4">&#9670;&nbsp;</a></span>dict_table_check_for_dup_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_check_for_dup_indexes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="dict0dict_8h.html#a96d4b1626b1bf4ea2e8d645210d4d476">check_name</a>&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for duplicate index entries in a table [using the index name]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>Check for dup indexes in this table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check</td><td>Whether and when to allow temporary index names </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d923a0efd8786f3f21a026c89bcee1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d923a0efd8786f3f21a026c89bcee1f">&#9670;&nbsp;</a></span>dict_table_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dict_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>try_drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the count of open handles to a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dict_locked</td><td>True=data dictionary locked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">try_drop</td><td>True=try to drop any orphan indexes after an aborted online index creation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c514f3985e99bc04eef58c65d3638b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c514f3985e99bc04eef58c65d3638b">&#9670;&nbsp;</a></span>dict_table_close_and_drop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_close_and_drop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the only open handle to a table and drops a table while assuring that dict_sys-&gt;mutex is held the whole time. </p>
<p>This assures that the table is not evicted after the close when the count of open handles goes to zero. Because dict_sys-&gt;mutex is held, we do not need to call dict_table_prevent_eviction(). in/out: table</p>
<p>This assures that the table is not evicted after the close when the count of open handles goes to zero. Because dict_sys-&gt;mutex is held, we do not need to call dict_table_prevent_eviction(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: data dictionary transaction </td></tr>
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a797e361e55268f546239b0256aaa971d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797e361e55268f546239b0256aaa971d">&#9670;&nbsp;</a></span>dict_table_col_in_clustered_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool dict_table_col_in_clustered_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a column is in the ordering columns of the clustered index of a table. </p>
<p>Column prefixes are treated like whole columns. </p><dl class="section return"><dt>Returns</dt><dd>true if the column, or its prefix, is in the clustered key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">n</td><td>in: column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7db504f10796a76e4bd6292d7550e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7db504f10796a76e4bd6292d7550e23">&#9670;&nbsp;</a></span>dict_table_copy_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_copy_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies types of columns contained in table to tuple and sets all fields of the tuple to the SQL NULL value. </p>
<p>This function should be called right after dtuple_create(). in: table</p>
<p>This function should be called right after dtuple_create(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in/out: data tuple </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e125ce275e8acec996bb7187919a1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e125ce275e8acec996bb7187919a1b8">&#9670;&nbsp;</a></span>dict_table_copy_v_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_copy_v_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies types of virtual columns contained in table to tuple and sets all fields of the tuple to the SQL NULL value. </p>
<p>This function should be called right after dtuple_create(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tuple</td><td>data tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f10eb5d5e910775206e21b6cd54689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f10eb5d5e910775206e21b6cd54689">&#9670;&nbsp;</a></span>dict_table_ddl_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_ddl_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move this table to non-LRU list for DDL operations if it's currently not there. </p>
<p>This also prevents later opening table via DD objects, when the table name in InnoDB doesn't match with DD object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table to put in non-LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f0bfabd1d7de19db4adc7f877ac6520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0bfabd1d7de19db4adc7f877ac6520">&#9670;&nbsp;</a></span>dict_table_ddl_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_ddl_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move this table to LRU list after DDL operations if it was moved to non-LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table to put in LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61e30fe2a05f008b3e1953b19fa76d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e30fe2a05f008b3e1953b19fa76d19">&#9670;&nbsp;</a></span>dict_table_decode_n_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_decode_n_col </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>n_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>n_v_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode number of virtual and non-virtual columns in one 4 bytes value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>encoded value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_col</td><td>number of non-virtual column </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n_v_col</td><td>number of virtual column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7604db6c69e41636ddceb44e00bbe8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7604db6c69e41636ddceb44e00bbe8c">&#9670;&nbsp;</a></span>dict_table_encode_n_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_table_encode_n_col </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_v_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>encode number of columns and number of virtual columns in one 4 bytes value. </p>
<p>We could do this because the number of columns in InnoDB is limited to 1017 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_col</td><td>number of non-virtual column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_v_col</td><td>number of virtual column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded value </dd></dl>

</div>
</div>
<a id="a010eb6ef71e5661c3a7ed5064aa390c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010eb6ef71e5661c3a7ed5064aa390c3">&#9670;&nbsp;</a></span>dict_table_extent_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> dict_table_extent_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the extent size (in pages) for the given table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table whose extent size is being calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>extent size in pages (256, 128 or 64) </dd></dl>

</div>
</div>
<a id="a63682f9ca158da7b1f9bd9fb03e170d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63682f9ca158da7b1f9bd9fb03e170d3">&#9670;&nbsp;</a></span>dict_table_get_all_fts_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_get_all_fts_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__vector__t.html">ib_vector_t</a> *&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the FTS indexes on a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indexes</td><td>all FTS indexes on this table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of FTS indexes </dd></dl>

</div>
</div>
<a id="a3b879a4e1c0bb3d724254462feb15b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b879a4e1c0bb3d724254462feb15b21">&#9670;&nbsp;</a></span>dict_table_get_curr_table_sess_trx_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> dict_table_get_curr_table_sess_trx_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current session trx-id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table local trx-id. </dd></dl>

</div>
</div>
<a id="abffc1e21c1e5137d055affd1acbe1808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffc1e21c1e5137d055affd1acbe1808">&#9670;&nbsp;</a></span>dict_table_get_datadir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dict_table_get_datadir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tablespace data directory if set, otherwise empty string. </p>
<dl class="section return"><dt>Returns</dt><dd>the data directory </dd></dl>

</div>
</div>
<a id="a09f552c54e180ca58368c8b67c4961ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f552c54e180ca58368c8b67c4961ad">&#9670;&nbsp;</a></span>dict_table_get_highest_foreign_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_get_highest_foreign_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the highest [number] for foreign key constraints of the table. </p>
<p>Looks only at the &gt;= 4.0.18-format id's, which are of the form databasename/tablename_ibfk_[number]. </p><dl class="section return"><dt>Returns</dt><dd>highest number, 0 if table has no new format foreign key constraints in: table in the dictionary memory cache</dd></dl>
<p>Looks only at the &gt;= 4.0.18-format id's, which are of the form databasename/tablename_ibfk_[number]. TODO: Remove this function once in-place ALTER TABLE code is updated to avoid its use. </p><dl class="section return"><dt>Returns</dt><dd>highest number, 0 if table has no new format foreign key constraints </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table in the dictionary memory cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54fc1d882c647412901764072155fbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fc1d882c647412901764072155fbe4">&#9670;&nbsp;</a></span>dict_table_get_index_on_first_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_get_index_on_first_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index by first field of the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_index</td><td>position of column in table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index which is having first field matches with the field present in field_index position of table </dd></dl>

</div>
</div>
<a id="a36312cc400aa52913fed4f3c85a497f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36312cc400aa52913fed4f3c85a497f8">&#9670;&nbsp;</a></span>dict_table_get_index_on_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_get_index_on_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>committed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an index by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table where to look for the index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the index name to look for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">committed</td><td>true=search for committed, false=search for uncommitted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index, NULL if does not exist </dd></dl>

</div>
</div>
<a id="aeb97122de57a9075cf1f29225f4e3130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb97122de57a9075cf1f29225f4e3130">&#9670;&nbsp;</a></span>dict_table_get_index_on_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_get_index_on_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>committed</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an index by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table where to look for the index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the index name to look for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">committed</td><td>true=search for committed, false=search for uncommitted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index, NULL if does not exist </dd></dl>

</div>
</div>
<a id="aed48b92a7b200136b50a2daf8160c4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed48b92a7b200136b50a2daf8160c4a0">&#9670;&nbsp;</a></span>dict_table_get_n_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ib_uint64_t dict_table_get_n_rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the approximately estimated number of rows in the table. </p>
<dl class="section return"><dt>Returns</dt><dd>estimated number of rows </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70fdd5d2ee9d560bef7d3cedcdb74ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fdd5d2ee9d560bef7d3cedcdb74ca2">&#9670;&nbsp;</a></span>dict_table_get_n_tot_u_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_table_get_n_tot_u_cols </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11595ad706917a335b47a6734105077c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11595ad706917a335b47a6734105077c">&#9670;&nbsp;</a></span>dict_table_get_n_v_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_table_get_n_v_cols </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of virtual columns in a table in the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of virtual columns of a table </dd></dl>

</div>
</div>
<a id="a06055532ed1bb098508dca8466cf0d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06055532ed1bb098508dca8466cf0d76">&#9670;&nbsp;</a></span>dict_table_get_next_table_sess_row_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="trx0types_8h.html#a3f6397f57064f579d2c5d68884ba44e0">row_id_t</a> dict_table_get_next_table_sess_row_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get table session row-id and increment the row-id counter for next use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next table local row-id. </dd></dl>

</div>
</div>
<a id="a8f2071e8a4b4ace0780851d674913fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2071e8a4b4ace0780851d674913fb7">&#9670;&nbsp;</a></span>dict_table_get_next_table_sess_trx_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> dict_table_get_next_table_sess_trx_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get table session trx-id and increment the trx-id counter for next use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next table local trx-id. </dd></dl>

</div>
</div>
<a id="ad1d9a33a3b22e3721253efa027dd3fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d9a33a3b22e3721253efa027dd3fd7">&#9670;&nbsp;</a></span>dict_table_get_nth_col_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_get_nth_col_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for non-virtual column n position in the clustered index. </p>
<dl class="section return"><dt>Returns</dt><dd>position in internal representation of the clustered index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">n</td><td>in: column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a495ddc5f7f28813dc2cbcb21fe165d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495ddc5f7f28813dc2cbcb21fe165d8f">&#9670;&nbsp;</a></span>dict_table_get_nth_v_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdict__v__col__t.html">dict_v_col_t</a>* dict_table_get_nth_v_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the nth virtual column of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>position of virtual column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to virtual column object </dd></dl>

</div>
</div>
<a id="aefcd69a7fa04517678a1b68f97048003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcd69a7fa04517678a1b68f97048003">&#9670;&nbsp;</a></span>dict_table_get_nth_v_col_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__v__col__t.html">dict_v_col_t</a>* dict_table_get_nth_v_col_mysql </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nth virtual column according to its original MySQL table position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>target table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_nr</td><td>column number in MySQL Table definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dict_v_col_t ptr </dd></dl>

</div>
</div>
<a id="aa7a07438085b78a25a4ca3a654ab95e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a07438085b78a25a4ca3a654ab95e0">&#9670;&nbsp;</a></span>dict_table_get_sys_col_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_table_get_sys_col_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>sys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the given system column number of a table. </p>
<dl class="section return"><dt>Returns</dt><dd>column number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">sys</td><td>in: DATA_ROW_ID, ... </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a603d4def7151df6008aacc0b2ca8a1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603d4def7151df6008aacc0b2ca8a1e1">&#9670;&nbsp;</a></span>dict_table_get_v_col_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_table_get_v_col_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a virtual column's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>target table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_nr</td><td>virtual column number (nth virtual column) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column name or NULL if column number out of range. </dd></dl>

</div>
</div>
<a id="a5285275bc97480ce7f158971772b698c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5285275bc97480ce7f158971772b698c">&#9670;&nbsp;</a></span>dict_table_get_v_col_name_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_table_get_v_col_name_mysql </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a virtual column's name according to its original MySQL table position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>target table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_nr</td><td>column number (nth column in the table) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column name. </dd></dl>

</div>
</div>
<a id="aa76e62b02b7c8267837a724ee71a5c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76e62b02b7c8267837a724ee71a5c73">&#9670;&nbsp;</a></span>dict_table_has_atomic_blobs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_has_atomic_blobs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a table uses atomic BLOBs (no locally stored prefix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>InnoDB table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether BLOBs are atomic </dd></dl>

</div>
</div>
<a id="ad2bdbdc3606119a8d33abe776bbd8eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bdbdc3606119a8d33abe776bbd8eb7">&#9670;&nbsp;</a></span>dict_table_has_autoinc_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_has_autoinc_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a table has an autoinc counter column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is an autoinc column in the table, otherwise false. </dd></dl>

</div>
</div>
<a id="a84ce2800fb70a5cffb298fba8721f195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ce2800fb70a5cffb298fba8721f195">&#9670;&nbsp;</a></span>dict_table_has_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_has_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the table has a given (non_virtual) column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_name</td><td>column name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_nr</td><td>column number guessed, 0 as default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column number if the table has the specified column, otherwise table-&gt;n_def </dd></dl>
<p>The order of column may changed, check it with other columns </p>

</div>
</div>
<a id="acaa46249ead572b05272e5c5b99fac07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa46249ead572b05272e5c5b99fac07">&#9670;&nbsp;</a></span>dict_table_has_fts_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool dict_table_has_fts_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the table has an FTS index. </p>
<dl class="section return"><dt>Returns</dt><dd>true if table has an FTS index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ad387c85d045ac4f8c7b74eaf9df3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ad387c85d045ac4f8c7b74eaf9df3d">&#9670;&nbsp;</a></span>dict_table_has_indexed_v_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_has_indexed_v_cols </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a table has indexed virtual columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is the table has indexed virtual columns </dd></dl>

</div>
</div>
<a id="ad0863b7dc172e4cb9906c3ec68d86d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0863b7dc172e4cb9906c3ec68d86d11">&#9670;&nbsp;</a></span>dict_table_have_virtual_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_have_virtual_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the table have virtual index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>InnoDB table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the table have virtual index, false otherwise. </dd></dl>

</div>
</div>
<a id="aadadd762fb6bdc532a078d5348b4bd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadadd762fb6bdc532a078d5348b4bd0e">&#9670;&nbsp;</a></span>dict_table_in_shared_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_in_shared_tablespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the table is in a shared tablespace (System or General). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table is a shared tablespace, false if not. </dd></dl>

</div>
</div>
<a id="afeb24172dd54a082038c4f7c6aff7ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb24172dd54a082038c4f7c6aff7ce6">&#9670;&nbsp;</a></span>dict_table_is_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool dict_table_is_comp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the table uses the compact page format. </p>
<dl class="section return"><dt>Returns</dt><dd>true if table uses the compact page format </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6d42641281fd397af442083d63d35ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d42641281fd397af442083d63d35ea">&#9670;&nbsp;</a></span>dict_table_is_compressed_temporary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_is_compressed_temporary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a table is a temporary table with compressed row format, we should always expect false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it's a compressed temporary table, false otherwise </dd></dl>

</div>
</div>
<a id="ac0f8634691e40cc161b8c09eac9a470e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f8634691e40cc161b8c09eac9a470e">&#9670;&nbsp;</a></span>dict_table_is_discarded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_is_discarded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the tablespace for the table has been discarded. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the tablespace has been discarded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4385f247a9ebe9e190b54ae4c890cbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4385f247a9ebe9e190b54ae4c890cbe5">&#9670;&nbsp;</a></span>dict_table_is_fts_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dict_table_is_fts_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__vector__t.html">ib_vector_t</a> *&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_virtual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexes</td><td>out: ULINT_UNDEFINED if no match else the offset within the vector in: vector containing only FTS indexes </td></tr>
    <tr><td class="paramname">col_no</td><td>in: col number to search for </td></tr>
    <tr><td class="paramname">is_virtual</td><td>in: whether it is a virtual column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb1c87bbda5e0443a10bd433a1f9316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1c87bbda5e0443a10bd433a1f9316e">&#9670;&nbsp;</a></span>dict_table_is_locking_disabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_is_locking_disabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether locking is disabled for this table. </p>
<p>Currently this is done for intrinsic table as their visibility is limited to the connection and the DDTableBuffer as it's protected by dict_persist-&gt;mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if locking is disabled. </dd></dl>

</div>
</div>
<a id="a9084ec58b734f47f0940b7e83b385b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9084ec58b734f47f0940b7e83b385b51">&#9670;&nbsp;</a></span>dict_table_is_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_is_partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the dict_table_t is a partition. </p>
<p>A partitioned table on the SQL level is composed of InnoDB tables, where each InnoDB table is a [sub]partition including its secondary indexes which belongs to the partition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>Table to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the dict_table_t is a partition else false. </dd></dl>

</div>
</div>
<a id="a2bb312e354c9f49b250de7f5d4ab8791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb312e354c9f49b250de7f5d4ab8791">&#9670;&nbsp;</a></span>dict_table_is_referenced_by_foreign_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool dict_table_is_referenced_by_foreign_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a table is referenced by foreign keys. </p>
<dl class="section return"><dt>Returns</dt><dd>true if table is referenced by a foreign key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: InnoDB table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a658d5dc2b146fd312965d86d3925645b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658d5dc2b146fd312965d86d3925645b">&#9670;&nbsp;</a></span>dict_table_is_sdi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_is_sdi </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>table_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an table id belongs SDI table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table_id</td><td>dict_table_t id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if table_id is SDI table_id else false </dd></dl>

</div>
</div>
<a id="a6f771d7fdbec90778be84c82ebbabb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f771d7fdbec90778be84c82ebbabb62">&#9670;&nbsp;</a></span>dict_table_is_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_is_system </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a>&#160;</td>
          <td class="paramname"><em>table_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if table is InnoDB SYS_* table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table_id</td><td>table id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98167c3c3772439a718780f49b9e6167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98167c3c3772439a718780f49b9e6167">&#9670;&nbsp;</a></span>dict_table_is_table_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_is_table_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the table is DDTableBuffer. </p>
<p>See class DDTableBuffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this is a DDTableBuffer table. </dd></dl>

</div>
</div>
<a id="ae2b0a27f5d69091934c4fa34a789b101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0a27f5d69091934c4fa34a789b101">&#9670;&nbsp;</a></span>dict_table_load_dynamic_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_load_dynamic_metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is any latest persistent dynamic metadata recorded in DDTableBuffer table of the specific table. </p>
<p>If so, read the metadata and update the table object accordingly. It's used when loading table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3421570f26455402b131132912b79f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3421570f26455402b131132912b79f34">&#9670;&nbsp;</a></span>dict_table_mark_dirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_mark_dirty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the dirty_status of a table as METADATA_DIRTY, and add it to the dirty_dict_tables list if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bfb54b5eea94a36619fd87f702b6324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfb54b5eea94a36619fd87f702b6324">&#9670;&nbsp;</a></span>dict_table_move_from_lru_to_non_lru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_move_from_lru_to_non_lru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a table to the non LRU end of the LRU list. </p>
<p>in: table to move from LRU to non-LRU</p>
<p>Move a table to the non LRU end of the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to move from LRU to non-LRU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40b5e7c188e636667f0bef65daee7229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b5e7c188e636667f0bef65daee7229">&#9670;&nbsp;</a></span>dict_table_move_from_non_lru_to_lru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_move_from_non_lru_to_lru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a table to the LRU end from the non LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>InnoDB table object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1216310eb143d1b7cb7fc508b7343327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1216310eb143d1b7cb7fc508b7343327">&#9670;&nbsp;</a></span>dict_table_mysql_pos_to_innodb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_mysql_pos_to_innodb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the innodb column position for a non-virtual column according to its original MySQL table position n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>MySQL column position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column position in InnoDB </dd></dl>

</div>
</div>
<a id="a1ab9d56517abf5aa197f0effd485f858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab9d56517abf5aa197f0effd485f858">&#9670;&nbsp;</a></span>dict_table_n_rows_dec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_n_rows_dec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the number of rows in the table by one. </p>
<p>Notice that this operation is not protected by any latch, the number is approximate. in/out: table </p>

</div>
</div>
<a id="a9db7ed4886637b827211934ba6429781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db7ed4886637b827211934ba6429781">&#9670;&nbsp;</a></span>dict_table_n_rows_inc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_n_rows_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the number of rows in the table by one. </p>
<p>Notice that this operation is not protected by any latch, the number is approximate. in/out: table </p>

</div>
</div>
<a id="a41351d480e889a949b052e63d7fd2155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41351d480e889a949b052e63d7fd2155">&#9670;&nbsp;</a></span>dict_table_open_on_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__table__t.html">dict_table_t</a>* dict_table_open_on_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dict_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>try_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a>&#160;</td>
          <td class="paramname"><em>ignore_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a table object and increments its open handle count. </p>
<p>NOTE! This is a high-level function to be used mainly from outside the 'dict' directory. Inside this directory dict_table_get_low is usually the appropriate function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table_name</td><td>Table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dict_locked</td><td>TRUE=data dictionary locked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">try_drop</td><td>TRUE=try to drop any orphan indexes after an aborted online index creation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_err</td><td>error to be ignored when loading the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table, NULL if does not exist</dd></dl>
<p>Returns a table object and increments its open handle count.</p>
<p>NOTE! This is a high-level function to be used mainly from outside the 'dict' module. Inside this directory dict_table_get_low is usually the appropriate function. </p><dl class="section return"><dt>Returns</dt><dd>table, NULL if does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_name</td><td>in: table name </td></tr>
    <tr><td class="paramname">dict_locked</td><td>in: TRUE=data dictionary locked </td></tr>
    <tr><td class="paramname">try_drop</td><td>in: TRUE=try to drop any orphan indexes after an aborted online index creation </td></tr>
    <tr><td class="paramname">ignore_err</td><td>in: error to be ignored when loading a table definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2b0a62aa0830f3ae32c1696d7d7c429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b0a62aa0830f3ae32c1696d7d7c429">&#9670;&nbsp;</a></span>dict_table_page_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="classpage__size__t.html">page_size_t</a> dict_table_page_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the table page size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compressed page size, or 0 if not compressed </dd></dl>

</div>
</div>
<a id="a79fe59fa3a891b4e558e8b4d444c3f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fe59fa3a891b4e558e8b4d444c3f25">&#9670;&nbsp;</a></span>dict_table_persist_to_dd_table_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_persist_to_dd_table_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write back the dirty persistent dynamic metadata of the table to DDTableBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac3e541f152dbe753f6559b4b370e610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3e541f152dbe753f6559b4b370e610">&#9670;&nbsp;</a></span>dict_table_prevent_eviction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_prevent_eviction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent table eviction by moving a table to the non-LRU list from the LRU list if it is not already there. </p>
<p>in: table to prevent eviction </p>

</div>
</div>
<a id="a7b85c4c87665434f757416b0e6be12c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b85c4c87665434f757416b0e6be12c7">&#9670;&nbsp;</a></span>dict_table_read_dynamic_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_read_dynamic_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPersistentTableMetadata.html">PersistentTableMetadata</a> *&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read persistent dynamic metadata stored in a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>buffer to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of data in buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata</td><td>where we store the metadata from buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee058e08dcafa661c882f9b6b7fbe00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee058e08dcafa661c882f9b6b7fbe00b">&#9670;&nbsp;</a></span>dict_table_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a table object from the dictionary cache. </p>
<p>in, own: table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in, own: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90f84bd0906f8e993d2d0c74c1dbc055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f84bd0906f8e993d2d0c74c1dbc055">&#9670;&nbsp;</a></span>dict_table_remove_from_cache_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_remove_from_cache_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>lru_evict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a table object from the dictionary cache, for debug purpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lru_evict</td><td>true if table being evicted to make room in the table LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab103b93381b8141ce2e96786165af0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab103b93381b8141ce2e96786165af0a8">&#9670;&nbsp;</a></span>dict_table_rename_in_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_table_rename_in_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>rename_also_foreigns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames a table object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">new_name</td><td>in: new name </td></tr>
    <tr><td class="paramname">rename_also_foreigns</td><td>in: in ALTER TABLE we want to preserve the original table name in constraints which reference it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf5d60969e4ea074a2acc49d71c1895f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5d60969e4ea074a2acc49d71c1895f">&#9670;&nbsp;</a></span>dict_table_set_big_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_set_big_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark if table has big rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fea7e3f600763f1ec8ada4c88f7a806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fea7e3f600763f1ec8ada4c88f7a806">&#9670;&nbsp;</a></span>dict_table_stats_latch_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_stats_latch_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dict_table_t's stats latch or delay for lazy creation. </p>
<p>This function is only called from either single threaded environment or from a thread that has not shared the table object with other threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table whose stats latch to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>if false then the latch is disabled and dict_table_stats_lock()/unlock() become noop on this table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a428c4723fd38a1e83223604d42b7b8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c4723fd38a1e83223604d42b7b8ab">&#9670;&nbsp;</a></span>dict_table_stats_latch_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_stats_latch_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a dict_table_t's stats latch. </p>
<p>This function is only called from either single threaded environment or from a thread that has not shared the table object with other threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table whose stats latch to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a938a0f110db72710173e9c7d05f7b3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938a0f110db72710173e9c7d05f7b3e6">&#9670;&nbsp;</a></span>dict_table_stats_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_stats_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the appropriate latch to protect a given table's statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table whose stats to lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">latch_mode</td><td>RW_S_LATCH or RW_X_LATCH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89442a48c8aa6af63265a00fb9f0d708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89442a48c8aa6af63265a00fb9f0d708">&#9670;&nbsp;</a></span>dict_table_stats_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_stats_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the latch that has been locked by dict_table_stats_lock(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table whose stats to unlock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">latch_mode</td><td>RW_S_LATCH or RW_X_LATCH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae44b48b7ad1ec5524521777dab831525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44b48b7ad1ec5524521777dab831525">&#9670;&nbsp;</a></span>dict_table_wait_for_bg_threads_to_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_wait_for_bg_threads_to_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">delay</td><td>in: time in microseconds to wait between checks of bg_threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02a14af44950ae0a52cb6fbb0b96fe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a14af44950ae0a52cb6fbb0b96fe72">&#9670;&nbsp;</a></span>dict_table_x_lock_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_x_lock_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain exclusive locks on all index trees of the table. </p>
<p>This is to prevent accessing index trees while InnoDB is updating internal metadata for operations such as FLUSH TABLES. in: table </p>

</div>
</div>
<a id="a6cd362138ce7c587e00dab59ea943d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd362138ce7c587e00dab59ea943d63">&#9670;&nbsp;</a></span>dict_table_x_unlock_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_table_x_unlock_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the exclusive locks on all index tree. </p>
<p>in: table </p>

</div>
</div>
<a id="a470227bec9c1779310c07a084f96df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470227bec9c1779310c07a084f96df26">&#9670;&nbsp;</a></span>dict_tables_have_same_db()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool dict_tables_have_same_db </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the database name in two table names is the same. </p>
<dl class="section return"><dt>Returns</dt><dd>true if same db name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name1</td><td>in: table name in the form dbname '/' tablename </td></tr>
    <tr><td class="paramname">name2</td><td>in: table name in the form dbname '/' tablename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2768e24cb2b67587725e956e720e58cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2768e24cb2b67587725e956e720e58cc">&#9670;&nbsp;</a></span>dict_tf2_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_tf2_is_valid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate both table flags and table flags2 and make sure they are compatible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Table flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags2</td><td>Table flags2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="aae48995f6252b6137db697fccab0bd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae48995f6252b6137db697fccab0bd79">&#9670;&nbsp;</a></span>dict_tf_get_page_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="classpage__size__t.html">page_size_t</a> dict_tf_get_page_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the page size info from table flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure containing the compressed and uncompressed page sizes and a boolean indicating if the page is compressed. </dd></dl>

</div>
</div>
<a id="a96efe7a27819dee0949d5af50b2ea06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96efe7a27819dee0949d5af50b2ea06a">&#9670;&nbsp;</a></span>dict_tf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE uint32_t dict_tf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>atomic_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>data_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>shared_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a dict_table_t::flags pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compact</td><td>Table uses Compact or greater </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zip_ssize</td><td>Zip Shift Size (log 2 minus 9) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atomic_blobs</td><td>Table uses Compressed or Dynamic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_dir</td><td>Table uses DATA DIRECTORY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shared_space</td><td>Table uses a General Shared Tablespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae58cc13b5a9233c46526c2ba2b8be0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58cc13b5a9233c46526c2ba2b8be0ea">&#9670;&nbsp;</a></span>dict_tf_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_tf_is_valid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the table flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Table flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

</div>
</div>
<a id="ad8497bac4fc023f3182725cd696de130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8497bac4fc023f3182725cd696de130">&#9670;&nbsp;</a></span>dict_tf_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dict_tf_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a9b18c9be596083dfcd337b11972f1c1e">rec_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>zip_ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_data_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>shared_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the various values in a dict_table_t::flags pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">flags</td><td>Pointer to a 4 byte Table Flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>File Format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zip_ssize</td><td>Zip Shift Size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_data_dir</td><td>Table uses DATA DIRECTORY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shared_space</td><td>Table uses a General Shared Tablespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ff395441ca0c0c0a38890b6279b6ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff395441ca0c0c0a38890b6279b6ce4">&#9670;&nbsp;</a></span>dict_tf_to_fsp_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dict_tf_to_fsp_flags </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a 32 bit integer table flags to the 32 bit FSP Flags. </p>
<p>Fsp Flags are written into the tablespace header at the offset FSP_SPACE_FLAGS and are also stored in the fil_space_t::flags field. The following chart shows the translation of the low order bit. Other bits are the same. ========================= Low order bit ========================== | REDUNDANT | COMPACT | COMPRESSED | DYNAMIC dict_table_t::flags | 0 | 1 | 1 | 1 </p><h1>fil_space_t::flags | 0 | 0 | 1 | 1 </h1>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table_flags</td><td>dict_table_t::flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tablespace flags (fil_space_t::flags) </dd></dl>

</div>
</div>
<a id="a0039ab13ce5eae4eb1f44585f93852b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0039ab13ce5eae4eb1f44585f93852b1">&#9670;&nbsp;</a></span>dict_tf_to_row_format_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_tf_to_row_format_string </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert table flag to row format string. </p>
<dl class="section return"><dt>Returns</dt><dd>row format name in: row format setting</dd>
<dd>
row format name. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_flag</td><td>in: row format setting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f37e12ac5d68ceaa751f248f3c593c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f37e12ac5d68ceaa751f248f3c593c1">&#9670;&nbsp;</a></span>dict_upgrade_evict_tables_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_upgrade_evict_tables_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evict all tables that are loaded for applying purge. </p>
<p>Since we move the offset of all table ids during upgrade, these tables cannot exist in cache. Also change table_ids of SYS_* tables if they are upgraded from earlier versions </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6ec24ab0a32d423b164b07c9b75efaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec24ab0a32d423b164b07c9b75efaab">&#9670;&nbsp;</a></span>dict_foreign_err_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* dict_foreign_err_file</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46914897b15bb9b3b8b967b2a2602e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46914897b15bb9b3b8b967b2a2602e5a">&#9670;&nbsp;</a></span>dict_foreign_err_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t dict_foreign_err_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89825a6bd9d1aa7ab16bc6418745478e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89825a6bd9d1aa7ab16bc6418745478e">&#9670;&nbsp;</a></span>dict_ind_redundant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_ind_redundant</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dummy index for ROW_FORMAT=REDUNDANT supremum and infimum records </p>

</div>
</div>
<a id="a3d0d20c61722131666bc819ac4072cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0d20c61722131666bc819ac4072cff">&#9670;&nbsp;</a></span>dict_operation_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>* dict_operation_lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the data dictionary rw-latch protecting dict_sys </p>
<p>table create, drop, etc. reserve this in X-mode; implicit or backround operations purge, rollback, foreign key checks reserve this in S-mode; we cannot trust that MySQL protects implicit or background operations a table drop since MySQL does not know of them; therefore we need this; NOTE: a transaction which reserves this must keep book on the mode in trx_t::dict_operation_lock_mode </p>

</div>
</div>
<a id="a4485b103be6b18c0bf9a08df4fc5f3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4485b103be6b18c0bf9a08df4fc5f3c0">&#9670;&nbsp;</a></span>dict_persist</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__persist__t.html">dict_persist_t</a>* dict_persist</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the dictionary persisting structure </p>

</div>
</div>
<a id="af9def99724e81248120f5c58eaa14dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9def99724e81248120f5c58eaa14dc2">&#9670;&nbsp;</a></span>dict_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__sys__t.html">dict_sys_t</a>* dict_sys</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the dictionary system </p>

</div>
</div>
<a id="a60b90ad886cc69ff15315694fbd1eaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b90ad886cc69ff15315694fbd1eaee">&#9670;&nbsp;</a></span>SDI_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t SDI_VERSION = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDI version. </p>
<p>Written on Page 1 &amp; 2 at FIL_PAGE_FILE_FLUSH_LSN offset. </p>

</div>
</div>
<a id="a96f11204c7263dead39ca57c419de657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f11204c7263dead39ca57c419de657">&#9670;&nbsp;</a></span>SYSTEM_TABLE_SPACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> SYSTEM_TABLE_SPACE = <a class="el" href="trx0types_8h.html#ad30d6802ba5017c3db592827e1c90b03">TRX_SYS_SPACE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Space id of system tablespace. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="dict0dict_8h.html">dict0dict.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
