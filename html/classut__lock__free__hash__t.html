<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: ut_lock_free_hash_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classut__lock__free__hash__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classut__lock__free__hash__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ut_lock_free_hash_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock free hash table.  
 <a href="classut__lock__free__hash__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ut0lock__free__hash_8h_source.html">ut0lock_free_hash.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ut_lock_free_hash_t:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classut__lock__free__hash__t.png" usemap="#ut_5Flock_5Ffree_5Fhash_5Ft_map" alt=""/>
  <map id="ut_5Flock_5Ffree_5Fhash_5Ft_map" name="ut_5Flock_5Ffree_5Fhash_5Ft_map">
<area href="classut__hash__interface__t.html" title="An interface class to a basic hash table, that ut_lock_free_hash_t is. " alt="ut_hash_interface_t" shape="rect" coords="0,0,126,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(key, val) tuple type.  <a href="structut__lock__free__hash__t_1_1key__val__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade316ea416a1c597092c63ffcb202e93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#ade316ea416a1c597092c63ffcb202e93">ut_lock_free_hash_t</a> (size_t initial_size, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> del_when_zero)</td></tr>
<tr class="memdesc:ade316ea416a1c597092c63ffcb202e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ade316ea416a1c597092c63ffcb202e93">More...</a><br /></td></tr>
<tr class="separator:ade316ea416a1c597092c63ffcb202e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af343ff96e2735c79843b64887b6501f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#af343ff96e2735c79843b64887b6501f6">~ut_lock_free_hash_t</a> () override</td></tr>
<tr class="memdesc:af343ff96e2735c79843b64887b6501f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af343ff96e2735c79843b64887b6501f6">More...</a><br /></td></tr>
<tr class="separator:af343ff96e2735c79843b64887b6501f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0c780e260db0d13c53d7625de5fffd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#abf0c780e260db0d13c53d7625de5fffd">get</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>) const override</td></tr>
<tr class="memdesc:abf0c780e260db0d13c53d7625de5fffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value mapped to a given key.  <a href="#abf0c780e260db0d13c53d7625de5fffd">More...</a><br /></td></tr>
<tr class="separator:abf0c780e260db0d13c53d7625de5fffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004914aedc5659f48a81a4f27a1311d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a004914aedc5659f48a81a4f27a1311d6">set</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, int64_t val) override</td></tr>
<tr class="memdesc:a004914aedc5659f48a81a4f27a1311d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value for a given key, either inserting a new (key, val) tuple or overwriting an existent value.  <a href="#a004914aedc5659f48a81a4f27a1311d6">More...</a><br /></td></tr>
<tr class="separator:a004914aedc5659f48a81a4f27a1311d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2565b91959ab49b57f4c521ea92ed93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#ab2565b91959ab49b57f4c521ea92ed93">del</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>) override</td></tr>
<tr class="memdesc:ab2565b91959ab49b57f4c521ea92ed93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a (key, val) pair from the hash.  <a href="#ab2565b91959ab49b57f4c521ea92ed93">More...</a><br /></td></tr>
<tr class="separator:ab2565b91959ab49b57f4c521ea92ed93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd3c3af5786db720b40aa346cb3a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a25dd3c3af5786db720b40aa346cb3a90">inc</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>) override</td></tr>
<tr class="memdesc:a25dd3c3af5786db720b40aa346cb3a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the value for a given key with 1 or insert a new tuple (key, 1).  <a href="#a25dd3c3af5786db720b40aa346cb3a90">More...</a><br /></td></tr>
<tr class="separator:a25dd3c3af5786db720b40aa346cb3a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833265d7bbb931c2fccc06614bbdac03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a833265d7bbb931c2fccc06614bbdac03">dec</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>) override</td></tr>
<tr class="memdesc:a833265d7bbb931c2fccc06614bbdac03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the value of a given key with 1 or insert a new tuple (key, -1).  <a href="#a833265d7bbb931c2fccc06614bbdac03">More...</a><br /></td></tr>
<tr class="separator:a833265d7bbb931c2fccc06614bbdac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classut__hash__interface__t"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classut__hash__interface__t')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classut__hash__interface__t.html">ut_hash_interface_t</a></td></tr>
<tr class="memitem:a50fda05fe155cf6c423174ebaca60886 inherit pub_methods_classut__hash__interface__t"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__hash__interface__t.html#a50fda05fe155cf6c423174ebaca60886">~ut_hash_interface_t</a> ()</td></tr>
<tr class="memdesc:a50fda05fe155cf6c423174ebaca60886 inherit pub_methods_classut__hash__interface__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classut__hash__interface__t.html#a50fda05fe155cf6c423174ebaca60886">More...</a><br /></td></tr>
<tr class="separator:a50fda05fe155cf6c423174ebaca60886 inherit pub_methods_classut__hash__interface__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a7489bcc596b9218d7b976d2d0e270e1c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classut__lock__free__list__node__t.html">ut_lock_free_list_node_t</a>&lt; <a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a></td></tr>
<tr class="memdesc:a7489bcc596b9218d7b976d2d0e270e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array node in the hash.  <a href="#a7489bcc596b9218d7b976d2d0e270e1c">More...</a><br /></td></tr>
<tr class="separator:a7489bcc596b9218d7b976d2d0e270e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9321d22421f8eae25a9213ecf5e7e0f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#aa9321d22421f8eae25a9213ecf5e7e0f">hollow_alloc_t</a></td></tr>
<tr class="separator:aa9321d22421f8eae25a9213ecf5e7e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca1990347d973270f38d9a05233cef7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt; <a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *, <a class="el" href="classut__lock__free__hash__t.html#aa9321d22421f8eae25a9213ecf5e7e0f">hollow_alloc_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#aaca1990347d973270f38d9a05233cef7">hollow_t</a></td></tr>
<tr class="separator:aaca1990347d973270f38d9a05233cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a691947c10f6e6b5f65122939dcd51a55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a691947c10f6e6b5f65122939dcd51a55">guess_position</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, size_t arr_size) const</td></tr>
<tr class="memdesc:a691947c10f6e6b5f65122939dcd51a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash function used to map a key to its suggested position in the array.  <a href="#a691947c10f6e6b5f65122939dcd51a55">More...</a><br /></td></tr>
<tr class="separator:a691947c10f6e6b5f65122939dcd51a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f90a6dcbc565822fc3dc1c1100cdecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a8f90a6dcbc565822fc3dc1c1100cdecf">get_tuple_from_array</a> (<a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *arr, size_t arr_size, uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>) const</td></tr>
<tr class="memdesc:a8f90a6dcbc565822fc3dc1c1100cdecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the array cell of a key from a given array.  <a href="#a8f90a6dcbc565822fc3dc1c1100cdecf">More...</a><br /></td></tr>
<tr class="separator:a8f90a6dcbc565822fc3dc1c1100cdecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9742331407c3bd1560622cf21d3b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a8d9742331407c3bd1560622cf21d3b2f">get_tuple</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> **arr) const</td></tr>
<tr class="memdesc:a8d9742331407c3bd1560622cf21d3b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the array cell of a key.  <a href="#a8d9742331407c3bd1560622cf21d3b2f">More...</a><br /></td></tr>
<tr class="separator:a8d9742331407c3bd1560622cf21d3b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6c99368da30aa3ddf780088a3d1d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a12e6c99368da30aa3ddf780088a3d1d1">insert_or_get_position_in_array</a> (<a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *arr, size_t arr_size, uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:a12e6c99368da30aa3ddf780088a3d1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given key into a given array or return its cell if already present.  <a href="#a12e6c99368da30aa3ddf780088a3d1d1">More...</a><br /></td></tr>
<tr class="separator:a12e6c99368da30aa3ddf780088a3d1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec735b42dede9ae50acc86627b45cc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#acec735b42dede9ae50acc86627b45cc2">copy_to_another_array</a> (<a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *src_arr, <a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *dst_arr)</td></tr>
<tr class="memdesc:acec735b42dede9ae50acc86627b45cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all used elements from one array to another.  <a href="#acec735b42dede9ae50acc86627b45cc2">More...</a><br /></td></tr>
<tr class="separator:acec735b42dede9ae50acc86627b45cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2807e3b8c70d676be32ce97f1673b10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a2807e3b8c70d676be32ce97f1673b10a">update_tuple</a> (<a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *t, int64_t val_to_set, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_delta)</td></tr>
<tr class="memdesc:a2807e3b8c70d676be32ce97f1673b10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a given tuple.  <a href="#a2807e3b8c70d676be32ce97f1673b10a">More...</a><br /></td></tr>
<tr class="separator:a2807e3b8c70d676be32ce97f1673b10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755f0d126db7b1b45bb6aacab1205b76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a755f0d126db7b1b45bb6aacab1205b76">optimize</a> ()</td></tr>
<tr class="memdesc:a755f0d126db7b1b45bb6aacab1205b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the hash table.  <a href="#a755f0d126db7b1b45bb6aacab1205b76">More...</a><br /></td></tr>
<tr class="separator:a755f0d126db7b1b45bb6aacab1205b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75899b957eda40fca6ad8c471242e758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a75899b957eda40fca6ad8c471242e758">insert_or_update</a> (uint64_t <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, int64_t val, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_delta, <a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *arr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> optimize_allowed=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:a75899b957eda40fca6ad8c471242e758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new tuple or update an existent one.  <a href="#a75899b957eda40fca6ad8c471242e758">More...</a><br /></td></tr>
<tr class="separator:a75899b957eda40fca6ad8c471242e758"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af82cca35d060585fe1bc4c3ebefc752c"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#af82cca35d060585fe1bc4c3ebefc752c">m_data</a></td></tr>
<tr class="memdesc:af82cca35d060585fe1bc4c3ebefc752c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the (key, val) tuples.  <a href="#af82cca35d060585fe1bc4c3ebefc752c">More...</a><br /></td></tr>
<tr class="separator:af82cca35d060585fe1bc4c3ebefc752c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc8c4ebea0f7c3419dd70d8e4996f1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__lock__free__hash__t.html#aaca1990347d973270f38d9a05233cef7">hollow_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#acdc8c4ebea0f7c3419dd70d8e4996f1d">m_hollow_objects</a></td></tr>
<tr class="memdesc:acdc8c4ebea0f7c3419dd70d8e4996f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for hollow (semi-destroyed) objects that have been removed from the list that starts at m_data.  <a href="#acdc8c4ebea0f7c3419dd70d8e4996f1d">More...</a><br /></td></tr>
<tr class="separator:acdc8c4ebea0f7c3419dd70d8e4996f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f08d1093327ed7202641f2bba231d94"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a7f08d1093327ed7202641f2bba231d94">m_optimize_latch</a></td></tr>
<tr class="memdesc:a7f08d1093327ed7202641f2bba231d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent copy-all-elements-to-the-next-array, removal of the head of the list and freeing of its m_base member are serialized with this latch.  <a href="#a7f08d1093327ed7202641f2bba231d94">More...</a><br /></td></tr>
<tr class="separator:a7f08d1093327ed7202641f2bba231d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a25c24887b1b32bf1914d8e5952d9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a4a25c24887b1b32bf1914d8e5952d9d6">m_del_when_zero</a></td></tr>
<tr class="memdesc:a4a25c24887b1b32bf1914d8e5952d9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if a tuple should be automatically deleted from the hash if its value becomes 0 after an increment or decrement.  <a href="#a4a25c24887b1b32bf1914d8e5952d9d6">More...</a><br /></td></tr>
<tr class="separator:a4a25c24887b1b32bf1914d8e5952d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a5a84cb843aa2e14a84dcfa7c032ce650"><td class="memItemLeft" align="right" valign="top">static const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a5a84cb843aa2e14a84dcfa7c032ce650">UNUSED</a> = UINT64_MAX</td></tr>
<tr class="memdesc:a5a84cb843aa2e14a84dcfa7c032ce650"><td class="mdescLeft">&#160;</td><td class="mdescRight">A key == UNUSED designates that this cell in the array is empty.  <a href="#a5a84cb843aa2e14a84dcfa7c032ce650">More...</a><br /></td></tr>
<tr class="separator:a5a84cb843aa2e14a84dcfa7c032ce650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b403d11365f4174086a3ff4a74a825"><td class="memItemLeft" align="right" valign="top">static const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#aa1b403d11365f4174086a3ff4a74a825">AVOID</a> = <a class="el" href="classut__lock__free__hash__t.html#a5a84cb843aa2e14a84dcfa7c032ce650">UNUSED</a> - 1</td></tr>
<tr class="memdesc:aa1b403d11365f4174086a3ff4a74a825"><td class="mdescLeft">&#160;</td><td class="mdescRight">A key == AVOID designates an unusable cell.  <a href="#aa1b403d11365f4174086a3ff4a74a825">More...</a><br /></td></tr>
<tr class="separator:aa1b403d11365f4174086a3ff4a74a825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2d44104d9c1305ee39fc83d208462b"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#a0c2d44104d9c1305ee39fc83d208462b">DELETED</a> = <a class="el" href="classut__hash__interface__t.html#a0db53144f1f1ceecd47927c21f69070e">NOT_FOUND</a> - 1</td></tr>
<tr class="memdesc:a0c2d44104d9c1305ee39fc83d208462b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A val == DELETED designates that this cell in the array has been used in the past, but it was deleted later.  <a href="#a0c2d44104d9c1305ee39fc83d208462b">More...</a><br /></td></tr>
<tr class="separator:a0c2d44104d9c1305ee39fc83d208462b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf930e7226ec36c0447bbea348532f89"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__lock__free__hash__t.html#adf930e7226ec36c0447bbea348532f89">GOTO_NEXT_ARRAY</a> = <a class="el" href="classut__lock__free__hash__t.html#a0c2d44104d9c1305ee39fc83d208462b">DELETED</a> - 1</td></tr>
<tr class="memdesc:adf930e7226ec36c0447bbea348532f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">A val == GOTO_NEXT_ARRAY designates that this tuple (key, whatever) has been moved to the next array.  <a href="#adf930e7226ec36c0447bbea348532f89">More...</a><br /></td></tr>
<tr class="separator:adf930e7226ec36c0447bbea348532f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classut__hash__interface__t"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classut__hash__interface__t')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classut__hash__interface__t.html">ut_hash_interface_t</a></td></tr>
<tr class="memitem:a0db53144f1f1ceecd47927c21f69070e inherit pub_static_attribs_classut__hash__interface__t"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classut__hash__interface__t.html#a0db53144f1f1ceecd47927c21f69070e">NOT_FOUND</a> = INT64_MAX</td></tr>
<tr class="memdesc:a0db53144f1f1ceecd47927c21f69070e inherit pub_static_attribs_classut__hash__interface__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value that is returned when the searched for key is not found.  <a href="classut__hash__interface__t.html#a0db53144f1f1ceecd47927c21f69070e">More...</a><br /></td></tr>
<tr class="separator:a0db53144f1f1ceecd47927c21f69070e inherit pub_static_attribs_classut__hash__interface__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lock free hash table. </p>
<p>It stores (key, value) pairs where both the key and the value are of integer type. The possible keys are: UNUSED: a (key = UNUSED, val) tuple means that it is empty/unused. This is the initial state of all keys. AVOID: a (key = AVOID, val = any) tuple means that this tuple is disabled, does not contain a real data and should be avoided by searches and inserts. This is used when migrating all elements of an array to the next array. real key: anything other than the above means this is a real key, specified by the user.</p>
<p>The possible values are: NOT_FOUND: a (key, val = NOT_FOUND) tuple means that it is just being inserted and returning "not found" is ok. This is the initial state of all values. DELETED: a (key, val = DELETED) tuple means that a tuple with this key existed before but was deleted at some point. Searches for this key return "not found" and inserts reuse the tuple, replacing the DELETED value with something else. GOTO_NEXT_ARRAY: a (key, val = GOTO_NEXT_ARRAY) tuple means that the searches for this tuple (get and insert) should go to the next array and repeat the search there. Used when migrating all tuples from one array to the next. real value: anything other than the above means this is a real value, specified by the user.</p>
<p>Transitions for keys (a real key is anything other than UNUSED and AVOID): UNUSED -&gt; real key &ndash; allowed UNUSED -&gt; AVOID &ndash; allowed anything else is not allowed: real key -&gt; UNUSED &ndash; not allowed real key -&gt; AVOID &ndash; not allowed real key -&gt; another real key &ndash; not allowed AVOID -&gt; UNUSED &ndash; not allowed AVOID -&gt; real key &ndash; not allowed</p>
<p>Transitions for values (a real value is anything other than NOT_FOUND, DELETED and GOTO_NEXT_ARRAY): NOT_FOUND -&gt; real value &ndash; allowed NOT_FOUND -&gt; DELETED &ndash; allowed real value -&gt; another real value &ndash; allowed real value -&gt; DELETED &ndash; allowed real value -&gt; GOTO_NEXT_ARRAY &ndash; allowed DELETED -&gt; real value &ndash; allowed DELETED -&gt; GOTO_NEXT_ARRAY &ndash; allowed anything else is not allowed: NOT_FOUND -&gt; GOTO_NEXT_ARRAY &ndash; not allowed real value -&gt; NOT_FOUND &ndash; not allowed DELETED -&gt; NOT_FOUND &ndash; not allowed GOTO_NEXT_ARRAY -&gt; real value &ndash; not allowed GOTO_NEXT_ARRAY -&gt; NOT_FOUND &ndash; not allowed GOTO_NEXT_ARRAY -&gt; DELETED &ndash; not allowed </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7489bcc596b9218d7b976d2d0e270e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7489bcc596b9218d7b976d2d0e270e1c">&#9670;&nbsp;</a></span>arr_node_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classut__lock__free__list__node__t.html">ut_lock_free_list_node_t</a>&lt;<a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a>&gt; <a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">ut_lock_free_hash_t::arr_node_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An array node in the hash. </p>
<p>The hash table consists of a linked list of such nodes. </p>

</div>
</div>
<a id="aa9321d22421f8eae25a9213ecf5e7e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9321d22421f8eae25a9213ecf5e7e0f">&#9670;&nbsp;</a></span>hollow_alloc_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classut__allocator.html">ut_allocator</a>&lt;<a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *&gt; <a class="el" href="classut__lock__free__hash__t.html#aa9321d22421f8eae25a9213ecf5e7e0f">ut_lock_free_hash_t::hollow_alloc_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaca1990347d973270f38d9a05233cef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca1990347d973270f38d9a05233cef7">&#9670;&nbsp;</a></span>hollow_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt;<a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *, <a class="el" href="classut__lock__free__hash__t.html#aa9321d22421f8eae25a9213ecf5e7e0f">hollow_alloc_t</a>&gt; <a class="el" href="classut__lock__free__hash__t.html#aaca1990347d973270f38d9a05233cef7">ut_lock_free_hash_t::hollow_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade316ea416a1c597092c63ffcb202e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade316ea416a1c597092c63ffcb202e93">&#9670;&nbsp;</a></span>ut_lock_free_hash_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ut_lock_free_hash_t::ut_lock_free_hash_t </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>del_when_zero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Not thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_size</td><td>number of elements to allocate initially. Must be a power of 2, greater than 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del_when_zero</td><td>if true then automatically delete a tuple from the hash if due to increment or decrement its value becomes zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af343ff96e2735c79843b64887b6501f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af343ff96e2735c79843b64887b6501f6">&#9670;&nbsp;</a></span>~ut_lock_free_hash_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ut_lock_free_hash_t::~ut_lock_free_hash_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Not thread safe. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acec735b42dede9ae50acc86627b45cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec735b42dede9ae50acc86627b45cc2">&#9670;&nbsp;</a></span>copy_to_another_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_lock_free_hash_t::copy_to_another_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *&#160;</td>
          <td class="paramname"><em>src_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *&#160;</td>
          <td class="paramname"><em>dst_arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all used elements from one array to another. </p>
<p>Flag the ones in the old array as 'go to the next array'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">src_arr</td><td>array to copy from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst_arr</td><td>array to copy to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a833265d7bbb931c2fccc06614bbdac03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833265d7bbb931c2fccc06614bbdac03">&#9670;&nbsp;</a></span>dec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_lock_free_hash_t::dec </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the value of a given key with 1 or insert a new tuple (key, -1). </p>
<p>With respect to calling this together with set(), inc() or dec() the same applies as with inc(), see its comment. The only guarantee is that the calls will execute in isolation, but the order in which they will execute is undeterministic. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key whose value to decrement </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classut__hash__interface__t.html#a7b494c02cc82d40d714719ca22fe45c4">ut_hash_interface_t</a>.</p>

</div>
</div>
<a id="ab2565b91959ab49b57f4c521ea92ed93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2565b91959ab49b57f4c521ea92ed93">&#9670;&nbsp;</a></span>del()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_lock_free_hash_t::del </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a (key, val) pair from the hash. </p>
<p>If this gets called concurrently with get(), inc(), dec() or set(), then to the caller it will look like the calls executed in isolation, the hash structure itself will not be damaged, but it is undefined in what order the calls will be executed. For example: Let this tuple exist in the hash: (key == 5, val == 10) Thread 1: inc(key == 5) Thread 2: del(key == 5) [1] If inc() executes first then the tuple will become (key == 5, val == 11) and then del() will make it (key == 5, val == DELETED), which get()s for key == 5 will return as NOT_FOUND. [2] If del() executes first then the tuple will become (key == 5, val == DELETED) and then inc() will change it to (key == 5, value == 1). It is undefined which one of [1] or [2] will happen. It is up to the caller to accept this behavior or prevent it at a higher level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key whose pair to delete </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classut__hash__interface__t.html#a2e6c12e510d0fa1d563700436fc1c302">ut_hash_interface_t</a>.</p>

</div>
</div>
<a id="abf0c780e260db0d13c53d7625de5fffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0c780e260db0d13c53d7625de5fffd">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ut_lock_free_hash_t::get </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value mapped to a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value that corresponds to key or NOT_FOUND. </dd></dl>

<p>Implements <a class="el" href="classut__hash__interface__t.html#a60c0f9bcb2e0054cacc10595fafcc16b">ut_hash_interface_t</a>.</p>

</div>
</div>
<a id="a8d9742331407c3bd1560622cf21d3b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9742331407c3bd1560622cf21d3b2f">&#9670;&nbsp;</a></span>get_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a>* ut_lock_free_hash_t::get_tuple </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> **&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the array cell of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key to search for </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arr</td><td>start the search from this array; when this method ends, *arr will point to the array in which the search ended (in which the returned key_val resides) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the array cell or NULL if not found </dd></dl>

</div>
</div>
<a id="a8f90a6dcbc565822fc3dc1c1100cdecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f90a6dcbc565822fc3dc1c1100cdecf">&#9670;&nbsp;</a></span>get_tuple_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a>* ut_lock_free_hash_t::get_tuple_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arr_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the array cell of a key from a given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>array to search into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr_size</td><td>number of elements in the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>search for a tuple with this key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the array cell or NULL if not found </dd></dl>

</div>
</div>
<a id="a691947c10f6e6b5f65122939dcd51a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691947c10f6e6b5f65122939dcd51a55">&#9670;&nbsp;</a></span>guess_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ut_lock_free_hash_t::guess_position </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A hash function used to map a key to its suggested position in the array. </p>
<p>A linear search to the right is done after this position to find the tuple with the given key or find a tuple with key == UNUSED or AVOID which means that the key is not present in the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key to map into a position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr_size</td><td>number of elements in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a position (index) in the array where the tuple is guessed to be </dd></dl>

</div>
</div>
<a id="a25dd3c3af5786db720b40aa346cb3a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dd3c3af5786db720b40aa346cb3a90">&#9670;&nbsp;</a></span>inc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_lock_free_hash_t::inc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the value for a given key with 1 or insert a new tuple (key, 1). </p>
<p>If two threads call this method at the same time with the same key, then it is guaranteed that when both calls have finished, the value will be incremented with 2. If two threads call this method and set() at the same time with the same key it is undeterministic whether the value will be what was given to set() or what was given to set() + 1. E.g. Thread 1: set(key, val) Thread 2: inc(key) or Thread 1: inc(key) Thread 2: set(key, val) when both have finished the value will be either val or val + 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key whose value to increment or insert as 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classut__hash__interface__t.html#a97df1a796e0869780e6a0f8831298053">ut_hash_interface_t</a>.</p>

</div>
</div>
<a id="a12e6c99368da30aa3ddf780088a3d1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e6c99368da30aa3ddf780088a3d1d1">&#9670;&nbsp;</a></span>insert_or_get_position_in_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a>* ut_lock_free_hash_t::insert_or_get_position_in_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arr_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given key into a given array or return its cell if already present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>array into which to search and insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr_size</td><td>number of elements in the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key to insert or whose cell to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the inserted or previously existent tuple or NULL if a tuple with this key is not present in the array and the array is full, without any unused cells and thus insertion cannot be done into it. </dd></dl>

</div>
</div>
<a id="a75899b957eda40fca6ad8c471242e758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75899b957eda40fca6ad8c471242e758">&#9670;&nbsp;</a></span>insert_or_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_lock_free_hash_t::insert_or_update </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>optimize_allowed</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new tuple or update an existent one. </p>
<p>If a tuple with this key does not exist then a new one is inserted (key, val) and is_delta is ignored. If a tuple with this key exists and is_delta is true, then the current value is changed to be current value + val, otherwise it is overwritten to be val. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key to insert or whose value to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to set; if the tuple does not exist or if is_delta is false, then the new value is set to val, otherwise it is set to old + val </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_delta</td><td>if true then set the new value to old + val, otherwise just set to val. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>array to start the search from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optimize_allowed</td><td>if true then call optimize() after an eventual grow(), if false, then never call optimize(). Used to prevent recursive optimize() call by insert_or_update() -&gt; optimize() -&gt; copy_to_another_array() -&gt; insert_or_update() -&gt; optimize(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a755f0d126db7b1b45bb6aacab1205b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755f0d126db7b1b45bb6aacab1205b76">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_lock_free_hash_t::optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimize the hash table. </p>
<p>Called after a new array is appended to the list of arrays (grow). Having more than one array in the list of arrays works, but is suboptimal because searches (for get/insert/update) have to search in more than one array. This method starts from the head of the list and migrates all tuples from this array to the next arrays. Then it removes the array from the head of the list, waits for readers to go away and frees it's m_base member. </p>

</div>
</div>
<a id="a004914aedc5659f48a81a4f27a1311d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004914aedc5659f48a81a4f27a1311d6">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ut_lock_free_hash_t::set </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value for a given key, either inserting a new (key, val) tuple or overwriting an existent value. </p>
<p>If two threads call this method at the same time with the key, but different val, then when both methods have finished executing the value will be one of the two ones, but undeterministic which one. E.g. Thread 1: set(key, val_a) Thread 2: set(key, val_b) when both have finished, then a tuple with the given key will be present with value either val_a or val_b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>key whose value to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to be set </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classut__hash__interface__t.html#abb4a2be45fe0697746d44aae39af0079">ut_hash_interface_t</a>.</p>

</div>
</div>
<a id="a2807e3b8c70d676be32ce97f1673b10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2807e3b8c70d676be32ce97f1673b10a">&#9670;&nbsp;</a></span>update_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ut_lock_free_hash_t::update_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structut__lock__free__hash__t_1_1key__val__t.html">key_val_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val_to_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">t</td><td>tuple whose value to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val_to_set</td><td>value to set or delta to apply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_delta</td><td>if true then set the new value to old + val, otherwise just set to val </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>update succeeded </td></tr>
    <tr><td class="paramname">false</td><td>update failed due to GOTO_NEXT_ARRAY </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the update succeeded or not </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa1b403d11365f4174086a3ff4a74a825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b403d11365f4174086a3ff4a74a825">&#9670;&nbsp;</a></span>AVOID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t ut_lock_free_hash_t::AVOID = <a class="el" href="classut__lock__free__hash__t.html#a5a84cb843aa2e14a84dcfa7c032ce650">UNUSED</a> - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A key == AVOID designates an unusable cell. </p>
<p>This cell of the array has been empty (key == UNUSED), but was then marked as AVOID in order to prevent new inserts into it. Searches should treat this like UNUSED (ie if they encounter it before the key they are searching for then stop the search and declare 'not found'). </p>

</div>
</div>
<a id="a0c2d44104d9c1305ee39fc83d208462b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2d44104d9c1305ee39fc83d208462b">&#9670;&nbsp;</a></span>DELETED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t ut_lock_free_hash_t::DELETED = <a class="el" href="classut__hash__interface__t.html#a0db53144f1f1ceecd47927c21f69070e">NOT_FOUND</a> - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A val == DELETED designates that this cell in the array has been used in the past, but it was deleted later. </p>
<p>Searches should return NOT_FOUND when they encounter it. </p>

</div>
</div>
<a id="adf930e7226ec36c0447bbea348532f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf930e7226ec36c0447bbea348532f89">&#9670;&nbsp;</a></span>GOTO_NEXT_ARRAY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t ut_lock_free_hash_t::GOTO_NEXT_ARRAY = <a class="el" href="classut__lock__free__hash__t.html#a0c2d44104d9c1305ee39fc83d208462b">DELETED</a> - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A val == GOTO_NEXT_ARRAY designates that this tuple (key, whatever) has been moved to the next array. </p>
<p>The search for it should continue there. </p>

</div>
</div>
<a id="af82cca35d060585fe1bc4c3ebefc752c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82cca35d060585fe1bc4c3ebefc752c">&#9670;&nbsp;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="classut__lock__free__hash__t.html#a7489bcc596b9218d7b976d2d0e270e1c">arr_node_t</a> *&gt; ut_lock_free_hash_t::m_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage for the (key, val) tuples. </p>

</div>
</div>
<a id="a4a25c24887b1b32bf1914d8e5952d9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a25c24887b1b32bf1914d8e5952d9d6">&#9670;&nbsp;</a></span>m_del_when_zero</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ut_lock_free_hash_t::m_del_when_zero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if a tuple should be automatically deleted from the hash if its value becomes 0 after an increment or decrement. </p>

</div>
</div>
<a id="acdc8c4ebea0f7c3419dd70d8e4996f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc8c4ebea0f7c3419dd70d8e4996f1d">&#9670;&nbsp;</a></span>m_hollow_objects</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__lock__free__hash__t.html#aaca1990347d973270f38d9a05233cef7">hollow_t</a>* ut_lock_free_hash_t::m_hollow_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container for hollow (semi-destroyed) objects that have been removed from the list that starts at m_data. </p>
<p>Those objects have their m_base member freed and are entirely destroyed at the end of the hash table life time. The access to this member is protected by m_optimize_latch (adding of new elements) and the removal of elements is done in the destructor of the hash table. </p>

</div>
</div>
<a id="a7f08d1093327ed7202641f2bba231d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f08d1093327ed7202641f2bba231d94">&#9670;&nbsp;</a></span>m_optimize_latch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t ut_lock_free_hash_t::m_optimize_latch</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concurrent copy-all-elements-to-the-next-array, removal of the head of the list and freeing of its m_base member are serialized with this latch. </p>
<p>Those operations could be implemented without serialization, but this immensely increases the complexity of the code. Growing of the hash table is not too hot operation and thus we chose simplicity and maintainability instead of top performance in this case. "Get" operations and "insert/update" ones that do not cause grow still run concurrently even if this latch is locked. </p>

</div>
</div>
<a id="a5a84cb843aa2e14a84dcfa7c032ce650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a84cb843aa2e14a84dcfa7c032ce650">&#9670;&nbsp;</a></span>UNUSED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t ut_lock_free_hash_t::UNUSED = UINT64_MAX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A key == UNUSED designates that this cell in the array is empty. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>storage/innobase/include/<a class="el" href="ut0lock__free__hash_8h_source.html">ut0lock_free_hash.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classut__lock__free__hash__t.html">ut_lock_free_hash_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
