<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/log/log0buf.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('log0buf_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">log0buf.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Redo log buffer implementation, including functions to:  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="arch0arch_8h_source.html">arch0arch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0test_8h_source.html">log0test.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Reservation of space in the redo log</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a9ac9e6fe964ca2c33b116e0f97f94e15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a9ac9e6fe964ca2c33b116e0f97f94e15">log_wait_for_space_after_reserving</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;<a class="el" href="engine__loader_8c.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>)</td></tr>
<tr class="memdesc:a9ac9e6fe964ca2c33b116e0f97f94e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until there is free space in log buffer up to reserved handle.end_sn.  <a href="#a9ac9e6fe964ca2c33b116e0f97f94e15">More...</a><br /></td></tr>
<tr class="separator:a9ac9e6fe964ca2c33b116e0f97f94e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab175d0b0dbc2db18ecff3bb6f933a6dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#ab175d0b0dbc2db18ecff3bb6f933a6dc">log_update_buf_limit</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log)</td></tr>
<tr class="memdesc:ab175d0b0dbc2db18ecff3bb6f933a6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates limit used when writing to log buffer.  <a href="#ab175d0b0dbc2db18ecff3bb6f933a6dc">More...</a><br /></td></tr>
<tr class="separator:ab175d0b0dbc2db18ecff3bb6f933a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2095859ef19eb671d201412bee3e7cc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a2095859ef19eb671d201412bee3e7cc9">log_update_buf_limit</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> write_lsn)</td></tr>
<tr class="memdesc:a2095859ef19eb671d201412bee3e7cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates limit used when writing to log buffer, according to provided write_lsn.  <a href="#a2095859ef19eb671d201412bee3e7cc9">More...</a><br /></td></tr>
<tr class="separator:a2095859ef19eb671d201412bee3e7cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa781f9ba4b59a4003e7e553ef6d0f1d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#aa781f9ba4b59a4003e7e553ef6d0f1d3">log_wait_for_space_in_log_buf</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, <a class="el" href="log0types_8h.html#a57d287f79a40a87174b5bf6aa922c5cd">sn_t</a> end_sn)</td></tr>
<tr class="memdesc:aa781f9ba4b59a4003e7e553ef6d0f1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until there is free space in the log buffer.  <a href="#aa781f9ba4b59a4003e7e553ef6d0f1d3">More...</a><br /></td></tr>
<tr class="separator:aa781f9ba4b59a4003e7e553ef6d0f1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328e943d26733bafa29f8e17dae6cc7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLog__handle.html">Log_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a328e943d26733bafa29f8e17dae6cc7b">log_buffer_reserve</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, size_t len)</td></tr>
<tr class="memdesc:a328e943d26733bafa29f8e17dae6cc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space in the redo log for following write operations.  <a href="#a328e943d26733bafa29f8e17dae6cc7b">More...</a><br /></td></tr>
<tr class="separator:a328e943d26733bafa29f8e17dae6cc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Locking for the redo log</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a465c9367bd5fe9a2dce1eab0eb49e067"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a465c9367bd5fe9a2dce1eab0eb49e067">log_buffer_s_lock_wait</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, const <a class="el" href="log0types_8h.html#a57d287f79a40a87174b5bf6aa922c5cd">sn_t</a> start_sn)</td></tr>
<tr class="memdesc:a465c9367bd5fe9a2dce1eab0eb49e067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the start_sn unlocked and allowed to write to the buffer.  <a href="#a465c9367bd5fe9a2dce1eab0eb49e067">More...</a><br /></td></tr>
<tr class="separator:a465c9367bd5fe9a2dce1eab0eb49e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf8a72d7b3be1dfd9ff470da138eb1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="log0types_8h.html#a57d287f79a40a87174b5bf6aa922c5cd">sn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#ac1cf8a72d7b3be1dfd9ff470da138eb1">log_buffer_s_lock_enter_reserve</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, size_t len)</td></tr>
<tr class="memdesc:ac1cf8a72d7b3be1dfd9ff470da138eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the log buffer s-lock.  <a href="#ac1cf8a72d7b3be1dfd9ff470da138eb1">More...</a><br /></td></tr>
<tr class="separator:ac1cf8a72d7b3be1dfd9ff470da138eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df7ccb6c29a204a0f057ae5d3039d71"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a0df7ccb6c29a204a0f057ae5d3039d71">log_buffer_s_lock_exit_close</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> start_lsn, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> end_lsn)</td></tr>
<tr class="memdesc:a0df7ccb6c29a204a0f057ae5d3039d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the log buffer s-lock.  <a href="#a0df7ccb6c29a204a0f057ae5d3039d71">More...</a><br /></td></tr>
<tr class="separator:a0df7ccb6c29a204a0f057ae5d3039d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e97788e046bf9702d1e88d82c493aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a2e97788e046bf9702d1e88d82c493aab">log_buffer_x_lock_enter</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log)</td></tr>
<tr class="memdesc:a2e97788e046bf9702d1e88d82c493aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the log buffer x-lock.  <a href="#a2e97788e046bf9702d1e88d82c493aab">More...</a><br /></td></tr>
<tr class="separator:a2e97788e046bf9702d1e88d82c493aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4209c250ff2cd1cdb4030d94468b4ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#ac4209c250ff2cd1cdb4030d94468b4ab">log_buffer_x_lock_exit</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log)</td></tr>
<tr class="memdesc:ac4209c250ff2cd1cdb4030d94468b4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the log buffer x-lock.  <a href="#ac4209c250ff2cd1cdb4030d94468b4ab">More...</a><br /></td></tr>
<tr class="separator:ac4209c250ff2cd1cdb4030d94468b4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Writing to the redo log buffer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><pre class="fragment"></pre> </div></td></tr>
<tr class="memitem:a45d765c39f47d7f78a34b97993f40fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a45d765c39f47d7f78a34b97993f40fc2">log_buffer_write</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;<a class="el" href="engine__loader_8c.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *str, size_t str_len, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> start_lsn)</td></tr>
<tr class="memdesc:a45d765c39f47d7f78a34b97993f40fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the log buffer.  <a href="#a45d765c39f47d7f78a34b97993f40fc2">More...</a><br /></td></tr>
<tr class="separator:a45d765c39f47d7f78a34b97993f40fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5c9b805784de3533cc1e48035a5d05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a2d5c9b805784de3533cc1e48035a5d05">log_buffer_write_completed</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;<a class="el" href="engine__loader_8c.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> start_lsn, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> end_lsn)</td></tr>
<tr class="memdesc:a2d5c9b805784de3533cc1e48035a5d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a link start_lsn -&gt; end_lsn to the log recent written buffer.  <a href="#a2d5c9b805784de3533cc1e48035a5d05">More...</a><br /></td></tr>
<tr class="separator:a2d5c9b805784de3533cc1e48035a5d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715e9dfdcc273eef3b9252030394bbf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a715e9dfdcc273eef3b9252030394bbf1">log_wait_for_space_in_log_recent_closed</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> <a class="el" href="xcom__base_8cc.html#a0ce0765b958f7289d206f0c78bd105c7">lsn</a>)</td></tr>
<tr class="memdesc:a715e9dfdcc273eef3b9252030394bbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until there is free space in the log recent closed buffer for any links start_lsn -&gt; end_lsn, which start at provided start_lsn.  <a href="#a715e9dfdcc273eef3b9252030394bbf1">More...</a><br /></td></tr>
<tr class="separator:a715e9dfdcc273eef3b9252030394bbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252fabbe7ed36d19eeed741c5584935b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a252fabbe7ed36d19eeed741c5584935b">log_buffer_close</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;<a class="el" href="engine__loader_8c.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>)</td></tr>
<tr class="memdesc:a252fabbe7ed36d19eeed741c5584935b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a link start_lsn -&gt; end_lsn to the log recent closed buffer.  <a href="#a252fabbe7ed36d19eeed741c5584935b">More...</a><br /></td></tr>
<tr class="separator:a252fabbe7ed36d19eeed741c5584935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f8a95f42a50947241bdb93928e3321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a47f8a95f42a50947241bdb93928e3321">log_buffer_set_first_record_group</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;<a class="el" href="engine__loader_8c.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> rec_group_end_lsn)</td></tr>
<tr class="memdesc:a47f8a95f42a50947241bdb93928e3321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies header of log block in the log buffer, which contains a given lsn value, and sets offset to the first group of log records within the block.  <a href="#a47f8a95f42a50947241bdb93928e3321">More...</a><br /></td></tr>
<tr class="separator:a47f8a95f42a50947241bdb93928e3321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf4290bd4483a83a3fb0b93b70175ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#aeaf4290bd4483a83a3fb0b93b70175ff">log_buffer_flush_to_disk</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync)</td></tr>
<tr class="memdesc:aeaf4290bd4483a83a3fb0b93b70175ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the log file up to the last log entry.  <a href="#aeaf4290bd4483a83a3fb0b93b70175ff">More...</a><br /></td></tr>
<tr class="separator:aeaf4290bd4483a83a3fb0b93b70175ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab076df4763772180013a4aa7efb76d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#ab076df4763772180013a4aa7efb76d6a">log_buffer_sync_in_background</a> ()</td></tr>
<tr class="memdesc:ab076df4763772180013a4aa7efb76d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the log buffer to the log file.  <a href="#ab076df4763772180013a4aa7efb76d6a">More...</a><br /></td></tr>
<tr class="separator:ab076df4763772180013a4aa7efb76d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b6c6c14c2b05387351d3226a4fe6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a38b6c6c14c2b05387351d3226a4fe6c1">log_buffer_get_last_block</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> &amp;last_lsn, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *last_block, uint32_t &amp;block_len)</td></tr>
<tr class="memdesc:a38b6c6c14c2b05387351d3226a4fe6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last redo block from redo buffer and end LSN.  <a href="#a38b6c6c14c2b05387351d3226a4fe6c1">More...</a><br /></td></tr>
<tr class="separator:a38b6c6c14c2b05387351d3226a4fe6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Traversing links in the redo log recent buffers</div></td></tr>
<tr><td colspan="2"><div class="groupText"></div></td></tr>
<tr class="memitem:a05eba532ebede1765ac1b070593f250a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0buf_8cc.html#a05eba532ebede1765ac1b070593f250a">log_advance_ready_for_write_lsn</a> (<a class="el" href="structlog__t.html">log_t</a> &amp;log)</td></tr>
<tr class="memdesc:a05eba532ebede1765ac1b070593f250a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances log.buf_ready_for_write_lsn using links in the recent written buffer.  <a href="#a05eba532ebede1765ac1b070593f250a">More...</a><br /></td></tr>
<tr class="separator:a05eba532ebede1765ac1b070593f250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Redo log buffer implementation, including functions to: </p>
<ol type="1">
<li>Reserve space in the redo log buffer,</li>
<li>Write to the reserved space in the log buffer,</li>
<li>Add link to the log recent written buffer,</li>
<li>Add link to the log recent closed buffer. </li>
</ol>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a05eba532ebede1765ac1b070593f250a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eba532ebede1765ac1b070593f250a">&#9670;&nbsp;</a></span>log_advance_ready_for_write_lsn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> log_advance_ready_for_write_lsn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances log.buf_ready_for_write_lsn using links in the recent written buffer. </p>
<p>It's used by the log writer thread only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log</td><td>redo log </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the lsn has been advanced </dd></dl>

</div>
</div>
<a id="a252fabbe7ed36d19eeed741c5584935b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252fabbe7ed36d19eeed741c5584935b">&#9670;&nbsp;</a></span>log_buffer_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a link start_lsn -&gt; end_lsn to the log recent closed buffer. </p>
<p>This is called after all dirty pages related to [start_lsn, end_lsn) have been added to corresponding flush lists. For detailed explanation - </p><dl class="section see"><dt>See also</dt><dd>log0write.cc. </dd>
<dd>
<a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_add_link_to_recent_closed">Adding link to the log recent</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle for the reservation of space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaf4290bd4483a83a3fb0b93b70175ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf4290bd4483a83a3fb0b93b70175ff">&#9670;&nbsp;</a></span>log_buffer_flush_to_disk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_flush_to_disk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the log file up to the last log entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>whether we want the written log also to be flushed to disk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38b6c6c14c2b05387351d3226a4fe6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b6c6c14c2b05387351d3226a4fe6c1">&#9670;&nbsp;</a></span>log_buffer_get_last_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_get_last_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> &amp;&#160;</td>
          <td class="paramname"><em>last_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>last_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>block_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last redo block from redo buffer and end LSN. </p>
<p>Note that it takes x-lock on the log buffer for a short period. Out values are always set, even when provided last_block is nullptr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">last_lsn</td><td>end lsn of last mtr </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">last_block</td><td>last redo block </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_len</td><td>length in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a328e943d26733bafa29f8e17dae6cc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328e943d26733bafa29f8e17dae6cc7b">&#9670;&nbsp;</a></span>log_buffer_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLog__handle.html">Log_handle</a> log_buffer_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves space in the redo log for following write operations. </p>
<p>Space is reserved for a given number of data bytes. Additionally bytes for required headers and footers of log blocks are reserved.</p>
<p>After the space is reserved, range of lsn values from a start_lsn to an end_lsn is assigned. The log writer thread cannot proceed further than to the start_lsn, until a link start_lsn -&gt; end_lsn has been added to the log recent written buffer.</p>
<p>NOTE that the link is added after data is written to the reserved space in the log buffer. It is very critical to do all these steps as fast as possible, because very likely the log writer thread is waiting for the link. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_buf_reserve">Reservation of space in the redo</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of data bytes to reserve for write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle that represents the reservation </dd></dl>

</div>
</div>
<a id="ac1cf8a72d7b3be1dfd9ff470da138eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cf8a72d7b3be1dfd9ff470da138eb1">&#9670;&nbsp;</a></span>log_buffer_s_lock_enter_reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="log0types_8h.html#a57d287f79a40a87174b5bf6aa922c5cd">sn_t</a> log_buffer_s_lock_enter_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires the log buffer s-lock. </p>
<p>And reserve space in the log buffer. The corresponding unlock operation is adding link to log.recent_closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of data bytes to reserve for write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>start sn of reserved </dd></dl>

</div>
</div>
<a id="a0df7ccb6c29a204a0f057ae5d3039d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df7ccb6c29a204a0f057ae5d3039d71">&#9670;&nbsp;</a></span>log_buffer_s_lock_exit_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_buffer_s_lock_exit_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the log buffer s-lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_lsn</td><td>start lsn of the reservation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_lsn</td><td>end lsn of the reservation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a465c9367bd5fe9a2dce1eab0eb49e067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465c9367bd5fe9a2dce1eab0eb49e067">&#9670;&nbsp;</a></span>log_buffer_s_lock_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_buffer_s_lock_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="log0types_8h.html#a57d287f79a40a87174b5bf6aa922c5cd">sn_t</a>&#160;</td>
          <td class="paramname"><em>start_sn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the start_sn unlocked and allowed to write to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_sn</td><td>target sn value to start to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47f8a95f42a50947241bdb93928e3321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f8a95f42a50947241bdb93928e3321">&#9670;&nbsp;</a></span>log_buffer_set_first_record_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_set_first_record_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>rec_group_end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies header of log block in the log buffer, which contains a given lsn value, and sets offset to the first group of log records within the block. </p>
<p>This is used by mtr after writing a log record group which ends at lsn belonging to different log block than lsn at which the group was started. When write was finished at the last data byte of log block, it is considered ended in the next log block, because the next data byte belongs to that block.</p>
<p>During recovery, when recovery is started in the middle of some group of log records, it first looks for the beginning of the next group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle for the reservation of space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_group_end_lsn</td><td>lsn at which the first log record group starts within the block containing this lsn value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab076df4763772180013a4aa7efb76d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab076df4763772180013a4aa7efb76d6a">&#9670;&nbsp;</a></span>log_buffer_sync_in_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_sync_in_background </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the log buffer to the log file. </p>
<p>It is intended to be called from background master thread periodically. If the log writer threads are active, this function writes nothing. </p>

</div>
</div>
<a id="a45d765c39f47d7f78a34b97993f40fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d765c39f47d7f78a34b97993f40fc2">&#9670;&nbsp;</a></span>log_buffer_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> log_buffer_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>str_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>start_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to the log buffer. </p>
<p>The space in the redo log has to be reserved before calling to this function and lsn pointing to inside the reserved range of lsn values has to be provided.</p>
<p>The write does not have to cover the whole reserved space, but may not overflow it. If it does not cover, then returned value should be used to start the next write operation. Note that finally we must use exactly all the reserved space. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_buf_write">Copying data to the reserved space</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle for the reservation of space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>memory to write data from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_len</td><td>number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_lsn</td><td>lsn to start writing at (the reserved space)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end_lsn after writing the data (in the reserved space), could be used to start the next write operation if there is still free space in the reserved space </dd></dl>

</div>
</div>
<a id="a2d5c9b805784de3533cc1e48035a5d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5c9b805784de3533cc1e48035a5d05">&#9670;&nbsp;</a></span>log_buffer_write_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_write_completed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a link start_lsn -&gt; end_lsn to the log recent written buffer. </p>
<p>This function must be called after the data has been written to the fragment of log buffer represented by range [start_lsn, end_lsn). After the link is added, the log writer may write the data to disk.</p>
<p>NOTE that still dirty pages for the [start_lsn, end_lsn) are not added to flush lists when this function is called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_buf_add_links_to_recent_written">Adding links to the</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle for the reservation of space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_lsn</td><td>start_lsn of the link to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_lsn</td><td>end_lsn of the link to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e97788e046bf9702d1e88d82c493aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e97788e046bf9702d1e88d82c493aab">&#9670;&nbsp;</a></span>log_buffer_x_lock_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_x_lock_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the log buffer x-lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4209c250ff2cd1cdb4030d94468b4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4209c250ff2cd1cdb4030d94468b4ab">&#9670;&nbsp;</a></span>log_buffer_x_lock_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_buffer_x_lock_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the log buffer x-lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab175d0b0dbc2db18ecff3bb6f933a6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab175d0b0dbc2db18ecff3bb6f933a6dc">&#9670;&nbsp;</a></span>log_update_buf_limit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_update_buf_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates limit used when writing to log buffer. </p>
<p>Note that the log buffer may have space for log records for which we still do not have space in log files (for larger lsn values). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2095859ef19eb671d201412bee3e7cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2095859ef19eb671d201412bee3e7cc9">&#9670;&nbsp;</a></span>log_update_buf_limit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_update_buf_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>write_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates limit used when writing to log buffer, according to provided write_lsn. </p>
<p>It must be &lt;= log.write_lsn.load() to protect from log buffer overwrites. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_lsn</td><td>value &lt;= log.write_lsn.load() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac9e6fe964ca2c33b116e0f97f94e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac9e6fe964ca2c33b116e0f97f94e15">&#9670;&nbsp;</a></span>log_wait_for_space_after_reserving()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_wait_for_space_after_reserving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLog__handle.html">Log_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until there is free space in log buffer up to reserved handle.end_sn. </p>
<p>If there was no space, it basically waits for log writer thread which copies data from log buffer to log files and advances log.write_lsn, reclaiming space in the log buffer (it's a ring buffer).</p>
<p>There is a special case - if it turned out, that log buffer is too small for the reserved range of lsn values, it resizes the log buffer.</p>
<p>It's used during reservation of lsn values, when the reserved handle.end_sn is greater than log.buf_limit_sn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle for the reservation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa781f9ba4b59a4003e7e553ef6d0f1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa781f9ba4b59a4003e7e553ef6d0f1d3">&#9670;&nbsp;</a></span>log_wait_for_space_in_log_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_wait_for_space_in_log_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#a57d287f79a40a87174b5bf6aa922c5cd">sn_t</a>&#160;</td>
          <td class="paramname"><em>end_sn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until there is free space in the log buffer. </p>
<p>The free space has to be available for range of sn values ending at the provided sn. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_waiting_for_writer">Waiting until log has been written to</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_sn</td><td>end of the range of sn values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a715e9dfdcc273eef3b9252030394bbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715e9dfdcc273eef3b9252030394bbf1">&#9670;&nbsp;</a></span>log_wait_for_space_in_log_recent_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void log_wait_for_space_in_log_recent_closed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__t.html">log_t</a> &amp;&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until there is free space in the log recent closed buffer for any links start_lsn -&gt; end_lsn, which start at provided start_lsn. </p>
<p>It does not add any link.</p>
<p>This is called just before dirty pages for [start_lsn, end_lsn) are added to flush lists. That's because we need to guarantee, that the delay until dirty page is added to flush list is limited. For detailed explanation - </p><dl class="section see"><dt>See also</dt><dd>log0write.cc. </dd>
<dd>
<a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_add_dirty_pages">Adding dirty pages to flush lists</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>redo log </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn</td><td>lsn on which we wait (for any link: lsn -&gt; x) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_7c61b8982e4f26eda8a4a9a87fddd769.html">log</a></li><li class="navelem"><a class="el" href="log0buf_8cc.html">log0buf.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
