<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Window Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classWindow.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classWindow-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Window Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the (explicit) window of a SQL 2003 section 7.11 &lt;window clause&gt;, or the implicit (inlined) window of a window function call, or a reference to a named window in a window function call (instead of the inlined definition) before resolution.  
 <a href="classWindow.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="window_8h_source.html">window.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Window:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classWindow.png" usemap="#Window_map" alt=""/>
  <map id="Window_map" name="Window_map">
<area href="classPT__window.html" title="Parse tree node for a window; just a shallow wrapper for class Window, q.v. " alt="PT_window" shape="rect" coords="0,56,76,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWindow_1_1Frame__buffer__position.html">Frame_buffer_position</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds information about a position in the buffer frame as stored in a temporary file (cf.  <a href="structWindow_1_1Frame__buffer__position.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWindow_1_1st__lead__lag.html">st_lead_lag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWindow_1_1st__ll__offset.html">st_ll_offset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWindow_1_1st__nth.html">st_nth</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWindow_1_1st__offset.html">st_offset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acd4370dc1039029dd04e36ad5912a795"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795">Special_keys</a> { <a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795ab4a020d8f4b16e8cfec253f05373e1e2">FBC_FIRST_IN_NEXT_PARTITION</a> = -1, 
<a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795a4618c13adf2be869f1b456ef57fbcd3f">FBC_LAST_BUFFERED_ROW</a> = -2, 
<a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795aa62e2f406702d0ee4951a3442695139f">FBC_FIRST_KEY</a> = FBC_FIRST_IN_NEXT_PARTITION, 
<a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795a3b575399866c3e5e3b0caaefcb025b80">FBC_LAST_KEY</a> = FBC_LAST_BUFFERED_ROW
 }<tr class="memdesc:acd4370dc1039029dd04e36ad5912a795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keys for m_frame_buffer_cache and m_special_rows_cache, for special rows.  <a href="classWindow.html#acd4370dc1039029dd04e36ad5912a795">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acd4370dc1039029dd04e36ad5912a795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1abdab0773d91d2963573ed5cf4edda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ad1abdab0773d91d2963573ed5cf4edda">Reset_level</a> { <a class="el" href="classWindow.html#ad1abdab0773d91d2963573ed5cf4eddaa6cba3e64f6a5b5cd6fe040363b8fe8a9">RL_FULL</a>, 
<a class="el" href="classWindow.html#ad1abdab0773d91d2963573ed5cf4eddaa24fdeab51a63fc7f44000d9cace935c3">RL_ROUND</a>, 
<a class="el" href="classWindow.html#ad1abdab0773d91d2963573ed5cf4eddaa349a30c361a14731a032d03546d4c925">RL_PARTITION</a>
 }</td></tr>
<tr class="separator:ad1abdab0773d91d2963573ed5cf4edda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95b0aea4fd06cb60b0d4799c160f833f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a95b0aea4fd06cb60b0d4799c160f833f">save_pos</a> (<a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a> reason)</td></tr>
<tr class="memdesc:a95b0aea4fd06cb60b0d4799c160f833f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_tmp_pos.  <a href="#a95b0aea4fd06cb60b0d4799c160f833f">More...</a><br /></td></tr>
<tr class="separator:a95b0aea4fd06cb60b0d4799c160f833f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e270a2d26c26ce8ff55e2ceb163e08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ae3e270a2d26c26ce8ff55e2ceb163e08">restore_pos</a> (<a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a> reason)</td></tr>
<tr class="memdesc:ae3e270a2d26c26ce8ff55e2ceb163e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_tmp_pos.  <a href="#ae3e270a2d26c26ce8ff55e2ceb163e08">More...</a><br /></td></tr>
<tr class="separator:ae3e270a2d26c26ce8ff55e2ceb163e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a05cd78c25c41cd82e91da74aca63f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a2a05cd78c25c41cd82e91da74aca63f7">copy_pos</a> (<a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a> from_reason, <a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a> to_reason)</td></tr>
<tr class="memdesc:a2a05cd78c25c41cd82e91da74aca63f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy frame buffer position hint from one to another.  <a href="#a2a05cd78c25c41cd82e91da74aca63f7">More...</a><br /></td></tr>
<tr class="separator:a2a05cd78c25c41cd82e91da74aca63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f671af8e7c5531b73672865c39b4f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a52f671af8e7c5531b73672865c39b4f5">Window</a> (<a class="el" href="classItem__string.html">Item_string</a> *<a class="el" href="classWindow.html#a1f41db4ef8446e3e3a85134d5658fe7d">name</a>)</td></tr>
<tr class="memdesc:a52f671af8e7c5531b73672865c39b4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a named window.  <a href="#a52f671af8e7c5531b73672865c39b4f5">More...</a><br /></td></tr>
<tr class="separator:a52f671af8e7c5531b73672865c39b4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ea5b709b9cdcf4716fe50d1d89de04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a64ea5b709b9cdcf4716fe50d1d89de04">Window</a> (<a class="el" href="classPT__order__list.html">PT_order_list</a> *partition_by, <a class="el" href="classPT__order__list.html">PT_order_list</a> *order_by, <a class="el" href="classPT__frame.html">PT_frame</a> *<a class="el" href="classWindow.html#ad5cc04aa3c3ecddbf9683da7851c6b22">frame</a>)</td></tr>
<tr class="memdesc:a64ea5b709b9cdcf4716fe50d1d89de04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unnamed window.  <a href="#a64ea5b709b9cdcf4716fe50d1d89de04">More...</a><br /></td></tr>
<tr class="separator:a64ea5b709b9cdcf4716fe50d1d89de04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c66af3fe356c0900189b0c1567dfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a8c7c66af3fe356c0900189b0c1567dfe">Window</a> (<a class="el" href="classPT__order__list.html">PT_order_list</a> *partition_by, <a class="el" href="classPT__order__list.html">PT_order_list</a> *order_by, <a class="el" href="classPT__frame.html">PT_frame</a> *<a class="el" href="classWindow.html#ad5cc04aa3c3ecddbf9683da7851c6b22">frame</a>, <a class="el" href="classItem__string.html">Item_string</a> *inherit)</td></tr>
<tr class="memdesc:a8c7c66af3fe356c0900189b0c1567dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unnamed window based on a named window.  <a href="#a8c7c66af3fe356c0900189b0c1567dfe">More...</a><br /></td></tr>
<tr class="separator:a8c7c66af3fe356c0900189b0c1567dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712c4eb7d7170bffaeb5a8d3ebc19274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a712c4eb7d7170bffaeb5a8d3ebc19274">set_name</a> (<a class="el" href="classItem__string.html">Item_string</a> *<a class="el" href="classWindow.html#a1f41db4ef8446e3e3a85134d5658fe7d">name</a>)</td></tr>
<tr class="memdesc:a712c4eb7d7170bffaeb5a8d3ebc19274"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have a named window.  <a href="#a712c4eb7d7170bffaeb5a8d3ebc19274">More...</a><br /></td></tr>
<tr class="separator:a712c4eb7d7170bffaeb5a8d3ebc19274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef7fcb16a29b9f7437f80d34ef728f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a8ef7fcb16a29b9f7437f80d34ef728f4">set_ancestor</a> (<a class="el" href="classWindow.html">Window</a> *a)</td></tr>
<tr class="memdesc:a8ef7fcb16a29b9f7437f80d34ef728f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">After resolving an existing window name reference in a window definition, we set the ancestor pointer to easy access later.  <a href="#a8ef7fcb16a29b9f7437f80d34ef728f4">More...</a><br /></td></tr>
<tr class="separator:a8ef7fcb16a29b9f7437f80d34ef728f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f41db4ef8446e3e3a85134d5658fe7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__string.html">Item_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a1f41db4ef8446e3e3a85134d5658fe7d">name</a> () const</td></tr>
<tr class="memdesc:a1f41db4ef8446e3e3a85134d5658fe7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a window.  <a href="#a1f41db4ef8446e3e3a85134d5658fe7d">More...</a><br /></td></tr>
<tr class="separator:a1f41db4ef8446e3e3a85134d5658fe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada67710bbdbe70e79d1a5e358a650352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ada67710bbdbe70e79d1a5e358a650352">def_pos</a> () const</td></tr>
<tr class="separator:ada67710bbdbe70e79d1a5e358a650352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183ec945821c6b62836322c0832049cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a183ec945821c6b62836322c0832049cb">set_def_pos</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)</td></tr>
<tr class="separator:a183ec945821c6b62836322c0832049cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cc04aa3c3ecddbf9683da7851c6b22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPT__frame.html">PT_frame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ad5cc04aa3c3ecddbf9683da7851c6b22">frame</a> () const</td></tr>
<tr class="memdesc:ad5cc04aa3c3ecddbf9683da7851c6b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the frame, if any.  <a href="#ad5cc04aa3c3ecddbf9683da7851c6b22">More...</a><br /></td></tr>
<tr class="separator:ad5cc04aa3c3ecddbf9683da7851c6b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7c710a8b30918145c2d8852c59e38d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aaa7c710a8b30918145c2d8852c59e38d">effective_order_by</a> () const</td></tr>
<tr class="memdesc:aaa7c710a8b30918145c2d8852c59e38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ORDER BY, if any.  <a href="#aaa7c710a8b30918145c2d8852c59e38d">More...</a><br /></td></tr>
<tr class="separator:aaa7c710a8b30918145c2d8852c59e38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b9ef3da74f4028903128ea1770eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a6b2b9ef3da74f4028903128ea1770eed">first_order_by</a> () const</td></tr>
<tr class="memdesc:a6b2b9ef3da74f4028903128ea1770eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first argument of the ORDER BY clause for this window if any.  <a href="#a6b2b9ef3da74f4028903128ea1770eed">More...</a><br /></td></tr>
<tr class="separator:a6b2b9ef3da74f4028903128ea1770eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ab8ce122fbc31b8227b65398e6022b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a01ab8ce122fbc31b8227b65398e6022b">effective_partition_by</a> () const</td></tr>
<tr class="memdesc:a01ab8ce122fbc31b8227b65398e6022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partition, if any.  <a href="#a01ab8ce122fbc31b8227b65398e6022b">More...</a><br /></td></tr>
<tr class="separator:a01ab8ce122fbc31b8227b65398e6022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75448526f76b24bffe4dc2245ef63ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aa75448526f76b24bffe4dc2245ef63ff">first_partition_by</a> () const</td></tr>
<tr class="memdesc:aa75448526f76b24bffe4dc2245ef63ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first argument of the PARTITION clause for this window if any.  <a href="#aa75448526f76b24bffe4dc2245ef63ff">More...</a><br /></td></tr>
<tr class="separator:aa75448526f76b24bffe4dc2245ef63ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e1fc73a241169d5e2d609f760b333b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__sum.html">Item_sum</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a57e1fc73a241169d5e2d609f760b333b">functions</a> ()</td></tr>
<tr class="memdesc:a57e1fc73a241169d5e2d609f760b333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of functions invoked on this window.  <a href="#a57e1fc73a241169d5e2d609f760b333b">More...</a><br /></td></tr>
<tr class="separator:a57e1fc73a241169d5e2d609f760b333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82848ef9f2a022697b29d13decef1ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#af82848ef9f2a022697b29d13decef1ac">sorting_order</a> (<a class="el" href="classTHD.html">THD</a> *thd=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> implicit_grouping=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:af82848ef9f2a022697b29d13decef1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation of columns in PARTITION BY and ORDER BY.  <a href="#af82848ef9f2a022697b29d13decef1ac">More...</a><br /></td></tr>
<tr class="separator:af82848ef9f2a022697b29d13decef1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c28dbd791854c7bced5968e9a490db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a88c28dbd791854c7bced5968e9a490db">check_window_functions1</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select)</td></tr>
<tr class="memdesc:a88c28dbd791854c7bced5968e9a490db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the semantic requirements for window functions over this window are fulfilled, and accumulate evaluation requirements.  <a href="#a88c28dbd791854c7bced5968e9a490db">More...</a><br /></td></tr>
<tr class="separator:a88c28dbd791854c7bced5968e9a490db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59de85a00fc7292924e497e2e4014e05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a59de85a00fc7292924e497e2e4014e05">check_window_functions2</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a59de85a00fc7292924e497e2e4014e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like check_window_functions1() but contains checks which must wait until the start of the execution phase.  <a href="#a59de85a00fc7292924e497e2e4014e05">More...</a><br /></td></tr>
<tr class="separator:a59de85a00fc7292924e497e2e4014e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a431e502ca0299cc0f0dd291d5d6f25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a9a431e502ca0299cc0f0dd291d5d6f25">setup_range_expressions</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a9a431e502ca0299cc0f0dd291d5d6f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">For RANGE frames we need to do computations involving add/subtract and less than, smaller than.  <a href="#a9a431e502ca0299cc0f0dd291d5d6f25">More...</a><br /></td></tr>
<tr class="separator:a9a431e502ca0299cc0f0dd291d5d6f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab552c6855bb972ba76b316f2a990e41a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab552c6855bb972ba76b316f2a990e41a">is_reference</a> () const</td></tr>
<tr class="memdesc:ab552c6855bb972ba76b316f2a990e41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if this window represents an unresolved window reference seen in a window function OVER clause.  <a href="#ab552c6855bb972ba76b316f2a990e41a">More...</a><br /></td></tr>
<tr class="separator:ab552c6855bb972ba76b316f2a990e41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea57e0b6638bb7fe383ca2f67bdad67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#adea57e0b6638bb7fe383ca2f67bdad67">check_partition_boundary</a> ()</td></tr>
<tr class="memdesc:adea57e0b6638bb7fe383ca2f67bdad67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the just read input row marks the start of a new partition.  <a href="#adea57e0b6638bb7fe383ca2f67bdad67">More...</a><br /></td></tr>
<tr class="separator:adea57e0b6638bb7fe383ca2f67bdad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068df09c65b7531f3cb4dac516e20d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a068df09c65b7531f3cb4dac516e20d8f">reset_order_by_peer_set</a> ()</td></tr>
<tr class="memdesc:a068df09c65b7531f3cb4dac516e20d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the current row's ORDER BY expressions when starting a new peer set.  <a href="#a068df09c65b7531f3cb4dac516e20d8f">More...</a><br /></td></tr>
<tr class="separator:a068df09c65b7531f3cb4dac516e20d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f3cf9831c264d78791db7473a6ee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0b7f3cf9831c264d78791db7473a6ee3">in_new_order_by_peer_set</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> compare_all_order_by_items=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:a0b7f3cf9831c264d78791db7473a6ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the current row is not in the same peer set as the previous row.  <a href="#a0b7f3cf9831c264d78791db7473a6ee3">More...</a><br /></td></tr>
<tr class="separator:a0b7f3cf9831c264d78791db7473a6ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c51faca303360d8dac082df8d068e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a94c51faca303360d8dac082df8d068e2">before_frame</a> ()</td></tr>
<tr class="memdesc:a94c51faca303360d8dac082df8d068e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">While processing buffered rows in RANGE frame mode we, determine if the present row revisited from the buffer is before the row being processed; i.e.  <a href="#a94c51faca303360d8dac082df8d068e2">More...</a><br /></td></tr>
<tr class="separator:a94c51faca303360d8dac082df8d068e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27426a6440302a91461ab00cef8a5899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a27426a6440302a91461ab00cef8a5899">after_frame</a> ()</td></tr>
<tr class="separator:a27426a6440302a91461ab00cef8a5899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824e6fd952f270a08725286ed9ccec01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a824e6fd952f270a08725286ed9ccec01">at_partition_border</a> () const</td></tr>
<tr class="memdesc:a824e6fd952f270a08725286ed9ccec01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have read all the rows in a partition, possibly having buffered them for further processing.  <a href="#a824e6fd952f270a08725286ed9ccec01">More...</a><br /></td></tr>
<tr class="separator:a824e6fd952f270a08725286ed9ccec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a4ed26b9591fd1aa44477ce7711ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf5a4ed26b9591fd1aa44477ce7711ccf">save_special_record</a> (<a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> special_rowno, <a class="el" href="structTABLE.html">TABLE</a> *t)</td></tr>
<tr class="memdesc:gaf5a4ed26b9591fd1aa44477ce7711ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save row special_rowno in table t-&gt;record[0] to an in-memory copy for later restoration.  <a href="group__Query__Executor.html#gaf5a4ed26b9591fd1aa44477ce7711ccf">More...</a><br /></td></tr>
<tr class="separator:gaf5a4ed26b9591fd1aa44477ce7711ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56193ae529e5919b702ada22af55d242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga56193ae529e5919b702ada22af55d242">restore_special_record</a> (<a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> special_rowno, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="memdesc:ga56193ae529e5919b702ada22af55d242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore row special_rowno into record from in-memory copy.  <a href="group__Query__Executor.html#ga56193ae529e5919b702ada22af55d242">More...</a><br /></td></tr>
<tr class="separator:ga56193ae529e5919b702ada22af55d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0de6227a07de8acdaae828af600833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0b0de6227a07de8acdaae828af600833">resolve_window_ordering</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="structORDER.html">ORDER</a> *o, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> partition_order)</td></tr>
<tr class="memdesc:a0b0de6227a07de8acdaae828af600833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve and set up the PARTITION BY or an ORDER BY list of a window.  <a href="#a0b0de6227a07de8acdaae828af600833">More...</a><br /></td></tr>
<tr class="separator:a0b0de6227a07de8acdaae828af600833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a87fbada3d8e8947ecfd7c1dbc5ea78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a3a87fbada3d8e8947ecfd7c1dbc5ea78">check_unique_name</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;windows)</td></tr>
<tr class="memdesc:a3a87fbada3d8e8947ecfd7c1dbc5ea78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this window's name is not unique in windows.  <a href="#a3a87fbada3d8e8947ecfd7c1dbc5ea78">More...</a><br /></td></tr>
<tr class="separator:a3a87fbada3d8e8947ecfd7c1dbc5ea78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d6abbfbe9374479fc265a15a5450b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a99d6abbfbe9374479fc265a15a5450b0">setup_ordering_cached_items</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, const <a class="el" href="classPT__order__list.html">PT_order_list</a> *o, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> partition_order)</td></tr>
<tr class="memdesc:a99d6abbfbe9374479fc265a15a5450b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up cached items for an partition or an order by list updating m_partition_items or m_order_by_items respectively.  <a href="#a99d6abbfbe9374479fc265a15a5450b0">More...</a><br /></td></tr>
<tr class="separator:a99d6abbfbe9374479fc265a15a5450b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f7ea6b5cd627fb8ed3f42e35e85659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a91f7ea6b5cd627fb8ed3f42e35e85659">needs_sorting</a> () const</td></tr>
<tr class="memdesc:a91f7ea6b5cd627fb8ed3f42e35e85659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the window had either a partition clause (inclusive) or a ORDER BY clause, either defined by itself or inherited from another window.  <a href="#a91f7ea6b5cd627fb8ed3f42e35e85659">More...</a><br /></td></tr>
<tr class="separator:a91f7ea6b5cd627fb8ed3f42e35e85659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575e7bc09584f7c853e4940e170e228b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a575e7bc09584f7c853e4940e170e228b">needs_buffering</a> () const</td></tr>
<tr class="memdesc:a575e7bc09584f7c853e4940e170e228b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we cannot compute one of window functions without looking at succeeding rows, return true, else false.  <a href="#a575e7bc09584f7c853e4940e170e228b">More...</a><br /></td></tr>
<tr class="separator:a575e7bc09584f7c853e4940e170e228b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda722c65501ed833321f9cd7d16a41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#acda722c65501ed833321f9cd7d16a41e">needs_peerset</a> () const</td></tr>
<tr class="memdesc:acda722c65501ed833321f9cd7d16a41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we cannot compute one of window functions without looking at all rows in the peerset of the current row, return true, else false.  <a href="#acda722c65501ed833321f9cd7d16a41e">More...</a><br /></td></tr>
<tr class="separator:acda722c65501ed833321f9cd7d16a41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068cd0671aae0f28f0c8e68536fea2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a068cd0671aae0f28f0c8e68536fea2eb">needs_last_peer_in_frame</a> () const</td></tr>
<tr class="memdesc:a068cd0671aae0f28f0c8e68536fea2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we cannot compute one of window functions without looking at all rows in the peerset of the current row in this frame, return true, else false.  <a href="#a068cd0671aae0f28f0c8e68536fea2eb">More...</a><br /></td></tr>
<tr class="separator:a068cd0671aae0f28f0c8e68536fea2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababaeb649cb3b579e216bb8e18145b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ababaeb649cb3b579e216bb8e18145b91">needs_card</a> () const</td></tr>
<tr class="memdesc:ababaeb649cb3b579e216bb8e18145b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we need to read the entire partition before we can evaluate some window function(s) on this window,.  <a href="#ababaeb649cb3b579e216bb8e18145b91">More...</a><br /></td></tr>
<tr class="separator:ababaeb649cb3b579e216bb8e18145b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e70f4dfb65c24741c6c886f32110ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ac5e70f4dfb65c24741c6c886f32110ab">optimizable_row_aggregates</a> () const</td></tr>
<tr class="memdesc:ac5e70f4dfb65c24741c6c886f32110ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the set of window functions are all ROW unit optimizable.  <a href="#ac5e70f4dfb65c24741c6c886f32110ab">More...</a><br /></td></tr>
<tr class="separator:ac5e70f4dfb65c24741c6c886f32110ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0d0f6baea34cd23bc9e89a6456ae1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ade0d0f6baea34cd23bc9e89a6456ae1a">optimizable_range_aggregates</a> () const</td></tr>
<tr class="memdesc:ade0d0f6baea34cd23bc9e89a6456ae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the set of window functions are all RANGE unit optimizable.  <a href="#ade0d0f6baea34cd23bc9e89a6456ae1a">More...</a><br /></td></tr>
<tr class="separator:ade0d0f6baea34cd23bc9e89a6456ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f5d841e5191626d716038a6d2713b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a235f5d841e5191626d716038a6d2713b">static_aggregates</a> () const</td></tr>
<tr class="memdesc:a235f5d841e5191626d716038a6d2713b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the aggregates are static, i.e.  <a href="#a235f5d841e5191626d716038a6d2713b">More...</a><br /></td></tr>
<tr class="separator:a235f5d841e5191626d716038a6d2713b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebc242f5aa9a2ed75b7c3df47e922f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a6ebc242f5aa9a2ed75b7c3df47e922f7">opt_first_row</a> () const</td></tr>
<tr class="memdesc:a6ebc242f5aa9a2ed75b7c3df47e922f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_opt_first_row.  <a href="#a6ebc242f5aa9a2ed75b7c3df47e922f7">More...</a><br /></td></tr>
<tr class="separator:a6ebc242f5aa9a2ed75b7c3df47e922f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6bfa76488853925dc6790c8df0532f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0d6bfa76488853925dc6790c8df0532f">opt_last_row</a> () const</td></tr>
<tr class="memdesc:a0d6bfa76488853925dc6790c8df0532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_opt_last_row.  <a href="#a0d6bfa76488853925dc6790c8df0532f">More...</a><br /></td></tr>
<tr class="separator:a0d6bfa76488853925dc6790c8df0532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b1846e6e0a24207674c5eedfd34561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ac9b1846e6e0a24207674c5eedfd34561">is_last</a> () const</td></tr>
<tr class="memdesc:ac9b1846e6e0a24207674c5eedfd34561"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last.  <a href="#ac9b1846e6e0a24207674c5eedfd34561">More...</a><br /></td></tr>
<tr class="separator:ac9b1846e6e0a24207674c5eedfd34561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6611c566d596c0aaffd9f01fdfae38c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a6611c566d596c0aaffd9f01fdfae38c6">set_needs_restore_input_row</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> b)</td></tr>
<tr class="memdesc:a6611c566d596c0aaffd9f01fdfae38c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_needs_restore_input_row.  <a href="#a6611c566d596c0aaffd9f01fdfae38c6">More...</a><br /></td></tr>
<tr class="separator:a6611c566d596c0aaffd9f01fdfae38c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f046772a208b624fc57a77f08ecf5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#af4f046772a208b624fc57a77f08ecf5b">needs_restore_input_row</a> () const</td></tr>
<tr class="memdesc:af4f046772a208b624fc57a77f08ecf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_needs_restore_input_row.  <a href="#af4f046772a208b624fc57a77f08ecf5b">More...</a><br /></td></tr>
<tr class="separator:af4f046772a208b624fc57a77f08ecf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89929fd75370740ec6403630420b7f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structWindow_1_1st__nth.html">st_nth</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aa89929fd75370740ec6403630420b7f7">opt_nth_row</a> () const</td></tr>
<tr class="memdesc:aa89929fd75370740ec6403630420b7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_opt_nth_row.  <a href="#aa89929fd75370740ec6403630420b7f7">More...</a><br /></td></tr>
<tr class="separator:aa89929fd75370740ec6403630420b7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ed36e63b1d764d6b2c198061bf765"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structWindow_1_1st__lead__lag.html">st_lead_lag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a5b8ed36e63b1d764d6b2c198061bf765">opt_lead_lag</a> () const</td></tr>
<tr class="memdesc:a5b8ed36e63b1d764d6b2c198061bf765"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_opt_lead_lag.  <a href="#a5b8ed36e63b1d764d6b2c198061bf765">More...</a><br /></td></tr>
<tr class="separator:a5b8ed36e63b1d764d6b2c198061bf765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada05c0467175f4809da720968d71b754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ada05c0467175f4809da720968d71b754">frame_buffer_param</a> () const</td></tr>
<tr class="memdesc:ada05c0467175f4809da720968d71b754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for m_frame_buffer_param, q.v.  <a href="#ada05c0467175f4809da720968d71b754">More...</a><br /></td></tr>
<tr class="separator:ada05c0467175f4809da720968d71b754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2aa17761fdd6bb0b06a78a46ecfe9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4b2aa17761fdd6bb0b06a78a46ecfe9e">set_frame_buffer_param</a> (<a class="el" href="classTemp__table__param.html">Temp_table_param</a> *<a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>)</td></tr>
<tr class="memdesc:a4b2aa17761fdd6bb0b06a78a46ecfe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for m_frame_buffer_param, q.v.  <a href="#a4b2aa17761fdd6bb0b06a78a46ecfe9e">More...</a><br /></td></tr>
<tr class="separator:a4b2aa17761fdd6bb0b06a78a46ecfe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db276e3aadcb170aef5f5867f0a4093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a3db276e3aadcb170aef5f5867f0a4093">frame_buffer</a> () const</td></tr>
<tr class="memdesc:a3db276e3aadcb170aef5f5867f0a4093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for m_frame_buffer, q.v.  <a href="#a3db276e3aadcb170aef5f5867f0a4093">More...</a><br /></td></tr>
<tr class="separator:a3db276e3aadcb170aef5f5867f0a4093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4fa7833379ad91e58e022e5be66d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4e4fa7833379ad91e58e022e5be66d79">set_frame_buffer</a> (<a class="el" href="structTABLE.html">TABLE</a> *tab)</td></tr>
<tr class="memdesc:a4e4fa7833379ad91e58e022e5be66d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for m_frame_buffer, q.v.  <a href="#a4e4fa7833379ad91e58e022e5be66d79">More...</a><br /></td></tr>
<tr class="separator:a4e4fa7833379ad91e58e022e5be66d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687e9949d29ff808d1fb1c2bff2d6579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a687e9949d29ff808d1fb1c2bff2d6579">outtable_param</a> () const</td></tr>
<tr class="memdesc:a687e9949d29ff808d1fb1c2bff2d6579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for m_outtable_param, q.v.  <a href="#a687e9949d29ff808d1fb1c2bff2d6579">More...</a><br /></td></tr>
<tr class="separator:a687e9949d29ff808d1fb1c2bff2d6579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bd08f876de6bb6ce7ab6c424b7f687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a99bd08f876de6bb6ce7ab6c424b7f687">set_outtable_param</a> (<a class="el" href="classTemp__table__param.html">Temp_table_param</a> *<a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>)</td></tr>
<tr class="memdesc:a99bd08f876de6bb6ce7ab6c424b7f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for m_outtable_param, q.v.  <a href="#a99bd08f876de6bb6ce7ab6c424b7f687">More...</a><br /></td></tr>
<tr class="separator:a99bd08f876de6bb6ce7ab6c424b7f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b53e1d1beeeb61008d4611b401f33b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aa0b53e1d1beeeb61008d4611b401f33b">partition_rowno</a> () const</td></tr>
<tr class="memdesc:aa0b53e1d1beeeb61008d4611b401f33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for m_part_row_number, q.v., the current row number within the partition.  <a href="#aa0b53e1d1beeeb61008d4611b401f33b">More...</a><br /></td></tr>
<tr class="separator:aa0b53e1d1beeeb61008d4611b401f33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460c43de63e39d108bb38ac56cdf2dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a460c43de63e39d108bb38ac56cdf2dac">make_special_rows_cache</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *out_tbl)</td></tr>
<tr class="memdesc:a460c43de63e39d108bb38ac56cdf2dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the cache for special rows.  <a href="#a460c43de63e39d108bb38ac56cdf2dac">More...</a><br /></td></tr>
<tr class="separator:a460c43de63e39d108bb38ac56cdf2dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97df217d2998bfc76d5d1ac0c8067e64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a97df217d2998bfc76d5d1ac0c8067e64">last_row_output</a> () const</td></tr>
<tr class="memdesc:a97df217d2998bfc76d5d1ac0c8067e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_row_output.  <a href="#a97df217d2998bfc76d5d1ac0c8067e64">More...</a><br /></td></tr>
<tr class="separator:a97df217d2998bfc76d5d1ac0c8067e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6f6d07efa04796b38196522728d8c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a8f6f6d07efa04796b38196522728d8c8">set_last_row_output</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rno)</td></tr>
<tr class="memdesc:a8f6f6d07efa04796b38196522728d8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_row_output.  <a href="#a8f6f6d07efa04796b38196522728d8c8">More...</a><br /></td></tr>
<tr class="separator:a8f6f6d07efa04796b38196522728d8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3b90334621a4011707563afc0faa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#add3b90334621a4011707563afc0faa27">rowno_being_visited</a> () const</td></tr>
<tr class="memdesc:add3b90334621a4011707563afc0faa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_rowno_being_visited.  <a href="#add3b90334621a4011707563afc0faa27">More...</a><br /></td></tr>
<tr class="separator:add3b90334621a4011707563afc0faa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada96ea4b7c867e24e884f64d1a5c39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aada96ea4b7c867e24e884f64d1a5c39f">set_rowno_being_visited</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rno)</td></tr>
<tr class="memdesc:aada96ea4b7c867e24e884f64d1a5c39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_rowno_being_visited.  <a href="#aada96ea4b7c867e24e884f64d1a5c39f">More...</a><br /></td></tr>
<tr class="separator:aada96ea4b7c867e24e884f64d1a5c39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af654adb66a91ceb82fb2b1728b8f0a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#af654adb66a91ceb82fb2b1728b8f0a76">last_rowno_in_cache</a> () const</td></tr>
<tr class="memdesc:af654adb66a91ceb82fb2b1728b8f0a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_rowno_in_cache.  <a href="#af654adb66a91ceb82fb2b1728b8f0a76">More...</a><br /></td></tr>
<tr class="separator:af654adb66a91ceb82fb2b1728b8f0a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92af7504ac7ba66e9994c1895ec3677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab92af7504ac7ba66e9994c1895ec3677">set_last_rowno_in_cache</a> (<a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> rno)</td></tr>
<tr class="memdesc:ab92af7504ac7ba66e9994c1895ec3677"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_rowno_in_cache.  <a href="#ab92af7504ac7ba66e9994c1895ec3677">More...</a><br /></td></tr>
<tr class="separator:ab92af7504ac7ba66e9994c1895ec3677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076d4cf1c54d6c83f31977e22ff61afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a076d4cf1c54d6c83f31977e22ff61afc">last_rowno_in_range_frame</a> () const</td></tr>
<tr class="memdesc:a076d4cf1c54d6c83f31977e22ff61afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_rowno_in_range_frame.  <a href="#a076d4cf1c54d6c83f31977e22ff61afc">More...</a><br /></td></tr>
<tr class="separator:a076d4cf1c54d6c83f31977e22ff61afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148f15c47457c9b5ceb14ecedeeb3ef1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a148f15c47457c9b5ceb14ecedeeb3ef1">set_last_rowno_in_range_frame</a> (<a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> rno)</td></tr>
<tr class="memdesc:a148f15c47457c9b5ceb14ecedeeb3ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_rowno_in_range_frame.  <a href="#a148f15c47457c9b5ceb14ecedeeb3ef1">More...</a><br /></td></tr>
<tr class="separator:a148f15c47457c9b5ceb14ecedeeb3ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b4b07aed9cb072e570b7162f204879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ac3b4b07aed9cb072e570b7162f204879">last_rowno_in_peerset</a> () const</td></tr>
<tr class="memdesc:ac3b4b07aed9cb072e570b7162f204879"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_rowno_in_peerset.  <a href="#ac3b4b07aed9cb072e570b7162f204879">More...</a><br /></td></tr>
<tr class="separator:ac3b4b07aed9cb072e570b7162f204879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7db13aa61ec8ede42fd8c2916ea730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a9d7db13aa61ec8ede42fd8c2916ea730">set_last_rowno_in_peerset</a> (<a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> rno)</td></tr>
<tr class="memdesc:a9d7db13aa61ec8ede42fd8c2916ea730"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_last_rowno_in_peerset.  <a href="#a9d7db13aa61ec8ede42fd8c2916ea730">More...</a><br /></td></tr>
<tr class="separator:a9d7db13aa61ec8ede42fd8c2916ea730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9a2b5b1353bd02183a9705c8cdfa55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a8f9a2b5b1353bd02183a9705c8cdfa55">is_last_row_in_peerset_within_frame</a> () const</td></tr>
<tr class="memdesc:a8f9a2b5b1353bd02183a9705c8cdfa55"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_is_last_row_in_peerset_within_frame.  <a href="#a8f9a2b5b1353bd02183a9705c8cdfa55">More...</a><br /></td></tr>
<tr class="separator:a8f9a2b5b1353bd02183a9705c8cdfa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db435963ca6dda1c5dbfa964d67770e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a6db435963ca6dda1c5dbfa964d67770e">set_is_last_row_in_peerset_within_frame</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a6db435963ca6dda1c5dbfa964d67770e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_is_last_row_in_peerset_within_frame.  <a href="#a6db435963ca6dda1c5dbfa964d67770e">More...</a><br /></td></tr>
<tr class="separator:a6db435963ca6dda1c5dbfa964d67770e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c27b87499dd88acc0f95db4d1d02f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab3c27b87499dd88acc0f95db4d1d02f4">do_copy_null</a> () const</td></tr>
<tr class="memdesc:ab3c27b87499dd88acc0f95db4d1d02f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_do_copy_null.  <a href="#ab3c27b87499dd88acc0f95db4d1d02f4">More...</a><br /></td></tr>
<tr class="separator:ab3c27b87499dd88acc0f95db4d1d02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8fc05e57c149b0c22b72b414e46608"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#afb8fc05e57c149b0c22b72b414e46608">set_do_copy_null</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> b)</td></tr>
<tr class="memdesc:afb8fc05e57c149b0c22b72b414e46608"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_do_copy_null.  <a href="#afb8fc05e57c149b0c22b72b414e46608">More...</a><br /></td></tr>
<tr class="separator:afb8fc05e57c149b0c22b72b414e46608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fc427740f0edee7ac124636be94d32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aa7fc427740f0edee7ac124636be94d32">do_inverse</a> () const</td></tr>
<tr class="memdesc:aa7fc427740f0edee7ac124636be94d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_inverse_aggregation.  <a href="#aa7fc427740f0edee7ac124636be94d32">More...</a><br /></td></tr>
<tr class="separator:aa7fc427740f0edee7ac124636be94d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f866028034436425a5c44bd70f0cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWindow.html">Window</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab8f866028034436425a5c44bd70f0cfe">set_inverse</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> b)</td></tr>
<tr class="memdesc:ab8f866028034436425a5c44bd70f0cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_inverse_aggregation.  <a href="#ab8f866028034436425a5c44bd70f0cfe">More...</a><br /></td></tr>
<tr class="separator:ab8f866028034436425a5c44bd70f0cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400fc74c97d29d7e3a72f1dc3081bfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a400fc74c97d29d7e3a72f1dc3081bfc0">aggregates_primed</a> () const</td></tr>
<tr class="memdesc:a400fc74c97d29d7e3a72f1dc3081bfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_aggregates_primed.  <a href="#a400fc74c97d29d7e3a72f1dc3081bfc0">More...</a><br /></td></tr>
<tr class="separator:a400fc74c97d29d7e3a72f1dc3081bfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed86c074d30075ddabe9decb5a2372f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aed86c074d30075ddabe9decb5a2372f3">set_aggregates_primed</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> b)</td></tr>
<tr class="memdesc:aed86c074d30075ddabe9decb5a2372f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_aggregates_primed.  <a href="#aed86c074d30075ddabe9decb5a2372f3">More...</a><br /></td></tr>
<tr class="separator:aed86c074d30075ddabe9decb5a2372f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cef719ee622b79be8ef4724faf528cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a6cef719ee622b79be8ef4724faf528cb">is_last_row_in_frame</a> () const</td></tr>
<tr class="memdesc:a6cef719ee622b79be8ef4724faf528cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_is_last_row_in_frame.  <a href="#a6cef719ee622b79be8ef4724faf528cb">More...</a><br /></td></tr>
<tr class="separator:a6cef719ee622b79be8ef4724faf528cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1355142ce82e6669ba4251438261bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aed1355142ce82e6669ba4251438261bb">set_is_last_row_in_frame</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> b)</td></tr>
<tr class="memdesc:aed1355142ce82e6669ba4251438261bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_is_last_row_in_frame.  <a href="#aed1355142ce82e6669ba4251438261bb">More...</a><br /></td></tr>
<tr class="separator:aed1355142ce82e6669ba4251438261bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac5c168dd9a8c6a40a66a30583fca2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4ac5c168dd9a8c6a40a66a30583fca2c">rowno_in_frame</a> () const</td></tr>
<tr class="memdesc:a4ac5c168dd9a8c6a40a66a30583fca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the frame in number of rows.  <a href="#a4ac5c168dd9a8c6a40a66a30583fca2c">More...</a><br /></td></tr>
<tr class="separator:a4ac5c168dd9a8c6a40a66a30583fca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823ff8c353ee4278ec9d4f3b4e03dcb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWindow.html">Window</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a823ff8c353ee4278ec9d4f3b4e03dcb2">set_rowno_in_frame</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rowno)</td></tr>
<tr class="memdesc:a823ff8c353ee4278ec9d4f3b4e03dcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_rowno_in_frame.  <a href="#a823ff8c353ee4278ec9d4f3b4e03dcb2">More...</a><br /></td></tr>
<tr class="separator:a823ff8c353ee4278ec9d4f3b4e03dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0206fd0843b62659b7fdc0dda2019c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0206fd0843b62659b7fdc0dda2019c25">rowno_in_partition</a> () const</td></tr>
<tr class="memdesc:a0206fd0843b62659b7fdc0dda2019c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_rowno_in_partition.  <a href="#a0206fd0843b62659b7fdc0dda2019c25">More...</a><br /></td></tr>
<tr class="separator:a0206fd0843b62659b7fdc0dda2019c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bc5d170459a069cc26928e7fd7f298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ae0bc5d170459a069cc26928e7fd7f298">set_rowno_in_partition</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rowno)</td></tr>
<tr class="memdesc:ae0bc5d170459a069cc26928e7fd7f298"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_rowno_in_partition.  <a href="#ae0bc5d170459a069cc26928e7fd7f298">More...</a><br /></td></tr>
<tr class="separator:ae0bc5d170459a069cc26928e7fd7f298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5169f16d3479c9dd078a83adab157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a37b5169f16d3479c9dd078a83adab157">set_first_rowno_in_range_frame</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rowno)</td></tr>
<tr class="memdesc:a37b5169f16d3479c9dd078a83adab157"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_first_rowno_in_range_frame.  <a href="#a37b5169f16d3479c9dd078a83adab157">More...</a><br /></td></tr>
<tr class="separator:a37b5169f16d3479c9dd078a83adab157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25304b705102e40e3e7035ab26ef4281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a25304b705102e40e3e7035ab26ef4281">first_rowno_in_range_frame</a> () const</td></tr>
<tr class="memdesc:a25304b705102e40e3e7035ab26ef4281"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_first_rowno_in_range_frame.  <a href="#a25304b705102e40e3e7035ab26ef4281">More...</a><br /></td></tr>
<tr class="separator:a25304b705102e40e3e7035ab26ef4281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e7936f935c13637e39373ec43c37ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ae9e7936f935c13637e39373ec43c37ab">set_frame_buffer_total_rows</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rows)</td></tr>
<tr class="memdesc:ae9e7936f935c13637e39373ec43c37ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_frame_buffer_total_rows.  <a href="#ae9e7936f935c13637e39373ec43c37ab">More...</a><br /></td></tr>
<tr class="separator:ae9e7936f935c13637e39373ec43c37ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502a019632199a5527a57264d2c38a77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a502a019632199a5527a57264d2c38a77">frame_buffer_total_rows</a> () const</td></tr>
<tr class="memdesc:a502a019632199a5527a57264d2c38a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_frame_buffer_total_rows.  <a href="#a502a019632199a5527a57264d2c38a77">More...</a><br /></td></tr>
<tr class="separator:a502a019632199a5527a57264d2c38a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf06c4e9907c3255ee5f2d782f875a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#abf06c4e9907c3255ee5f2d782f875a3b">set_frame_buffer_partition_offset</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> offset)</td></tr>
<tr class="memdesc:abf06c4e9907c3255ee5f2d782f875a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_frame_buffer_partition_offset.  <a href="#abf06c4e9907c3255ee5f2d782f875a3b">More...</a><br /></td></tr>
<tr class="separator:abf06c4e9907c3255ee5f2d782f875a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebba3282a95d28b241853110f07520aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aebba3282a95d28b241853110f07520aa">frame_buffer_partition_offset</a> () const</td></tr>
<tr class="memdesc:aebba3282a95d28b241853110f07520aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_frame_buffer_partition_offset.  <a href="#aebba3282a95d28b241853110f07520aa">More...</a><br /></td></tr>
<tr class="separator:aebba3282a95d28b241853110f07520aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f719c44d707e5f713b8a508b0fd52a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a42f719c44d707e5f713b8a508b0fd52a">row_has_fields_in_out_table</a> () const</td></tr>
<tr class="memdesc:a42f719c44d707e5f713b8a508b0fd52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_row_has_fields_in_out_table.  <a href="#a42f719c44d707e5f713b8a508b0fd52a">More...</a><br /></td></tr>
<tr class="separator:a42f719c44d707e5f713b8a508b0fd52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d7f64d0e916d27a300f2e4fe4ad40c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a30d7f64d0e916d27a300f2e4fe4ad40c">set_row_has_fields_in_out_table</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rowno)</td></tr>
<tr class="memdesc:a30d7f64d0e916d27a300f2e4fe4ad40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See m_row_has_fields_in_out_table.  <a href="#a30d7f64d0e916d27a300f2e4fe4ad40c">More...</a><br /></td></tr>
<tr class="separator:a30d7f64d0e916d27a300f2e4fe4ad40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2531e56f7ac0440c1890f327d15ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a27c2531e56f7ac0440c1890f327d15ff">cleanup</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a27c2531e56f7ac0440c1890f327d15ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free up any resource used to process the window functions of this window, e.g.  <a href="#a27c2531e56f7ac0440c1890f327d15ff">More...</a><br /></td></tr>
<tr class="separator:a27c2531e56f7ac0440c1890f327d15ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89262ad2538473c8d7e4d8dd641849d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aa89262ad2538473c8d7e4d8dd641849d">destroy</a> ()</td></tr>
<tr class="memdesc:aa89262ad2538473c8d7e4d8dd641849d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free structures that were set up during preparation of window functions.  <a href="#aa89262ad2538473c8d7e4d8dd641849d">More...</a><br /></td></tr>
<tr class="separator:aa89262ad2538473c8d7e4d8dd641849d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e43cbaf2e782e53ca0d368308d2f94c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a1e43cbaf2e782e53ca0d368308d2f94c">reset_partition_state</a> ()</td></tr>
<tr class="memdesc:a1e43cbaf2e782e53ca0d368308d2f94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset window state for a new partition.  <a href="#a1e43cbaf2e782e53ca0d368308d2f94c">More...</a><br /></td></tr>
<tr class="separator:a1e43cbaf2e782e53ca0d368308d2f94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1da9fee9ddb97d7a5520e86bb72452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#abc1da9fee9ddb97d7a5520e86bb72452">reset_round</a> ()</td></tr>
<tr class="memdesc:abc1da9fee9ddb97d7a5520e86bb72452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset execution state for next call to JOIN::exec, cf.  <a href="#abc1da9fee9ddb97d7a5520e86bb72452">More...</a><br /></td></tr>
<tr class="separator:abc1da9fee9ddb97d7a5520e86bb72452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f0eeb27ae12bf2cae3f89f9da937d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a56f0eeb27ae12bf2cae3f89f9da937d9">reinit_before_use</a> ()</td></tr>
<tr class="memdesc:a56f0eeb27ae12bf2cae3f89f9da937d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset resolution and execution state to prepare for next execution of a prepared statement.  <a href="#a56f0eeb27ae12bf2cae3f89f9da937d9">More...</a><br /></td></tr>
<tr class="separator:a56f0eeb27ae12bf2cae3f89f9da937d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d44350e47688e24e333125143b23fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab9d44350e47688e24e333125143b23fc">reset_lead_lag</a> ()</td></tr>
<tr class="memdesc:ab9d44350e47688e24e333125143b23fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset execution state for LEAD/LAG for the current row in partition.  <a href="#ab9d44350e47688e24e333125143b23fc">More...</a><br /></td></tr>
<tr class="separator:ab9d44350e47688e24e333125143b23fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af3655b68cb63d000f6a0956dc6708a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0af3655b68cb63d000f6a0956dc6708a">reset_all_wf_state</a> ()</td></tr>
<tr class="memdesc:a0af3655b68cb63d000f6a0956dc6708a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the execution state for all window functions defined on this window.  <a href="#a0af3655b68cb63d000f6a0956dc6708a">More...</a><br /></td></tr>
<tr class="separator:a0af3655b68cb63d000f6a0956dc6708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33261521eb1351568fe104d0fefd6b0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab33261521eb1351568fe104d0fefd6b0">printable_name</a> () const</td></tr>
<tr class="separator:ab33261521eb1351568fe104d0fefd6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc15dca1a3b5e323d26334f8d114ddbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#adc15dca1a3b5e323d26334f8d114ddbe">print</a> (const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classString.html">String</a> *str, <a class="el" href="enum__query__type_8h.html#a84267bb0a3694b1d41b6494868ce18ac">enum_query_type</a> qt, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> expand_definition) const</td></tr>
<tr class="separator:adc15dca1a3b5e323d26334f8d114ddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae642e6a89f11a19205dfb2bd5607ea75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ae642e6a89f11a19205dfb2bd5607ea75">has_windowing_steps</a> () const</td></tr>
<tr class="separator:ae642e6a89f11a19205dfb2bd5607ea75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4b2545287b4cccb328b43df7c2941a0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4b2545287b4cccb328b43df7c2941a0c">resolve_reference</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem__sum.html">Item_sum</a> *wf, <a class="el" href="classPT__window.html">PT_window</a> **m_window)</td></tr>
<tr class="memdesc:a4b2545287b4cccb328b43df7c2941a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve any named window to its definition and update m_window to point to the definition instead.  <a href="#a4b2545287b4cccb328b43df7c2941a0c">More...</a><br /></td></tr>
<tr class="separator:a4b2545287b4cccb328b43df7c2941a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd1bbf31b37ebba389ec799419e801"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a8efd1bbf31b37ebba389ec799419e801">setup_windows1</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;windows)</td></tr>
<tr class="memdesc:a8efd1bbf31b37ebba389ec799419e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic checking of windows.  <a href="#a8efd1bbf31b37ebba389ec799419e801">More...</a><br /></td></tr>
<tr class="separator:a8efd1bbf31b37ebba389ec799419e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0173d80c9786966af8d12eaac5414b21"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0173d80c9786966af8d12eaac5414b21">setup_windows2</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;windows)</td></tr>
<tr class="memdesc:a0173d80c9786966af8d12eaac5414b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like setup_windows1() but contains operations which must wait until the start of the execution phase.  <a href="#a0173d80c9786966af8d12eaac5414b21">More...</a><br /></td></tr>
<tr class="separator:a0173d80c9786966af8d12eaac5414b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e38184def3c475078ea487f8d1235e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a84e38184def3c475078ea487f8d1235e">remove_unused_windows</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;windows)</td></tr>
<tr class="memdesc:a84e38184def3c475078ea487f8d1235e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused window definitions.  <a href="#a84e38184def3c475078ea487f8d1235e">More...</a><br /></td></tr>
<tr class="separator:a84e38184def3c475078ea487f8d1235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeb479455b291bd970312d6b1f0fca6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aaaeb479455b291bd970312d6b1f0fca6">compute_cost</a> (double cost, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;windows)</td></tr>
<tr class="memdesc:aaaeb479455b291bd970312d6b1f0fca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sorting costs for windowing.  <a href="#aaaeb479455b291bd970312d6b1f0fca6">More...</a><br /></td></tr>
<tr class="separator:aaaeb479455b291bd970312d6b1f0fca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac5eac4e74934033635df8387a4f29c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array__YY.html">Mem_root_array_YY</a>&lt; <a class="el" href="structWindow_1_1Frame__buffer__position.html">Frame_buffer_position</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ac5eac4e74934033635df8387a4f29c9c">m_frame_buffer_positions</a></td></tr>
<tr class="memdesc:ac5eac4e74934033635df8387a4f29c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: used iff m_needs_frame_buffering.  <a href="#ac5eac4e74934033635df8387a4f29c9c">More...</a><br /></td></tr>
<tr class="separator:ac5eac4e74934033635df8387a4f29c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22890eaf1766c609c6798a304066d87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structWindow_1_1Frame__buffer__position.html">Frame_buffer_position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a22890eaf1766c609c6798a304066d87b">m_tmp_pos</a></td></tr>
<tr class="memdesc:a22890eaf1766c609c6798a304066d87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sometimes we read one row too many, so that the saved position will be too far out because we subsequently need to read an earlier (previous) row of the same kind (reason).  <a href="#a22890eaf1766c609c6798a304066d87b">More...</a><br /></td></tr>
<tr class="separator:a22890eaf1766c609c6798a304066d87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6335e70f5e0fc0b35c1672484afaea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0a6335e70f5e0fc0b35c1672484afaea">m_comparators</a> [<a class="el" href="window__lex_8h.html#aacf6e2c5ab15b74f44e72c7221c71f8baa60594f2a674a4c740f0839f2f3efe27">WBT_VALUE_FOLLOWING</a>+1][2]</td></tr>
<tr class="memdesc:a0a6335e70f5e0fc0b35c1672484afaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">RANGE bound determination computation; first index is a value of the enum_window_border_type enum; second index 0 for the start bound, 1 for the end bound.  <a href="#a0a6335e70f5e0fc0b35c1672484afaea">More...</a><br /></td></tr>
<tr class="separator:a0a6335e70f5e0fc0b35c1672484afaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e84191eed4b7e87c6ec53b1305be2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a1e84191eed4b7e87c6ec53b1305be2b5">m_inverse_comparators</a> [<a class="el" href="window__lex_8h.html#aacf6e2c5ab15b74f44e72c7221c71f8baa60594f2a674a4c740f0839f2f3efe27">WBT_VALUE_FOLLOWING</a>+1][2]</td></tr>
<tr class="memdesc:a1e84191eed4b7e87c6ec53b1305be2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each item has inverse operation of the corresponding comparator in m_comparators.  <a href="#a1e84191eed4b7e87c6ec53b1305be2b5">More...</a><br /></td></tr>
<tr class="separator:a1e84191eed4b7e87c6ec53b1305be2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7791674012b0ed3d0e891f53e521a575"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a7791674012b0ed3d0e891f53e521a575">FRAME_BUFFER_POSITIONS_CARD</a></td></tr>
<tr class="memdesc:a7791674012b0ed3d0e891f53e521a575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cardinality of m_frame_buffer_positions if no NTH_VALUE, LEAD/LAG.  <a href="#a7791674012b0ed3d0e891f53e521a575">More...</a><br /></td></tr>
<tr class="separator:a7791674012b0ed3d0e891f53e521a575"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af1289c052b4481e33dfad38f02ec30c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#af1289c052b4481e33dfad38f02ec30c1">m_select</a></td></tr>
<tr class="memdesc:af1289c052b4481e33dfad38f02ec30c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SELECT the window is on.  <a href="#af1289c052b4481e33dfad38f02ec30c1">More...</a><br /></td></tr>
<tr class="separator:af1289c052b4481e33dfad38f02ec30c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca36dae2db6f95e3529d27081c930d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPT__order__list.html">PT_order_list</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#afca36dae2db6f95e3529d27081c930d2">m_partition_by</a></td></tr>
<tr class="memdesc:afca36dae2db6f95e3529d27081c930d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;window partition clause&gt;  <a href="#afca36dae2db6f95e3529d27081c930d2">More...</a><br /></td></tr>
<tr class="separator:afca36dae2db6f95e3529d27081c930d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495a78db188bf6ba6e5aa43499bcd0e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPT__order__list.html">PT_order_list</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a495a78db188bf6ba6e5aa43499bcd0e6">m_order_by</a></td></tr>
<tr class="memdesc:a495a78db188bf6ba6e5aa43499bcd0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;window order clause&gt;  <a href="#a495a78db188bf6ba6e5aa43499bcd0e6">More...</a><br /></td></tr>
<tr class="separator:a495a78db188bf6ba6e5aa43499bcd0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330f0aba2e75358c29f62bd6fbd68905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a330f0aba2e75358c29f62bd6fbd68905">m_sorting_order</a></td></tr>
<tr class="memdesc:a330f0aba2e75358c29f62bd6fbd68905"><td class="mdescLeft">&#160;</td><td class="mdescRight">merged partition/order by  <a href="#a330f0aba2e75358c29f62bd6fbd68905">More...</a><br /></td></tr>
<tr class="separator:a330f0aba2e75358c29f62bd6fbd68905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb88a512c5644560e4266986bd27afd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPT__frame.html">PT_frame</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#adb88a512c5644560e4266986bd27afd2">m_frame</a></td></tr>
<tr class="memdesc:adb88a512c5644560e4266986bd27afd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;window frame clause&gt;  <a href="#adb88a512c5644560e4266986bd27afd2">More...</a><br /></td></tr>
<tr class="separator:adb88a512c5644560e4266986bd27afd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21602ae681064bae23ee0eefa3801206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__string.html">Item_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a21602ae681064bae23ee0eefa3801206">m_name</a></td></tr>
<tr class="memdesc:a21602ae681064bae23ee0eefa3801206"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;window name&gt;  <a href="#a21602ae681064bae23ee0eefa3801206">More...</a><br /></td></tr>
<tr class="separator:a21602ae681064bae23ee0eefa3801206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b5bce2537a290d061f6ed540bbce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a3b6b5bce2537a290d061f6ed540bbce8">m_def_pos</a></td></tr>
<tr class="memdesc:a3b6b5bce2537a290d061f6ed540bbce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of definition in query's text, 1 for leftmost.  <a href="#a3b6b5bce2537a290d061f6ed540bbce8">More...</a><br /></td></tr>
<tr class="separator:a3b6b5bce2537a290d061f6ed540bbce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028148fc459db83d705edab451e8aca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__string.html">Item_string</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a028148fc459db83d705edab451e8aca7">m_inherit_from</a></td></tr>
<tr class="memdesc:a028148fc459db83d705edab451e8aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;existing window name&gt;  <a href="#a028148fc459db83d705edab451e8aca7">More...</a><br /></td></tr>
<tr class="separator:a028148fc459db83d705edab451e8aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d4d1ea03ffe3d8caa4a0f853bc600c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a05d4d1ea03ffe3d8caa4a0f853bc600c">m_is_reference</a></td></tr>
<tr class="memdesc:a05d4d1ea03ffe3d8caa4a0f853bc600c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, m_name is an unbound window reference, other fields are unused.  <a href="#a05d4d1ea03ffe3d8caa4a0f853bc600c">More...</a><br /></td></tr>
<tr class="separator:a05d4d1ea03ffe3d8caa4a0f853bc600c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95a62be57b6562776d29cd5dd333c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ac95a62be57b6562776d29cd5dd333c58">m_needs_frame_buffering</a></td></tr>
<tr class="memdesc:ac95a62be57b6562776d29cd5dd333c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">(At least) one window function needs to buffer frame rows for evaluation i.e.  <a href="#ac95a62be57b6562776d29cd5dd333c58">More...</a><br /></td></tr>
<tr class="separator:ac95a62be57b6562776d29cd5dd333c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c45af7cf6c66c1f93339cc460fcab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a319c45af7cf6c66c1f93339cc460fcab">m_needs_peerset</a></td></tr>
<tr class="memdesc:a319c45af7cf6c66c1f93339cc460fcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">(At least) one window function needs the peer set of the current row to evaluate the wf for the current row  <a href="#a319c45af7cf6c66c1f93339cc460fcab">More...</a><br /></td></tr>
<tr class="separator:a319c45af7cf6c66c1f93339cc460fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829ca8e083149c23d83a3351853f350c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a829ca8e083149c23d83a3351853f350c">m_needs_last_peer_in_frame</a></td></tr>
<tr class="memdesc:a829ca8e083149c23d83a3351853f350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(At least) one window function (currently JSON_OBJECTAGG) needs the last peer for the current row to evaluate the wf for the current row.  <a href="#a829ca8e083149c23d83a3351853f350c">More...</a><br /></td></tr>
<tr class="separator:a829ca8e083149c23d83a3351853f350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1c69cb59cce1cc6e9d5aff2db67d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ada1c69cb59cce1cc6e9d5aff2db67d41">m_needs_card</a></td></tr>
<tr class="memdesc:ada1c69cb59cce1cc6e9d5aff2db67d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">(At least) one window function needs the cardinality of the partition of the current row to evaluate the wf for the current row  <a href="#ada1c69cb59cce1cc6e9d5aff2db67d41">More...</a><br /></td></tr>
<tr class="separator:ada1c69cb59cce1cc6e9d5aff2db67d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049216e091cc1cfcf7be86efbcbe9509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a049216e091cc1cfcf7be86efbcbe9509">m_row_optimizable</a></td></tr>
<tr class="memdesc:a049216e091cc1cfcf7be86efbcbe9509"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions are optimizable with ROW unit.  <a href="#a049216e091cc1cfcf7be86efbcbe9509">More...</a><br /></td></tr>
<tr class="separator:a049216e091cc1cfcf7be86efbcbe9509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df31eacc380806c96b30395d2de25f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a5df31eacc380806c96b30395d2de25f9">m_range_optimizable</a></td></tr>
<tr class="memdesc:a5df31eacc380806c96b30395d2de25f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions are optimizable with RANGE unit.  <a href="#a5df31eacc380806c96b30395d2de25f9">More...</a><br /></td></tr>
<tr class="separator:a5df31eacc380806c96b30395d2de25f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f03eb20e00b2bad5edb160f0c94e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a60f03eb20e00b2bad5edb160f0c94e2c">m_static_aggregates</a></td></tr>
<tr class="memdesc:a60f03eb20e00b2bad5edb160f0c94e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aggregates (SUM, etc) can be evaluated once for a partition, since it is static, i.e.  <a href="#a60f03eb20e00b2bad5edb160f0c94e2c">More...</a><br /></td></tr>
<tr class="separator:a60f03eb20e00b2bad5edb160f0c94e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca855dfc77e145638ec936fe899d995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a5ca855dfc77e145638ec936fe899d995">m_opt_first_row</a></td></tr>
<tr class="memdesc:a5ca855dfc77e145638ec936fe899d995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Window equires re-evaluation of the first row in optimized moving frame mode e.g.  <a href="#a5ca855dfc77e145638ec936fe899d995">More...</a><br /></td></tr>
<tr class="separator:a5ca855dfc77e145638ec936fe899d995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdb975ad871c18bf2252b890eaf0d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#afcdb975ad871c18bf2252b890eaf0d53">m_opt_last_row</a></td></tr>
<tr class="memdesc:afcdb975ad871c18bf2252b890eaf0d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Window requires re-evaluation of the last row in optimized moving frame mode e.g.  <a href="#afcdb975ad871c18bf2252b890eaf0d53">More...</a><br /></td></tr>
<tr class="separator:afcdb975ad871c18bf2252b890eaf0d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6860d51c1f431ba49b2b6616b100e6a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a6860d51c1f431ba49b2b6616b100e6a4">m_needs_restore_input_row</a></td></tr>
<tr class="memdesc:a6860d51c1f431ba49b2b6616b100e6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be true if first window after a join: we may need to restore the input record after buffered window processing if EQRefIterator's caching logic presumes the record hasn't been modified (when last qep_tab uses JT_EQ_REF).  <a href="#a6860d51c1f431ba49b2b6616b100e6a4">More...</a><br /></td></tr>
<tr class="separator:a6860d51c1f431ba49b2b6616b100e6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832a813a83de44449ea5e9d627a571dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a832a813a83de44449ea5e9d627a571dd">m_last</a></td></tr>
<tr class="memdesc:a832a813a83de44449ea5e9d627a571dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last window to be evaluated at execution time.  <a href="#a832a813a83de44449ea5e9d627a571dd">More...</a><br /></td></tr>
<tr class="separator:a832a813a83de44449ea5e9d627a571dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f11b0e36b054f484466ac3f022d689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structWindow_1_1st__nth.html">st_nth</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#af0f11b0e36b054f484466ac3f022d689">m_opt_nth_row</a></td></tr>
<tr class="memdesc:af0f11b0e36b054f484466ac3f022d689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Window requires re-evaluation of the Nth row in optimized moving frame mode e.g.  <a href="#af0f11b0e36b054f484466ac3f022d689">More...</a><br /></td></tr>
<tr class="separator:af0f11b0e36b054f484466ac3f022d689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f2b8a5f05df71fb2d80c7eae52cbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structWindow_1_1st__lead__lag.html">st_lead_lag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a946f2b8a5f05df71fb2d80c7eae52cbf">m_opt_lead_lag</a></td></tr>
<tr class="separator:a946f2b8a5f05df71fb2d80c7eae52cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38996f07642a040a1b70d791d6bca516"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classWindow.html">Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a38996f07642a040a1b70d791d6bca516">m_ancestor</a></td></tr>
<tr class="memdesc:a38996f07642a040a1b70d791d6bca516"><td class="mdescLeft">&#160;</td><td class="mdescRight">resolved from existing window name  <a href="#a38996f07642a040a1b70d791d6bca516">More...</a><br /></td></tr>
<tr class="separator:a38996f07642a040a1b70d791d6bca516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb76d6cd2505424786356826381a2d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__sum.html">Item_sum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#afb76d6cd2505424786356826381a2d4d">m_functions</a></td></tr>
<tr class="memdesc:afb76d6cd2505424786356826381a2d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">window functions based on 'this'  <a href="#afb76d6cd2505424786356826381a2d4d">More...</a><br /></td></tr>
<tr class="separator:afb76d6cd2505424786356826381a2d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc606a658acfeaedb7b7e2ebc68e596e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCached__item.html">Cached_item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#abc606a658acfeaedb7b7e2ebc68e596e">m_partition_items</a></td></tr>
<tr class="memdesc:abc606a658acfeaedb7b7e2ebc68e596e"><td class="mdescLeft">&#160;</td><td class="mdescRight">items for the PARTITION BY columns  <a href="#abc606a658acfeaedb7b7e2ebc68e596e">More...</a><br /></td></tr>
<tr class="separator:abc606a658acfeaedb7b7e2ebc68e596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4969fceeeb0328dc5d3cecdf3c76ddaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCached__item.html">Cached_item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4969fceeeb0328dc5d3cecdf3c76ddaa">m_order_by_items</a></td></tr>
<tr class="memdesc:a4969fceeeb0328dc5d3cecdf3c76ddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">items for the ORDER BY exprs.  <a href="#a4969fceeeb0328dc5d3cecdf3c76ddaa">More...</a><br /></td></tr>
<tr class="separator:a4969fceeeb0328dc5d3cecdf3c76ddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca64477e64b5415037c60fa1ba2e0f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a3ca64477e64b5415037c60fa1ba2e0f3">m_frame_buffer_param</a></td></tr>
<tr class="memdesc:a3ca64477e64b5415037c60fa1ba2e0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: used iff m_needs_frame_buffering.  <a href="#a3ca64477e64b5415037c60fa1ba2e0f3">More...</a><br /></td></tr>
<tr class="separator:a3ca64477e64b5415037c60fa1ba2e0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd1b950667807719717cdc6ad9195a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a1fd1b950667807719717cdc6ad9195a7">m_outtable_param</a></td></tr>
<tr class="memdesc:a1fd1b950667807719717cdc6ad9195a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: Holds the temporary output table (for next step) parameters.  <a href="#a1fd1b950667807719717cdc6ad9195a7">More...</a><br /></td></tr>
<tr class="separator:a1fd1b950667807719717cdc6ad9195a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36ff971eea06183a78bc39c0f67e883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab36ff971eea06183a78bc39c0f67e883">m_frame_buffer</a></td></tr>
<tr class="memdesc:ab36ff971eea06183a78bc39c0f67e883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: used iff m_needs_frame_buffering.  <a href="#ab36ff971eea06183a78bc39c0f67e883">More...</a><br /></td></tr>
<tr class="separator:ab36ff971eea06183a78bc39c0f67e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5830feb57732ae91f99b41fd23879c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a5830feb57732ae91f99b41fd23879c27">m_frame_buffer_total_rows</a></td></tr>
<tr class="memdesc:a5830feb57732ae91f99b41fd23879c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: The frame buffer tmp file is not truncated for each new partition.  <a href="#a5830feb57732ae91f99b41fd23879c27">More...</a><br /></td></tr>
<tr class="separator:a5830feb57732ae91f99b41fd23879c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1cb972563a9134fef4be429c2836e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a2b1cb972563a9134fef4be429c2836e1">m_frame_buffer_partition_offset</a></td></tr>
<tr class="memdesc:a2b1cb972563a9134fef4be429c2836e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: Snapshot of m_frame_buffer_total_rows when we start a new partition, i.e.  <a href="#a2b1cb972563a9134fef4be429c2836e1">More...</a><br /></td></tr>
<tr class="separator:a2b1cb972563a9134fef4be429c2836e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e7a3070aabf03f05ee216d7fd3f886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a28e7a3070aabf03f05ee216d7fd3f886">m_row_has_fields_in_out_table</a></td></tr>
<tr class="memdesc:a28e7a3070aabf03f05ee216d7fd3f886"><td class="mdescLeft">&#160;</td><td class="mdescRight">If &gt;=1: the row with this number (1-based, relative to start of partition) currently has its fields in the record buffer of the IN table and of the OUT table.  <a href="#a28e7a3070aabf03f05ee216d7fd3f886">More...</a><br /></td></tr>
<tr class="separator:a28e7a3070aabf03f05ee216d7fd3f886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a8e25446490ffa084534e03596d9a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a75a8e25446490ffa084534e03596d9a0">m_special_rows_cache</a></td></tr>
<tr class="memdesc:a75a8e25446490ffa084534e03596d9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a fixed number of copies of special rows; each copy can use up to m_special_rows_cache_max_length bytes.  <a href="#a75a8e25446490ffa084534e03596d9a0">More...</a><br /></td></tr>
<tr class="separator:a75a8e25446490ffa084534e03596d9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49025f4eb90aeeb36a2e873ffd4a0597"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a49025f4eb90aeeb36a2e873ffd4a0597">m_special_rows_cache_length</a> [<a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795aa62e2f406702d0ee4951a3442695139f">FBC_FIRST_KEY</a> - <a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795a3b575399866c3e5e3b0caaefcb025b80">FBC_LAST_KEY</a>+1]</td></tr>
<tr class="memdesc:a49025f4eb90aeeb36a2e873ffd4a0597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of each copy in m_special_rows_cache, in bytes.  <a href="#a49025f4eb90aeeb36a2e873ffd4a0597">More...</a><br /></td></tr>
<tr class="separator:a49025f4eb90aeeb36a2e873ffd4a0597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2f33599ecc0b594d97a6053a8133cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aaf2f33599ecc0b594d97a6053a8133cc">m_special_rows_cache_max_length</a></td></tr>
<tr class="memdesc:aaf2f33599ecc0b594d97a6053a8133cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allocated size in m_special_rows_cache.  <a href="#aaf2f33599ecc0b594d97a6053a8133cc">More...</a><br /></td></tr>
<tr class="separator:aaf2f33599ecc0b594d97a6053a8133cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81870ca3607b1038dc2dc843e87e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#acb81870ca3607b1038dc2dc843e87e2b">m_last_rowno_in_cache</a></td></tr>
<tr class="memdesc:acb81870ca3607b1038dc2dc843e87e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: used iff m_needs_frame_buffering.  <a href="#acb81870ca3607b1038dc2dc843e87e2b">More...</a><br /></td></tr>
<tr class="separator:acb81870ca3607b1038dc2dc843e87e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8129cbc0ab6ad7fcec814dd09f7555a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab8129cbc0ab6ad7fcec814dd09f7555a">m_last_rowno_in_peerset</a></td></tr>
<tr class="memdesc:ab8129cbc0ab6ad7fcec814dd09f7555a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: used iff m_needs_peerset.  <a href="#ab8129cbc0ab6ad7fcec814dd09f7555a">More...</a><br /></td></tr>
<tr class="separator:ab8129cbc0ab6ad7fcec814dd09f7555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461190125463218b323ec001845f169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4461190125463218b323ec001845f169">m_is_last_row_in_peerset_within_frame</a></td></tr>
<tr class="memdesc:a4461190125463218b323ec001845f169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: used iff m_needs_last_peer_in_frame.  <a href="#a4461190125463218b323ec001845f169">More...</a><br /></td></tr>
<tr class="separator:a4461190125463218b323ec001845f169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4952f1c8b0e3325d30d564f89162e629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4952f1c8b0e3325d30d564f89162e629">m_part_row_number</a></td></tr>
<tr class="memdesc:a4952f1c8b0e3325d30d564f89162e629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: the current row number in the current partition.  <a href="#a4952f1c8b0e3325d30d564f89162e629">More...</a><br /></td></tr>
<tr class="separator:a4952f1c8b0e3325d30d564f89162e629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eff4d39a973df2aed891ca8cd23880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ab6eff4d39a973df2aed891ca8cd23880">m_partition_border</a></td></tr>
<tr class="memdesc:ab6eff4d39a973df2aed891ca8cd23880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: the current row starts a new partition.  <a href="#ab6eff4d39a973df2aed891ca8cd23880">More...</a><br /></td></tr>
<tr class="separator:ab6eff4d39a973df2aed891ca8cd23880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f40dea3086ce2e97bacb03d4317877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ad2f40dea3086ce2e97bacb03d4317877">m_last_row_output</a></td></tr>
<tr class="memdesc:ad2f40dea3086ce2e97bacb03d4317877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: The number, in the current partition, of the last output row, i.e.  <a href="#ad2f40dea3086ce2e97bacb03d4317877">More...</a><br /></td></tr>
<tr class="separator:ad2f40dea3086ce2e97bacb03d4317877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794fb95b5dbce1596be075d8898d58be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a794fb95b5dbce1596be075d8898d58be">m_rowno_being_visited</a></td></tr>
<tr class="memdesc:a794fb95b5dbce1596be075d8898d58be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: The number of the row being visited for its contribution to a window function, relative to the start of the partition.  <a href="#a794fb95b5dbce1596be075d8898d58be">More...</a><br /></td></tr>
<tr class="separator:a794fb95b5dbce1596be075d8898d58be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0fc7fc0abfbad9c8aaa1492240c54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a8a0fc7fc0abfbad9c8aaa1492240c54b">m_rowno_in_frame</a></td></tr>
<tr class="memdesc:a8a0fc7fc0abfbad9c8aaa1492240c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: the row number of the current row within a frame, cf.  <a href="#a8a0fc7fc0abfbad9c8aaa1492240c54b">More...</a><br /></td></tr>
<tr class="separator:a8a0fc7fc0abfbad9c8aaa1492240c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100dcb0cd123248943b0877b1958e9d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a100dcb0cd123248943b0877b1958e9d3">m_rowno_in_partition</a></td></tr>
<tr class="memdesc:a100dcb0cd123248943b0877b1958e9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: The row number of the current row being readied for output within the partition.  <a href="#a100dcb0cd123248943b0877b1958e9d3">More...</a><br /></td></tr>
<tr class="separator:a100dcb0cd123248943b0877b1958e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b039f74e30aaecabeb02800198edcaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a8b039f74e30aaecabeb02800198edcaa">m_aggregates_primed</a></td></tr>
<tr class="memdesc:a8b039f74e30aaecabeb02800198edcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: for optimizable aggregates, cf.  <a href="#a8b039f74e30aaecabeb02800198edcaa">More...</a><br /></td></tr>
<tr class="separator:a8b039f74e30aaecabeb02800198edcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e13895b07ee0d799f470b44992a4f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a1e13895b07ee0d799f470b44992a4f14">m_first_rowno_in_range_frame</a></td></tr>
<tr class="memdesc:a1e13895b07ee0d799f470b44992a4f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: the row number of the first row in a frame when evaluating RANGE based frame bounds.  <a href="#a1e13895b07ee0d799f470b44992a4f14">More...</a><br /></td></tr>
<tr class="separator:a1e13895b07ee0d799f470b44992a4f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d7b5922eb43a3b83d9fa8ca8712d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ad2d7b5922eb43a3b83d9fa8ca8712d58">m_last_rowno_in_range_frame</a></td></tr>
<tr class="memdesc:ad2d7b5922eb43a3b83d9fa8ca8712d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: used for RANGE bounds frame evaluation for the continued evaluation for current row &gt; 2 in a partition.  <a href="#ad2d7b5922eb43a3b83d9fa8ca8712d58">More...</a><br /></td></tr>
<tr class="separator:ad2d7b5922eb43a3b83d9fa8ca8712d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aacede481bcb89a62e6c118d1dca1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a02aacede481bcb89a62e6c118d1dca1a">m_is_last_row_in_frame</a></td></tr>
<tr class="memdesc:a02aacede481bcb89a62e6c118d1dca1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: the current row is the last row in a window frame For some aggregate functions, e.g AVG, we can save computation by not evaluating the entire function value before the last row has been read.  <a href="#a02aacede481bcb89a62e6c118d1dca1a">More...</a><br /></td></tr>
<tr class="separator:a02aacede481bcb89a62e6c118d1dca1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb44dc670100b86590b3fdd3f8bc07e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a5bb44dc670100b86590b3fdd3f8bc07e">m_do_copy_null</a></td></tr>
<tr class="memdesc:a5bb44dc670100b86590b3fdd3f8bc07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: make frame wf produce a NULL (or 0 depending, e.g.  <a href="#a5bb44dc670100b86590b3fdd3f8bc07e">More...</a><br /></td></tr>
<tr class="separator:a5bb44dc670100b86590b3fdd3f8bc07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfb1fcff13e5b844c1ea5ba39a5d6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a5cfb1fcff13e5b844c1ea5ba39a5d6d0">m_inverse_aggregation</a></td></tr>
<tr class="memdesc:a5cfb1fcff13e5b844c1ea5ba39a5d6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution state: do inverse, e.g.  <a href="#a5cfb1fcff13e5b844c1ea5ba39a5d6d0">More...</a><br /></td></tr>
<tr class="separator:a5cfb1fcff13e5b844c1ea5ba39a5d6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ada9b08a9f8e4f79d05abfc64b79a395e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ada9b08a9f8e4f79d05abfc64b79a395e">Window</a> (<a class="el" href="classItem__string.html">Item_string</a> *<a class="el" href="classWindow.html#a1f41db4ef8446e3e3a85134d5658fe7d">name</a>, <a class="el" href="classPT__order__list.html">PT_order_list</a> *part, <a class="el" href="classPT__order__list.html">PT_order_list</a> *ord, <a class="el" href="classPT__frame.html">PT_frame</a> *<a class="el" href="classWindow.html#ad5cc04aa3c3ecddbf9683da7851c6b22">frame</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classWindow.html#ab552c6855bb972ba76b316f2a990e41a">is_reference</a>, <a class="el" href="classItem__string.html">Item_string</a> *inherit)</td></tr>
<tr class="memdesc:ada9b08a9f8e4f79d05abfc64b79a395e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic window constructor, shared.  <a href="#ada9b08a9f8e4f79d05abfc64b79a395e">More...</a><br /></td></tr>
<tr class="separator:ada9b08a9f8e4f79d05abfc64b79a395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c8ecc7b4b13f333c7cd019f85c7d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#aa2c8ecc7b4b13f333c7cd019f85c7d97">reset_execution_state</a> (<a class="el" href="classWindow.html#ad1abdab0773d91d2963573ed5cf4edda">Reset_level</a> level)</td></tr>
<tr class="memdesc:aa2c8ecc7b4b13f333c7cd019f85c7d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common function for all types of resetting.  <a href="#aa2c8ecc7b4b13f333c7cd019f85c7d97">More...</a><br /></td></tr>
<tr class="separator:aa2c8ecc7b4b13f333c7cd019f85c7d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad6fc33e909946f0b8f14ec086753b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0ad6fc33e909946f0b8f14ec086753b5">before_or_after_frame</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> before)</td></tr>
<tr class="memdesc:a0ad6fc33e909946f0b8f14ec086753b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common implementation of before_frame() and after_frame().  <a href="#a0ad6fc33e909946f0b8f14ec086753b5">More...</a><br /></td></tr>
<tr class="separator:a0ad6fc33e909946f0b8f14ec086753b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5226891683e08b345ec182916864df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#acd5226891683e08b345ec182916864df">print_frame</a> (const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classString.html">String</a> *str, <a class="el" href="enum__query__type_8h.html#a84267bb0a3694b1d41b6494868ce18ac">enum_query_type</a> qt) const</td></tr>
<tr class="separator:acd5226891683e08b345ec182916864df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87462a516dd71e57c1af994399e7b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ad87462a516dd71e57c1af994399e7b9a">print_border</a> (const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classString.html">String</a> *str, <a class="el" href="classPT__border.html">PT_border</a> *b, <a class="el" href="enum__query__type_8h.html#a84267bb0a3694b1d41b6494868ce18ac">enum_query_type</a> qt) const</td></tr>
<tr class="separator:ad87462a516dd71e57c1af994399e7b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f34d6fb9daa6530b1a1332d05a19f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ac8f34d6fb9daa6530b1a1332d05a19f2">check_constant_bound</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classPT__border.html">PT_border</a> *border)</td></tr>
<tr class="memdesc:ac8f34d6fb9daa6530b1a1332d05a19f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that a frame border is constant during execution and that it does not contain subqueries (relevant for INTERVAL only): implementation limitation.  <a href="#ac8f34d6fb9daa6530b1a1332d05a19f2">More...</a><br /></td></tr>
<tr class="separator:ac8f34d6fb9daa6530b1a1332d05a19f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1d63a4813af408371d00d5768b4afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a4a1d63a4813af408371d00d5768b4afe">check_border_sanity1</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a4a1d63a4813af408371d00d5768b4afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that frame borders are sane; resolution phase.  <a href="#a4a1d63a4813af408371d00d5768b4afe">More...</a><br /></td></tr>
<tr class="separator:a4a1d63a4813af408371d00d5768b4afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0510a8e601fc206a09d9a1b3fa50fcf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a0510a8e601fc206a09d9a1b3fa50fcf4">check_border_sanity2</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:a0510a8e601fc206a09d9a1b3fa50fcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like check_border_sanity1() but contains checks which must wait until the start of the execution phase.  <a href="#a0510a8e601fc206a09d9a1b3fa50fcf4">More...</a><br /></td></tr>
<tr class="separator:a0510a8e601fc206a09d9a1b3fa50fcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ad2314586f8241e89419add89fc645e13"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#ad2314586f8241e89419add89fc645e13">reorder_and_eliminate_sorts</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;windows)</td></tr>
<tr class="memdesc:ad2314586f8241e89419add89fc645e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder windows and eliminate redundant ordering.  <a href="#ad2314586f8241e89419add89fc645e13">More...</a><br /></td></tr>
<tr class="separator:ad2314586f8241e89419add89fc645e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011ecd4e135385410857b47945baa0a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWindow.html#a011ecd4e135385410857b47945baa0a8">equal_sort</a> (<a class="el" href="classWindow.html">Window</a> *w1, <a class="el" href="classWindow.html">Window</a> *w2)</td></tr>
<tr class="memdesc:a011ecd4e135385410857b47945baa0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true of the physical[1] sort orderings for the two windows are the same, cf.  <a href="#a011ecd4e135385410857b47945baa0a8">More...</a><br /></td></tr>
<tr class="separator:a011ecd4e135385410857b47945baa0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the (explicit) window of a SQL 2003 section 7.11 &lt;window clause&gt;, or the implicit (inlined) window of a window function call, or a reference to a named window in a window function call (instead of the inlined definition) before resolution. </p>
<p>After resolving referencing instances become unused, having been replaced with the window resolved to in the w.f. call.</p>
<pre class="fragment">Cf. 7.11 &lt;window definition&gt; and &lt;existing window name&gt;
    6.10 &lt;window name or specification&gt; and
         &lt;in-line window specification&gt;
    5.4 &lt;window name&gt;
</pre><p>See also PT_window (which wraps Window as a parse_tree_node), and the related classes PT_frame, PT_border and PT_exclusion in parse_tree_nodes.</p>
<p>Currently includes both prepared query and execution state information. The latter is marked as such for ease of separation later. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad1abdab0773d91d2963573ed5cf4edda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1abdab0773d91d2963573ed5cf4edda">&#9670;&nbsp;</a></span>Reset_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classWindow.html#ad1abdab0773d91d2963573ed5cf4edda">Window::Reset_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad1abdab0773d91d2963573ed5cf4eddaa6cba3e64f6a5b5cd6fe040363b8fe8a9"></a>RL_FULL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad1abdab0773d91d2963573ed5cf4eddaa24fdeab51a63fc7f44000d9cace935c3"></a>RL_ROUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad1abdab0773d91d2963573ed5cf4eddaa349a30c361a14731a032d03546d4c925"></a>RL_PARTITION&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="acd4370dc1039029dd04e36ad5912a795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4370dc1039029dd04e36ad5912a795">&#9670;&nbsp;</a></span>Special_keys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795">Window::Special_keys</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keys for m_frame_buffer_cache and m_special_rows_cache, for special rows. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acd4370dc1039029dd04e36ad5912a795ab4a020d8f4b16e8cfec253f05373e1e2"></a>FBC_FIRST_IN_NEXT_PARTITION&#160;</td><td class="fielddoc"><p>We read an incoming row. </p>
<p>We notice it is the start of a new partition. We must thus process the just-finished partition, but that processing uses this row's buffer; so, we save this row first, process the partition, and restore it later. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4370dc1039029dd04e36ad5912a795a4618c13adf2be869f1b456ef57fbcd3f"></a>FBC_LAST_BUFFERED_ROW&#160;</td><td class="fielddoc"><p>The last row cached in the frame buffer; needed to resurrect input row. </p>
</td></tr>
<tr><td class="fieldname"><a id="acd4370dc1039029dd04e36ad5912a795aa62e2f406702d0ee4951a3442695139f"></a>FBC_FIRST_KEY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acd4370dc1039029dd04e36ad5912a795a3b575399866c3e5e3b0caaefcb025b80"></a>FBC_LAST_KEY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ada9b08a9f8e4f79d05abfc64b79a395e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9b08a9f8e4f79d05abfc64b79a395e">&#9670;&nbsp;</a></span>Window() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Window::Window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__string.html">Item_string</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td>
          <td class="paramname"><em>ord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__frame.html">PT_frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__string.html">Item_string</a> *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic window constructor, shared. </p>

</div>
</div>
<a id="a52f671af8e7c5531b73672865c39b4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f671af8e7c5531b73672865c39b4f5">&#9670;&nbsp;</a></span>Window() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Window::Window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__string.html">Item_string</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to a named window. </p>
<p>This kind is only used before resolution, references to it being replaced by the referenced window object thereafter. </p>

</div>
</div>
<a id="a64ea5b709b9cdcf4716fe50d1d89de04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ea5b709b9cdcf4716fe50d1d89de04">&#9670;&nbsp;</a></span>Window() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Window::Window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td>
          <td class="paramname"><em>partition_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td>
          <td class="paramname"><em>order_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__frame.html">PT_frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unnamed window. </p>
<p>If the window turns out to be named, the name will be set later, cf. set_name(). </p>

</div>
</div>
<a id="a8c7c66af3fe356c0900189b0c1567dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7c66af3fe356c0900189b0c1567dfe">&#9670;&nbsp;</a></span>Window() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Window::Window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td>
          <td class="paramname"><em>partition_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td>
          <td class="paramname"><em>order_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__frame.html">PT_frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__string.html">Item_string</a> *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unnamed window based on a named window. </p>
<p>If the window turns out to be named, the name will be set later, cf. set_name(). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27426a6440302a91461ab00cef8a5899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27426a6440302a91461ab00cef8a5899">&#9670;&nbsp;</a></span>after_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::after_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a400fc74c97d29d7e3a72f1dc3081bfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400fc74c97d29d7e3a72f1dc3081bfc0">&#9670;&nbsp;</a></span>aggregates_primed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::aggregates_primed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_aggregates_primed. </p>

</div>
</div>
<a id="a824e6fd952f270a08725286ed9ccec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824e6fd952f270a08725286ed9ccec01">&#9670;&nbsp;</a></span>at_partition_border()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::at_partition_border </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if we have read all the rows in a partition, possibly having buffered them for further processing. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is the case </dd></dl>

</div>
</div>
<a id="a94c51faca303360d8dac082df8d068e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c51faca303360d8dac082df8d068e2">&#9670;&nbsp;</a></span>before_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::before_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While processing buffered rows in RANGE frame mode we, determine if the present row revisited from the buffer is before the row being processed; i.e. </p>
<p>the current row.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the present row is before the RANGE, i.e. not to be includedSee before_frame() </dd></dl>

</div>
</div>
<a id="a0ad6fc33e909946f0b8f14ec086753b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad6fc33e909946f0b8f14ec086753b5">&#9670;&nbsp;</a></span>before_or_after_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::before_or_after_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>before</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common implementation of before_frame() and after_frame(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">before</td><td>True if 'before' is wanted; false if 'after' is. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a1d63a4813af408371d00d5768b4afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1d63a4813af408371d00d5768b4afe">&#9670;&nbsp;</a></span>check_border_sanity1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::check_border_sanity1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that frame borders are sane; resolution phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error </dd></dl>

</div>
</div>
<a id="a0510a8e601fc206a09d9a1b3fa50fcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0510a8e601fc206a09d9a1b3fa50fcf4">&#9670;&nbsp;</a></span>check_border_sanity2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::check_border_sanity2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like check_border_sanity1() but contains checks which must wait until the start of the execution phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error </dd></dl>

</div>
</div>
<a id="ac8f34d6fb9daa6530b1a1332d05a19f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f34d6fb9daa6530b1a1332d05a19f2">&#9670;&nbsp;</a></span>check_constant_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::check_constant_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__border.html">PT_border</a> *&#160;</td>
          <td class="paramname"><em>border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that a frame border is constant during execution and that it does not contain subqueries (relevant for INTERVAL only): implementation limitation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session thread </td></tr>
    <tr><td class="paramname">border</td><td>The border to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if OK, true if error </dd></dl>

</div>
</div>
<a id="adea57e0b6638bb7fe383ca2f67bdad67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea57e0b6638bb7fe383ca2f67bdad67">&#9670;&nbsp;</a></span>check_partition_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::check_partition_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the just read input row marks the start of a new partition. </p>
<p>Sets the member variables:</p>
<p>m_partition_border and m_part_row_number </p>
<p>If we have partitioning and any one of the partitioning columns have changed since last row, we have a new partition.</p>

</div>
</div>
<a id="a3a87fbada3d8e8947ecfd7c1dbc5ea78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a87fbada3d8e8947ecfd7c1dbc5ea78">&#9670;&nbsp;</a></span>check_unique_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::check_unique_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>windows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this window's name is not unique in windows. </p>

</div>
</div>
<a id="a88c28dbd791854c7bced5968e9a490db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c28dbd791854c7bced5968e9a490db">&#9670;&nbsp;</a></span>check_window_functions1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::check_window_functions1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the semantic requirements for window functions over this window are fulfilled, and accumulate evaluation requirements. </p>
<p>This is run at resolution. </p>

</div>
</div>
<a id="a59de85a00fc7292924e497e2e4014e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59de85a00fc7292924e497e2e4014e05">&#9670;&nbsp;</a></span>check_window_functions2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::check_window_functions2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like check_window_functions1() but contains checks which must wait until the start of the execution phase. </p>

</div>
</div>
<a id="a27c2531e56f7ac0440c1890f327d15ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2531e56f7ac0440c1890f327d15ff">&#9670;&nbsp;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::cleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free up any resource used to process the window functions of this window, e.g. </p>
<p>temporary files and in-memory data structures. Called when done with all window processing steps from SELECT_LEX::cleanup. </p>

</div>
</div>
<a id="aaaeb479455b291bd970312d6b1f0fca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaeb479455b291bd970312d6b1f0fca6">&#9670;&nbsp;</a></span>compute_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Window::compute_cost </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>windows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute sorting costs for windowing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost</td><td>Cost of sorting result set once </td></tr>
    <tr><td class="paramname">windows</td><td>The set of windows</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the aggregated sorting costs of the windowing </dd></dl>

</div>
</div>
<a id="a2a05cd78c25c41cd82e91da74aca63f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a05cd78c25c41cd82e91da74aca63f7">&#9670;&nbsp;</a></span>copy_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::copy_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a>&#160;</td>
          <td class="paramname"><em>from_reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a>&#160;</td>
          <td class="paramname"><em>to_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy frame buffer position hint from one to another. </p>

</div>
</div>
<a id="ada67710bbdbe70e79d1a5e358a650352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada67710bbdbe70e79d1a5e358a650352">&#9670;&nbsp;</a></span>def_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Window::def_pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>m_def_pos </dd></dl>

</div>
</div>
<a id="aa89262ad2538473c8d7e4d8dd641849d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89262ad2538473c8d7e4d8dd641849d">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free structures that were set up during preparation of window functions. </p>

</div>
</div>
<a id="ab3c27b87499dd88acc0f95db4d1d02f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c27b87499dd88acc0f95db4d1d02f4">&#9670;&nbsp;</a></span>do_copy_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::do_copy_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_do_copy_null. </p>

</div>
</div>
<a id="aa7fc427740f0edee7ac124636be94d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fc427740f0edee7ac124636be94d32">&#9670;&nbsp;</a></span>do_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::do_inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_inverse_aggregation. </p>

</div>
</div>
<a id="aaa7c710a8b30918145c2d8852c59e38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7c710a8b30918145c2d8852c59e38d">&#9670;&nbsp;</a></span>effective_order_by()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPT__order__list.html">PT_order_list</a>* Window::effective_order_by </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ORDER BY, if any. </p>
<p>That is, the first we find along the ancestor chain. Uniqueness checked in setup_windows1 SQL 2011 7.11 GR 1.b.i.5.A-C </p>

</div>
</div>
<a id="a01ab8ce122fbc31b8227b65398e6022b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ab8ce122fbc31b8227b65398e6022b">&#9670;&nbsp;</a></span>effective_partition_by()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPT__order__list.html">PT_order_list</a>* Window::effective_partition_by </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get partition, if any. </p>
<p>That is, the partition if any, of the root window. SQL 2011 7.11 GR 1.b.i.4.A-C </p>

</div>
</div>
<a id="a011ecd4e135385410857b47945baa0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011ecd4e135385410857b47945baa0a8">&#9670;&nbsp;</a></span>equal_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::equal_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWindow.html">Window</a> *&#160;</td>
          <td class="paramname"><em>w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWindow.html">Window</a> *&#160;</td>
          <td class="paramname"><em>w2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true of the physical[1] sort orderings for the two windows are the same, cf. </p>
<p>guarantee of SQL 2014 4.15.15 Windowed tables bullet two: The windowing functions are computed using the same row ordering if they specify the same ordering.</p>
<p>Collation and null handling is not supported, so moot.</p>
<p>The two other bullet points are also covered by this test.</p>
<p>[1] After concatenating effective PARTITION BY and ORDER BY (including inheritance) expressions. </p>

</div>
</div>
<a id="a6b2b9ef3da74f4028903128ea1770eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2b9ef3da74f4028903128ea1770eed">&#9670;&nbsp;</a></span>first_order_by()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a> * Window::first_order_by </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first argument of the ORDER BY clause for this window if any. </p>
<p>"ORDER BY" is not checked in ancestor unlike effective_order_by(). Use when the goal is to operate on the set of item clauses for all windows of a query. When interrogating the effective order by for a window (specified for it or inherited from another window) use effective_order_by(). </p>

</div>
</div>
<a id="aa75448526f76b24bffe4dc2245ef63ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75448526f76b24bffe4dc2245ef63ff">&#9670;&nbsp;</a></span>first_partition_by()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a> * Window::first_partition_by </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first argument of the PARTITION clause for this window if any. </p>
<p>"PARTITION BY" is not checked in ancestor unlike effective_partition_by(). Use when the goal is to operate on the set of item clauses for all windows of a query. When interrogating the effective partition by for a window (specified for it or inherited from another window) use effective_partition_by(). </p>

</div>
</div>
<a id="a25304b705102e40e3e7035ab26ef4281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25304b705102e40e3e7035ab26ef4281">&#9670;&nbsp;</a></span>first_rowno_in_range_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::first_rowno_in_range_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_first_rowno_in_range_frame. </p>

</div>
</div>
<a id="ad5cc04aa3c3ecddbf9683da7851c6b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cc04aa3c3ecddbf9683da7851c6b22">&#9670;&nbsp;</a></span>frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPT__frame.html">PT_frame</a>* Window::frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the frame, if any. </p>
<p>SQL 2011 7.11 GR 1.b.i.6 </p>

</div>
</div>
<a id="a3db276e3aadcb170aef5f5867f0a4093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db276e3aadcb170aef5f5867f0a4093">&#9670;&nbsp;</a></span>frame_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* Window::frame_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for m_frame_buffer, q.v. </p>

</div>
</div>
<a id="ada05c0467175f4809da720968d71b754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada05c0467175f4809da720968d71b754">&#9670;&nbsp;</a></span>frame_buffer_param()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTemp__table__param.html">Temp_table_param</a>* Window::frame_buffer_param </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for m_frame_buffer_param, q.v. </p>

</div>
</div>
<a id="aebba3282a95d28b241853110f07520aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebba3282a95d28b241853110f07520aa">&#9670;&nbsp;</a></span>frame_buffer_partition_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::frame_buffer_partition_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_frame_buffer_partition_offset. </p>

</div>
</div>
<a id="a502a019632199a5527a57264d2c38a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502a019632199a5527a57264d2c38a77">&#9670;&nbsp;</a></span>frame_buffer_total_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::frame_buffer_total_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_frame_buffer_total_rows. </p>

</div>
</div>
<a id="a57e1fc73a241169d5e2d609f760b333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e1fc73a241169d5e2d609f760b333b">&#9670;&nbsp;</a></span>functions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classList.html">List</a>&lt;<a class="el" href="classItem__sum.html">Item_sum</a>&gt;&amp; Window::functions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of functions invoked on this window. </p>

</div>
</div>
<a id="ae642e6a89f11a19205dfb2bd5607ea75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae642e6a89f11a19205dfb2bd5607ea75">&#9670;&nbsp;</a></span>has_windowing_steps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::has_windowing_steps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b7f3cf9831c264d78791db7473a6ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7f3cf9831c264d78791db7473a6ee3">&#9670;&nbsp;</a></span>in_new_order_by_peer_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::in_new_order_by_peer_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>compare_all_order_by_items</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the current row is not in the same peer set as the previous row. </p>
<p>Used for RANGE frame and implicit RANGE frame (the latter is used by aggregates in the presence of ORDER BY).</p>
<p>The current row is in the same peer set if all ORDER BY columns have the same value as in the previous row.</p>
<p>For JSON_OBJECTAGG only the first order by column needs to be compared to check if a row is in peer set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare_all_order_by_items</td><td>If true, compare all the order by items to determine if a row is in peer set. Else, compare only the first order by item to determine peer set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if current row is in a new peer set </dd></dl>

</div>
</div>
<a id="ac9b1846e6e0a24207674c5eedfd34561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b1846e6e0a24207674c5eedfd34561">&#9670;&nbsp;</a></span>is_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::is_last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last. </p>

</div>
</div>
<a id="a6cef719ee622b79be8ef4724faf528cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cef719ee622b79be8ef4724faf528cb">&#9670;&nbsp;</a></span>is_last_row_in_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::is_last_row_in_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_is_last_row_in_frame. </p>

</div>
</div>
<a id="a8f9a2b5b1353bd02183a9705c8cdfa55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9a2b5b1353bd02183a9705c8cdfa55">&#9670;&nbsp;</a></span>is_last_row_in_peerset_within_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::is_last_row_in_peerset_within_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_is_last_row_in_peerset_within_frame. </p>

</div>
</div>
<a id="ab552c6855bb972ba76b316f2a990e41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab552c6855bb972ba76b316f2a990e41a">&#9670;&nbsp;</a></span>is_reference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::is_reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if this window represents an unresolved window reference seen in a window function OVER clause. </p>

</div>
</div>
<a id="a97df217d2998bfc76d5d1ac0c8067e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97df217d2998bfc76d5d1ac0c8067e64">&#9670;&nbsp;</a></span>last_row_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::last_row_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_row_output. </p>

</div>
</div>
<a id="af654adb66a91ceb82fb2b1728b8f0a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af654adb66a91ceb82fb2b1728b8f0a76">&#9670;&nbsp;</a></span>last_rowno_in_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::last_rowno_in_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_rowno_in_cache. </p>

</div>
</div>
<a id="ac3b4b07aed9cb072e570b7162f204879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b4b07aed9cb072e570b7162f204879">&#9670;&nbsp;</a></span>last_rowno_in_peerset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::last_rowno_in_peerset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_rowno_in_peerset. </p>

</div>
</div>
<a id="a076d4cf1c54d6c83f31977e22ff61afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076d4cf1c54d6c83f31977e22ff61afc">&#9670;&nbsp;</a></span>last_rowno_in_range_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::last_rowno_in_range_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_rowno_in_range_frame. </p>

</div>
</div>
<a id="a460c43de63e39d108bb38ac56cdf2dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460c43de63e39d108bb38ac56cdf2dac">&#9670;&nbsp;</a></span>make_special_rows_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::make_special_rows_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>out_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the cache for special rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">out_tbl</td><td>The table where this window function's value is written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error. </dd></dl>

</div>
</div>
<a id="a1f41db4ef8446e3e3a85134d5658fe7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f41db4ef8446e3e3a85134d5658fe7d">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__string.html">Item_string</a>* Window::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of a window. </p>
<p>Can be empty, cf. printable_name which is not. </p>

</div>
</div>
<a id="a575e7bc09584f7c853e4940e170e228b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575e7bc09584f7c853e4940e170e228b">&#9670;&nbsp;</a></span>needs_buffering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::needs_buffering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we cannot compute one of window functions without looking at succeeding rows, return true, else false. </p>

</div>
</div>
<a id="ababaeb649cb3b579e216bb8e18145b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababaeb649cb3b579e216bb8e18145b91">&#9670;&nbsp;</a></span>needs_card()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::needs_card </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we need to read the entire partition before we can evaluate some window function(s) on this window,. </p>
<dl class="section return"><dt>Returns</dt><dd>true if that is the case, else false </dd></dl>

</div>
</div>
<a id="a068cd0671aae0f28f0c8e68536fea2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068cd0671aae0f28f0c8e68536fea2eb">&#9670;&nbsp;</a></span>needs_last_peer_in_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::needs_last_peer_in_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we cannot compute one of window functions without looking at all rows in the peerset of the current row in this frame, return true, else false. </p>
<p>E.g. JSON_OBJECTAGG. </p>

</div>
</div>
<a id="acda722c65501ed833321f9cd7d16a41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda722c65501ed833321f9cd7d16a41e">&#9670;&nbsp;</a></span>needs_peerset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::needs_peerset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we cannot compute one of window functions without looking at all rows in the peerset of the current row, return true, else false. </p>
<p>E.g. CUME_DIST. </p>

</div>
</div>
<a id="af4f046772a208b624fc57a77f08ecf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f046772a208b624fc57a77f08ecf5b">&#9670;&nbsp;</a></span>needs_restore_input_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::needs_restore_input_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_needs_restore_input_row. </p>

</div>
</div>
<a id="a91f7ea6b5cd627fb8ed3f42e35e85659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f7ea6b5cd627fb8ed3f42e35e85659">&#9670;&nbsp;</a></span>needs_sorting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::needs_sorting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the window had either a partition clause (inclusive) or a ORDER BY clause, either defined by itself or inherited from another window. </p>
<dl class="section return"><dt>Returns</dt><dd>true if we have such a clause, which means we need to sort the input table before evaluating the window functions, unless it has been made redundant by a previous windowing step, cf. reorder_and_eliminate_sorts, or due to a single row result set, cf. SELECT_LEX::is_implicitly_grouped(). </dd></dl>

</div>
</div>
<a id="a6ebc242f5aa9a2ed75b7c3df47e922f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebc242f5aa9a2ed75b7c3df47e922f7">&#9670;&nbsp;</a></span>opt_first_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::opt_first_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_opt_first_row. </p>

</div>
</div>
<a id="a0d6bfa76488853925dc6790c8df0532f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6bfa76488853925dc6790c8df0532f">&#9670;&nbsp;</a></span>opt_last_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::opt_last_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_opt_last_row. </p>

</div>
</div>
<a id="a5b8ed36e63b1d764d6b2c198061bf765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8ed36e63b1d764d6b2c198061bf765">&#9670;&nbsp;</a></span>opt_lead_lag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structWindow_1_1st__lead__lag.html">st_lead_lag</a>&amp; Window::opt_lead_lag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_opt_lead_lag. </p>

</div>
</div>
<a id="aa89929fd75370740ec6403630420b7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89929fd75370740ec6403630420b7f7">&#9670;&nbsp;</a></span>opt_nth_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structWindow_1_1st__nth.html">st_nth</a>&amp; Window::opt_nth_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_opt_nth_row. </p>

</div>
</div>
<a id="ade0d0f6baea34cd23bc9e89a6456ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0d0f6baea34cd23bc9e89a6456ae1a">&#9670;&nbsp;</a></span>optimizable_range_aggregates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::optimizable_range_aggregates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the set of window functions are all RANGE unit optimizable. </p>
<p>Only relevant if m_needs_buffering and m_range_optimizable are true. </p>

</div>
</div>
<a id="ac5e70f4dfb65c24741c6c886f32110ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e70f4dfb65c24741c6c886f32110ab">&#9670;&nbsp;</a></span>optimizable_row_aggregates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::optimizable_row_aggregates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the set of window functions are all ROW unit optimizable. </p>
<p>Only relevant if m_needs_buffering and m_row_optimizable are true. </p>

</div>
</div>
<a id="a687e9949d29ff808d1fb1c2bff2d6579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687e9949d29ff808d1fb1c2bff2d6579">&#9670;&nbsp;</a></span>outtable_param()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTemp__table__param.html">Temp_table_param</a>* Window::outtable_param </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for m_outtable_param, q.v. </p>

</div>
</div>
<a id="aa0b53e1d1beeeb61008d4611b401f33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b53e1d1beeeb61008d4611b401f33b">&#9670;&nbsp;</a></span>partition_rowno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::partition_rowno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for m_part_row_number, q.v., the current row number within the partition. </p>

</div>
</div>
<a id="adc15dca1a3b5e323d26334f8d114ddbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc15dca1a3b5e323d26334f8d114ddbe">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="enum__query__type_8h.html#a84267bb0a3694b1d41b6494868ce18ac">enum_query_type</a>&#160;</td>
          <td class="paramname"><em>qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>expand_definition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad87462a516dd71e57c1af994399e7b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87462a516dd71e57c1af994399e7b9a">&#9670;&nbsp;</a></span>print_border()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::print_border </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__border.html">PT_border</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="enum__query__type_8h.html#a84267bb0a3694b1d41b6494868ce18ac">enum_query_type</a>&#160;</td>
          <td class="paramname"><em>qt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd5226891683e08b345ec182916864df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5226891683e08b345ec182916864df">&#9670;&nbsp;</a></span>print_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::print_frame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="enum__query__type_8h.html#a84267bb0a3694b1d41b6494868ce18ac">enum_query_type</a>&#160;</td>
          <td class="paramname"><em>qt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab33261521eb1351568fe104d0fefd6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33261521eb1351568fe104d0fefd6b0">&#9670;&nbsp;</a></span>printable_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Window::printable_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56f0eeb27ae12bf2cae3f89f9da937d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f0eeb27ae12bf2cae3f89f9da937d9">&#9670;&nbsp;</a></span>reinit_before_use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reinit_before_use </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset resolution and execution state to prepare for next execution of a prepared statement. </p>

</div>
</div>
<a id="a84e38184def3c475078ea487f8d1235e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e38184def3c475078ea487f8d1235e">&#9670;&nbsp;</a></span>remove_unused_windows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::remove_unused_windows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>windows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove unused window definitions. </p>
<p>Do this only after syntactic and semantic checking for errors has been performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The session's execution thread </td></tr>
    <tr><td class="paramname">windows</td><td>The list of windows defined for this select </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2314586f8241e89419add89fc645e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2314586f8241e89419add89fc645e13">&#9670;&nbsp;</a></span>reorder_and_eliminate_sorts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reorder_and_eliminate_sorts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>windows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorder windows and eliminate redundant ordering. </p>
<p>If a window has the same ordering requirements as another, we will move them next to each other in the evaluation sequence, so we can sort only once, i.e. before the first window step. This allows us to fulfill the guarantee given by SQL standard when it comes to repeatability of non-deterministic (partially ordered) result sets for windowing inside a query, cf. equal_sort. If more than two have the same ordering, the same applies, we only sort before the first (sort equivalent) window.</p>
<p>If the result set is implicitly grouped, we also skip any sorting for windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windows</td><td>list of windows </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af3655b68cb63d000f6a0956dc6708a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af3655b68cb63d000f6a0956dc6708a">&#9670;&nbsp;</a></span>reset_all_wf_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reset_all_wf_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the execution state for all window functions defined on this window. </p>

</div>
</div>
<a id="aa2c8ecc7b4b13f333c7cd019f85c7d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c8ecc7b4b13f333c7cd019f85c7d97">&#9670;&nbsp;</a></span>reset_execution_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reset_execution_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWindow.html#ad1abdab0773d91d2963573ed5cf4edda">Reset_level</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common function for all types of resetting. </p>

</div>
</div>
<a id="ab9d44350e47688e24e333125143b23fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d44350e47688e24e333125143b23fc">&#9670;&nbsp;</a></span>reset_lead_lag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reset_lead_lag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset execution state for LEAD/LAG for the current row in partition. </p>

</div>
</div>
<a id="a068df09c65b7531f3cb4dac516e20d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068df09c65b7531f3cb4dac516e20d8f">&#9670;&nbsp;</a></span>reset_order_by_peer_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reset_order_by_peer_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the current row's ORDER BY expressions when starting a new peer set. </p>

</div>
</div>
<a id="a1e43cbaf2e782e53ca0d368308d2f94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e43cbaf2e782e53ca0d368308d2f94c">&#9670;&nbsp;</a></span>reset_partition_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reset_partition_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset window state for a new partition. </p>
<p>Reset the temporary storage used for window frames, typically when we find a new partition. The rows in the buffer are then no longer needed. </p>

</div>
</div>
<a id="abc1da9fee9ddb97d7a5520e86bb72452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1da9fee9ddb97d7a5520e86bb72452">&#9670;&nbsp;</a></span>reset_round()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::reset_round </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset execution state for next call to JOIN::exec, cf. </p>
<p>JOIN::reset, or using [Buffering]WindowingIterator::Init. </p>

</div>
</div>
<a id="a4b2545287b4cccb328b43df7c2941a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2545287b4cccb328b43df7c2941a0c">&#9670;&nbsp;</a></span>resolve_reference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::resolve_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> *&#160;</td>
          <td class="paramname"><em>wf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPT__window.html">PT_window</a> **&#160;</td>
          <td class="paramname"><em>m_window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve any named window to its definition and update m_window to point to the definition instead. </p>

</div>
</div>
<a id="a0b0de6227a07de8acdaae828af600833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0de6227a07de8acdaae828af600833">&#9670;&nbsp;</a></span>resolve_window_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::resolve_window_ordering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>partition_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve and set up the PARTITION BY or an ORDER BY list of a window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The session's execution thread </td></tr>
    <tr><td class="paramname">ref_item_array</td><td>The base ref items </td></tr>
    <tr><td class="paramname">tables</td><td>The list of tables involved </td></tr>
    <tr><td class="paramname">fields</td><td>The list of all fields, including hidden ones </td></tr>
    <tr><td class="paramname">o</td><td>A list of order by expressions </td></tr>
    <tr><td class="paramname">partition_order</td><td>If true, o represent a windowing PARTITION BY, else it represents a windowing ORDER BY </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ae3e270a2d26c26ce8ff55e2ceb163e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e270a2d26c26ce8ff55e2ceb163e08">&#9670;&nbsp;</a></span>restore_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::restore_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a>&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_tmp_pos. </p>

</div>
</div>
<a id="a42f719c44d707e5f713b8a508b0fd52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f719c44d707e5f713b8a508b0fd52a">&#9670;&nbsp;</a></span>row_has_fields_in_out_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::row_has_fields_in_out_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_row_has_fields_in_out_table. </p>

</div>
</div>
<a id="add3b90334621a4011707563afc0faa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3b90334621a4011707563afc0faa27">&#9670;&nbsp;</a></span>rowno_being_visited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::rowno_being_visited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_rowno_being_visited. </p>

</div>
</div>
<a id="a4ac5c168dd9a8c6a40a66a30583fca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac5c168dd9a8c6a40a66a30583fca2c">&#9670;&nbsp;</a></span>rowno_in_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::rowno_in_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the frame in number of rows. </p>
<dl class="section return"><dt>Returns</dt><dd>frame size See m_rowno_in_frame </dd></dl>

</div>
</div>
<a id="a0206fd0843b62659b7fdc0dda2019c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0206fd0843b62659b7fdc0dda2019c25">&#9670;&nbsp;</a></span>rowno_in_partition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::rowno_in_partition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_rowno_in_partition. </p>

</div>
</div>
<a id="a95b0aea4fd06cb60b0d4799c160f833f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b0aea4fd06cb60b0d4799c160f833f">&#9670;&nbsp;</a></span>save_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::save_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a>&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_tmp_pos. </p>

</div>
</div>
<a id="aed86c074d30075ddabe9decb5a2372f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed86c074d30075ddabe9decb5a2372f3">&#9670;&nbsp;</a></span>set_aggregates_primed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_aggregates_primed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_aggregates_primed. </p>

</div>
</div>
<a id="a8ef7fcb16a29b9f7437f80d34ef728f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef7fcb16a29b9f7437f80d34ef728f4">&#9670;&nbsp;</a></span>set_ancestor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_ancestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWindow.html">Window</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After resolving an existing window name reference in a window definition, we set the ancestor pointer to easy access later. </p>

</div>
</div>
<a id="a183ec945821c6b62836322c0832049cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183ec945821c6b62836322c0832049cb">&#9670;&nbsp;</a></span>set_def_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_def_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>m_def_pos </dd></dl>

</div>
</div>
<a id="afb8fc05e57c149b0c22b72b414e46608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8fc05e57c149b0c22b72b414e46608">&#9670;&nbsp;</a></span>set_do_copy_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_do_copy_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_do_copy_null. </p>

</div>
</div>
<a id="a37b5169f16d3479c9dd078a83adab157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b5169f16d3479c9dd078a83adab157">&#9670;&nbsp;</a></span>set_first_rowno_in_range_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_first_rowno_in_range_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rowno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_first_rowno_in_range_frame. </p>

</div>
</div>
<a id="a4e4fa7833379ad91e58e022e5be66d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4fa7833379ad91e58e022e5be66d79">&#9670;&nbsp;</a></span>set_frame_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_frame_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for m_frame_buffer, q.v. </p>

</div>
</div>
<a id="a4b2aa17761fdd6bb0b06a78a46ecfe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2aa17761fdd6bb0b06a78a46ecfe9e">&#9670;&nbsp;</a></span>set_frame_buffer_param()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_frame_buffer_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for m_frame_buffer_param, q.v. </p>

</div>
</div>
<a id="abf06c4e9907c3255ee5f2d782f875a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf06c4e9907c3255ee5f2d782f875a3b">&#9670;&nbsp;</a></span>set_frame_buffer_partition_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_frame_buffer_partition_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_frame_buffer_partition_offset. </p>

</div>
</div>
<a id="ae9e7936f935c13637e39373ec43c37ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e7936f935c13637e39373ec43c37ab">&#9670;&nbsp;</a></span>set_frame_buffer_total_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_frame_buffer_total_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_frame_buffer_total_rows. </p>

</div>
</div>
<a id="ab8f866028034436425a5c44bd70f0cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f866028034436425a5c44bd70f0cfe">&#9670;&nbsp;</a></span>set_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWindow.html">Window</a>&amp; Window::set_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_inverse_aggregation. </p>

</div>
</div>
<a id="aed1355142ce82e6669ba4251438261bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1355142ce82e6669ba4251438261bb">&#9670;&nbsp;</a></span>set_is_last_row_in_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_is_last_row_in_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_is_last_row_in_frame. </p>

</div>
</div>
<a id="a6db435963ca6dda1c5dbfa964d67770e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db435963ca6dda1c5dbfa964d67770e">&#9670;&nbsp;</a></span>set_is_last_row_in_peerset_within_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_is_last_row_in_peerset_within_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_is_last_row_in_peerset_within_frame. </p>

</div>
</div>
<a id="a8f6f6d07efa04796b38196522728d8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f6d07efa04796b38196522728d8c8">&#9670;&nbsp;</a></span>set_last_row_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_last_row_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_row_output. </p>

</div>
</div>
<a id="ab92af7504ac7ba66e9994c1895ec3677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92af7504ac7ba66e9994c1895ec3677">&#9670;&nbsp;</a></span>set_last_rowno_in_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_last_rowno_in_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td>
          <td class="paramname"><em>rno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_rowno_in_cache. </p>

</div>
</div>
<a id="a9d7db13aa61ec8ede42fd8c2916ea730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7db13aa61ec8ede42fd8c2916ea730">&#9670;&nbsp;</a></span>set_last_rowno_in_peerset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_last_rowno_in_peerset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td>
          <td class="paramname"><em>rno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_rowno_in_peerset. </p>

</div>
</div>
<a id="a148f15c47457c9b5ceb14ecedeeb3ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148f15c47457c9b5ceb14ecedeeb3ef1">&#9670;&nbsp;</a></span>set_last_rowno_in_range_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_last_rowno_in_range_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td>
          <td class="paramname"><em>rno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_last_rowno_in_range_frame. </p>

</div>
</div>
<a id="a712c4eb7d7170bffaeb5a8d3ebc19274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712c4eb7d7170bffaeb5a8d3ebc19274">&#9670;&nbsp;</a></span>set_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__string.html">Item_string</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We have a named window. </p>
<p>Now set its name. Used once, if at all, for a window as part of parsing. </p>

</div>
</div>
<a id="a6611c566d596c0aaffd9f01fdfae38c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6611c566d596c0aaffd9f01fdfae38c6">&#9670;&nbsp;</a></span>set_needs_restore_input_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_needs_restore_input_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_needs_restore_input_row. </p>

</div>
</div>
<a id="a99bd08f876de6bb6ce7ab6c424b7f687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bd08f876de6bb6ce7ab6c424b7f687">&#9670;&nbsp;</a></span>set_outtable_param()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_outtable_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for m_outtable_param, q.v. </p>

</div>
</div>
<a id="a30d7f64d0e916d27a300f2e4fe4ad40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d7f64d0e916d27a300f2e4fe4ad40c">&#9670;&nbsp;</a></span>set_row_has_fields_in_out_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_row_has_fields_in_out_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rowno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_row_has_fields_in_out_table. </p>

</div>
</div>
<a id="aada96ea4b7c867e24e884f64d1a5c39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada96ea4b7c867e24e884f64d1a5c39f">&#9670;&nbsp;</a></span>set_rowno_being_visited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_rowno_being_visited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_rowno_being_visited. </p>

</div>
</div>
<a id="a823ff8c353ee4278ec9d4f3b4e03dcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823ff8c353ee4278ec9d4f3b4e03dcb2">&#9670;&nbsp;</a></span>set_rowno_in_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWindow.html">Window</a>&amp; Window::set_rowno_in_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rowno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_rowno_in_frame. </p>

</div>
</div>
<a id="ae0bc5d170459a069cc26928e7fd7f298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bc5d170459a069cc26928e7fd7f298">&#9670;&nbsp;</a></span>set_rowno_in_partition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Window::set_rowno_in_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rowno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See m_rowno_in_partition. </p>

</div>
</div>
<a id="a99d6abbfbe9374479fc265a15a5450b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d6abbfbe9374479fc265a15a5450b0">&#9670;&nbsp;</a></span>setup_ordering_cached_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::setup_ordering_cached_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPT__order__list.html">PT_order_list</a> *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>partition_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up cached items for an partition or an order by list updating m_partition_items or m_order_by_items respectively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The session's execution thread </td></tr>
    <tr><td class="paramname">select</td><td>The select for which we are doing windowing </td></tr>
    <tr><td class="paramname">o</td><td>The list of ordering expressions </td></tr>
    <tr><td class="paramname">partition_order</td><td>If true, o represents a partition order list, else an ORDER BY list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="a9a431e502ca0299cc0f0dd291d5d6f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a431e502ca0299cc0f0dd291d5d6f25">&#9670;&nbsp;</a></span>setup_range_expressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::setup_range_expressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For RANGE frames we need to do computations involving add/subtract and less than, smaller than. </p>
<p>To make this work across types, we construct item trees to do the computations, so we can reuse all the special case handling, e.g. for signed/unsigned int wrap-around, overflow etc. </p>

</div>
</div>
<a id="a8efd1bbf31b37ebba389ec799419e801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efd1bbf31b37ebba389ec799419e801">&#9670;&nbsp;</a></span>setup_windows1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::setup_windows1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>windows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Semantic checking of windows. </p>
<p>Run at resolution.</p>
<p>Process any window inheritance, that is a window, that in its specification refer to another named window.</p>
<p>Rules: 1) There should be no loops 2) The inheriting window can not specify partitioning 3) The inheriting window can not specify is already specify by an ancestor. 4) An ancestor can not specify window framing clause.</p>
<p>Cf. SQL 2011 7.11 window clause SR 10-11.</p>
<p>Check requirements to the window from its using window functions and make a note of those so we know at execution time, for example if we need to buffer rows to process the window functions, whether inversion optimzation will be used for moving frames etc.</p>
<p>Prepare the physical ordering lists used by sorting at execution time.</p>
<p>Set up cached items for partition determination and for range/peer determination based on order by columns.</p>
<p>Check any frame semantics and for RANGE frames, set up bounds computation item trees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The session's execution thread </td></tr>
    <tr><td class="paramname">select</td><td>The select for which we are doing windowing </td></tr>
    <tr><td class="paramname">ref_item_array</td><td>The base ref items </td></tr>
    <tr><td class="paramname">tables</td><td>The list of tables involved </td></tr>
    <tr><td class="paramname">fields</td><td>The list of all fields, including hidden ones </td></tr>
    <tr><td class="paramname">windows</td><td>The list of windows defined for this select</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="a0173d80c9786966af8d12eaac5414b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0173d80c9786966af8d12eaac5414b21">&#9670;&nbsp;</a></span>setup_windows2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::setup_windows2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classWindow.html">Window</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>windows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like setup_windows1() but contains operations which must wait until the start of the execution phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The session's execution thread </td></tr>
    <tr><td class="paramname">select</td><td>The select for which we are doing windowing </td></tr>
    <tr><td class="paramname">windows</td><td>The list of windows defined for this select</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="af82848ef9f2a022697b29d13decef1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82848ef9f2a022697b29d13decef1ac">&#9670;&nbsp;</a></span>sorting_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a> * Window::sorting_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>implicit_grouping</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenation of columns in PARTITION BY and ORDER BY. </p>
<p>Columns present in both list (redundancies) are eliminated, while making sure the order of columns in the ORDER BY is maintained in the merged list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Optional. Session state. If not nullptr, initialize the cache.</td></tr>
    <tr><td class="paramname">implicit_grouping</td><td>Optional. If true, we won't sort (single row result set). Presence implies thd != nullptr for the first call when we lazily set up this information. Succeeding calls return the cached value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The start of the concatenated ordering expressions, or nullptr </dd></dl>

</div>
</div>
<a id="a235f5d841e5191626d716038a6d2713b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235f5d841e5191626d716038a6d2713b">&#9670;&nbsp;</a></span>static_aggregates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::static_aggregates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the aggregates are static, i.e. </p>
<p>the same aggregate values for all rows in partition. Only relevant if m_needs_buffering is true. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7791674012b0ed3d0e891f53e521a575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7791674012b0ed3d0e891f53e521a575">&#9670;&nbsp;</a></span>FRAME_BUFFER_POSITIONS_CARD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Window::FRAME_BUFFER_POSITIONS_CARD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7fa53f4d96b33c0bda32aec8530304661c2">Window_retrieve_cached_row_reason::MISC_POSITIONS</a>)</div></div><!-- fragment -->
<p>Cardinality of m_frame_buffer_positions if no NTH_VALUE, LEAD/LAG. </p>

</div>
</div>
<a id="a8b039f74e30aaecabeb02800198edcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b039f74e30aaecabeb02800198edcaa">&#9670;&nbsp;</a></span>m_aggregates_primed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_aggregates_primed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: for optimizable aggregates, cf. </p>
<p>m_row_optimizable and m_range_optimizable, we need to keep track of when we have computed the first aggregate, since aggregates for rows 2..N are computed in an optimized way by inverse aggregation of the row moving out of the frame. </p>

</div>
</div>
<a id="a38996f07642a040a1b70d791d6bca516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38996f07642a040a1b70d791d6bca516">&#9670;&nbsp;</a></span>m_ancestor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classWindow.html">Window</a>* Window::m_ancestor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resolved from existing window name </p>

</div>
</div>
<a id="a0a6335e70f5e0fc0b35c1672484afaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6335e70f5e0fc0b35c1672484afaea">&#9670;&nbsp;</a></span>m_comparators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__func.html">Item_func</a>* Window::m_comparators[<a class="el" href="window__lex_8h.html#aacf6e2c5ab15b74f44e72c7221c71f8baa60594f2a674a4c740f0839f2f3efe27">WBT_VALUE_FOLLOWING</a>+1][2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RANGE bound determination computation; first index is a value of the enum_window_border_type enum; second index 0 for the start bound, 1 for the end bound. </p>
<p>Each item is Item_func_lt/gt. </p>

</div>
</div>
<a id="a3b6b5bce2537a290d061f6ed540bbce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6b5bce2537a290d061f6ed540bbce8">&#9670;&nbsp;</a></span>m_def_pos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> Window::m_def_pos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Position of definition in query's text, 1 for leftmost. </p>
<p>References don't count. Thus, anonymous windows in SELECT list, then windows of WINDOW clause, then anonymous windows in ORDER BY. </p>

</div>
</div>
<a id="a5bb44dc670100b86590b3fdd3f8bc07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb44dc670100b86590b3fdd3f8bc07e">&#9670;&nbsp;</a></span>m_do_copy_null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_do_copy_null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: make frame wf produce a NULL (or 0 depending, e.g. </p>
<p>if COUNT) value because no rows are available for aggregation: e.g. for first row in partition if frame is ROWS BETWEEN 2 PRECEDING and 1 PRECEDING has no rows for which aggregation can happen </p>

</div>
</div>
<a id="a1e13895b07ee0d799f470b44992a4f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e13895b07ee0d799f470b44992a4f14">&#9670;&nbsp;</a></span>m_first_rowno_in_range_frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_first_rowno_in_range_frame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: the row number of the first row in a frame when evaluating RANGE based frame bounds. </p>
<p>When using RANGE bounds, we don't know a priori when moving the frame which row number will be the next lower bound, but we know it will have to be a row number higher than the lower bound of the previous frame, since the bounds increase monotonically as long as the frame bounds are static within the query (current limitation). So, it makes sense to remember the first row number in a frame until we have determined the start of the next frame.</p>
<p>If the frame for the previous current row in the partition was empty (cf. "current_row" in process_buffered_windowing_record), this should point to the next possible frame start. Relative to partition start, 1-based. </p>

</div>
</div>
<a id="adb88a512c5644560e4266986bd27afd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb88a512c5644560e4266986bd27afd2">&#9670;&nbsp;</a></span>m_frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPT__frame.html">PT_frame</a>* const Window::m_frame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;window frame clause&gt; </p>

</div>
</div>
<a id="ab36ff971eea06183a78bc39c0f67e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36ff971eea06183a78bc39c0f67e883">&#9670;&nbsp;</a></span>m_frame_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* Window::m_frame_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: used iff m_needs_frame_buffering. </p>
<p>Holds the TABLE object for the the temporary file used for the frame buffering. </p>

</div>
</div>
<a id="a3ca64477e64b5415037c60fa1ba2e0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca64477e64b5415037c60fa1ba2e0f3">&#9670;&nbsp;</a></span>m_frame_buffer_param</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTemp__table__param.html">Temp_table_param</a>* Window::m_frame_buffer_param</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: used iff m_needs_frame_buffering. </p>
<p>Holds the temporary file (used for the frame buffering) parameters </p>

</div>
</div>
<a id="a2b1cb972563a9134fef4be429c2836e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1cb972563a9134fef4be429c2836e1">&#9670;&nbsp;</a></span>m_frame_buffer_partition_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_frame_buffer_partition_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: Snapshot of m_frame_buffer_total_rows when we start a new partition, i.e. </p>
<p>for the first row in the first partition we will have a value of 1. </p>

</div>
</div>
<a id="ac5eac4e74934033635df8387a4f29c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eac4e74934033635df8387a4f29c9c">&#9670;&nbsp;</a></span>m_frame_buffer_positions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array__YY.html">Mem_root_array_YY</a>&lt;<a class="el" href="structWindow_1_1Frame__buffer__position.html">Frame_buffer_position</a>&gt; Window::m_frame_buffer_positions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execution state: used iff m_needs_frame_buffering. </p>
<p>Holds pointers to positions in the file in m_frame_buffer. We use these saved positions to avoid having to position to the first row in the partition and then making many read calls to find the desired row. By repositioning to a suitably(*) saved position we normally (**) need to do only one positioned read and one ha_rdn_next call to get at a desired row. </p><pre class="fragment">   [0] the first row in the partition: at the
       beginning of a new partition that is the first row in the partition.
       Its rowno == 1 by definition.
   [1] position of the current row N  (for jump-back to current row or next
                                       current row in combo with ha_rnd_next)
   [2] position of the current first row M in frame (for aggregation looping
       jump-back)
   [3] position of the current last row in a frame
   [4] position and line number of the row last read
and optionally:
   [5..X] positions of Nth row of X-5+1 NTH_VALUE functions invoked on window
   [X+1..Y] position of last row of lead/lag functions invoked on window</pre><p> Pointers are lazily initialized if needed.</p>
<p>(*) We use the position closest below the desired position, cf logic in read_frame_buffer_row.</p>
<p>(**) Unless we have a frame beyond the current row, in which case we need to do some scanning for the first row in the partition. Also NTH_VALUE with RANGE might sometimes needs to read several rows, since the frame start can jump several rows ahead when the current row moves forward. </p>

</div>
</div>
<a id="a5830feb57732ae91f99b41fd23879c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5830feb57732ae91f99b41fd23879c27">&#9670;&nbsp;</a></span>m_frame_buffer_total_rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_frame_buffer_total_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: The frame buffer tmp file is not truncated for each new partition. </p>
<p>We need to keep track of where a partition starts in case we need to switch from heap to innodb tmp file on overflow, in order to re-initialize m_frame_buffer_positions with the current partition's row 1 (which is the minimum hint required) as we cross over. This number is incremented for each write. </p>

</div>
</div>
<a id="afb76d6cd2505424786356826381a2d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb76d6cd2505424786356826381a2d4d">&#9670;&nbsp;</a></span>m_functions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classList.html">List</a>&lt;<a class="el" href="classItem__sum.html">Item_sum</a>&gt; Window::m_functions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>window functions based on 'this' </p>

</div>
</div>
<a id="a028148fc459db83d705edab451e8aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028148fc459db83d705edab451e8aca7">&#9670;&nbsp;</a></span>m_inherit_from</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__string.html">Item_string</a>* const Window::m_inherit_from</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;existing window name&gt; </p>

</div>
</div>
<a id="a5cfb1fcff13e5b844c1ea5ba39a5d6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfb1fcff13e5b844c1ea5ba39a5d6d0">&#9670;&nbsp;</a></span>m_inverse_aggregation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_inverse_aggregation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: do inverse, e.g. </p>
<p>subtract rather than add in aggregates. Used for optimizing computation of sliding frames for eligible aggregates, cf. Item_sum::check_wf_semantics. </p>

</div>
</div>
<a id="a1e84191eed4b7e87c6ec53b1305be2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e84191eed4b7e87c6ec53b1305be2b5">&#9670;&nbsp;</a></span>m_inverse_comparators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__func.html">Item_func</a>* Window::m_inverse_comparators[<a class="el" href="window__lex_8h.html#aacf6e2c5ab15b74f44e72c7221c71f8baa60594f2a674a4c740f0839f2f3efe27">WBT_VALUE_FOLLOWING</a>+1][2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each item has inverse operation of the corresponding comparator in m_comparators. </p>
<p>Determines if comparison should continue with next field in order by list. </p>

</div>
</div>
<a id="a02aacede481bcb89a62e6c118d1dca1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aacede481bcb89a62e6c118d1dca1a">&#9670;&nbsp;</a></span>m_is_last_row_in_frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_is_last_row_in_frame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: the current row is the last row in a window frame For some aggregate functions, e.g AVG, we can save computation by not evaluating the entire function value before the last row has been read. </p>
<p>For AVG, do the summation for each row in the frame, but the division only for the last row, at which time the result is needed for the wf. Probably only useful for ROW based or static frames. For frame with peer set computation, determining the last row in the peer set ahead of processing is not possible, so we use a pessimistic assumption. </p>

</div>
</div>
<a id="a4461190125463218b323ec001845f169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4461190125463218b323ec001845f169">&#9670;&nbsp;</a></span>m_is_last_row_in_peerset_within_frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_is_last_row_in_peerset_within_frame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: used iff m_needs_last_peer_in_frame. </p>
<p>True if a row leaving the frame is the last row in the peer set withing the frame. </p>

</div>
</div>
<a id="a05d4d1ea03ffe3d8caa4a0f853bc600c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d4d1ea03ffe3d8caa4a0f853bc600c">&#9670;&nbsp;</a></span>m_is_reference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_is_reference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, m_name is an unbound window reference, other fields are unused. </p>

</div>
</div>
<a id="a832a813a83de44449ea5e9d627a571dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832a813a83de44449ea5e9d627a571dd">&#9670;&nbsp;</a></span>m_last</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_last</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The last window to be evaluated at execution time. </p>

</div>
</div>
<a id="ad2f40dea3086ce2e97bacb03d4317877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f40dea3086ce2e97bacb03d4317877">&#9670;&nbsp;</a></span>m_last_row_output</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_last_row_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: The number, in the current partition, of the last output row, i.e. </p>
<p>the row number of the last row hitherto evaluated and output to the next phase. </p>

</div>
</div>
<a id="acb81870ca3607b1038dc2dc843e87e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb81870ca3607b1038dc2dc843e87e2b">&#9670;&nbsp;</a></span>m_last_rowno_in_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_last_rowno_in_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: used iff m_needs_frame_buffering. </p>
<p>Holds the row number (in the partition) of the last row (hitherto) saved in the frame buffer </p>

</div>
</div>
<a id="ab8129cbc0ab6ad7fcec814dd09f7555a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8129cbc0ab6ad7fcec814dd09f7555a">&#9670;&nbsp;</a></span>m_last_rowno_in_peerset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_last_rowno_in_peerset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: used iff m_needs_peerset. </p>
<p>Holds the rowno for the last row in this peer set. </p>

</div>
</div>
<a id="ad2d7b5922eb43a3b83d9fa8ca8712d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d7b5922eb43a3b83d9fa8ca8712d58">&#9670;&nbsp;</a></span>m_last_rowno_in_range_frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_last_rowno_in_range_frame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: used for RANGE bounds frame evaluation for the continued evaluation for current row &gt; 2 in a partition. </p>
<p>If the frame for the current row visited (cf "current_row" in process_buffered_windowing_record) was empty, the invariant </p><pre class="fragment"> m_last_rowno_in_range_frame &lt; m_first_rowno_in_range_frame
</pre><p>should hold after the visit. Relative to partition start. 1-based. </p>

</div>
</div>
<a id="a21602ae681064bae23ee0eefa3801206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21602ae681064bae23ee0eefa3801206">&#9670;&nbsp;</a></span>m_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__string.html">Item_string</a>* Window::m_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;window name&gt; </p>

</div>
</div>
<a id="ada1c69cb59cce1cc6e9d5aff2db67d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1c69cb59cce1cc6e9d5aff2db67d41">&#9670;&nbsp;</a></span>m_needs_card</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_needs_card</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(At least) one window function needs the cardinality of the partition of the current row to evaluate the wf for the current row </p>

</div>
</div>
<a id="ac95a62be57b6562776d29cd5dd333c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95a62be57b6562776d29cd5dd333c58">&#9670;&nbsp;</a></span>m_needs_frame_buffering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_needs_frame_buffering</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(At least) one window function needs to buffer frame rows for evaluation i.e. </p>
<p>it cannot be evaluated on the fly just from previous rows seen </p>

</div>
</div>
<a id="a829ca8e083149c23d83a3351853f350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829ca8e083149c23d83a3351853f350c">&#9670;&nbsp;</a></span>m_needs_last_peer_in_frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_needs_last_peer_in_frame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(At least) one window function (currently JSON_OBJECTAGG) needs the last peer for the current row to evaluate the wf for the current row. </p>
<p>(This is used only during inversion/optimization) </p>

</div>
</div>
<a id="a319c45af7cf6c66c1f93339cc460fcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319c45af7cf6c66c1f93339cc460fcab">&#9670;&nbsp;</a></span>m_needs_peerset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_needs_peerset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(At least) one window function needs the peer set of the current row to evaluate the wf for the current row </p>

</div>
</div>
<a id="a6860d51c1f431ba49b2b6616b100e6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6860d51c1f431ba49b2b6616b100e6a4">&#9670;&nbsp;</a></span>m_needs_restore_input_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_needs_restore_input_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be true if first window after a join: we may need to restore the input record after buffered window processing if EQRefIterator's caching logic presumes the record hasn't been modified (when last qep_tab uses JT_EQ_REF). </p>

</div>
</div>
<a id="a5ca855dfc77e145638ec936fe899d995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca855dfc77e145638ec936fe899d995">&#9670;&nbsp;</a></span>m_opt_first_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_opt_first_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Window equires re-evaluation of the first row in optimized moving frame mode e.g. </p>
<p>FIRST_VALUE. </p>

</div>
</div>
<a id="afcdb975ad871c18bf2252b890eaf0d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdb975ad871c18bf2252b890eaf0d53">&#9670;&nbsp;</a></span>m_opt_last_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_opt_last_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Window requires re-evaluation of the last row in optimized moving frame mode e.g. </p>
<p>LAST_VALUE. </p>

</div>
</div>
<a id="a946f2b8a5f05df71fb2d80c7eae52cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946f2b8a5f05df71fb2d80c7eae52cbf">&#9670;&nbsp;</a></span>m_opt_lead_lag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structWindow_1_1st__lead__lag.html">st_lead_lag</a> Window::m_opt_lead_lag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0f11b0e36b054f484466ac3f022d689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f11b0e36b054f484466ac3f022d689">&#9670;&nbsp;</a></span>m_opt_nth_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structWindow_1_1st__nth.html">st_nth</a> Window::m_opt_nth_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Window requires re-evaluation of the Nth row in optimized moving frame mode e.g. </p>
<p>NTH_VALUE. </p>

</div>
</div>
<a id="a495a78db188bf6ba6e5aa43499bcd0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495a78db188bf6ba6e5aa43499bcd0e6">&#9670;&nbsp;</a></span>m_order_by</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPT__order__list.html">PT_order_list</a>* const Window::m_order_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;window order clause&gt; </p>

</div>
</div>
<a id="a4969fceeeb0328dc5d3cecdf3c76ddaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4969fceeeb0328dc5d3cecdf3c76ddaa">&#9670;&nbsp;</a></span>m_order_by_items</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classList.html">List</a>&lt;<a class="el" href="classCached__item.html">Cached_item</a>&gt; Window::m_order_by_items</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>items for the ORDER BY exprs. </p>

</div>
</div>
<a id="a1fd1b950667807719717cdc6ad9195a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd1b950667807719717cdc6ad9195a7">&#9670;&nbsp;</a></span>m_outtable_param</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTemp__table__param.html">Temp_table_param</a>* Window::m_outtable_param</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: Holds the temporary output table (for next step) parameters. </p>

</div>
</div>
<a id="a4952f1c8b0e3325d30d564f89162e629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4952f1c8b0e3325d30d564f89162e629">&#9670;&nbsp;</a></span>m_part_row_number</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_part_row_number</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: the current row number in the current partition. </p>
<p>Set in check_partition_boundary. Used while reading input rows, in contrast to m_rowno_in_partition, which is used when processing buffered rows. Cf. check_partition_boundary. </p>

</div>
</div>
<a id="ab6eff4d39a973df2aed891ca8cd23880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6eff4d39a973df2aed891ca8cd23880">&#9670;&nbsp;</a></span>m_partition_border</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_partition_border</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: the current row starts a new partition. </p>
<p>Set in check_partition_boundary. </p>

</div>
</div>
<a id="afca36dae2db6f95e3529d27081c930d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca36dae2db6f95e3529d27081c930d2">&#9670;&nbsp;</a></span>m_partition_by</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPT__order__list.html">PT_order_list</a>* const Window::m_partition_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;window partition clause&gt; </p>

</div>
</div>
<a id="abc606a658acfeaedb7b7e2ebc68e596e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc606a658acfeaedb7b7e2ebc68e596e">&#9670;&nbsp;</a></span>m_partition_items</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classList.html">List</a>&lt;<a class="el" href="classCached__item.html">Cached_item</a>&gt; Window::m_partition_items</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>items for the PARTITION BY columns </p>

</div>
</div>
<a id="a5df31eacc380806c96b30395d2de25f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df31eacc380806c96b30395d2de25f9">&#9670;&nbsp;</a></span>m_range_optimizable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_range_optimizable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The functions are optimizable with RANGE unit. </p>
<p>For example SUM is, MAX is not always optimizable. Optimized means we can use the optimized evaluation path in process_buffered_windowing_record which uses inversion to avoid revisiting all frame rows for every row being evaluated. </p>

</div>
</div>
<a id="a28e7a3070aabf03f05ee216d7fd3f886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e7a3070aabf03f05ee216d7fd3f886">&#9670;&nbsp;</a></span>m_row_has_fields_in_out_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_row_has_fields_in_out_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If &gt;=1: the row with this number (1-based, relative to start of partition) currently has its fields in the record buffer of the IN table and of the OUT table. </p>
<p>0 means "unset". Usable only with buffering. Set and read by bring_back_frame_row(), so that multiple successive calls to it for same row do only one read from FB (optimization). </p>

</div>
</div>
<a id="a049216e091cc1cfcf7be86efbcbe9509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049216e091cc1cfcf7be86efbcbe9509">&#9670;&nbsp;</a></span>m_row_optimizable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_row_optimizable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The functions are optimizable with ROW unit. </p>
<p>For example SUM is, MAX is not always optimizable. Optimized means we can use the optimized evaluation path in process_buffered_windowing_record which uses inversion to avoid revisiting all frame rows for every row being evaluated. </p>

</div>
</div>
<a id="a794fb95b5dbce1596be075d8898d58be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794fb95b5dbce1596be075d8898d58be">&#9670;&nbsp;</a></span>m_rowno_being_visited</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_rowno_being_visited</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: The number of the row being visited for its contribution to a window function, relative to the start of the partition. </p>
<p>Note that this will often be different from the current row for which we are processing the window function, reading it for output. That is given by m_rowno_in_partition, q.v. </p>

</div>
</div>
<a id="a8a0fc7fc0abfbad9c8aaa1492240c54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0fc7fc0abfbad9c8aaa1492240c54b">&#9670;&nbsp;</a></span>m_rowno_in_frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_rowno_in_frame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: the row number of the current row within a frame, cf. </p>
<p>m_is_last_row_in_frame, relative to start of the frame. 1-based. </p>

</div>
</div>
<a id="a100dcb0cd123248943b0877b1958e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100dcb0cd123248943b0877b1958e9d3">&#9670;&nbsp;</a></span>m_rowno_in_partition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> Window::m_rowno_in_partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execution state: The row number of the current row being readied for output within the partition. </p>
<p>1-based. </p>

</div>
</div>
<a id="af1289c052b4481e33dfad38f02ec30c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1289c052b4481e33dfad38f02ec30c1">&#9670;&nbsp;</a></span>m_select</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a>* Window::m_select</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SELECT the window is on. </p>

</div>
</div>
<a id="a330f0aba2e75358c29f62bd6fbd68905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330f0aba2e75358c29f62bd6fbd68905">&#9670;&nbsp;</a></span>m_sorting_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a>* Window::m_sorting_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>merged partition/order by </p>

</div>
</div>
<a id="a75a8e25446490ffa084534e03596d9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a8e25446490ffa084534e03596d9a0">&#9670;&nbsp;</a></span>m_special_rows_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* Window::m_special_rows_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a fixed number of copies of special rows; each copy can use up to m_special_rows_cache_max_length bytes. </p>
<p>cf. the Special_keys enumeration. </p>

</div>
</div>
<a id="a49025f4eb90aeeb36a2e873ffd4a0597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49025f4eb90aeeb36a2e873ffd4a0597">&#9670;&nbsp;</a></span>m_special_rows_cache_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Window::m_special_rows_cache_length[<a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795aa62e2f406702d0ee4951a3442695139f">FBC_FIRST_KEY</a> - <a class="el" href="classWindow.html#acd4370dc1039029dd04e36ad5912a795a3b575399866c3e5e3b0caaefcb025b80">FBC_LAST_KEY</a>+1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Length of each copy in m_special_rows_cache, in bytes. </p>

</div>
</div>
<a id="aaf2f33599ecc0b594d97a6053a8133cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2f33599ecc0b594d97a6053a8133cc">&#9670;&nbsp;</a></span>m_special_rows_cache_max_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Window::m_special_rows_cache_max_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum allocated size in m_special_rows_cache. </p>

</div>
</div>
<a id="a60f03eb20e00b2bad5edb160f0c94e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f03eb20e00b2bad5edb160f0c94e2c">&#9670;&nbsp;</a></span>m_static_aggregates</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Window::m_static_aggregates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The aggregates (SUM, etc) can be evaluated once for a partition, since it is static, i.e. </p>
<p>all rows will have the same value for the aggregates, e.g. ROWS/RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING. </p>

</div>
</div>
<a id="a22890eaf1766c609c6798a304066d87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22890eaf1766c609c6798a304066d87b">&#9670;&nbsp;</a></span>m_tmp_pos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structWindow_1_1Frame__buffer__position.html">Frame_buffer_position</a> Window::m_tmp_pos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sometimes we read one row too many, so that the saved position will be too far out because we subsequently need to read an earlier (previous) row of the same kind (reason). </p>
<p>For such cases, we first save the current position, read, and if we see we read too far, restore the old position. See save_pos and restore_pos. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="window_8h_source.html">window.h</a></li>
<li>sql/<a class="el" href="sql__executor_8cc.html">sql_executor.cc</a></li>
<li>sql/<a class="el" href="window_8cc.html">window.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classWindow.html">Window</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
