<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Innodb data lock instrumentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PAGE_INNODB_PFS.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Innodb data lock instrumentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Innodb Performance Schema data lock instrumentation</p>
<h1><a class="anchor" id="data_lock_iterators"></a>
Data lock iterators</h1>
<p>To provide content to the performance_schema.data_locks table, innodb implements Innodb_data_lock_iterator.</p>
<p>Likewise, table performance_schema.data_wait_locks is populated with Innodb_data_lock_wait_iterator.</p>
<p>Both these iterators need to return the data present in the innodb engine memory, which imply to take the proper mutex locks when inspecting it. The structure to inspect here is the transaction list (trx_sys)</p>
<p>How to implement this scan is critical for performances.</p>
<h2><a class="anchor" id="no_full_scan"></a>
No full scan</h2>
<p>Consider this implementation:</p><ul>
<li>Take all necessary locks</li>
<li>Scan all the innodb internal locks</li>
<li>Report all of them to the performance schema</li>
<li>Release all the locks taken</li>
</ul>
<p>This implementation materializes the entire table.</p>
<p>The benefits with this approach are:</p><ul>
<li>The materialized table is consistent</li>
</ul>
<p>The problems with this approach are:</p><ul>
<li>The innodb engine is frozen for the entire duration, for a time that is unpredictable.</li>
<li>Memory consumption spikes, without bounds</li>
<li>Materializing all rows upfront is incompatible with supporting an index</li>
</ul>
<p>For example with N = 10,000 transactions, a single scan reports all 10,000 transaction locks.</p>
<p>This alternative is rejected.</p>
<h2><a class="anchor" id="no_single_row_scan"></a>
No single row scan</h2>
<p>Consider this implementation:</p><ul>
<li>Take all necessary locks</li>
<li>Resume the scan on innodb internal locks for 1 record</li>
<li>Report this record to the performance schema</li>
<li>Release all the locks taken</li>
</ul>
<p>This implementation returns a row for a single transaction, or even a single lock, at a time.</p>
<p>The benefits with this approach are:</p><ul>
<li>Memory consumption is well bounded, and low.</li>
</ul>
<p>The problems with this approach are:</p><ul>
<li>Data reported can be very inconsistent.</li>
<li>Implementing a restartable scan, on a very dynamic structure, without holding any lock, is complex.</li>
<li>Even assuming how to implement a scan is resolved, looping N times to find element i, i+1, i+2 ... in a list ends up having a complexity in O(N^2), consuming CPU.</li>
</ul>
<p>For example with N = 10,000 transactions, the trx_list would be scanned 10,000 times to return 1 record each time. The total number of operations on the list is 100 Millions.</p>
<p>This alternative is rejected.</p>
<h2><a class="anchor" id="restartable_batch_scan"></a>
Restartable batch scan</h2>
<p>What is implemented is:</p><ul>
<li>Take all necessary locks</li>
<li>Resume the scan on innodb internal locks, for a given record range</li>
<li>Report all the records in the range to the performance schema</li>
<li>Release all the locks taken</li>
</ul>
<p>This is a compromise, with the following properties:</p><ul>
<li>Memory consumption is bounded, by the number of records returned in each range.</li>
<li>The duration of mutex locks on innodb structures is bounded by the number of records in each range</li>
<li>The data returned is not consistent, but at least it is "consistent by chunks"</li>
<li>The overall scan complexity is (N/RANGE)^2, where RANGE is the range size. This is still technically O(N^2), but in practice should be reasonable.</li>
</ul>
<p>For example with N = 10,000 transactions and RANGE = 256, there are 40 batches at the trx list, where each batch reports (up to) 256 trx, with the trx locks. The total number of operations on the list is 400 thousands. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_STORAGE.html">Data Storage</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
