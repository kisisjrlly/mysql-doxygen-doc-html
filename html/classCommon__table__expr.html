<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Common_table_expr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classCommon__table__expr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classCommon__table__expr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Common_table_expr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>After parsing, a Common Table Expression is accessed through a TABLE_LIST.  
 <a href="classCommon__table__expr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sql_2table_8h_source.html">table.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10aa8aff9872c20e98b84e21f7a5eb32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#a10aa8aff9872c20e98b84e21f7a5eb32">Common_table_expr</a> (<a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *<a class="el" href="client__plugin_8cc.html#a7d0fe2f135db987da18cea87b4778737">mem_root</a>)</td></tr>
<tr class="separator:a10aa8aff9872c20e98b84e21f7a5eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cbfc46fc3c750f18529b85ceba5378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#a58cbfc46fc3c750f18529b85ceba5378">clone_tmp_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:a58cbfc46fc3c750f18529b85ceba5378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces, from the first tmp TABLE object, a clone TABLE object for TABLE_LIST 'tl', to have a single materialization of multiple references to a CTE.  <a href="#a58cbfc46fc3c750f18529b85ceba5378">More...</a><br /></td></tr>
<tr class="separator:a58cbfc46fc3c750f18529b85ceba5378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6765fc369a6f508e44f134fb32134070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#a6765fc369a6f508e44f134fb32134070">substitute_recursive_reference</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *sl)</td></tr>
<tr class="memdesc:a6765fc369a6f508e44f134fb32134070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the recursive reference in query block 'sl' with a clone of the first tmp table.  <a href="#a6765fc369a6f508e44f134fb32134070">More...</a><br /></td></tr>
<tr class="separator:a6765fc369a6f508e44f134fb32134070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59554beff1357ed61d07fce3b830553a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#a59554beff1357ed61d07fce3b830553a">clear_all_references</a> ()</td></tr>
<tr class="memdesc:a59554beff1357ed61d07fce3b830553a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the materialized CTE and informs all of its clones.  <a href="#a59554beff1357ed61d07fce3b830553a">More...</a><br /></td></tr>
<tr class="separator:a59554beff1357ed61d07fce3b830553a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abb356bb410fa498796443d4e41e8b783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#abb356bb410fa498796443d4e41e8b783">references</a></td></tr>
<tr class="memdesc:abb356bb410fa498796443d4e41e8b783"><td class="mdescLeft">&#160;</td><td class="mdescRight">All references to this CTE in the statement, except those inside the query expression defining this CTE.  <a href="#abb356bb410fa498796443d4e41e8b783">More...</a><br /></td></tr>
<tr class="separator:abb356bb410fa498796443d4e41e8b783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8071125f6526126cb6ec7887158664dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#a8071125f6526126cb6ec7887158664dc">recursive</a></td></tr>
<tr class="memdesc:a8071125f6526126cb6ec7887158664dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if it's a recursive CTE.  <a href="#a8071125f6526126cb6ec7887158664dc">More...</a><br /></td></tr>
<tr class="separator:a8071125f6526126cb6ec7887158664dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b9606a539b130500a9fb9a98d720d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#a75b9606a539b130500a9fb9a98d720d9">tmp_tables</a></td></tr>
<tr class="memdesc:a75b9606a539b130500a9fb9a98d720d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all TABLE_LISTSs reading/writing to the tmp table created to materialize this CTE.  <a href="#a75b9606a539b130500a9fb9a98d720d9">More...</a><br /></td></tr>
<tr class="separator:a75b9606a539b130500a9fb9a98d720d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c71fb8d5acb9fb55345877d87873b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lex__string_8h.html#a1fb89d4ad1109660fb2b796efdb3933e">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommon__table__expr.html#a2c71fb8d5acb9fb55345877d87873b5c">name</a></td></tr>
<tr class="memdesc:a2c71fb8d5acb9fb55345877d87873b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the WITH block. Used only for EXPLAIN FORMAT=tree.  <a href="#a2c71fb8d5acb9fb55345877d87873b5c">More...</a><br /></td></tr>
<tr class="separator:a2c71fb8d5acb9fb55345877d87873b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>After parsing, a Common Table Expression is accessed through a TABLE_LIST. </p>
<p>This class contains all information about the CTE which the TABLE_LIST needs.</p>
<dl class="section note"><dt>Note</dt><dd>that before and during parsing, the CTE is described by a PT_common_table_expr. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a10aa8aff9872c20e98b84e21f7a5eb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa8aff9872c20e98b84e21f7a5eb32">&#9670;&nbsp;</a></span>Common_table_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Common_table_expr::Common_table_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>mem_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a59554beff1357ed61d07fce3b830553a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59554beff1357ed61d07fce3b830553a">&#9670;&nbsp;</a></span>clear_all_references()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Common_table_expr::clear_all_references </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empties the materialized CTE and informs all of its clones. </p>

</div>
</div>
<a id="a58cbfc46fc3c750f18529b85ceba5378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cbfc46fc3c750f18529b85ceba5378">&#9670;&nbsp;</a></span>clone_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a> * Common_table_expr::clone_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces, from the first tmp TABLE object, a clone TABLE object for TABLE_LIST 'tl', to have a single materialization of multiple references to a CTE. </p>
<h1>How sharing of a single tmp table works </h1>
<p>There are several scenarios. (1) Non-recursive CTE referenced only once: nothing special. (2) Non-recursive CTE referenced more than once:</p><ul>
<li>multiple TABLEs, one TABLE_SHARE.</li>
<li>The first ref in setup_materialized_derived() calls create_tmp_table(); others call open_table_from_share().</li>
<li>The first ref in create_derived() calls instantiate_tmp_table() (which calls handler::create() then open_tmp_table()); others call open_tmp_table(). open_tmp_table() calls handler::open().</li>
<li>The first ref in materialize_derived() evaluates the subquery and does all writes to the tmp table.</li>
<li>Finally all refs set up a read access method (table scan, index scan, index lookup, etc) and do reads, possibly interlaced (example: a nested-loop join of two references to the CTE).</li>
<li>The storage engine (MEMORY or InnoDB) must be informed of the uses above; this is done by having TABLE_SHARE::ref_count&gt;=2 for every handler::open() call. (3) Recursive CTE, referenced once or more than once: All of (2) applies, where the set of refs is the non-recursive ones (a recursive ref is a ref appearing in the definition of a recursive CTE). Additionally:</li>
<li>recursive refs do not call setup_materialized_derived(), create_derived(), materialize_derived().</li>
<li>right after a non-recursive ref has been in setup_materialized_derived(), its recursive refs are replaced with clones of that ref, made with open_table_from_share().</li>
<li>the first non-recursive ref in materialized_derived() initiates the with-recursive algorithm: its recursive refs call open_tmp_table(). Then writes (to the non-recursive ref) and reads (from the recursive refs) happen interlaced.</li>
<li>a particular recursive ref is the UNION table, if UNION DISTINCT is present in the CTE's definition: there is a single TABLE for it, writes/reads to/from it happen interlaced (writes are done by Query_result_union::send_data(); reads are done by the fake_select_lex's JOIN).</li>
<li>Finally all non-recursive refs set up a read access method and do reads, possibly interlaced.</li>
<li>The storage engine (MEMORY or InnoDB) must be informed of the uses above; this is done by having TABLE_SHARE::ref_count&gt;=2 for every handler::open() call.</li>
<li>The Server code handling tmp table creation must also be informed: see how Query_result_union::create_result_table() disables PK promotion.</li>
</ul>
<h1>How InnoDB manages the uses above </h1>
<p>The storage engine needs to take measures so that inserts and reads don't corrupt each other's behaviour. In InnoDB that means two things (</p><dl class="section see"><dt>See also</dt><dd>row_search_no_mvcc()): (a) A certain way to use its cursor when reading (b) Making the different handlers inform each other when one insertion modifies the structure of the index tree (e.g. splits a page; this triggers a refreshing of all read cursors).</dd></dl>
<h1>Requirements on tmp tables used to write/read CTEs </h1>
<p>The internal tmp table must support a phase where table scans and insertions happen interlaced, either issued from a single TABLE or from multiple TABLE clones. If from a single TABLE, that object does repetitions of {"write rows" then "init scan / read rows / close scan"}. If from multiple TABLEs, one does "write rows", every other one does "init scan /
read rows / close scan". During this, neither updates, nor deletes, nor any other type of read access than table scans, are allowed on this table (they are allowed after the phase's end). Any started table scan on this table:</p><ul>
<li>must remember its position between two read operations, without influence from other scans/inserts;</li>
<li>must return rows inserted before and after it started (be catching up continuously) (however, when it reports EOF it is allowed to stop catching up and report EOF until closed).</li>
<li>must return rows in insertion order.</li>
<li>may be started from the first record (ha_rnd_init, ha_rnd_next) or from the record where the previous scan was ended (position(), ha_rnd_end, [...], ha_rnd_init, ha_rnd_pos(saved position), ha_rnd_next).</li>
<li>must return positions (handler::position()) which are stable if a write later occurs, so that a handler::rnd_pos() happening after the write finds the same record.</li>
</ul>
<h1>Cursor re-positioning when MEMORY is converted to InnoDB </h1>
<p>See create_ondisk_from_heap(). A requirement is that InnoDB is able to start a scan like this: rnd_init, rnd_pos(some PK value), rnd_next.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tl</td><td>Table reference wanting the copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New clone, or NULL if error </dd></dl>

</div>
</div>
<a id="a6765fc369a6f508e44f134fb32134070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6765fc369a6f508e44f134fb32134070">&#9670;&nbsp;</a></span>substitute_recursive_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Common_table_expr::substitute_recursive_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>sl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the recursive reference in query block 'sl' with a clone of the first tmp table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">sl</td><td>Query block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2c71fb8d5acb9fb55345877d87873b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c71fb8d5acb9fb55345877d87873b5c">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lex__string_8h.html#a1fb89d4ad1109660fb2b796efdb3933e">LEX_STRING</a> Common_table_expr::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the WITH block. Used only for EXPLAIN FORMAT=tree. </p>

</div>
</div>
<a id="a8071125f6526126cb6ec7887158664dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8071125f6526126cb6ec7887158664dc">&#9670;&nbsp;</a></span>recursive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Common_table_expr::recursive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if it's a recursive CTE. </p>

</div>
</div>
<a id="abb356bb410fa498796443d4e41e8b783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb356bb410fa498796443d4e41e8b783">&#9670;&nbsp;</a></span>references</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt;<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; Common_table_expr::references</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All references to this CTE in the statement, except those inside the query expression defining this CTE. </p>
<p>In other words, all non-recursive references. </p>

</div>
</div>
<a id="a75b9606a539b130500a9fb9a98d720d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b9606a539b130500a9fb9a98d720d9">&#9670;&nbsp;</a></span>tmp_tables</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt;<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; Common_table_expr::tmp_tables</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all TABLE_LISTSs reading/writing to the tmp table created to materialize this CTE. </p>
<p>Due to shared materialization, only the first one has a TABLE generated by create_tmp_table(); other ones have a TABLE generated by open_table_from_share(). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="sql_2table_8h_source.html">table.h</a></li>
<li>sql/<a class="el" href="sql__derived_8cc.html">sql_derived.cc</a></li>
<li>sql/<a class="el" href="sql__union_8cc.html">sql_union.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classCommon__table__expr.html">Common_table_expr</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
