<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/data0data.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('data0data_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">data0data.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SQL data field and tuple.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="data0type_8h_source.html">data0type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="data0types_8h_source.html">data0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0bitset_8h_source.html">ut0bitset.h</a>&quot;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &quot;data0data.ic&quot;</code><br />
</div>
<p><a href="data0data_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmulti__value__data.html">multi_value_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold number of multiple values.  <a href="structmulti__value__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMulti__value__logger.html">Multi_value_logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to log the multi-value data and read it from the log.  <a href="classMulti__value__logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdfield__t.html">dfield_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an SQL data field.  <a href="structdfield__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdtuple__t.html">dtuple_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an SQL data tuple of fields (logical record)  <a href="structdtuple__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbig__rec__field__t.html">big_rec_field_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot for a field in a big rec vector.  <a href="structbig__rec__field__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbig__rec__t.html">big_rec_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage format for overflow data in a big record, that is, a clustered index record which needs external storage of data fields.  <a href="structbig__rec__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0f6efe84dfff32bbcffbf9cec79b461a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a0f6efe84dfff32bbcffbf9cec79b461a">DTUPLE_EST_ALLOC</a>(n_fields)&#160;&#160;&#160;(sizeof(<a class="el" href="structdtuple__t.html">dtuple_t</a>) + (n_fields) * sizeof(<a class="el" href="structdfield__t.html">dfield_t</a>))</td></tr>
<tr class="separator:a0f6efe84dfff32bbcffbf9cec79b461a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111f9bd7e0ef1fa34380e992e49c1f4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a111f9bd7e0ef1fa34380e992e49c1f4e">DATA_TUPLE_MAGIC_N</a>&#160;&#160;&#160;65478679</td></tr>
<tr class="memdesc:a111f9bd7e0ef1fa34380e992e49c1f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of dtuple_t::magic_n.  <a href="#a111f9bd7e0ef1fa34380e992e49c1f4e">More...</a><br /></td></tr>
<tr class="separator:a111f9bd7e0ef1fa34380e992e49c1f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afa2193dc1042a969a4904ea764bd9b16"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdtype__t.html">dtype_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#afa2193dc1042a969a4904ea764bd9b16">dfield_get_type</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:afa2193dc1042a969a4904ea764bd9b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to the type struct of SQL data field.  <a href="#afa2193dc1042a969a4904ea764bd9b16">More...</a><br /></td></tr>
<tr class="separator:afa2193dc1042a969a4904ea764bd9b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dbd5377b3616939a972b4126c1b218"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a63dbd5377b3616939a972b4126c1b218">dfield_get_data</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:a63dbd5377b3616939a972b4126c1b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to the data in a field.  <a href="#a63dbd5377b3616939a972b4126c1b218">More...</a><br /></td></tr>
<tr class="separator:a63dbd5377b3616939a972b4126c1b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb94e2dc123822e391555f0449c42ab"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a5cb94e2dc123822e391555f0449c42ab">dfield_set_type</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, const <a class="el" href="structdtype__t.html">dtype_t</a> *type)</td></tr>
<tr class="memdesc:a5cb94e2dc123822e391555f0449c42ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type struct of SQL data field.  <a href="#a5cb94e2dc123822e391555f0449c42ab">More...</a><br /></td></tr>
<tr class="separator:a5cb94e2dc123822e391555f0449c42ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22cc2cae2eee0a747a42a1a874f49d6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad22cc2cae2eee0a747a42a1a874f49d6">dfield_get_len</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:ad22cc2cae2eee0a747a42a1a874f49d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets length of field data.  <a href="#ad22cc2cae2eee0a747a42a1a874f49d6">More...</a><br /></td></tr>
<tr class="separator:ad22cc2cae2eee0a747a42a1a874f49d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa69c1a7dad64b83a8f7bec2066f57c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a3fa69c1a7dad64b83a8f7bec2066f57c">dfield_set_len</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, ulint len)</td></tr>
<tr class="memdesc:a3fa69c1a7dad64b83a8f7bec2066f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets length in a field.  <a href="#a3fa69c1a7dad64b83a8f7bec2066f57c">More...</a><br /></td></tr>
<tr class="separator:a3fa69c1a7dad64b83a8f7bec2066f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdfd235bef36c9cf972e32cd691206f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a4cdfd235bef36c9cf972e32cd691206f">dfield_is_null</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:a4cdfd235bef36c9cf972e32cd691206f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a field is SQL NULL.  <a href="#a4cdfd235bef36c9cf972e32cd691206f">More...</a><br /></td></tr>
<tr class="separator:a4cdfd235bef36c9cf972e32cd691206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1c85e508ac8ff58fcde24563747056"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#aea1c85e508ac8ff58fcde24563747056">dfield_is_ext</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:aea1c85e508ac8ff58fcde24563747056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a field is externally stored.  <a href="#aea1c85e508ac8ff58fcde24563747056">More...</a><br /></td></tr>
<tr class="separator:aea1c85e508ac8ff58fcde24563747056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f984e32809f85985ca013602f501fc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a63f984e32809f85985ca013602f501fc">dfield_set_ext</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:a63f984e32809f85985ca013602f501fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the "external storage" flag.  <a href="#a63f984e32809f85985ca013602f501fc">More...</a><br /></td></tr>
<tr class="separator:a63f984e32809f85985ca013602f501fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37fb8a6ffac985561eff1cb8858ada2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="dict0types_8h.html#a2dc72e9ff7d0244e9f223ab2052a147d">spatial_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ac37fb8a6ffac985561eff1cb8858ada2">dfield_get_spatial_status</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:ac37fb8a6ffac985561eff1cb8858ada2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets spatial status for "external storage".  <a href="#ac37fb8a6ffac985561eff1cb8858ada2">More...</a><br /></td></tr>
<tr class="separator:ac37fb8a6ffac985561eff1cb8858ada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae779af0790bee00bfaf938d4c932e19c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ae779af0790bee00bfaf938d4c932e19c">dfield_set_spatial_status</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, <a class="el" href="dict0types_8h.html#a2dc72e9ff7d0244e9f223ab2052a147d">spatial_status_t</a> spatial_status)</td></tr>
<tr class="memdesc:ae779af0790bee00bfaf938d4c932e19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets spatial status for "external storage".  <a href="#ae779af0790bee00bfaf938d4c932e19c">More...</a><br /></td></tr>
<tr class="separator:ae779af0790bee00bfaf938d4c932e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01263061c103fce3c132355c7de2d847"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a01263061c103fce3c132355c7de2d847">dfield_set_data</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, const void *data, ulint len)</td></tr>
<tr class="memdesc:a01263061c103fce3c132355c7de2d847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointer to the data and length in a field.  <a href="#a01263061c103fce3c132355c7de2d847">More...</a><br /></td></tr>
<tr class="separator:a01263061c103fce3c132355c7de2d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138d98e23bf363427fc8a1c921ed2549"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a138d98e23bf363427fc8a1c921ed2549">dfield_write_mbr</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, const double *mbr)</td></tr>
<tr class="memdesc:a138d98e23bf363427fc8a1c921ed2549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointer to the data and length in a field.  <a href="#a138d98e23bf363427fc8a1c921ed2549">More...</a><br /></td></tr>
<tr class="separator:a138d98e23bf363427fc8a1c921ed2549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11470d2230b3c1344f0cb3f4288260"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a8d11470d2230b3c1344f0cb3f4288260">dfield_set_null</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:a8d11470d2230b3c1344f0cb3f4288260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a data field to SQL NULL.  <a href="#a8d11470d2230b3c1344f0cb3f4288260">More...</a><br /></td></tr>
<tr class="separator:a8d11470d2230b3c1344f0cb3f4288260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723247dfa4a44c42bc23f7974c614f30"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a723247dfa4a44c42bc23f7974c614f30">data_write_sql_null</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *data, ulint len)</td></tr>
<tr class="memdesc:a723247dfa4a44c42bc23f7974c614f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an SQL null field full of zeros.  <a href="#a723247dfa4a44c42bc23f7974c614f30">More...</a><br /></td></tr>
<tr class="separator:a723247dfa4a44c42bc23f7974c614f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878476de45ad3aec1b46c0f15c2030bd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a878476de45ad3aec1b46c0f15c2030bd">dfield_copy_data</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field1, const <a class="el" href="structdfield__t.html">dfield_t</a> *field2)</td></tr>
<tr class="memdesc:a878476de45ad3aec1b46c0f15c2030bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data and len fields.  <a href="#a878476de45ad3aec1b46c0f15c2030bd">More...</a><br /></td></tr>
<tr class="separator:a878476de45ad3aec1b46c0f15c2030bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f262d515175333929a9e60bf1d853b1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a7f262d515175333929a9e60bf1d853b1">dfield_copy</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field1, const <a class="el" href="structdfield__t.html">dfield_t</a> *field2)</td></tr>
<tr class="memdesc:a7f262d515175333929a9e60bf1d853b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a data field to another.  <a href="#a7f262d515175333929a9e60bf1d853b1">More...</a><br /></td></tr>
<tr class="separator:a7f262d515175333929a9e60bf1d853b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca971975bd2d769f474547ce3b02170"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a3ca971975bd2d769f474547ce3b02170">dfield_dup</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a3ca971975bd2d769f474547ce3b02170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data pointed to by a data field.  <a href="#a3ca971975bd2d769f474547ce3b02170">More...</a><br /></td></tr>
<tr class="separator:a3ca971975bd2d769f474547ce3b02170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c08a7154f3ea951aa570cc14087eed"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ae1c08a7154f3ea951aa570cc14087eed">dfield_multi_value_dup</a> (<a class="el" href="structdfield__t.html">dfield_t</a> *field, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:ae1c08a7154f3ea951aa570cc14087eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data pointed to by a data field.  <a href="#ae1c08a7154f3ea951aa570cc14087eed">More...</a><br /></td></tr>
<tr class="separator:ae1c08a7154f3ea951aa570cc14087eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e05d68cd6ae496c4144c6c7b81cc7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad79e05d68cd6ae496c4144c6c7b81cc7">dfield_is_multi_value</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:ad79e05d68cd6ae496c4144c6c7b81cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a field is of multi-value type.  <a href="#ad79e05d68cd6ae496c4144c6c7b81cc7">More...</a><br /></td></tr>
<tr class="separator:ad79e05d68cd6ae496c4144c6c7b81cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c878864cc6fd0e05959a42c2f12b88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a0c878864cc6fd0e05959a42c2f12b88c">dfield_datas_are_binary_equal</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field1, const <a class="el" href="structdfield__t.html">dfield_t</a> *field2, ulint len)</td></tr>
<tr class="memdesc:a0c878864cc6fd0e05959a42c2f12b88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if two data fields are equal.  <a href="#a0c878864cc6fd0e05959a42c2f12b88c">More...</a><br /></td></tr>
<tr class="separator:a0c878864cc6fd0e05959a42c2f12b88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fe705473f0a67a084dd52df2c1c148"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a04fe705473f0a67a084dd52df2c1c148">dfield_data_is_binary_equal</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field, ulint len, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *data)</td></tr>
<tr class="memdesc:a04fe705473f0a67a084dd52df2c1c148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if dfield data length and content is equal to the given.  <a href="#a04fe705473f0a67a084dd52df2c1c148">More...</a><br /></td></tr>
<tr class="separator:a04fe705473f0a67a084dd52df2c1c148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7428ae7a40a49adcdfce196edd7d1f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a4f7428ae7a40a49adcdfce196edd7d1f">dtuple_get_n_fields</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a4f7428ae7a40a49adcdfce196edd7d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of fields in a data tuple.  <a href="#a4f7428ae7a40a49adcdfce196edd7d1f">More...</a><br /></td></tr>
<tr class="separator:a4f7428ae7a40a49adcdfce196edd7d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b11a8ce22ba8842f7920a1ff3a292c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad8b11a8ce22ba8842f7920a1ff3a292c">dtuple_get_n_v_fields</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:ad8b11a8ce22ba8842f7920a1ff3a292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of virtual fields in a data tuple.  <a href="#ad8b11a8ce22ba8842f7920a1ff3a292c">More...</a><br /></td></tr>
<tr class="separator:ad8b11a8ce22ba8842f7920a1ff3a292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb318a58295cba54d3353921f0a741f7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#abb318a58295cba54d3353921f0a741f7">dtuple_get_nth_field</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:abb318a58295cba54d3353921f0a741f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets nth field of a tuple.  <a href="#abb318a58295cba54d3353921f0a741f7">More...</a><br /></td></tr>
<tr class="separator:abb318a58295cba54d3353921f0a741f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36073653b3b3573486fe803f42e28b2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#af36073653b3b3573486fe803f42e28b2">dtuple_get_nth_v_field</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:af36073653b3b3573486fe803f42e28b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets nth virtual field of a tuple.  <a href="#af36073653b3b3573486fe803f42e28b2">More...</a><br /></td></tr>
<tr class="separator:af36073653b3b3573486fe803f42e28b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63aeaa8ed83fc7f5a5fe9630c7ae16c3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a63aeaa8ed83fc7f5a5fe9630c7ae16c3">dtuple_get_info_bits</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a63aeaa8ed83fc7f5a5fe9630c7ae16c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets info bits in a data tuple.  <a href="#a63aeaa8ed83fc7f5a5fe9630c7ae16c3">More...</a><br /></td></tr>
<tr class="separator:a63aeaa8ed83fc7f5a5fe9630c7ae16c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20a69eb0d449b21f5908192e795b532"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad20a69eb0d449b21f5908192e795b532">dtuple_set_info_bits</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint info_bits)</td></tr>
<tr class="memdesc:ad20a69eb0d449b21f5908192e795b532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets info bits in a data tuple.  <a href="#ad20a69eb0d449b21f5908192e795b532">More...</a><br /></td></tr>
<tr class="separator:ad20a69eb0d449b21f5908192e795b532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8097d0d733dece8d8a2c3c66aa3a23a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ab8097d0d733dece8d8a2c3c66aa3a23a">dtuple_get_n_fields_cmp</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:ab8097d0d733dece8d8a2c3c66aa3a23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of fields used in record comparisons.  <a href="#ab8097d0d733dece8d8a2c3c66aa3a23a">More...</a><br /></td></tr>
<tr class="separator:ab8097d0d733dece8d8a2c3c66aa3a23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ae30cd191d27432987140f3ba48dc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a973ae30cd191d27432987140f3ba48dc">dtuple_set_n_fields_cmp</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint n_fields_cmp)</td></tr>
<tr class="memdesc:a973ae30cd191d27432987140f3ba48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of fields used in record comparisons.  <a href="#a973ae30cd191d27432987140f3ba48dc">More...</a><br /></td></tr>
<tr class="separator:a973ae30cd191d27432987140f3ba48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e47d2f9f8c7d07d9a98478e571e299"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ac6e47d2f9f8c7d07d9a98478e571e299">dtuple_create_from_mem</a> (void *buf, ulint <a class="el" href="create__def_8cc.html#a83a426bc389379d92979b5248e18877c">buf_size</a>, ulint n_fields, ulint n_v_fields)</td></tr>
<tr class="memdesc:ac6e47d2f9f8c7d07d9a98478e571e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data tuple from an already allocated chunk of memory.  <a href="#ac6e47d2f9f8c7d07d9a98478e571e299">More...</a><br /></td></tr>
<tr class="separator:ac6e47d2f9f8c7d07d9a98478e571e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b66eef320eabdf84bf7b1cbb84a6b63"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a5b66eef320eabdf84bf7b1cbb84a6b63">dtuple_create</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, ulint n_fields)</td></tr>
<tr class="memdesc:a5b66eef320eabdf84bf7b1cbb84a6b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data tuple to a memory heap.  <a href="#a5b66eef320eabdf84bf7b1cbb84a6b63">More...</a><br /></td></tr>
<tr class="separator:a5b66eef320eabdf84bf7b1cbb84a6b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6476a4ad33e24d7be8305875033ede6c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a6476a4ad33e24d7be8305875033ede6c">dtuple_init_v_fld</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *vrow)</td></tr>
<tr class="memdesc:a6476a4ad33e24d7be8305875033ede6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the virtual field data in a dtuple_t.  <a href="#a6476a4ad33e24d7be8305875033ede6c">More...</a><br /></td></tr>
<tr class="separator:a6476a4ad33e24d7be8305875033ede6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b093801c7fedd0d5d3ce8ad66faf81"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a22b093801c7fedd0d5d3ce8ad66faf81">dtuple_dup_v_fld</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *vrow, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a22b093801c7fedd0d5d3ce8ad66faf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the virtual field data in a dtuple_t.  <a href="#a22b093801c7fedd0d5d3ce8ad66faf81">More...</a><br /></td></tr>
<tr class="separator:a22b093801c7fedd0d5d3ce8ad66faf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5b42e050cd197002fc7a1e670cab3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a37b5b42e050cd197002fc7a1e670cab3">dtuple_create_with_vcol</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, ulint n_fields, ulint n_v_fields)</td></tr>
<tr class="memdesc:a37b5b42e050cd197002fc7a1e670cab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data tuple with possible virtual columns to a memory heap.  <a href="#a37b5b42e050cd197002fc7a1e670cab3">More...</a><br /></td></tr>
<tr class="separator:a37b5b42e050cd197002fc7a1e670cab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8d43ed0e1bee3b08641f1e7c950d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#adf8d43ed0e1bee3b08641f1e7c950d7a">dtuple_set_n_fields</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint n_fields)</td></tr>
<tr class="memdesc:adf8d43ed0e1bee3b08641f1e7c950d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets number of fields used in a tuple.  <a href="#adf8d43ed0e1bee3b08641f1e7c950d7a">More...</a><br /></td></tr>
<tr class="separator:adf8d43ed0e1bee3b08641f1e7c950d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e4e564c2d4c62556e5ae069ab6c7f8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a28e4e564c2d4c62556e5ae069ab6c7f8">dtuple_copy_v_fields</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *d_tuple, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *s_tuple)</td></tr>
<tr class="memdesc:a28e4e564c2d4c62556e5ae069ab6c7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a data tuple's virtaul fields to another.  <a href="#a28e4e564c2d4c62556e5ae069ab6c7f8">More...</a><br /></td></tr>
<tr class="separator:a28e4e564c2d4c62556e5ae069ab6c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2159fa513b56375d2eacaa591799dc0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ab2159fa513b56375d2eacaa591799dc0">dtuple_copy</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:ab2159fa513b56375d2eacaa591799dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a data tuple to another.  <a href="#ab2159fa513b56375d2eacaa591799dc0">More...</a><br /></td></tr>
<tr class="separator:ab2159fa513b56375d2eacaa591799dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a0d3c0ea154b3dfb04ac9a104dc673"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad0a0d3c0ea154b3dfb04ac9a104dc673">dtuple_get_data_size</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint comp)</td></tr>
<tr class="memdesc:ad0a0d3c0ea154b3dfb04ac9a104dc673"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following function returns the sum of data lengths of a tuple.  <a href="#ad0a0d3c0ea154b3dfb04ac9a104dc673">More...</a><br /></td></tr>
<tr class="separator:ad0a0d3c0ea154b3dfb04ac9a104dc673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b8e7bff68b8b66497fb1e0dd12b598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a44b8e7bff68b8b66497fb1e0dd12b598">dtuple_coll_eq</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple1, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple2)</td></tr>
<tr class="memdesc:a44b8e7bff68b8b66497fb1e0dd12b598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two data tuples.  <a href="#a44b8e7bff68b8b66497fb1e0dd12b598">More...</a><br /></td></tr>
<tr class="separator:a44b8e7bff68b8b66497fb1e0dd12b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3c61bb0fc96d51797ae783f6f3b986"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a6c3c61bb0fc96d51797ae783f6f3b986">dtuple_fold</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint n_fields, ulint n_bytes, ulint fold)</td></tr>
<tr class="memdesc:a6c3c61bb0fc96d51797ae783f6f3b986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value of a prefix of an index record.  <a href="#a6c3c61bb0fc96d51797ae783f6f3b986">More...</a><br /></td></tr>
<tr class="separator:a6c3c61bb0fc96d51797ae783f6f3b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c135fb7f2df5a348c80be89a3a68108"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a5c135fb7f2df5a348c80be89a3a68108">dtuple_set_types_binary</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a5c135fb7f2df5a348c80be89a3a68108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets types of fields binary in a tuple.  <a href="#a5c135fb7f2df5a348c80be89a3a68108">More...</a><br /></td></tr>
<tr class="separator:a5c135fb7f2df5a348c80be89a3a68108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d6119e995bf3628c81456f508c961c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ab7d6119e995bf3628c81456f508c961c">dtuple_contains_null</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:ab7d6119e995bf3628c81456f508c961c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a dtuple contains an SQL null value.  <a href="#ab7d6119e995bf3628c81456f508c961c">More...</a><br /></td></tr>
<tr class="separator:ab7d6119e995bf3628c81456f508c961c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417aae4ccf1c7c89c49ac9058d000bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a417aae4ccf1c7c89c49ac9058d000bb0">dfield_check_typed</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *field)</td></tr>
<tr class="memdesc:a417aae4ccf1c7c89c49ac9058d000bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a data field is typed.  <a href="#a417aae4ccf1c7c89c49ac9058d000bb0">More...</a><br /></td></tr>
<tr class="separator:a417aae4ccf1c7c89c49ac9058d000bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeefaf37870bd3e89565013299b00ee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#aaeefaf37870bd3e89565013299b00ee6">dtuple_check_typed</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:aaeefaf37870bd3e89565013299b00ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a data tuple is typed.  <a href="#aaeefaf37870bd3e89565013299b00ee6">More...</a><br /></td></tr>
<tr class="separator:aaeefaf37870bd3e89565013299b00ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad757a56e8efb93f2bd86865554866c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad757a56e8efb93f2bd86865554866c9e">dtuple_validate</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:ad757a56e8efb93f2bd86865554866c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the consistency of a tuple which must be complete, i.e, all fields must have been set.  <a href="#ad757a56e8efb93f2bd86865554866c9e">More...</a><br /></td></tr>
<tr class="separator:ad757a56e8efb93f2bd86865554866c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521c7a872be3c23572507ef7ad56af87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a521c7a872be3c23572507ef7ad56af87">dfield_print_also_hex</a> (const <a class="el" href="structdfield__t.html">dfield_t</a> *dfield)</td></tr>
<tr class="memdesc:a521c7a872be3c23572507ef7ad56af87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty prints a dfield value according to its data type.  <a href="#a521c7a872be3c23572507ef7ad56af87">More...</a><br /></td></tr>
<tr class="separator:a521c7a872be3c23572507ef7ad56af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2150b92bb2453b18518265765f187667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a2150b92bb2453b18518265765f187667">dtuple_print</a> (FILE *f, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a2150b92bb2453b18518265765f187667"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following function prints the contents of a tuple.  <a href="#a2150b92bb2453b18518265765f187667">More...</a><br /></td></tr>
<tr class="separator:a2150b92bb2453b18518265765f187667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94f7ed24290fc14d92f5d4b07ffa2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad94f7ed24290fc14d92f5d4b07ffa2e6">dfield_print</a> (std::ostream &amp;o, const <a class="el" href="structdfield__t.html">dfield_t</a> *field, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:ad94f7ed24290fc14d92f5d4b07ffa2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of a tuple.  <a href="#ad94f7ed24290fc14d92f5d4b07ffa2e6">More...</a><br /></td></tr>
<tr class="separator:ad94f7ed24290fc14d92f5d4b07ffa2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d309cee6fd50d7427c0af12b4e1678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a36d309cee6fd50d7427c0af12b4e1678">dtuple_print</a> (std::ostream &amp;o, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a36d309cee6fd50d7427c0af12b4e1678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of a tuple.  <a href="#a36d309cee6fd50d7427c0af12b4e1678">More...</a><br /></td></tr>
<tr class="separator:a36d309cee6fd50d7427c0af12b4e1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f21372a07da2b51702b4f18ddf78168"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a9f21372a07da2b51702b4f18ddf78168">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structdtuple__t.html">dtuple_t</a> &amp;tuple)</td></tr>
<tr class="memdesc:a9f21372a07da2b51702b4f18ddf78168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of a tuple.  <a href="#a9f21372a07da2b51702b4f18ddf78168">More...</a><br /></td></tr>
<tr class="separator:a9f21372a07da2b51702b4f18ddf78168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4c7fd14b0af318810113c886289e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#aaf4c7fd14b0af318810113c886289e9e">dtuple_convert_big_rec</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structupd__t.html">upd_t</a> *upd, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>)</td></tr>
<tr class="memdesc:aaf4c7fd14b0af318810113c886289e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves parts of long fields in entry to the big record vector so that the size of tuple drops below the maximum record size allowed in the database.  <a href="#aaf4c7fd14b0af318810113c886289e9e">More...</a><br /></td></tr>
<tr class="separator:aaf4c7fd14b0af318810113c886289e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29105b3d51e8d24d1934940d3488d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ab29105b3d51e8d24d1934940d3488d84">dtuple_convert_back_big_rec</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structbig__rec__t.html">big_rec_t</a> *vector)</td></tr>
<tr class="memdesc:ab29105b3d51e8d24d1934940d3488d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts back to entry the data stored in vector.  <a href="#ab29105b3d51e8d24d1934940d3488d84">More...</a><br /></td></tr>
<tr class="separator:ab29105b3d51e8d24d1934940d3488d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07f23b840822815145cd40b717bcf4f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ad07f23b840822815145cd40b717bcf4f">dtuple_big_rec_free</a> (<a class="el" href="structbig__rec__t.html">big_rec_t</a> *vector)</td></tr>
<tr class="memdesc:ad07f23b840822815145cd40b717bcf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory in a big rec vector.  <a href="#ad07f23b840822815145cd40b717bcf4f">More...</a><br /></td></tr>
<tr class="separator:ad07f23b840822815145cd40b717bcf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85422b4ec5599afda0bb6b59a1e266c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#a85422b4ec5599afda0bb6b59a1e266c9">is_multi_value_clust_and_sec_equal</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *clust_field, uint64_t clust_len, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *sec_field, uint64_t sec_len, const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col)</td></tr>
<tr class="memdesc:a85422b4ec5599afda0bb6b59a1e266c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a multi-value clustered index field with a secondary index field, to see if they are equal.  <a href="#a85422b4ec5599afda0bb6b59a1e266c9">More...</a><br /></td></tr>
<tr class="separator:a85422b4ec5599afda0bb6b59a1e266c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac588d8c8e6c628fb4e23bfb3531e6f63"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#ac588d8c8e6c628fb4e23bfb3531e6f63">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structdfield__t.html">dfield_t</a> &amp;obj)</td></tr>
<tr class="memdesc:ac588d8c8e6c628fb4e23bfb3531e6f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloading the global output operator to easily print the given dfield_t object into the given output stream.  <a href="#ac588d8c8e6c628fb4e23bfb3531e6f63">More...</a><br /></td></tr>
<tr class="separator:ac588d8c8e6c628fb4e23bfb3531e6f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee84928b29643bb1f37aca37d76f6524"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#aee84928b29643bb1f37aca37d76f6524">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structbig__rec__field__t.html">big_rec_field_t</a> &amp;obj)</td></tr>
<tr class="memdesc:aee84928b29643bb1f37aca37d76f6524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloading the global output operator to easily print the given big_rec_field_t object into the given output stream.  <a href="#aee84928b29643bb1f37aca37d76f6524">More...</a><br /></td></tr>
<tr class="separator:aee84928b29643bb1f37aca37d76f6524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f4920650aa09fc3298d87bc3f96761"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data0data_8h.html#af8f4920650aa09fc3298d87bc3f96761">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structbig__rec__t.html">big_rec_t</a> &amp;obj)</td></tr>
<tr class="memdesc:af8f4920650aa09fc3298d87bc3f96761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloading the global output operator to easily print the given big_rec_t object into the given output stream.  <a href="#af8f4920650aa09fc3298d87bc3f96761">More...</a><br /></td></tr>
<tr class="separator:af8f4920650aa09fc3298d87bc3f96761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SQL data field and tuple. </p>
<p>Created 5/30/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a111f9bd7e0ef1fa34380e992e49c1f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111f9bd7e0ef1fa34380e992e49c1f4e">&#9670;&nbsp;</a></span>DATA_TUPLE_MAGIC_N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DATA_TUPLE_MAGIC_N&#160;&#160;&#160;65478679</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of dtuple_t::magic_n. </p>

</div>
</div>
<a id="a0f6efe84dfff32bbcffbf9cec79b461a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6efe84dfff32bbcffbf9cec79b461a">&#9670;&nbsp;</a></span>DTUPLE_EST_ALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTUPLE_EST_ALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_fields</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(<a class="el" href="structdtuple__t.html">dtuple_t</a>) + (n_fields) * sizeof(<a class="el" href="structdfield__t.html">dfield_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a723247dfa4a44c42bc23f7974c614f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723247dfa4a44c42bc23f7974c614f30">&#9670;&nbsp;</a></span>data_write_sql_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void data_write_sql_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an SQL null field full of zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to a buffer of size len </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>SQL null size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a417aae4ccf1c7c89c49ac9058d000bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417aae4ccf1c7c89c49ac9058d000bb0">&#9670;&nbsp;</a></span>dfield_check_typed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dfield_check_typed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a data field is typed. </p>
<p>Asserts an error if not. </p><dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: data field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f262d515175333929a9e60bf1d853b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f262d515175333929a9e60bf1d853b1">&#9670;&nbsp;</a></span>dfield_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a data field to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field1</td><td>field to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>field to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a878476de45ad3aec1b46c0f15c2030bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878476de45ad3aec1b46c0f15c2030bd">&#9670;&nbsp;</a></span>dfield_copy_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_copy_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data and len fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field1</td><td>field to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>field to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04fe705473f0a67a084dd52df2c1c148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fe705473f0a67a084dd52df2c1c148">&#9670;&nbsp;</a></span>dfield_data_is_binary_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dfield_data_is_binary_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if dfield data length and content is equal to the given. </p>
<dl class="section return"><dt>Returns</dt><dd>true if equal </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: field </td></tr>
    <tr><td class="paramname">len</td><td>in: data length or UNIV_SQL_NULL </td></tr>
    <tr><td class="paramname">data</td><td>in: data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c878864cc6fd0e05959a42c2f12b88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c878864cc6fd0e05959a42c2f12b88c">&#9670;&nbsp;</a></span>dfield_datas_are_binary_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dfield_datas_are_binary_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if two data fields are equal. </p>
<p>If len==0, tests the data length and content for equality. If len&gt;0, tests the first len bytes of the content for equality. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>first field to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>second field to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>maximum prefix to compare, or 0 to compare the whole field length. This works only if !multi_val </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both fields are NULL or if they are equal </dd></dl>

</div>
</div>
<a id="a3ca971975bd2d769f474547ce3b02170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca971975bd2d769f474547ce3b02170">&#9670;&nbsp;</a></span>dfield_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data pointed to by a data field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">field</td><td>data field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap where allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63dbd5377b3616939a972b4126c1b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dbd5377b3616939a972b4126c1b218">&#9670;&nbsp;</a></span>dfield_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* dfield_get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to the data in a field. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to data </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad22cc2cae2eee0a747a42a1a874f49d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22cc2cae2eee0a747a42a1a874f49d6">&#9670;&nbsp;</a></span>dfield_get_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE uint32_t dfield_get_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets length of field data. </p>
<dl class="section return"><dt>Returns</dt><dd>length of data; UNIV_SQL_NULL if SQL null data </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac37fb8a6ffac985561eff1cb8858ada2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37fb8a6ffac985561eff1cb8858ada2">&#9670;&nbsp;</a></span>dfield_get_spatial_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="dict0types_8h.html#a2dc72e9ff7d0244e9f223ab2052a147d">spatial_status_t</a> dfield_get_spatial_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets spatial status for "external storage". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">field</td><td>field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa2193dc1042a969a4904ea764bd9b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2193dc1042a969a4904ea764bd9b16">&#9670;&nbsp;</a></span>dfield_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdtype__t.html">dtype_t</a>* dfield_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to the type struct of SQL data field. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the type struct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: SQL data field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea1c85e508ac8ff58fcde24563747056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1c85e508ac8ff58fcde24563747056">&#9670;&nbsp;</a></span>dfield_is_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dfield_is_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a field is externally stored. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero if externally stored </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad79e05d68cd6ae496c4144c6c7b81cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79e05d68cd6ae496c4144c6c7b81cc7">&#9670;&nbsp;</a></span>dfield_is_multi_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dfield_is_multi_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a field is of multi-value type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>data field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if multi-value type field, otherwise false </dd></dl>

</div>
</div>
<a id="a4cdfd235bef36c9cf972e32cd691206f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdfd235bef36c9cf972e32cd691206f">&#9670;&nbsp;</a></span>dfield_is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dfield_is_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a field is SQL NULL. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero if SQL null data </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1c08a7154f3ea951aa570cc14087eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c08a7154f3ea951aa570cc14087eed">&#9670;&nbsp;</a></span>dfield_multi_value_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_multi_value_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the data pointed to by a data field. </p>
<p>This function works for multi-value fields only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">field</td><td>data field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap where allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad94f7ed24290fc14d92f5d4b07ffa2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94f7ed24290fc14d92f5d4b07ffa2e6">&#9670;&nbsp;</a></span>dfield_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfield_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the contents of a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>array of data fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of data fields </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a521c7a872be3c23572507ef7ad56af87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521c7a872be3c23572507ef7ad56af87">&#9670;&nbsp;</a></span>dfield_print_also_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dfield_print_also_hex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>dfield</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty prints a dfield value according to its data type. </p>
<p>Also the hex string is printed if a string contains non-printable characters. in: dfield </p>

</div>
</div>
<a id="a01263061c103fce3c132355c7de2d847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01263061c103fce3c132355c7de2d847">&#9670;&nbsp;</a></span>dfield_set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_set_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pointer to the data and length in a field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length or UNIV_SQL_NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63f984e32809f85985ca013602f501fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f984e32809f85985ca013602f501fc">&#9670;&nbsp;</a></span>dfield_set_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_set_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the "external storage" flag. </p>
<p>in/out: field </p>

</div>
</div>
<a id="a3fa69c1a7dad64b83a8f7bec2066f57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa69c1a7dad64b83a8f7bec2066f57c">&#9670;&nbsp;</a></span>dfield_set_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_set_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets length in a field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length or UNIV_SQL_NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d11470d2230b3c1344f0cb3f4288260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d11470d2230b3c1344f0cb3f4288260">&#9670;&nbsp;</a></span>dfield_set_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_set_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a data field to SQL NULL. </p>
<p>in/out: field </p>

</div>
</div>
<a id="ae779af0790bee00bfaf938d4c932e19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae779af0790bee00bfaf938d4c932e19c">&#9670;&nbsp;</a></span>dfield_set_spatial_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_set_spatial_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a2dc72e9ff7d0244e9f223ab2052a147d">spatial_status_t</a>&#160;</td>
          <td class="paramname"><em>spatial_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets spatial status for "external storage". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">field</td><td>field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spatial_status</td><td>spatial status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cb94e2dc123822e391555f0449c42ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb94e2dc123822e391555f0449c42ab">&#9670;&nbsp;</a></span>dfield_set_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_set_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtype__t.html">dtype_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type struct of SQL data field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>SQL data field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>pointer to data type struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a138d98e23bf363427fc8a1c921ed2549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138d98e23bf363427fc8a1c921ed2549">&#9670;&nbsp;</a></span>dfield_write_mbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dfield_write_mbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdfield__t.html">dfield_t</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>mbr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pointer to the data and length in a field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mbr</td><td>data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad07f23b840822815145cd40b717bcf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07f23b840822815145cd40b717bcf4f">&#9670;&nbsp;</a></span>dtuple_big_rec_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dtuple_big_rec_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory in a big rec vector. </p>
<p>in, own: big rec vector; it is freed in this function </p>

</div>
</div>
<a id="aaeefaf37870bd3e89565013299b00ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeefaf37870bd3e89565013299b00ee6">&#9670;&nbsp;</a></span>dtuple_check_typed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dtuple_check_typed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a data tuple is typed. </p>
<p>Asserts an error if not. </p><dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in: tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44b8e7bff68b8b66497fb1e0dd12b598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b8e7bff68b8b66497fb1e0dd12b598">&#9670;&nbsp;</a></span>dtuple_coll_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dtuple_coll_eq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two data tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple1</td><td>first data tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple2</td><td>second data tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether tuple1==tuple2 </dd></dl>

</div>
</div>
<a id="ab7d6119e995bf3628c81456f508c961c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d6119e995bf3628c81456f508c961c">&#9670;&nbsp;</a></span>dtuple_contains_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dtuple_contains_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a dtuple contains an SQL null value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if some field is SQL null </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in: dtuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab29105b3d51e8d24d1934940d3488d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29105b3d51e8d24d1934940d3488d84">&#9670;&nbsp;</a></span>dtuple_convert_back_big_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dtuple_convert_back_big_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts back to entry the data stored in vector. </p>
<p>Note that to ensure the fields in entry can accommodate the data, vector must have been created from entry with dtuple_convert_big_rec. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>Entry whose data was put to vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vector</td><td>Big rec vector; it is freed in this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf4c7fd14b0af318810113c886289e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4c7fd14b0af318810113c886289e9e">&#9670;&nbsp;</a></span>dtuple_convert_big_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbig__rec__t.html">big_rec_t</a>* dtuple_convert_big_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>upd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves parts of long fields in entry to the big record vector so that the size of tuple drops below the maximum record size allowed in the database. </p>
<p>Moves data only from those fields which are not necessary to determine uniquely the insertion place of the tuple in the index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>Index that owns the record. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">upd</td><td>Update vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>Index entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: created big record vector, NULL if we are not able to shorten the entry enough, i.e., if there are too many fixed-length or short fields in entry or the index is clustered </dd></dl>

</div>
</div>
<a id="ab2159fa513b56375d2eacaa591799dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2159fa513b56375d2eacaa591799dc0">&#9670;&nbsp;</a></span>dtuple_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a>* dtuple_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a data tuple to another. </p>
<p>This is a shallow copy; if a deep copy is desired, dfield_dup() will have to be invoked on each field. </p><dl class="section return"><dt>Returns</dt><dd>own: copy of tuple </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in: tuple to copy from </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where the tuple is created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28e4e564c2d4c62556e5ae069ab6c7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e4e564c2d4c62556e5ae069ab6c7f8">&#9670;&nbsp;</a></span>dtuple_copy_v_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dtuple_copy_v_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>d_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>s_tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a data tuple's virtaul fields to another. </p>
<p>This is a shallow copy; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_tuple</td><td>destination tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_tuple</td><td>source tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b66eef320eabdf84bf7b1cbb84a6b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b66eef320eabdf84bf7b1cbb84a6b63">&#9670;&nbsp;</a></span>dtuple_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a>* dtuple_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data tuple to a memory heap. </p>
<p>The default value for number of fields used in record comparisons for this tuple is n_fields. </p><dl class="section return"><dt>Returns</dt><dd>own: created tuple </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where the tuple is created, DTUPLE_EST_ALLOC(n_fields) bytes will be allocated from this heap </td></tr>
    <tr><td class="paramname">n_fields</td><td>in: number of fields </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6e47d2f9f8c7d07d9a98478e571e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e47d2f9f8c7d07d9a98478e571e299">&#9670;&nbsp;</a></span>dtuple_create_from_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a>* dtuple_create_from_mem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_v_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data tuple from an already allocated chunk of memory. </p>
<p>The size of the chunk must be at least DTUPLE_EST_ALLOC(n_fields). The default value for number of fields used in record comparisons for this tuple is n_fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>buffer to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_size</td><td>buffer size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_fields</td><td>number of field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_v_fields</td><td>number of fields on virtual columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>created tuple (inside buf) </dd></dl>

</div>
</div>
<a id="a37b5b42e050cd197002fc7a1e670cab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b5b42e050cd197002fc7a1e670cab3">&#9670;&nbsp;</a></span>dtuple_create_with_vcol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdtuple__t.html">dtuple_t</a>* dtuple_create_with_vcol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_v_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data tuple with possible virtual columns to a memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap where the tuple is created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_fields</td><td>number of fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_v_fields</td><td>number of fields on virtual col </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: created tuple </dd></dl>

</div>
</div>
<a id="a22b093801c7fedd0d5d3ce8ad66faf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b093801c7fedd0d5d3ce8ad66faf81">&#9670;&nbsp;</a></span>dtuple_dup_v_fld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dtuple_dup_v_fld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate the virtual field data in a dtuple_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrow</td><td>dtuple contains the virtual fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>heap memory to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c3c61bb0fc96d51797ae783f6f3b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3c61bb0fc96d51797ae783f6f3b986">&#9670;&nbsp;</a></span>dtuple_fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dtuple_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>fold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a hash value of a prefix of an index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_fields</td><td>number of fields to include </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_bytes</td><td>number of bytes to fold in the last field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fold</td><td>fold value of the index identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the folded value </dd></dl>

</div>
</div>
<a id="ad0a0d3c0ea154b3dfb04ac9a104dc673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a0d3c0ea154b3dfb04ac9a104dc673">&#9670;&nbsp;</a></span>dtuple_get_data_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dtuple_get_data_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following function returns the sum of data lengths of a tuple. </p>
<p>The space occupied by the field structs or the tuple struct is not counted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>typed data tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>nonzero=ROW_FORMAT=COMPACT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of data lens </dd></dl>

</div>
</div>
<a id="a63aeaa8ed83fc7f5a5fe9630c7ae16c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63aeaa8ed83fc7f5a5fe9630c7ae16c3">&#9670;&nbsp;</a></span>dtuple_get_info_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dtuple_get_info_bits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets info bits in a data tuple. </p>
<dl class="section return"><dt>Returns</dt><dd>info bits </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in: tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f7428ae7a40a49adcdfce196edd7d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7428ae7a40a49adcdfce196edd7d1f">&#9670;&nbsp;</a></span>dtuple_get_n_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dtuple_get_n_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets number of fields in a data tuple. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in: tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8097d0d733dece8d8a2c3c66aa3a23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8097d0d733dece8d8a2c3c66aa3a23a">&#9670;&nbsp;</a></span>dtuple_get_n_fields_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dtuple_get_n_fields_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets number of fields used in record comparisons. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields used in comparisons in rem0cmp.* </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in: tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8b11a8ce22ba8842f7920a1ff3a292c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b11a8ce22ba8842f7920a1ff3a292c">&#9670;&nbsp;</a></span>dtuple_get_n_v_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint dtuple_get_n_v_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets number of virtual fields in a data tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>dtuple to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>

</div>
</div>
<a id="abb318a58295cba54d3353921f0a741f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb318a58295cba54d3353921f0a741f7">&#9670;&nbsp;</a></span>dtuple_get_nth_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdfield__t.html">dfield_t</a>* dtuple_get_nth_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets nth field of a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index of field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nth field </dd></dl>

</div>
</div>
<a id="af36073653b3b3573486fe803f42e28b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36073653b3b3573486fe803f42e28b2">&#9670;&nbsp;</a></span>dtuple_get_nth_v_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdfield__t.html">dfield_t</a>* dtuple_get_nth_v_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets nth virtual field of a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the nth field to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nth field </dd></dl>

</div>
</div>
<a id="a6476a4ad33e24d7be8305875033ede6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6476a4ad33e24d7be8305875033ede6c">&#9670;&nbsp;</a></span>dtuple_init_v_fld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dtuple_init_v_fld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>vrow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the virtual field data in a dtuple_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrow</td><td>dtuple contains the virtual fields </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2150b92bb2453b18518265765f187667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2150b92bb2453b18518265765f187667">&#9670;&nbsp;</a></span>dtuple_print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dtuple_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following function prints the contents of a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>Output stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>Tuple to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36d309cee6fd50d7427c0af12b4e1678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d309cee6fd50d7427c0af12b4e1678">&#9670;&nbsp;</a></span>dtuple_print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dtuple_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the contents of a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>data tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad20a69eb0d449b21f5908192e795b532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20a69eb0d449b21f5908192e795b532">&#9670;&nbsp;</a></span>dtuple_set_info_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dtuple_set_info_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>info_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets info bits in a data tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info_bits</td><td>info bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf8d43ed0e1bee3b08641f1e7c950d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8d43ed0e1bee3b08641f1e7c950d7a">&#9670;&nbsp;</a></span>dtuple_set_n_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dtuple_set_n_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets number of fields used in a tuple. </p>
<p>Normally this is set in dtuple_create, but if you want later to set it smaller, you can use this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>Tuple. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_fields</td><td>Number of fields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a973ae30cd191d27432987140f3ba48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973ae30cd191d27432987140f3ba48dc">&#9670;&nbsp;</a></span>dtuple_set_n_fields_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dtuple_set_n_fields_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields_cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets number of fields used in record comparisons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_fields_cmp</td><td>number of fields used in comparisons in rem0cmp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c135fb7f2df5a348c80be89a3a68108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c135fb7f2df5a348c80be89a3a68108">&#9670;&nbsp;</a></span>dtuple_set_types_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void dtuple_set_types_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets types of fields binary in a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>data tuple </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of fields to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad757a56e8efb93f2bd86865554866c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad757a56e8efb93f2bd86865554866c9e">&#9670;&nbsp;</a></span>dtuple_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dtuple_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the consistency of a tuple which must be complete, i.e, all fields must have been set. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in: tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85422b4ec5599afda0bb6b59a1e266c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85422b4ec5599afda0bb6b59a1e266c9">&#9670;&nbsp;</a></span>is_multi_value_clust_and_sec_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_multi_value_clust_and_sec_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>clust_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>clust_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>sec_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a multi-value clustered index field with a secondary index field, to see if they are equal. </p>
<p>If the clustered index field is the array, then equal means it contains the secondary index field </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_field</td><td>clustered index field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_len</td><td>clustered index field length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_field</td><td>secondary index field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_len</td><td>secondary index field length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the column tied to this field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if they are equal, otherwise false </dd></dl>

</div>
</div>
<a id="a9f21372a07da2b51702b4f18ddf78168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f21372a07da2b51702b4f18ddf78168">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">o</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>data tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac588d8c8e6c628fb4e23bfb3531e6f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac588d8c8e6c628fb4e23bfb3531e6f63">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdfield__t.html">dfield_t</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloading the global output operator to easily print the given dfield_t object into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the given object to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream. </dd></dl>

</div>
</div>
<a id="aee84928b29643bb1f37aca37d76f6524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee84928b29643bb1f37aca37d76f6524">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbig__rec__field__t.html">big_rec_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloading the global output operator to easily print the given big_rec_field_t object into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the given object to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream. </dd></dl>

</div>
</div>
<a id="af8f4920650aa09fc3298d87bc3f96761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f4920650aa09fc3298d87bc3f96761">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbig__rec__t.html">big_rec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloading the global output operator to easily print the given big_rec_t object into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the given object to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="data0data_8h.html">data0data.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
