<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Commit_stage_manager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classCommit__stage__manager.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classCommit__stage__manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Commit_stage_manager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for maintaining the commit stages for binary log group commit.  
 <a href="classCommit__stage__manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rpl__commit__stage__manager_8h_source.html">rpl_commit_stage_manager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager_1_1Mutex__queue.html">Mutex_queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a87820f6cd4c5552fbbe187b02bb60be0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> { <br />
&#160;&#160;<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aa2eaeedb90de8c3ad012b8f82a212c8c">BINLOG_FLUSH_STAGE</a>, 
<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0ac2e91b8eca7331d0414c78d86fd826e4">SYNC_STAGE</a>, 
<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0a88211ab4996f7881d1a75fb9978ef4ea">COMMIT_STAGE</a>, 
<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0a52703d9abfdf18bab97cf2728b2c1fa8">COMMIT_ORDER_FLUSH_STAGE</a>, 
<br />
&#160;&#160;<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aea53d9e5e491e1a6b92f1840f2951610">STAGE_COUNTER</a>
<br />
 }<tr class="memdesc:a87820f6cd4c5552fbbe187b02bb60be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants for queues for different stages.  <a href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a87820f6cd4c5552fbbe187b02bb60be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b1b7cdbf9b87fad1b1029666f473fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a8b1b7cdbf9b87fad1b1029666f473fdd">init</a> (<a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a> key_LOCK_flush_queue, <a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a> key_LOCK_sync_queue, <a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a> key_LOCK_commit_queue, <a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a> key_LOCK_done, <a class="el" href="group__psi__abi__cond.html#gad83033d86d97d0b965b0257be7674a51">PSI_cond_key</a> key_COND_done)</td></tr>
<tr class="memdesc:a8b1b7cdbf9b87fad1b1029666f473fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes m_stage_cond_binlog, m_stage_cond_commit_order, m_stage_cond_leader condition variables and m_lock_done mutex.  <a href="#a8b1b7cdbf9b87fad1b1029666f473fdd">More...</a><br /></td></tr>
<tr class="separator:a8b1b7cdbf9b87fad1b1029666f473fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401fe1633d679c1508630c655fd61a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a401fe1633d679c1508630c655fd61a51">deinit</a> ()</td></tr>
<tr class="memdesc:a401fe1633d679c1508630c655fd61a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes m_stage_cond_binlog, m_stage_cond_commit_order, m_stage_cond_leader condition variables and m_lock_done mutex.  <a href="#a401fe1633d679c1508630c655fd61a51">More...</a><br /></td></tr>
<tr class="separator:a401fe1633d679c1508630c655fd61a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83c9ddf0203b496402594639a4c4dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#af83c9ddf0203b496402594639a4c4dd8">enroll_for</a> (<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage, <a class="el" href="classTHD.html">THD</a> *first, <a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a> *stage_mutex, <a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a> *enter_mutex)</td></tr>
<tr class="memdesc:af83c9ddf0203b496402594639a4c4dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enroll a set of sessions for a stage.  <a href="#af83c9ddf0203b496402594639a4c4dd8">More...</a><br /></td></tr>
<tr class="separator:af83c9ddf0203b496402594639a4c4dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2529356ee87307fecc60a91bb851e24"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="classTHD.html">THD</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#af2529356ee87307fecc60a91bb851e24">pop_front</a> (<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage)</td></tr>
<tr class="memdesc:af2529356ee87307fecc60a91bb851e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove first member from the queue for given stage.  <a href="#af2529356ee87307fecc60a91bb851e24">More...</a><br /></td></tr>
<tr class="separator:af2529356ee87307fecc60a91bb851e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511279db5ce68b57cd3ebdd5bb7222f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a511279db5ce68b57cd3ebdd5bb7222f6">clear_preempt_status</a> (<a class="el" href="classTHD.html">THD</a> *head)</td></tr>
<tr class="memdesc:a511279db5ce68b57cd3ebdd5bb7222f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method ensures the follower's execution path can be preempted by the leader's thread.  <a href="#a511279db5ce68b57cd3ebdd5bb7222f6">More...</a><br /></td></tr>
<tr class="separator:a511279db5ce68b57cd3ebdd5bb7222f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fd2e494824d46a9b2f127ecbee9628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#ab4fd2e494824d46a9b2f127ecbee9628">fetch_queue_acquire_lock</a> (<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage)</td></tr>
<tr class="memdesc:ab4fd2e494824d46a9b2f127ecbee9628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the entire queue and empty it.  <a href="#ab4fd2e494824d46a9b2f127ecbee9628">More...</a><br /></td></tr>
<tr class="separator:ab4fd2e494824d46a9b2f127ecbee9628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3769ebf82d16a457793123cc447b6a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#af3769ebf82d16a457793123cc447b6a8">fetch_queue_skip_acquire_lock</a> (<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage)</td></tr>
<tr class="memdesc:af3769ebf82d16a457793123cc447b6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the entire queue and empty it.  <a href="#af3769ebf82d16a457793123cc447b6a8">More...</a><br /></td></tr>
<tr class="separator:af3769ebf82d16a457793123cc447b6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c13bfa09a66901a2387042d5037bc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#ac7c13bfa09a66901a2387042d5037bc5">wait_count_or_timeout</a> (<a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> <a class="el" href="myisam__ftdump_8cc.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>, long usec, <a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage)</td></tr>
<tr class="memdesc:ac7c13bfa09a66901a2387042d5037bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a wait operation on the executing thread.  <a href="#ac7c13bfa09a66901a2387042d5037bc5">More...</a><br /></td></tr>
<tr class="separator:ac7c13bfa09a66901a2387042d5037bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49396c154288e76ab57cea748822eac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#af49396c154288e76ab57cea748822eac">signal_done</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="myisampack_8cc.html#aeea358856f1967fb51e985be8ded2b7a">queue</a>, <a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage=<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aa2eaeedb90de8c3ad012b8f82a212c8c">BINLOG_FLUSH_STAGE</a>)</td></tr>
<tr class="memdesc:af49396c154288e76ab57cea748822eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function is called after follower thread are processed by leader, to unblock follower threads.  <a href="#af49396c154288e76ab57cea748822eac">More...</a><br /></td></tr>
<tr class="separator:af49396c154288e76ab57cea748822eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2bdab931c64f9888bd741e5c39c5a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#aed2bdab931c64f9888bd741e5c39c5a7">process_final_stage_for_ordered_commit_group</a> (<a class="el" href="classTHD.html">THD</a> *first)</td></tr>
<tr class="memdesc:aed2bdab931c64f9888bd741e5c39c5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets called after transactions are flushed to the engine i.e.  <a href="#aed2bdab931c64f9888bd741e5c39c5a7">More...</a><br /></td></tr>
<tr class="separator:aed2bdab931c64f9888bd741e5c39c5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da6e6019e99b2b1abbbe5dee15436d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#ae4da6e6019e99b2b1abbbe5dee15436d">lock_queue</a> (<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage)</td></tr>
<tr class="memdesc:ae4da6e6019e99b2b1abbbe5dee15436d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on Mutex_queue lock(), acquires lock on stage queue.  <a href="#ae4da6e6019e99b2b1abbbe5dee15436d">More...</a><br /></td></tr>
<tr class="separator:ae4da6e6019e99b2b1abbbe5dee15436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6afe5ed0954a0f4c6f127552be31bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#af6afe5ed0954a0f4c6f127552be31bcb">unlock_queue</a> (<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a> stage)</td></tr>
<tr class="memdesc:af6afe5ed0954a0f4c6f127552be31bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on Mutex_queue unlock(), releases lock on stage queue.  <a href="#af6afe5ed0954a0f4c6f127552be31bcb">More...</a><br /></td></tr>
<tr class="separator:af6afe5ed0954a0f4c6f127552be31bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a89437cb17aa18ca4752507e7efa8e029"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a89437cb17aa18ca4752507e7efa8e029">get_instance</a> ()</td></tr>
<tr class="memdesc:a89437cb17aa18ca4752507e7efa8e029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch Commit_stage_manager class instance.  <a href="#a89437cb17aa18ca4752507e7efa8e029">More...</a><br /></td></tr>
<tr class="separator:a89437cb17aa18ca4752507e7efa8e029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac4c8efd5672af7b1528c4fc76590d8d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#ac4c8efd5672af7b1528c4fc76590d8d7">Commit_stage_manager</a> ()</td></tr>
<tr class="separator:ac4c8efd5672af7b1528c4fc76590d8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5934f310f4e3e3186a8e4db80798513c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a5934f310f4e3e3186a8e4db80798513c">Commit_stage_manager</a> (const <a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a> &amp;)=delete</td></tr>
<tr class="separator:a5934f310f4e3e3186a8e4db80798513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efd2bbe057c70e541632259447f3eec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a0efd2bbe057c70e541632259447f3eec">operator=</a> (const <a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a> &amp;)=delete</td></tr>
<tr class="separator:a0efd2bbe057c70e541632259447f3eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abb39a5f2ef1e37a69fec66cabcb1fd2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#abb39a5f2ef1e37a69fec66cabcb1fd2b">m_is_initialized</a></td></tr>
<tr class="memdesc:abb39a5f2ef1e37a69fec66cabcb1fd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Commit_stage_manager variables already initalized.  <a href="#abb39a5f2ef1e37a69fec66cabcb1fd2b">More...</a><br /></td></tr>
<tr class="separator:abb39a5f2ef1e37a69fec66cabcb1fd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51629c8694e4853b7d08cd4825d0b474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCommit__stage__manager_1_1Mutex__queue.html">Mutex_queue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a51629c8694e4853b7d08cd4825d0b474">m_queue</a> [<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aea53d9e5e491e1a6b92f1840f2951610">STAGE_COUNTER</a>]</td></tr>
<tr class="memdesc:a51629c8694e4853b7d08cd4825d0b474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues for sessions.  <a href="#a51629c8694e4853b7d08cd4825d0b474">More...</a><br /></td></tr>
<tr class="separator:a51629c8694e4853b7d08cd4825d0b474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfb2044120f03ff5a70c9e7637a00fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a2cfb2044120f03ff5a70c9e7637a00fd">m_stage_cond_leader</a></td></tr>
<tr class="memdesc:a2cfb2044120f03ff5a70c9e7637a00fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binlog leader waits on this condition variable till it is indicated to wake up.  <a href="#a2cfb2044120f03ff5a70c9e7637a00fd">More...</a><br /></td></tr>
<tr class="separator:a2cfb2044120f03ff5a70c9e7637a00fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e2d7191f1a9452a92bb312674d016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a4d9e2d7191f1a9452a92bb312674d016">m_stage_cond_binlog</a></td></tr>
<tr class="memdesc:a4d9e2d7191f1a9452a92bb312674d016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable to indicate that the binlog threads can wake up and continue.  <a href="#a4d9e2d7191f1a9452a92bb312674d016">More...</a><br /></td></tr>
<tr class="separator:a4d9e2d7191f1a9452a92bb312674d016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff063073786be9052b6f507b03ee55f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a5ff063073786be9052b6f507b03ee55f">m_stage_cond_commit_order</a></td></tr>
<tr class="memdesc:a5ff063073786be9052b6f507b03ee55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable to indicate that the flush to storage engine is done and commit order threads can again wake up and continue.  <a href="#a5ff063073786be9052b6f507b03ee55f">More...</a><br /></td></tr>
<tr class="separator:a5ff063073786be9052b6f507b03ee55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206252c710872103ab216cb896a53338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a206252c710872103ab216cb896a53338">m_lock_done</a></td></tr>
<tr class="memdesc:a206252c710872103ab216cb896a53338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used for the condition variable above.  <a href="#a206252c710872103ab216cb896a53338">More...</a><br /></td></tr>
<tr class="separator:a206252c710872103ab216cb896a53338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd6d2dde28077154e4ad4bed6d2c502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a7dd6d2dde28077154e4ad4bed6d2c502">m_queue_lock</a> [<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aea53d9e5e491e1a6b92f1840f2951610">STAGE_COUNTER</a> - 1]</td></tr>
<tr class="memdesc:a7dd6d2dde28077154e4ad4bed6d2c502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used for the stage level locks.  <a href="#a7dd6d2dde28077154e4ad4bed6d2c502">More...</a><br /></td></tr>
<tr class="separator:a7dd6d2dde28077154e4ad4bed6d2c502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae3d1b2d12e0e9b6409d0fe90005366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#aeae3d1b2d12e0e9b6409d0fe90005366">leader_thd</a></td></tr>
<tr class="memdesc:aeae3d1b2d12e0e9b6409d0fe90005366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save pointer to leader thread which is used later to awake leader.  <a href="#aeae3d1b2d12e0e9b6409d0fe90005366">More...</a><br /></td></tr>
<tr class="separator:aeae3d1b2d12e0e9b6409d0fe90005366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d0c38b97ba5d08be843b845b147eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#a49d0c38b97ba5d08be843b845b147eb6">leader_await_preempt_status</a></td></tr>
<tr class="memdesc:a49d0c38b97ba5d08be843b845b147eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag is set by Leader when it starts waiting for follower's all-clear.  <a href="#a49d0c38b97ba5d08be843b845b147eb6">More...</a><br /></td></tr>
<tr class="separator:a49d0c38b97ba5d08be843b845b147eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46820c0a78a27cdf73e20d5822ad974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCommit__stage__manager.html#af46820c0a78a27cdf73e20d5822ad974">m_cond_preempt</a></td></tr>
<tr class="memdesc:af46820c0a78a27cdf73e20d5822ad974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable to indicate a follower started waiting for commit.  <a href="#af46820c0a78a27cdf73e20d5822ad974">More...</a><br /></td></tr>
<tr class="separator:af46820c0a78a27cdf73e20d5822ad974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for maintaining the commit stages for binary log group commit. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a87820f6cd4c5552fbbe187b02bb60be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87820f6cd4c5552fbbe187b02bb60be0">&#9670;&nbsp;</a></span>StageID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">Commit_stage_manager::StageID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants for queues for different stages. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a87820f6cd4c5552fbbe187b02bb60be0aa2eaeedb90de8c3ad012b8f82a212c8c"></a>BINLOG_FLUSH_STAGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a87820f6cd4c5552fbbe187b02bb60be0ac2e91b8eca7331d0414c78d86fd826e4"></a>SYNC_STAGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a87820f6cd4c5552fbbe187b02bb60be0a88211ab4996f7881d1a75fb9978ef4ea"></a>COMMIT_STAGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a87820f6cd4c5552fbbe187b02bb60be0a52703d9abfdf18bab97cf2728b2c1fa8"></a>COMMIT_ORDER_FLUSH_STAGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a87820f6cd4c5552fbbe187b02bb60be0aea53d9e5e491e1a6b92f1840f2951610"></a>STAGE_COUNTER&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac4c8efd5672af7b1528c4fc76590d8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c8efd5672af7b1528c4fc76590d8d7">&#9670;&nbsp;</a></span>Commit_stage_manager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Commit_stage_manager::Commit_stage_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5934f310f4e3e3186a8e4db80798513c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5934f310f4e3e3186a8e4db80798513c">&#9670;&nbsp;</a></span>Commit_stage_manager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Commit_stage_manager::Commit_stage_manager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a511279db5ce68b57cd3ebdd5bb7222f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511279db5ce68b57cd3ebdd5bb7222f6">&#9670;&nbsp;</a></span>clear_preempt_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::clear_preempt_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The method ensures the follower's execution path can be preempted by the leader's thread. </p>
<p>Preempt status of <code>head</code> follower is checked to engange the leader into waiting when set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>THD* of a follower thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a401fe1633d679c1508630c655fd61a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401fe1633d679c1508630c655fd61a51">&#9670;&nbsp;</a></span>deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::deinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitializes m_stage_cond_binlog, m_stage_cond_commit_order, m_stage_cond_leader condition variables and m_lock_done mutex. </p>

</div>
</div>
<a id="af83c9ddf0203b496402594639a4c4dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83c9ddf0203b496402594639a4c4dd8">&#9670;&nbsp;</a></span>enroll_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Commit_stage_manager::enroll_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>stage_mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>enter_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enroll a set of sessions for a stage. </p>
<p>This will queue the session thread for writing and flushing.</p>
<p>If the thread being queued is assigned as stage leader, it will return immediately.</p>
<p>If wait_if_follower is true the thread is not the stage leader, the thread will be wait for the queue to be processed by the leader before it returns. In DBUG-ON version the follower marks is preempt status as ready.</p>
<p>The sesssion threads entering this function acquires mutexes, and few of them are not released while exiting based on thread and stage type.</p><ul>
<li>A binlog leader (returning true when stage!=COMMIT_ORDER_FLUSH_STAGE) will acquire the stage mutex in this function and not release it.</li>
<li>A commit order leader of the flush stage (returning true when stage==COMMIT_ORDER_FLUSH_STAGE) will acquire both the stage mutex and the flush queue mutex in this function, and not release them.</li>
<li>A follower (returning false) will release any mutexes it takes, before returning from the function.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Stage identifier for the queue to append to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Queue to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stage_mutex</td><td>Pointer to the currently held stage mutex, or nullptr if we're not in a stage, that will be released when changing stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enter_mutex</td><td>Pointer to the mutex that will be taken when changing stage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Thread is stage leader. </td></tr>
    <tr><td class="paramname">false</td><td>Thread was not stage leader and processing has been done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4fd2e494824d46a9b2f127ecbee9628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fd2e494824d46a9b2f127ecbee9628">&#9670;&nbsp;</a></span>fetch_queue_acquire_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTHD.html">THD</a> * Commit_stage_manager::fetch_queue_acquire_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the entire queue and empty it. </p>
<p>It acquires queue lock before fetching and emptying the queue threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Stage identifier for the queue to append to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first session of the queue. </dd></dl>

</div>
</div>
<a id="af3769ebf82d16a457793123cc447b6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3769ebf82d16a457793123cc447b6a8">&#9670;&nbsp;</a></span>fetch_queue_skip_acquire_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTHD.html">THD</a> * Commit_stage_manager::fetch_queue_skip_acquire_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the entire queue and empty it. </p>
<p>The caller must acquire queue lock before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Stage identifier for the queue to append to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first session of the queue. </dd></dl>

</div>
</div>
<a id="a89437cb17aa18ca4752507e7efa8e029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89437cb17aa18ca4752507e7efa8e029">&#9670;&nbsp;</a></span>get_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a> &amp; Commit_stage_manager::get_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch Commit_stage_manager class instance. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the Commit_stage_manager class instance. </dd></dl>

</div>
</div>
<a id="a8b1b7cdbf9b87fad1b1029666f473fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1b7cdbf9b87fad1b1029666f473fdd">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a>&#160;</td>
          <td class="paramname"><em>key_LOCK_flush_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a>&#160;</td>
          <td class="paramname"><em>key_LOCK_sync_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a>&#160;</td>
          <td class="paramname"><em>key_LOCK_commit_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a>&#160;</td>
          <td class="paramname"><em>key_LOCK_done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__psi__abi__cond.html#gad83033d86d97d0b965b0257be7674a51">PSI_cond_key</a>&#160;</td>
          <td class="paramname"><em>key_COND_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes m_stage_cond_binlog, m_stage_cond_commit_order, m_stage_cond_leader condition variables and m_lock_done mutex. </p>
<p>The binlog follower threads blocks on m_stage_cond_binlog condition variable till signalled to wake up from leader thread. And similarly commit order follower threads blocks on m_stage_cond_commit_order condition variable till signalled to wake up from leader thread.</p>
<p>The first binlog thread supposed to be leader finds that commit order queue is not empty then it blocks on m_stage_cond_leader till commit order leader signals it to awake and become new leader.</p>
<p>m_lock_done mutex is shared by all three stages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_LOCK_flush_queue</td><td>mutex instrumentation key </td></tr>
    <tr><td class="paramname">key_LOCK_sync_queue</td><td>mutex instrumentation key </td></tr>
    <tr><td class="paramname">key_LOCK_commit_queue</td><td>mutex instrumentation key </td></tr>
    <tr><td class="paramname">key_LOCK_done</td><td>mutex instrumentation key </td></tr>
    <tr><td class="paramname">key_COND_done</td><td>cond instrumentation key </td></tr>
  </table>
  </dd>
</dl>
<p>reuse key_COND_done 'cos a new PSI object would be wasteful in !DBUG_OFF</p>
<p>Initialize mutex for flush, sync and commit stage queue. The binlog flush stage and commit order flush stage share same mutex.</p>

</div>
</div>
<a id="ae4da6e6019e99b2b1abbbe5dee15436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da6e6019e99b2b1abbbe5dee15436d">&#9670;&nbsp;</a></span>lock_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::lock_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper on Mutex_queue lock(), acquires lock on stage queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Stage identifier for the queue to append to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0efd2bbe057c70e541632259447f3eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efd2bbe057c70e541632259447f3eec">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a>&amp; Commit_stage_manager::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2529356ee87307fecc60a91bb851e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2529356ee87307fecc60a91bb851e24">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="classTHD.html">THD</a> *&gt; Commit_stage_manager::pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove first member from the queue for given stage. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returns</td><td>std::pair&lt;bool, THD *&gt; object. The first boolean value of pair if true determines queue is not empty, and false determines queue is empty. The second value returns the first removed member. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed2bdab931c64f9888bd741e5c39c5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2bdab931c64f9888bd741e5c39c5a7">&#9670;&nbsp;</a></span>process_final_stage_for_ordered_commit_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::process_final_stage_for_ordered_commit_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>first</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets called after transactions are flushed to the engine i.e. </p>
<p>after calling ha_flush_logs, to unblock commit order thread list which are not needed to wait for other stages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the thread list which needs to ne unblocked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af49396c154288e76ab57cea748822eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49396c154288e76ab57cea748822eac">&#9670;&nbsp;</a></span>signal_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::signal_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em> = <code><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aa2eaeedb90de8c3ad012b8f82a212c8c">BINLOG_FLUSH_STAGE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function is called after follower thread are processed by leader, to unblock follower threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>the thread list which needs to ne unblocked </td></tr>
    <tr><td class="paramname">stage</td><td>Stage identifier current thread belong to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6afe5ed0954a0f4c6f127552be31bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6afe5ed0954a0f4c6f127552be31bcb">&#9670;&nbsp;</a></span>unlock_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::unlock_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper on Mutex_queue unlock(), releases lock on stage queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>Stage identifier for the queue to append to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7c13bfa09a66901a2387042d5037bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c13bfa09a66901a2387042d5037bc5">&#9670;&nbsp;</a></span>wait_count_or_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Commit_stage_manager::wait_count_or_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Introduces a wait operation on the executing thread. </p>
<p>The waiting is done until the timeout elapses or count is reached (whichever comes first).</p>
<p>If count == 0, then the session will wait until the timeout elapses. If timeout == 0, then there is no waiting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usec</td><td>the number of microseconds to wait. </td></tr>
    <tr><td class="paramname">count</td><td>wait for as many as count to join the queue the session is waiting on </td></tr>
    <tr><td class="paramname">stage</td><td>which stage queue size to compare count against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a49d0c38b97ba5d08be843b845b147eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d0c38b97ba5d08be843b845b147eb6">&#9670;&nbsp;</a></span>leader_await_preempt_status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Commit_stage_manager::leader_await_preempt_status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag is set by Leader when it starts waiting for follower's all-clear. </p>

</div>
</div>
<a id="aeae3d1b2d12e0e9b6409d0fe90005366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae3d1b2d12e0e9b6409d0fe90005366">&#9670;&nbsp;</a></span>leader_thd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTHD.html">THD</a>* Commit_stage_manager::leader_thd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save pointer to leader thread which is used later to awake leader. </p>

</div>
</div>
<a id="af46820c0a78a27cdf73e20d5822ad974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46820c0a78a27cdf73e20d5822ad974">&#9670;&nbsp;</a></span>m_cond_preempt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a> Commit_stage_manager::m_cond_preempt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition variable to indicate a follower started waiting for commit. </p>

</div>
</div>
<a id="abb39a5f2ef1e37a69fec66cabcb1fd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb39a5f2ef1e37a69fec66cabcb1fd2b">&#9670;&nbsp;</a></span>m_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Commit_stage_manager::m_is_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if Commit_stage_manager variables already initalized. </p>

</div>
</div>
<a id="a206252c710872103ab216cb896a53338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206252c710872103ab216cb896a53338">&#9670;&nbsp;</a></span>m_lock_done</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a> Commit_stage_manager::m_lock_done</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex used for the condition variable above. </p>

</div>
</div>
<a id="a51629c8694e4853b7d08cd4825d0b474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51629c8694e4853b7d08cd4825d0b474">&#9670;&nbsp;</a></span>m_queue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCommit__stage__manager_1_1Mutex__queue.html">Mutex_queue</a> Commit_stage_manager::m_queue[<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aea53d9e5e491e1a6b92f1840f2951610">STAGE_COUNTER</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues for sessions. </p>
<p>We need four queues:</p><ul>
<li>Binlog flush queue: transactions that are going to be flushed to the engine and written to the binary log.</li>
<li>Commit order flush queue: transactions that are not going to write the binlog at all, but participate in the beginning of the group commit, up to and including the engine flush.</li>
<li>Sync queue: transactions that are going to be synced to disk</li>
<li>Commit queue: transactions that are going to to be committed (when binlog_order_commit=1). </li>
</ul>

</div>
</div>
<a id="a7dd6d2dde28077154e4ad4bed6d2c502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd6d2dde28077154e4ad4bed6d2c502">&#9670;&nbsp;</a></span>m_queue_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a> Commit_stage_manager::m_queue_lock[<a class="el" href="classCommit__stage__manager.html#a87820f6cd4c5552fbbe187b02bb60be0aea53d9e5e491e1a6b92f1840f2951610">STAGE_COUNTER</a> - 1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex used for the stage level locks. </p>

</div>
</div>
<a id="a4d9e2d7191f1a9452a92bb312674d016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9e2d7191f1a9452a92bb312674d016">&#9670;&nbsp;</a></span>m_stage_cond_binlog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a> Commit_stage_manager::m_stage_cond_binlog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition variable to indicate that the binlog threads can wake up and continue. </p>

</div>
</div>
<a id="a5ff063073786be9052b6f507b03ee55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff063073786be9052b6f507b03ee55f">&#9670;&nbsp;</a></span>m_stage_cond_commit_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a> Commit_stage_manager::m_stage_cond_commit_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition variable to indicate that the flush to storage engine is done and commit order threads can again wake up and continue. </p>

</div>
</div>
<a id="a2cfb2044120f03ff5a70c9e7637a00fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfb2044120f03ff5a70c9e7637a00fd">&#9670;&nbsp;</a></span>m_stage_cond_leader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a> Commit_stage_manager::m_stage_cond_leader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The binlog leader waits on this condition variable till it is indicated to wake up. </p>
<p>If binlog flush queue gets first thread in the queue but by then commit order flush queue has already elected leader. The the first thread of binlog queue waits on this condition variable and get signalled to wake up from commit order flush queue leader later. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="rpl__commit__stage__manager_8h_source.html">rpl_commit_stage_manager.h</a></li>
<li>sql/<a class="el" href="rpl__commit__stage__manager_8cc.html">rpl_commit_stage_manager.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classCommit__stage__manager.html">Commit_stage_manager</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
