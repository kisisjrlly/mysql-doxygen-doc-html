<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/buf0lru.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('buf0lru_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0lru.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The database buffer pool LRU replacement algorithm.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
</div>
<p><a href="buf0lru_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for selecting the LRU list for eviction.  <a href="structbuf__LRU__stat__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8d6ec57c76991ad6ffd4d87309a49c38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a8d6ec57c76991ad6ffd4d87309a49c38">BUF_LRU_OLD_MIN_LEN</a>&#160;&#160;&#160;512 /* 8 megabytes of 16k pages */</td></tr>
<tr class="memdesc:a8d6ec57c76991ad6ffd4d87309a49c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum LRU list length for which the LRU_old pointer is defined.  <a href="#a8d6ec57c76991ad6ffd4d87309a49c38">More...</a><br /></td></tr>
<tr class="separator:a8d6ec57c76991ad6ffd4d87309a49c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33fa022c81d8729f8cedbbac34651ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#ad33fa022c81d8729f8cedbbac34651ab">buf_LRU_stat_inc_io</a>()&#160;&#160;&#160;buf_LRU_stat_cur.io++</td></tr>
<tr class="memdesc:ad33fa022c81d8729f8cedbbac34651ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the I/O counter in buf_LRU_stat_cur.  <a href="#ad33fa022c81d8729f8cedbbac34651ab">More...</a><br /></td></tr>
<tr class="separator:ad33fa022c81d8729f8cedbbac34651ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cd4b974ea6729a6b36693b401c7716"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#af0cd4b974ea6729a6b36693b401c7716">buf_LRU_stat_inc_unzip</a>()&#160;&#160;&#160;buf_LRU_stat_cur.unzip++</td></tr>
<tr class="memdesc:af0cd4b974ea6729a6b36693b401c7716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the page_zip_decompress() counter in buf_LRU_stat_cur.  <a href="#af0cd4b974ea6729a6b36693b401c7716">More...</a><br /></td></tr>
<tr class="separator:af0cd4b974ea6729a6b36693b401c7716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab515ca10b95a13c8fcac45f492b6e855"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#ab515ca10b95a13c8fcac45f492b6e855">buf_LRU_buf_pool_running_out</a> (void)</td></tr>
<tr class="memdesc:ab515ca10b95a13c8fcac45f492b6e855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if less than 25 % of the buffer pool is available.  <a href="#ab515ca10b95a13c8fcac45f492b6e855">More...</a><br /></td></tr>
<tr class="separator:ab515ca10b95a13c8fcac45f492b6e855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5d416871fb68c49e48d7f190dfa356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a1c5d416871fb68c49e48d7f190dfa356">buf_LRU_flush_or_remove_pages</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a> buf_remove, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> strict=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:a1c5d416871fb68c49e48d7f190dfa356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all dirty pages or removes all pages belonging to a given tablespace.  <a href="#a1c5d416871fb68c49e48d7f190dfa356">More...</a><br /></td></tr>
<tr class="separator:a1c5d416871fb68c49e48d7f190dfa356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71034f6a657d17a7b12f924484f5f4b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a71034f6a657d17a7b12f924484f5f4b9">buf_LRU_insert_zip_clean</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a71034f6a657d17a7b12f924484f5f4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a compressed block into buf_pool-&gt;zip_clean in the LRU order.  <a href="#a71034f6a657d17a7b12f924484f5f4b9">More...</a><br /></td></tr>
<tr class="separator:a71034f6a657d17a7b12f924484f5f4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944b5fe6a7102d6cdfd20c1c8baed0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#ab944b5fe6a7102d6cdfd20c1c8baed0e">buf_LRU_free_page</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> zip)</td></tr>
<tr class="memdesc:ab944b5fe6a7102d6cdfd20c1c8baed0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to free a block.  <a href="#ab944b5fe6a7102d6cdfd20c1c8baed0e">More...</a><br /></td></tr>
<tr class="separator:ab944b5fe6a7102d6cdfd20c1c8baed0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd67b9190c8f7b9d270e50c888160c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aa5bd67b9190c8f7b9d270e50c888160c">buf_LRU_scan_and_free_block</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> scan_all)</td></tr>
<tr class="memdesc:aa5bd67b9190c8f7b9d270e50c888160c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to free a replaceable block.  <a href="#aa5bd67b9190c8f7b9d270e50c888160c">More...</a><br /></td></tr>
<tr class="separator:aa5bd67b9190c8f7b9d270e50c888160c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437daab4f8f29da688cb649950f3c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aa437daab4f8f29da688cb649950f3c5b">buf_LRU_get_free_only</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:aa437daab4f8f29da688cb649950f3c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free block from the buf_pool.  <a href="#aa437daab4f8f29da688cb649950f3c5b">More...</a><br /></td></tr>
<tr class="separator:aa437daab4f8f29da688cb649950f3c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02f0192cd5a3751396b3c023a37b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a4b02f0192cd5a3751396b3c023a37b9e">buf_LRU_get_free_block</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a4b02f0192cd5a3751396b3c023a37b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free block from the buf_pool.  <a href="#a4b02f0192cd5a3751396b3c023a37b9e">More...</a><br /></td></tr>
<tr class="separator:a4b02f0192cd5a3751396b3c023a37b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b72ad753812794778dfbf22a961ce4"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a89b72ad753812794778dfbf22a961ce4">buf_LRU_evict_from_unzip_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a89b72ad753812794778dfbf22a961ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the unzip_LRU list should be used for evicting a victim instead of the general LRU list.  <a href="#a89b72ad753812794778dfbf22a961ce4">More...</a><br /></td></tr>
<tr class="separator:a89b72ad753812794778dfbf22a961ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81143c182cdc5ce2aeb5033dd435018e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a81143c182cdc5ce2aeb5033dd435018e">buf_LRU_block_free_non_file_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a81143c182cdc5ce2aeb5033dd435018e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a block back to the free list.  <a href="#a81143c182cdc5ce2aeb5033dd435018e">More...</a><br /></td></tr>
<tr class="separator:a81143c182cdc5ce2aeb5033dd435018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37acd1d770ff94c59155beb100720d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a0b37acd1d770ff94c59155beb100720d">buf_LRU_add_block</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, ibool old)</td></tr>
<tr class="memdesc:a0b37acd1d770ff94c59155beb100720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a block to the LRU list.  <a href="#a0b37acd1d770ff94c59155beb100720d">More...</a><br /></td></tr>
<tr class="separator:a0b37acd1d770ff94c59155beb100720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e495c4bde95a1ffeee80477589c19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aa2e495c4bde95a1ffeee80477589c19c">buf_unzip_LRU_add_block</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ibool old)</td></tr>
<tr class="memdesc:aa2e495c4bde95a1ffeee80477589c19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a block to the LRU list of decompressed zip pages.  <a href="#aa2e495c4bde95a1ffeee80477589c19c">More...</a><br /></td></tr>
<tr class="separator:aa2e495c4bde95a1ffeee80477589c19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a541c8810f1079a8f69ce67efb3dd48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a5a541c8810f1079a8f69ce67efb3dd48">buf_LRU_make_block_young</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a5a541c8810f1079a8f69ce67efb3dd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a block to the start of the LRU list.  <a href="#a5a541c8810f1079a8f69ce67efb3dd48">More...</a><br /></td></tr>
<tr class="separator:a5a541c8810f1079a8f69ce67efb3dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da9010d067c9ed107d9639a365939ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a4da9010d067c9ed107d9639a365939ed">buf_LRU_make_block_old</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a4da9010d067c9ed107d9639a365939ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a block to the end of the LRU list.  <a href="#a4da9010d067c9ed107d9639a365939ed">More...</a><br /></td></tr>
<tr class="separator:a4da9010d067c9ed107d9639a365939ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf0d5ba597c72a2c4dca148c74a498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a6fbf0d5ba597c72a2c4dca148c74a498">buf_LRU_old_ratio_update</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> old_pct, ibool adjust)</td></tr>
<tr class="memdesc:a6fbf0d5ba597c72a2c4dca148c74a498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates buf_pool-&gt;LRU_old_ratio.  <a href="#a6fbf0d5ba597c72a2c4dca148c74a498">More...</a><br /></td></tr>
<tr class="separator:a6fbf0d5ba597c72a2c4dca148c74a498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97799d0b01ded04c3a9530c29f7a009f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a97799d0b01ded04c3a9530c29f7a009f">buf_LRU_stat_update</a> (void)</td></tr>
<tr class="memdesc:a97799d0b01ded04c3a9530c29f7a009f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the historical stats that we are collecting for LRU eviction policy at the end of each interval.  <a href="#a97799d0b01ded04c3a9530c29f7a009f">More...</a><br /></td></tr>
<tr class="separator:a97799d0b01ded04c3a9530c29f7a009f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273f4959459f79c4f47fc8e626251f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a273f4959459f79c4f47fc8e626251f3a">buf_LRU_free_one_page</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> zip, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ignore_content)</td></tr>
<tr class="memdesc:a273f4959459f79c4f47fc8e626251f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one page from LRU list and put it to free list.  <a href="#a273f4959459f79c4f47fc8e626251f3a">More...</a><br /></td></tr>
<tr class="separator:a273f4959459f79c4f47fc8e626251f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7322b3f6632a7980efd30fdd388975e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a7322b3f6632a7980efd30fdd388975e7">buf_LRU_adjust_hp</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a7322b3f6632a7980efd30fdd388975e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust LRU hazard pointers if needed.  <a href="#a7322b3f6632a7980efd30fdd388975e7">More...</a><br /></td></tr>
<tr class="separator:a7322b3f6632a7980efd30fdd388975e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1658f4c7b393310ce247257ead0fbf"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a3a1658f4c7b393310ce247257ead0fbf">buf_LRU_validate</a> (void)</td></tr>
<tr class="memdesc:a3a1658f4c7b393310ce247257ead0fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the LRU list.  <a href="#a3a1658f4c7b393310ce247257ead0fbf">More...</a><br /></td></tr>
<tr class="separator:a3a1658f4c7b393310ce247257ead0fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94a8fa767c16d5922987d25bcfc2daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#ae94a8fa767c16d5922987d25bcfc2daf">buf_LRU_print</a> (void)</td></tr>
<tr class="memdesc:ae94a8fa767c16d5922987d25bcfc2daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the LRU list.  <a href="#ae94a8fa767c16d5922987d25bcfc2daf">More...</a><br /></td></tr>
<tr class="separator:ae94a8fa767c16d5922987d25bcfc2daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa535da980a8fb505f33884c4d838e65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aa535da980a8fb505f33884c4d838e65b">buf_LRU_stat_cur</a></td></tr>
<tr class="memdesc:aa535da980a8fb505f33884c4d838e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current operation counters.  <a href="#aa535da980a8fb505f33884c4d838e65b">More...</a><br /></td></tr>
<tr class="separator:aa535da980a8fb505f33884c4d838e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875cfab89124f0c3eee966035fd211e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a875cfab89124f0c3eee966035fd211e8">buf_LRU_stat_sum</a></td></tr>
<tr class="memdesc:a875cfab89124f0c3eee966035fd211e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Running sum of past values of buf_LRU_stat_cur.  <a href="#a875cfab89124f0c3eee966035fd211e8">More...</a><br /></td></tr>
<tr class="separator:a875cfab89124f0c3eee966035fd211e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Heuristics for detecting index scan</h2></td></tr>
<tr class="memitem:aae4d83c458daabfcd368131289b46af9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aae4d83c458daabfcd368131289b46af9">BUF_LRU_OLD_RATIO_DIV</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:aae4d83c458daabfcd368131289b46af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The denominator of buf_pool-&gt;LRU_old_ratio.  <a href="#aae4d83c458daabfcd368131289b46af9">More...</a><br /></td></tr>
<tr class="separator:aae4d83c458daabfcd368131289b46af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b18661ce0d86a7dd2f2aee37820cc7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a7b18661ce0d86a7dd2f2aee37820cc7a">BUF_LRU_OLD_RATIO_MAX</a>&#160;&#160;&#160;<a class="el" href="buf0lru_8h.html#aae4d83c458daabfcd368131289b46af9">BUF_LRU_OLD_RATIO_DIV</a></td></tr>
<tr class="memdesc:a7b18661ce0d86a7dd2f2aee37820cc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of buf_pool-&gt;LRU_old_ratio.  <a href="#a7b18661ce0d86a7dd2f2aee37820cc7a">More...</a><br /></td></tr>
<tr class="separator:a7b18661ce0d86a7dd2f2aee37820cc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df9eccdeaed1e37b90a32c76cda1520"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a7df9eccdeaed1e37b90a32c76cda1520">BUF_LRU_OLD_RATIO_MIN</a>&#160;&#160;&#160;51</td></tr>
<tr class="memdesc:a7df9eccdeaed1e37b90a32c76cda1520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum value of buf_pool-&gt;LRU_old_ratio.  <a href="#a7df9eccdeaed1e37b90a32c76cda1520">More...</a><br /></td></tr>
<tr class="separator:a7df9eccdeaed1e37b90a32c76cda1520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fb54c3fd2164554f62ef7b3c100607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a22fb54c3fd2164554f62ef7b3c100607">buf_LRU_old_threshold_ms</a></td></tr>
<tr class="memdesc:a22fb54c3fd2164554f62ef7b3c100607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move blocks to "new" LRU list only if the first access was at least this many milliseconds ago.  <a href="#a22fb54c3fd2164554f62ef7b3c100607">More...</a><br /></td></tr>
<tr class="separator:a22fb54c3fd2164554f62ef7b3c100607"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer pool LRU replacement algorithm. </p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8d6ec57c76991ad6ffd4d87309a49c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6ec57c76991ad6ffd4d87309a49c38">&#9670;&nbsp;</a></span>BUF_LRU_OLD_MIN_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_MIN_LEN&#160;&#160;&#160;512 /* 8 megabytes of 16k pages */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum LRU list length for which the LRU_old pointer is defined. </p>

</div>
</div>
<a id="aae4d83c458daabfcd368131289b46af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4d83c458daabfcd368131289b46af9">&#9670;&nbsp;</a></span>BUF_LRU_OLD_RATIO_DIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_RATIO_DIV&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The denominator of buf_pool-&gt;LRU_old_ratio. </p>

</div>
</div>
<a id="a7b18661ce0d86a7dd2f2aee37820cc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b18661ce0d86a7dd2f2aee37820cc7a">&#9670;&nbsp;</a></span>BUF_LRU_OLD_RATIO_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_RATIO_MAX&#160;&#160;&#160;<a class="el" href="buf0lru_8h.html#aae4d83c458daabfcd368131289b46af9">BUF_LRU_OLD_RATIO_DIV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value of buf_pool-&gt;LRU_old_ratio. </p>
<dl class="section see"><dt>See also</dt><dd>buf_LRU_old_adjust_len </dd>
<dd>
buf_pool-&gt;LRU_old_ratio_update </dd></dl>

</div>
</div>
<a id="a7df9eccdeaed1e37b90a32c76cda1520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df9eccdeaed1e37b90a32c76cda1520">&#9670;&nbsp;</a></span>BUF_LRU_OLD_RATIO_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_RATIO_MIN&#160;&#160;&#160;51</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum value of buf_pool-&gt;LRU_old_ratio. </p>
<dl class="section see"><dt>See also</dt><dd>buf_LRU_old_adjust_len </dd>
<dd>
buf_pool-&gt;LRU_old_ratio_update The minimum must exceed (BUF_LRU_OLD_TOLERANCE + 5) * BUF_LRU_OLD_RATIO_DIV / BUF_LRU_OLD_MIN_LEN. </dd></dl>

</div>
</div>
<a id="ad33fa022c81d8729f8cedbbac34651ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33fa022c81d8729f8cedbbac34651ab">&#9670;&nbsp;</a></span>buf_LRU_stat_inc_io</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_LRU_stat_inc_io</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;buf_LRU_stat_cur.io++</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the I/O counter in buf_LRU_stat_cur. </p>

</div>
</div>
<a id="af0cd4b974ea6729a6b36693b401c7716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cd4b974ea6729a6b36693b401c7716">&#9670;&nbsp;</a></span>buf_LRU_stat_inc_unzip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_LRU_stat_inc_unzip</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;buf_LRU_stat_cur.unzip++</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the page_zip_decompress() counter in buf_LRU_stat_cur. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0b37acd1d770ff94c59155beb100720d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37acd1d770ff94c59155beb100720d">&#9670;&nbsp;</a></span>buf_LRU_add_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_add_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a block to the LRU list. </p>
<p>Please make sure that the page_size is already set when invoking the function, so that we can get correct page_size from the buffer page when adding a block into LRU in: TRUE if should be put to the old blocks in the LRU list, else put to the start; if the LRU list is very short, added to the start regardless of this parameter</p>
<p>Please make sure that the page_size is already set when invoking the function, so that we can get correct page_size from the buffer page when adding a block into LRU </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: control block </td></tr>
    <tr><td class="paramname">old</td><td>in: TRUE if should be put to the old blocks in the LRU list, else put to the start; if the LRU list is very short, the block is added to the start, regardless of this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7322b3f6632a7980efd30fdd388975e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7322b3f6632a7980efd30fdd388975e7">&#9670;&nbsp;</a></span>buf_LRU_adjust_hp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_adjust_hp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust LRU hazard pointers if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>Buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>Control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81143c182cdc5ce2aeb5033dd435018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81143c182cdc5ce2aeb5033dd435018e">&#9670;&nbsp;</a></span>buf_LRU_block_free_non_file_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_block_free_non_file_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a block back to the free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>block must not contain a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab515ca10b95a13c8fcac45f492b6e855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515ca10b95a13c8fcac45f492b6e855">&#9670;&nbsp;</a></span>buf_LRU_buf_pool_running_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_LRU_buf_pool_running_out </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if less than 25 % of the buffer pool is available. </p>
<p>This can be used in heuristics to prevent huge transactions eating up the whole buffer pool for their locks. </p><dl class="section return"><dt>Returns</dt><dd>true if less than 25 % of buffer pool left</dd></dl>
<p>Returns TRUE if less than 25 % of the buffer pool is available.</p>
<p>This can be used in heuristics to prevent huge transactions eating up the whole buffer pool for their locks. </p><dl class="section return"><dt>Returns</dt><dd>true if less than 25 % of buffer pool left </dd></dl>

</div>
</div>
<a id="a89b72ad753812794778dfbf22a961ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b72ad753812794778dfbf22a961ce4">&#9670;&nbsp;</a></span>buf_LRU_evict_from_unzip_LRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_LRU_evict_from_unzip_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the unzip_LRU list should be used for evicting a victim instead of the general LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if should use unzip_LRU </dd></dl>

</div>
</div>
<a id="a1c5d416871fb68c49e48d7f190dfa356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5d416871fb68c49e48d7f190dfa356">&#9670;&nbsp;</a></span>buf_LRU_flush_or_remove_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_flush_or_remove_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a>&#160;</td>
          <td class="paramname"><em>buf_remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>strict</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes all dirty pages or removes all pages belonging to a given tablespace. </p>
<p>A PROBLEM: if readahead is being started, what guarantees that it will not try to read in pages after this operation has completed? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>tablespace ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_remove</td><td>remove or flush strategy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>to check if the operation must be interrupted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>true, if no page from tablespace can be in buffer pool just after flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a273f4959459f79c4f47fc8e626251f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273f4959459f79c4f47fc8e626251f3a">&#9670;&nbsp;</a></span>buf_LRU_free_one_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_free_one_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove one page from LRU list and put it to free list. </p>
<p>The caller must hold the LRU list and block mutexes and have page hash latched in X. The latch and the block mutexes will be released. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>block, must contain a file page and be in a state where it can be freed; there may or may not be a hash index to the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zip</td><td>true if should remove also the compressed page of an uncompressed page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_content</td><td>true if should ignore page content, since it could be not initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab944b5fe6a7102d6cdfd20c1c8baed0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab944b5fe6a7102d6cdfd20c1c8baed0e">&#9670;&nbsp;</a></span>buf_LRU_free_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_LRU_free_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to free a block. </p>
<p>If bpage is a descriptor of a compressed-only page, the descriptor object will be freed as well. NOTE: this function may temporarily release and relock the buf_page_get_mutex(). Furthermore, the page frame will no longer be accessible via bpage. If this function returns true, it will also release the LRU list mutex. The caller must hold the LRU list and buf_page_get_mutex() mutexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>block to be freed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zip</td><td>true if should remove also the compressed page of an uncompressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if freed, false otherwise. </dd></dl>

</div>
</div>
<a id="a4b02f0192cd5a3751396b3c023a37b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02f0192cd5a3751396b3c023a37b9e">&#9670;&nbsp;</a></span>buf_LRU_get_free_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_LRU_get_free_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free block from the buf_pool. </p>
<p>The block is taken off the free list. If free list is empty, blocks are moved from the end of the LRU list to the free list. This function is called from a user thread when it needs a clean block to read in a page. Note that we only ever get a block from the free list. Even when we flush a page or find a page in LRU scan we put it to free list to be used. iteration 0: get a block from free list, success:done if buf_pool-&gt;try_LRU_scan is set scan LRU up to srv_LRU_scan_depth to find a clean block the above will put the block on free list success:retry the free list flush one dirty page from tail of LRU to disk the above will put the block on free list success: retry the free list iteration 1: same as iteration 0 except: scan whole LRU list scan LRU list even if buf_pool-&gt;try_LRU_scan is not set iteration &gt; 1: same as iteration 1 but sleep 10ms </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the free control block, in state BUF_BLOCK_READY_FOR_USE </dd></dl>

</div>
</div>
<a id="aa437daab4f8f29da688cb649950f3c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa437daab4f8f29da688cb649950f3c5b">&#9670;&nbsp;</a></span>buf_LRU_get_free_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_LRU_get_free_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free block from the buf_pool. </p>
<p>The block is taken off the free list. If it is empty, returns NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a free control block, or NULL if the buf_block-&gt;free list is empty </dd></dl>

</div>
</div>
<a id="a71034f6a657d17a7b12f924484f5f4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71034f6a657d17a7b12f924484f5f4b9">&#9670;&nbsp;</a></span>buf_LRU_insert_zip_clean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_insert_zip_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a compressed block into buf_pool-&gt;zip_clean in the LRU order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4da9010d067c9ed107d9639a365939ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da9010d067c9ed107d9639a365939ed">&#9670;&nbsp;</a></span>buf_LRU_make_block_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_make_block_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a block to the end of the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a541c8810f1079a8f69ce67efb3dd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a541c8810f1079a8f69ce67efb3dd48">&#9670;&nbsp;</a></span>buf_LRU_make_block_young()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_make_block_young </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a block to the start of the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fbf0d5ba597c72a2c4dca148c74a498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbf0d5ba597c72a2c4dca148c74a498">&#9670;&nbsp;</a></span>buf_LRU_old_ratio_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> buf_LRU_old_ratio_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>old_pct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates buf_pool-&gt;LRU_old_ratio. </p>
<dl class="section return"><dt>Returns</dt><dd>updated old_pct in: TRUE=adjust the LRU list; FALSE=just assign buf_pool-&gt;LRU_old_ratio during the initialization of InnoDB</dd>
<dd>
updated old_pct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_pct</td><td>in: Reserve this percentage of the buffer pool for "old" blocks. </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE=adjust the LRU list; FALSE=just assign buf_pool-&gt;LRU_old_ratio during the initialization of InnoDB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae94a8fa767c16d5922987d25bcfc2daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94a8fa767c16d5922987d25bcfc2daf">&#9670;&nbsp;</a></span>buf_LRU_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the LRU list. </p>

</div>
</div>
<a id="aa5bd67b9190c8f7b9d270e50c888160c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bd67b9190c8f7b9d270e50c888160c">&#9670;&nbsp;</a></span>buf_LRU_scan_and_free_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_LRU_scan_and_free_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>scan_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to free a replaceable block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_all</td><td>scan whole LRU list if ture, otherwise scan only BUF_LRU_SEARCH_SCAN_THRESHOLD blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if found and freed </dd></dl>

</div>
</div>
<a id="a97799d0b01ded04c3a9530c29f7a009f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97799d0b01ded04c3a9530c29f7a009f">&#9670;&nbsp;</a></span>buf_LRU_stat_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_LRU_stat_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the historical stats that we are collecting for LRU eviction policy at the end of each interval. </p>

</div>
</div>
<a id="a3a1658f4c7b393310ce247257ead0fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1658f4c7b393310ce247257ead0fbf">&#9670;&nbsp;</a></span>buf_LRU_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_LRU_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the LRU list. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="aa2e495c4bde95a1ffeee80477589c19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e495c4bde95a1ffeee80477589c19c">&#9670;&nbsp;</a></span>buf_unzip_LRU_add_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_unzip_LRU_add_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a block to the LRU list of decompressed zip pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old</td><td>TRUE if should be put to the end of the list, else put to the start </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a22fb54c3fd2164554f62ef7b3c100607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fb54c3fd2164554f62ef7b3c100607">&#9670;&nbsp;</a></span>buf_LRU_old_threshold_ms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> buf_LRU_old_threshold_ms</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move blocks to "new" LRU list only if the first access was at least this many milliseconds ago. </p>
<p>Not protected by any mutex or latch. </p>

</div>
</div>
<a id="aa535da980a8fb505f33884c4d838e65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa535da980a8fb505f33884c4d838e65b">&#9670;&nbsp;</a></span>buf_LRU_stat_cur</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a> buf_LRU_stat_cur</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current operation counters. </p>
<p>Not protected by any mutex. Cleared by buf_LRU_stat_update(). </p>

</div>
</div>
<a id="a875cfab89124f0c3eee966035fd211e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875cfab89124f0c3eee966035fd211e8">&#9670;&nbsp;</a></span>buf_LRU_stat_sum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a> buf_LRU_stat_sum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Running sum of past values of buf_LRU_stat_cur. </p>
<p>Updated by buf_LRU_stat_update(). Accesses protected by memory barriers.</p>
<p>Updated by buf_LRU_stat_update(). Not Protected by any mutex. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="buf0lru_8h.html">buf0lru.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
