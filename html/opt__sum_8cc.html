<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: sql/opt_sum.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('opt__sum_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">opt_sum.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Optimising of MIN(), MAX() and COUNT(*) queries without 'group by' clause by replacing the aggregate expression with a constant.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ft__global_8h_source.html">ft_global.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__base_8h_source.html">my_base.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__bitmap_8h_source.html">my_bitmap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__inttypes_8h_source.html">my_inttypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__sys_8h_source.html">my_sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__table__map_8h_source.html">my_table_map.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mysql__com_8h_source.html">mysql_com.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql_2field_8h_source.html">sql/field.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql_2handler_8h_source.html">sql/handler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="item_8h_source.html">sql/item.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="item__cmpfunc_8h_source.html">sql/item_cmpfunc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="item__func_8h_source.html">sql/item_func.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="item__sum_8h_source.html">sql/item_sum.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="key_8h_source.html">sql/key.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__bitmap_8h_source.html">sql/sql_bitmap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__class_8h_source.html">sql/sql_class.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__const_8h_source.html">sql/sql_const.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__error_8h_source.html">sql/sql_error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__lex_8h_source.html">sql/sql_lex.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__list_8h_source.html">sql/sql_list.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__opt__exec__shared_8h_source.html">sql/sql_opt_exec_shared.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__select_8h_source.html">sql/sql_select.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql_2table_8h_source.html">sql/table.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b9e63a1ce68ffda8e8e9b88eb986f6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#a1b9e63a1ce68ffda8e8e9b88eb986f6c">find_key_for_maxmin</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> max_fl, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *range_fl, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *prefix_len)</td></tr>
<tr class="memdesc:a1b9e63a1ce68ffda8e8e9b88eb986f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether we can get value for {max|min}(field) by using a key.  <a href="#a1b9e63a1ce68ffda8e8e9b88eb986f6c">More...</a><br /></td></tr>
<tr class="separator:a1b9e63a1ce68ffda8e8e9b88eb986f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2152391d371e9704b9fa632c6cf183"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#a4c2152391d371e9704b9fa632c6cf183">reckey_in_range</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> max_fl, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> range_fl, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> prefix_len)</td></tr>
<tr class="memdesc:a4c2152391d371e9704b9fa632c6cf183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether found key is in range specified by conditions.  <a href="#a4c2152391d371e9704b9fa632c6cf183">More...</a><br /></td></tr>
<tr class="separator:a4c2152391d371e9704b9fa632c6cf183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5ef702acd4bf40c41589ff1030c41c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#a8d5ef702acd4bf40c41589ff1030c41c">maxmin_in_range</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> max_fl, <a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr class="memdesc:a8d5ef702acd4bf40c41589ff1030c41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether {MAX|MIN}(field) is in range specified by conditions.  <a href="#a8d5ef702acd4bf40c41589ff1030c41c">More...</a><br /></td></tr>
<tr class="separator:a8d5ef702acd4bf40c41589ff1030c41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbc8b09d69d865220628ae59ada692b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#a1cbc8b09d69d865220628ae59ada692b">get_exact_record_count</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr class="memdesc:a1cbc8b09d69d865220628ae59ada692b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get exact count of rows in all tables.  <a href="#a1cbc8b09d69d865220628ae59ada692b">More...</a><br /></td></tr>
<tr class="separator:a1cbc8b09d69d865220628ae59ada692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf0387169627f238df0500dc57e9bf4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#a7bf0387169627f238df0500dc57e9bf4">get_index_min_value</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> range_fl, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> prefix_len)</td></tr>
<tr class="memdesc:a7bf0387169627f238df0500dc57e9bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use index to read MIN(field) value.  <a href="#a7bf0387169627f238df0500dc57e9bf4">More...</a><br /></td></tr>
<tr class="separator:a7bf0387169627f238df0500dc57e9bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5700b2eed83272859e1a708fd72d86bf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#a5700b2eed83272859e1a708fd72d86bf">get_index_max_value</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> range_fl)</td></tr>
<tr class="memdesc:a5700b2eed83272859e1a708fd72d86bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use index to read MAX(field) value.  <a href="#a5700b2eed83272859e1a708fd72d86bf">More...</a><br /></td></tr>
<tr class="separator:a5700b2eed83272859e1a708fd72d86bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfc743a81e763a6c3cbfbf009e12e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#a0bfc743a81e763a6c3cbfbf009e12e3f">optimize_aggregated_query</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, <a class="el" href="classItem.html">Item</a> *conds, <a class="el" href="sql__select_8h.html#a5fb96357c4fe7aa7465c0eec3ea528b5">aggregate_evaluated</a> *decision)</td></tr>
<tr class="memdesc:a0bfc743a81e763a6c3cbfbf009e12e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute constants for some COUNT(), MIN() and MAX() functions in an aggregated (implicitly grouped) query.  <a href="#a0bfc743a81e763a6c3cbfbf009e12e3f">More...</a><br /></td></tr>
<tr class="separator:a0bfc743a81e763a6c3cbfbf009e12e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae7cc2d8de0971fd45df71329943de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#acae7cc2d8de0971fd45df71329943de4">simple_pred</a> (<a class="el" href="classItem__func.html">Item_func</a> *func_item, <a class="el" href="classItem.html">Item</a> **args, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *inv_order)</td></tr>
<tr class="memdesc:acae7cc2d8de0971fd45df71329943de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the predicate compares a field with constants.  <a href="#acae7cc2d8de0971fd45df71329943de4">More...</a><br /></td></tr>
<tr class="separator:acae7cc2d8de0971fd45df71329943de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc42bfd3093645303ef6fd0846e2ea85"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opt__sum_8cc.html#abc42bfd3093645303ef6fd0846e2ea85">matching_cond</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> max_fl, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="classKEY.html">KEY</a> *<a class="el" href="mi__test1_8cc.html#abbe831ba912eadb0f970ffb20d10340a">keyinfo</a>, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *field_part, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> map, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> *key_part_used, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *range_fl, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *prefix_len)</td></tr>
<tr class="memdesc:abc42bfd3093645303ef6fd0846e2ea85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a condition matches a key to get {MAX|MIN}(field):.  <a href="#abc42bfd3093645303ef6fd0846e2ea85">More...</a><br /></td></tr>
<tr class="separator:abc42bfd3093645303ef6fd0846e2ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Optimising of MIN(), MAX() and COUNT(*) queries without 'group by' clause by replacing the aggregate expression with a constant. </p>
<p>Given a table with a compound key on columns (a,b,c), the following types of queries are optimised (assuming the table handler supports the required methods)</p>
<pre class="fragment">SELECT COUNT(*) FROM t1[,t2,t3,...]
SELECT MIN(b) FROM t1 WHERE a=const
SELECT MAX(c) FROM t1 WHERE a=const AND b=const
SELECT MAX(b) FROM t1 WHERE a=const AND b&lt;const
SELECT MIN(b) FROM t1 WHERE a=const AND b&gt;const
SELECT MIN(b) FROM t1 WHERE a=const AND b BETWEEN const AND const
SELECT MAX(b) FROM t1 WHERE a=const AND b BETWEEN const AND const
</pre><p>Instead of '&lt;' one can use '&lt;=', '&gt;', '&gt;=' and '=' as well. Instead of 'a=const' the condition 'a IS NULL' can be used.</p>
<p>If all selected fields are replaced then we will also remove all involved tables and return the answer without any join. Thus, the following query will be replaced with a row of two constants: </p><pre class="fragment">SELECT MAX(b), MIN(d) FROM t1,t2
  WHERE a=const AND b&lt;const AND d&gt;const
</pre><p> (assuming a index for column d of table t2 is defined) </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1b9e63a1ce68ffda8e8e9b88eb986f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9e63a1ce68ffda8e8e9b88eb986f6c">&#9670;&nbsp;</a></span>find_key_for_maxmin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> find_key_for_maxmin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>max_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>range_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>prefix_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether we can get value for {max|min}(field) by using a key. </p>
<p>If where-condition is not a conjunction of 0 or more conjuct the function returns false, otherwise it checks whether there is an index including field as its k-th component/part such that:</p>
<ol type="1">
<li>for each previous component f_i there is one and only one conjunct of the form: f_i= const_i or const_i= f_i or f_i is null</li>
<li>references to field occur only in conjucts of the form: field {&lt;|&lt;=|&gt;=|&gt;|=} const or const {&lt;|&lt;=|&gt;=|&gt;|=} field or field BETWEEN const1 AND const2</li>
<li>all references to the columns from the same table as column field occur only in conjucts mentioned above.</li>
<li>each of k first components the index is not partial, i.e. is not defined on a fixed length proper prefix of the field.</li>
</ol>
<p>If such an index exists the function through the ref parameter returns the key value to find max/min for the field using the index, the length of first (k-1) components of the key and flags saying how to apply the key for the search max/min value. (if we have a condition field = const, prefix_len contains the length of the whole search key)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_fl</td><td>0 for MIN(field) / 1 for MAX(field) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref</td><td>Reference to the structure we store the key value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_field</td><td>Field used inside MIN() / MAX() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>WHERE condition </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">range_fl</td><td>Bit flags for how to search if key is ok </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prefix_len</td><td>Length of prefix for the search range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function may set field-&gt;table-&gt;key_read to true, which must be reset after index is used! (This can only happen when function returns 1)</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Index can not be used to optimize MIN(field)/MAX(field) </td></tr>
    <tr><td class="paramname">1</td><td>Can use key to optimize MIN()/MAX(). In this case ref, range_fl and prefix_len are updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cbc8b09d69d865220628ae59ada692b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbc8b09d69d865220628ae59ada692b">&#9670;&nbsp;</a></span>get_exact_record_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> get_exact_record_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get exact count of rows in all tables. </p>
<p>This is called, when at least one of the table handlers support HA_COUNT_ROWS_INSTANT, but not HA_STATS_RECORDS_IS_EXACT (NDB is one such storage engine).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables</td><td>List of tables</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Product</td><td>of number of rows in all tables. ULLONG_MAX for error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5700b2eed83272859e1a708fd72d86bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5700b2eed83272859e1a708fd72d86bf">&#9670;&nbsp;</a></span>get_index_max_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int get_index_max_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>range_fl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use index to read MAX(field) value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table object </td></tr>
    <tr><td class="paramname">ref</td><td>Reference to the structure where we store the key value </td></tr>
    <tr><td class="paramname">range_fl</td><td>Whether range endpoint is strict greater than</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>No errors HA_ERR_... Otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bf0387169627f238df0500dc57e9bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf0387169627f238df0500dc57e9bf4">&#9670;&nbsp;</a></span>get_index_min_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int get_index_min_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>range_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>prefix_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use index to read MIN(field) value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table object </td></tr>
    <tr><td class="paramname">ref</td><td>Reference to the structure where we store the key value </td></tr>
    <tr><td class="paramname">item_field</td><td>Field used in MIN() </td></tr>
    <tr><td class="paramname">range_fl</td><td>Whether range endpoint is strict less than </td></tr>
    <tr><td class="paramname">prefix_len</td><td>Length of common key part for the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>No errors HA_ERR_... Otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc42bfd3093645303ef6fd0846e2ea85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc42bfd3093645303ef6fd0846e2ea85">&#9670;&nbsp;</a></span>matching_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> matching_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>max_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>keyinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>field_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> *&#160;</td>
          <td class="paramname"><em>key_part_used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>range_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>prefix_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a condition matches a key to get {MAX|MIN}(field):. </p>
<p>For the index specified by the keyinfo parameter and an index that contains the field as its component (field_part), the function checks whether</p>
<ul>
<li>the condition cond is a conjunction,</li>
<li>all of its conjuncts refer to columns of the same table, and</li>
<li>each conjunct is on one of the following forms:<ul>
<li>f_i = const_i or const_i = f_i or f_i IS NULL, where f_i is part of the index</li>
<li>field {&lt;|&lt;=|&gt;=|&gt;|=} const</li>
<li>const {&lt;|&lt;=|&gt;=|&gt;|=} field</li>
<li>field BETWEEN const_1 AND const_2</li>
</ul>
</li>
</ul>
<p>As a side-effect, the key value to be used for looking up the MIN/MAX value is actually stored inside the Field object. An interesting feature is that the function will find the most restrictive endpoint by over-eager evaluation of the <code>WHERE</code> condition. It continually stores the current endpoint inside the Field object. For a query such as</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> <a class="code" href="crypt__genhash__impl_8cc.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(a) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> a &gt; 3 AND a &gt; 5;</div></div><!-- fragment --><p>the algorithm will recurse over the conjuction, storing first a 3 in the field. In the next recursive invocation the expression a &gt; 5 is evaluated as 3 &gt; 5 (Due to the dual nature of Field objects as value carriers and field identifiers), which will obviously fail, leading to 5 being stored in the Field object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_fl</td><td>Set to true if we are optimizing MAX(), false means we are optimizing MIN() </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref</td><td>Reference to the structure where the function stores the key value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyinfo</td><td>Reference to the key info </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_part</td><td>Pointer to the key part for the field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>WHERE condition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Table map for the key </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_part_used</td><td>Map of matchings parts. The function will output the set of key parts actually being matched in this set, yet it relies on the caller to initialize the value to zero. This is due to the fact that this value is passed recursively. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range_fl</td><td>Says whether endpoints use strict greater/less than. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prefix_len</td><td>Length of common key part for the range where MAX/MIN is searched for</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Index can't be used. </td></tr>
    <tr><td class="paramname">true</td><td>We can use the index to get MIN/MAX value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d5ef702acd4bf40c41589ff1030c41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5ef702acd4bf40c41589ff1030c41c">&#9670;&nbsp;</a></span>maxmin_in_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> maxmin_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>max_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether {MAX|MIN}(field) is in range specified by conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_fl</td><td>0 for MIN(field) / 1 for MAX(field) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_field</td><td>Item representing field used in MIN/MAX expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>WHERE condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>ok </td></tr>
    <tr><td class="paramname">true</td><td>WHERE was not true for the found row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bfc743a81e763a6c3cbfbf009e12e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfc743a81e763a6c3cbfbf009e12e3f">&#9670;&nbsp;</a></span>optimize_aggregated_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> optimize_aggregated_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__select_8h.html#a5fb96357c4fe7aa7465c0eec3ea528b5">aggregate_evaluated</a> *&#160;</td>
          <td class="paramname"><em>decision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute constants for some COUNT(), MIN() and MAX() functions in an aggregated (implicitly grouped) query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>query block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td>All fields to be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conds</td><td>WHERE clause </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decision</td><td>outcome for successful execution = AGGR_REGULAR regular execution required = AGGR_COMPLETE values available = AGGR_DELAYED execution with ha_records() required = AGGR_EMPTY source tables empty, aggregates are NULL or zero (for COUNT)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>This function is called for queries with aggregate functions and no GROUP BY, thus the result set will contain a single row only.</p>
<p>First, the function will analyze the source tables and WHERE clause to see whether the query qualifies for optimization. If not, the decision AGGR_REGULAR is returned.</p>
<p>Second, the function walks over all expressions in the SELECT list. If the expression can be optimized with a storage engine operation that is O(1) (MIN or MAX) or O(0) (instant COUNT), the value is looked up and inserted in the value buffer, and the corresponding Item is marked as being const. If the expression is a COUNT operation that can be evaluated efficiently by the storage manager (but still O(N)), indicated with HA_COUNT_ROWS_INSTANT, it will be marked as such.</p>
<p>When all SELECT list expressions have been processed, there are four possible outcomes:</p>
<ul>
<li>An empty result from the source tables is indicated, and the output state is AGGR_EMPTY. Notice that the result of aggregation is still one row, filled with zero for COUNT operations and NULL values for all other expressions.</li>
<li>All expressions have been given values, indicated with output state AGGR_COMPLETE.</li>
<li>All expressions have been given values, except for one or more COUNT operations that will be evaluated in execution. This is indicated with AGGR_DELAYED.</li>
<li>Some expressions must be evaluated as part of a regular execution, indicated with AGGR_REGULAR. Notice that some of the expressions may have been given values and are marked as const, but no expressions will be candidates for delayed execution. </li>
</ul>

</div>
</div>
<a id="a4c2152391d371e9704b9fa632c6cf183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2152391d371e9704b9fa632c6cf183">&#9670;&nbsp;</a></span>reckey_in_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reckey_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>max_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>range_fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>prefix_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether found key is in range specified by conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_fl</td><td>0 for MIN(field) / 1 for MAX(field) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>Reference to the key value and info </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_field</td><td>Item representing field used in MIN/MAX expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cond</td><td>WHERE condition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range_fl</td><td>Says whether there is a condition to to be checked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix_len</td><td>Length of the constant part of the key</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>ok </td></tr>
    <tr><td class="paramname">true</td><td>WHERE was not true for the found row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acae7cc2d8de0971fd45df71329943de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae7cc2d8de0971fd45df71329943de4">&#9670;&nbsp;</a></span>simple_pred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> simple_pred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>func_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>inv_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the predicate compares a field with constants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">func_item</td><td>Predicate item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">args</td><td>Here we store the field followed by constants </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inv_order</td><td>Is set to 1 if the predicate is of the form 'const op field'</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>func_item is a simple predicate: a field is compared with constants </td></tr>
    <tr><td class="paramname">1</td><td>Otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5bd71961b401a432086d0fb290a87f3f.html">sql</a></li><li class="navelem"><a class="el" href="opt__sum_8cc.html">opt_sum.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
