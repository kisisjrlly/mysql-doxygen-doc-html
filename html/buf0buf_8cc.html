<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/buf/buf0buf.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('buf0buf_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0buf.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The database buffer buf_pool.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;my_config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0sysspace_8h_source.html">fsp0sysspace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0size_8h_source.html">page0size.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buddy_8h_source.html">buf0buddy.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0stats_8h_source.html">buf0stats.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0stats__bg_8h_source.html">dict0stats_bg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0purge_8h_source.html">trx0purge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;<a class="el" href="time_8h_source.html">time.h</a>&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;new&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &quot;<a class="el" href="buf0checksum_8h_source.html">buf0checksum.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0dump_8h_source.html">buf0dump.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0thread-create_8h_source.html">os0thread-create.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0new_8h_source.html">ut0new.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBuf__fetch.html">Buf_fetch&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBuf__fetch__normal.html">Buf_fetch_normal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBuf__fetch__other.html">Buf_fetch_other</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9b6f47970d11da3cda7d05cbd5200d19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9b6f47970d11da3cda7d05cbd5200d19">NUMA_MEMPOLICY_INTERLEAVE_IN_SCOPE</a></td></tr>
<tr class="separator:a9b6f47970d11da3cda7d05cbd5200d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9747edc38b3e25bfc6042350dd40e30b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9747edc38b3e25bfc6042350dd40e30b">MONITOR_RW_COUNTER</a>(io_type,  <a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>)&#160;&#160;&#160;((io_type == <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27a43879bd19d7f60caa87698730d08ffcd">BUF_IO_READ</a>) ? (<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>##_READ) : (<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>##_WRITTEN))</td></tr>
<tr class="memdesc:a9747edc38b3e25bfc6042350dd40e30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to determine whether the read of write counter is used depending on the io_type.  <a href="#a9747edc38b3e25bfc6042350dd40e30b">More...</a><br /></td></tr>
<tr class="separator:a9747edc38b3e25bfc6042350dd40e30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee5983e657dc2cd2e8ecd1c0cebf68f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a8ee5983e657dc2cd2e8ecd1c0cebf68f">PAGE_TYPE</a>(x)</td></tr>
<tr class="separator:a8ee5983e657dc2cd2e8ecd1c0cebf68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab2e5308b1379f4316b26358f2d7f39b1"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *, buf_chunk_t *, std::less&lt; const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> * &gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; std::pair&lt; const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *const, buf_chunk_t * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ab2e5308b1379f4316b26358f2d7f39b1">buf_pool_chunk_map_t</a></td></tr>
<tr class="memdesc:ab2e5308b1379f4316b26358f2d7f39b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of buffer pool chunks by its first frame address This is newly made by initialization of buffer pool and buf_resize_thread.  <a href="#ab2e5308b1379f4316b26358f2d7f39b1">More...</a><br /></td></tr>
<tr class="separator:ab2e5308b1379f4316b26358f2d7f39b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a047fc26680ad517bffc30da26e6bc402"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a047fc26680ad517bffc30da26e6bc402">buf_pool_register_chunk</a> (buf_chunk_t *chunk)</td></tr>
<tr class="memdesc:a047fc26680ad517bffc30da26e6bc402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a chunk to buf_pool_chunk_map.  <a href="#a047fc26680ad517bffc30da26e6bc402">More...</a><br /></td></tr>
<tr class="separator:a047fc26680ad517bffc30da26e6bc402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18483f39367e4be86099560cd0cb938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa18483f39367e4be86099560cd0cb938">buf_pool_get_oldest_modification_approx</a> (void)</td></tr>
<tr class="memdesc:aa18483f39367e4be86099560cd0cb938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the smallest oldest_modification lsn among all of the earliest added pages in flush lists.  <a href="#aa18483f39367e4be86099560cd0cb938">More...</a><br /></td></tr>
<tr class="separator:aa18483f39367e4be86099560cd0cb938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274d89180ba0679ad7b31453f3dddbf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a274d89180ba0679ad7b31453f3dddbf6">buf_pool_get_oldest_modification_lwm</a> (void)</td></tr>
<tr class="memdesc:a274d89180ba0679ad7b31453f3dddbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a safe low watermark for oldest_modification.  <a href="#a274d89180ba0679ad7b31453f3dddbf6">More...</a><br /></td></tr>
<tr class="separator:a274d89180ba0679ad7b31453f3dddbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7560004e8ceba1e2a2089bd67371bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#afc7560004e8ceba1e2a2089bd67371bd">buf_get_total_list_len</a> (ulint *LRU_len, ulint *free_len, ulint *flush_list_len)</td></tr>
<tr class="memdesc:afc7560004e8ceba1e2a2089bd67371bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total buffer pool statistics.  <a href="#afc7560004e8ceba1e2a2089bd67371bd">More...</a><br /></td></tr>
<tr class="separator:afc7560004e8ceba1e2a2089bd67371bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dd922a4f122cd1870fbc8cdec76620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#af7dd922a4f122cd1870fbc8cdec76620">buf_get_total_list_size_in_bytes</a> (<a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *buf_pools_list_size)</td></tr>
<tr class="memdesc:af7dd922a4f122cd1870fbc8cdec76620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total list size in bytes from all buffer pools.  <a href="#af7dd922a4f122cd1870fbc8cdec76620">More...</a><br /></td></tr>
<tr class="separator:af7dd922a4f122cd1870fbc8cdec76620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451851befdfc82765a869314cdd073e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a451851befdfc82765a869314cdd073e6">buf_get_total_stat</a> (<a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *tot_stat)</td></tr>
<tr class="memdesc:a451851befdfc82765a869314cdd073e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total buffer pool statistics.  <a href="#a451851befdfc82765a869314cdd073e6">More...</a><br /></td></tr>
<tr class="separator:a451851befdfc82765a869314cdd073e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbea556516137bbb04568f60d7811e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#adbbea556516137bbb04568f60d7811e3">buf_block_alloc</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:adbbea556516137bbb04568f60d7811e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer block.  <a href="#adbbea556516137bbb04568f60d7811e3">More...</a><br /></td></tr>
<tr class="separator:adbbea556516137bbb04568f60d7811e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feb3f11f6a58e81598bf92d7b435500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a0feb3f11f6a58e81598bf92d7b435500">buf_page_print</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *read_buf, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:a0feb3f11f6a58e81598bf92d7b435500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a page to stderr.  <a href="#a0feb3f11f6a58e81598bf92d7b435500">More...</a><br /></td></tr>
<tr class="separator:a0feb3f11f6a58e81598bf92d7b435500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945adb066f000ee33cd26fcae9d943c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a945adb066f000ee33cd26fcae9d943c5">buf_block_init</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *frame)</td></tr>
<tr class="memdesc:a945adb066f000ee33cd26fcae9d943c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a buffer control block when the buf_pool is created.  <a href="#a945adb066f000ee33cd26fcae9d943c5">More...</a><br /></td></tr>
<tr class="separator:a945adb066f000ee33cd26fcae9d943c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee39fa7dde2fd24069257650c8c73e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2ee39fa7dde2fd24069257650c8c73e2">buf_pool_update_madvise</a> ()</td></tr>
<tr class="memdesc:a2ee39fa7dde2fd24069257650c8c73e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if innobase_should_madvise_buf_pool() value has changed since we've last check and if so, then updates buf_pool_should_madvise and calls madvise for all chunks in all srv_buf_pool_instances.  <a href="#a2ee39fa7dde2fd24069257650c8c73e2">More...</a><br /></td></tr>
<tr class="separator:a2ee39fa7dde2fd24069257650c8c73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b6a47345319a6ff87840d47bfeb06"><td class="memItemLeft" align="right" valign="top">static buf_chunk_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a1b9b6a47345319a6ff87840d47bfeb06">buf_chunk_init</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, buf_chunk_t *chunk, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> mem_size, <a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">std::mutex</a> *<a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">mutex</a>)</td></tr>
<tr class="memdesc:a1b9b6a47345319a6ff87840d47bfeb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a chunk of buffer frames.  <a href="#a1b9b6a47345319a6ff87840d47bfeb06">More...</a><br /></td></tr>
<tr class="separator:a1b9b6a47345319a6ff87840d47bfeb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c5092b736dd6853e2560d5d81c2264"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a89c5092b736dd6853e2560d5d81c2264">buf_chunk_contains_zip</a> (buf_chunk_t *chunk, const void *data)</td></tr>
<tr class="memdesc:a89c5092b736dd6853e2560d5d81c2264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a block in the given buffer chunk that points to a given compressed page.  <a href="#a89c5092b736dd6853e2560d5d81c2264">More...</a><br /></td></tr>
<tr class="separator:a89c5092b736dd6853e2560d5d81c2264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8239011f74f17732794942ff891bfbf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a8239011f74f17732794942ff891bfbf3">buf_pool_contains_zip</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const void *data)</td></tr>
<tr class="memdesc:a8239011f74f17732794942ff891bfbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a block in the buffer pool that points to a given compressed page.  <a href="#a8239011f74f17732794942ff891bfbf3">More...</a><br /></td></tr>
<tr class="separator:a8239011f74f17732794942ff891bfbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c83103459c7d5ed0fed83b35eaf1b6"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#af9c83103459c7d5ed0fed83b35eaf1b6">buf_chunk_not_freed</a> (buf_chunk_t *chunk)</td></tr>
<tr class="memdesc:af9c83103459c7d5ed0fed83b35eaf1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that all file pages in the buffer chunk are in a replaceable state.  <a href="#af9c83103459c7d5ed0fed83b35eaf1b6">More...</a><br /></td></tr>
<tr class="separator:af9c83103459c7d5ed0fed83b35eaf1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf95ed2818750214caab3fa60a4541a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#acaf95ed2818750214caab3fa60a4541a">buf_pool_set_sizes</a> (void)</td></tr>
<tr class="memdesc:acaf95ed2818750214caab3fa60a4541a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer pool size variables Note: It's safe without mutex protection because of startup only.  <a href="#acaf95ed2818750214caab3fa60a4541a">More...</a><br /></td></tr>
<tr class="separator:acaf95ed2818750214caab3fa60a4541a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4fc143128704b800deb7997e699857"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aef4fc143128704b800deb7997e699857">buf_pool_create</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint buf_pool_size, ulint instance_no, <a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">std::mutex</a> *<a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">mutex</a>, <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> &amp;err)</td></tr>
<tr class="memdesc:aef4fc143128704b800deb7997e699857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a buffer pool instance.  <a href="#aef4fc143128704b800deb7997e699857">More...</a><br /></td></tr>
<tr class="separator:aef4fc143128704b800deb7997e699857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cac1411711bbe034e1d6742c5ab6f63"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a5cac1411711bbe034e1d6742c5ab6f63">buf_pool_free_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a5cac1411711bbe034e1d6742c5ab6f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free one buffer pool instance.  <a href="#a5cac1411711bbe034e1d6742c5ab6f63">More...</a><br /></td></tr>
<tr class="separator:a5cac1411711bbe034e1d6742c5ab6f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fc8e6cd97f295e76cbab520c126c10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa3fc8e6cd97f295e76cbab520c126c10">buf_pool_free</a> ()</td></tr>
<tr class="memdesc:aa3fc8e6cd97f295e76cbab520c126c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the buffer pool global data structures.  <a href="#aa3fc8e6cd97f295e76cbab520c126c10">More...</a><br /></td></tr>
<tr class="separator:aa3fc8e6cd97f295e76cbab520c126c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec7d5de1f91e878e799748d903fb71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a0ec7d5de1f91e878e799748d903fb71b">buf_pool_init</a> (ulint total_size, ulint n_instances)</td></tr>
<tr class="memdesc:a0ec7d5de1f91e878e799748d903fb71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the buffer pool.  <a href="#a0ec7d5de1f91e878e799748d903fb71b">More...</a><br /></td></tr>
<tr class="separator:a0ec7d5de1f91e878e799748d903fb71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c1191fd056e70491b80b5c889ecf8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae1c1191fd056e70491b80b5c889ecf8b">buf_page_realloc</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:ae1c1191fd056e70491b80b5c889ecf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate a control block.  <a href="#ae1c1191fd056e70491b80b5c889ecf8b">More...</a><br /></td></tr>
<tr class="separator:ae1c1191fd056e70491b80b5c889ecf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1e628479afa1dea626e85e8e6e3066"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a1f1e628479afa1dea626e85e8e6e3066">buf_resize_status</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a1f1e628479afa1dea626e85e8e6e3066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the global variable that feeds MySQL's innodb_buffer_pool_resize_status to the specified string.  <a href="#a1f1e628479afa1dea626e85e8e6e3066">More...</a><br /></td></tr>
<tr class="separator:a1f1e628479afa1dea626e85e8e6e3066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca75ba503d2ad232adbff2b0585bc66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9ca75ba503d2ad232adbff2b0585bc66">buf_block_will_withdrawn</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a9ca75ba503d2ad232adbff2b0585bc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a block is intended to be withdrawn.  <a href="#a9ca75ba503d2ad232adbff2b0585bc66">More...</a><br /></td></tr>
<tr class="separator:a9ca75ba503d2ad232adbff2b0585bc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4f29f5614d709fd4fceb970ebd19be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2d4f29f5614d709fd4fceb970ebd19be">buf_frame_will_withdrawn</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr)</td></tr>
<tr class="memdesc:a2d4f29f5614d709fd4fceb970ebd19be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a frame is intended to be withdrawn.  <a href="#a2d4f29f5614d709fd4fceb970ebd19be">More...</a><br /></td></tr>
<tr class="separator:a2d4f29f5614d709fd4fceb970ebd19be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7ca6aafcc2908bed941c08e770027f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9c7ca6aafcc2908bed941c08e770027f">buf_pool_withdraw_blocks</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a9c7ca6aafcc2908bed941c08e770027f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Withdraw the buffer pool blocks from end of the buffer pool instance until withdrawn by buf_pool-&gt;withdraw_target.  <a href="#a9c7ca6aafcc2908bed941c08e770027f">More...</a><br /></td></tr>
<tr class="separator:a9c7ca6aafcc2908bed941c08e770027f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635283cf84c099ad42d89d4dc050ca40"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a635283cf84c099ad42d89d4dc050ca40">buf_pool_resize_hash</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a635283cf84c099ad42d89d4dc050ca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">resize page_hash and zip_hash for a buffer pool instance.  <a href="#a635283cf84c099ad42d89d4dc050ca40">More...</a><br /></td></tr>
<tr class="separator:a635283cf84c099ad42d89d4dc050ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58476968445da673d8803816b32ec229"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a58476968445da673d8803816b32ec229">buf_pool_resize_chunk_make_null</a> (buf_chunk_t **new_chunks)</td></tr>
<tr class="memdesc:a58476968445da673d8803816b32ec229"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a debug routine to inject an memory allocation failure error.  <a href="#a58476968445da673d8803816b32ec229">More...</a><br /></td></tr>
<tr class="separator:a58476968445da673d8803816b32ec229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc4c9f9a04819fb962432b2c0b8e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2fdc4c9f9a04819fb962432b2c0b8e8f">buf_pool_adjust_chunk_unit</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> size)</td></tr>
<tr class="memdesc:a2fdc4c9f9a04819fb962432b2c0b8e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the proposed chunk unit size so that it satisfies all invariants.  <a href="#a2fdc4c9f9a04819fb962432b2c0b8e8f">More...</a><br /></td></tr>
<tr class="separator:a2fdc4c9f9a04819fb962432b2c0b8e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca1d119a3c91bee1e488b0957ed4eed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2ca1d119a3c91bee1e488b0957ed4eed">buf_pool_resize</a> ()</td></tr>
<tr class="memdesc:a2ca1d119a3c91bee1e488b0957ed4eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffer pool based on srv_buf_pool_size from srv_buf_pool_old_size.  <a href="#a2ca1d119a3c91bee1e488b0957ed4eed">More...</a><br /></td></tr>
<tr class="separator:a2ca1d119a3c91bee1e488b0957ed4eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9781b154f5eb92bbc15d0c4538e46124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9781b154f5eb92bbc15d0c4538e46124">buf_resize_thread</a> ()</td></tr>
<tr class="memdesc:a9781b154f5eb92bbc15d0c4538e46124"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the thread for resizing buffer pool.  <a href="#a9781b154f5eb92bbc15d0c4538e46124">More...</a><br /></td></tr>
<tr class="separator:a9781b154f5eb92bbc15d0c4538e46124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bed44f93d9f9850ad30d4900164174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a42bed44f93d9f9850ad30d4900164174">buf_pool_clear_hash_index</a> (void)</td></tr>
<tr class="memdesc:a42bed44f93d9f9850ad30d4900164174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the adaptive hash index on all pages in the buffer pool.  <a href="#a42bed44f93d9f9850ad30d4900164174">More...</a><br /></td></tr>
<tr class="separator:a42bed44f93d9f9850ad30d4900164174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3510a63046d01ab7904e34c76e6713be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a3510a63046d01ab7904e34c76e6713be">buf_relocate</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *dpage)</td></tr>
<tr class="memdesc:a3510a63046d01ab7904e34c76e6713be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocate a buffer control block.  <a href="#a3510a63046d01ab7904e34c76e6713be">More...</a><br /></td></tr>
<tr class="separator:a3510a63046d01ab7904e34c76e6713be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae799641f6fffb0ac145542154be08361"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae799641f6fffb0ac145542154be08361">buf_pool_watch_is_sentinel</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ae799641f6fffb0ac145542154be08361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a block is a sentinel for a buffer pool watch.  <a href="#ae799641f6fffb0ac145542154be08361">More...</a><br /></td></tr>
<tr class="separator:ae799641f6fffb0ac145542154be08361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937f25b54f0325b08e0e57d5df7a7c0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a937f25b54f0325b08e0e57d5df7a7c0a">buf_pool_watch_set</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> **hash_lock)</td></tr>
<tr class="memdesc:a937f25b54f0325b08e0e57d5df7a7c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add watch for the given page to be read in.  <a href="#a937f25b54f0325b08e0e57d5df7a7c0a">More...</a><br /></td></tr>
<tr class="separator:a937f25b54f0325b08e0e57d5df7a7c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7832111496d8a89a6eff6191aa7bfa94"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7832111496d8a89a6eff6191aa7bfa94">buf_pool_watch_remove</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *watch)</td></tr>
<tr class="memdesc:a7832111496d8a89a6eff6191aa7bfa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the sentinel block for the watch before replacing it with a real block.  <a href="#a7832111496d8a89a6eff6191aa7bfa94">More...</a><br /></td></tr>
<tr class="separator:a7832111496d8a89a6eff6191aa7bfa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607741f6ab261487ea1e2efef4d7640e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a607741f6ab261487ea1e2efef4d7640e">buf_pool_watch_unset</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a607741f6ab261487ea1e2efef4d7640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop watching if the page has been read in.  <a href="#a607741f6ab261487ea1e2efef4d7640e">More...</a><br /></td></tr>
<tr class="separator:a607741f6ab261487ea1e2efef4d7640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b6dd3b80c03a713c7f160611d00455"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a35b6dd3b80c03a713c7f160611d00455">buf_pool_watch_occurred</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a35b6dd3b80c03a713c7f160611d00455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the page has been read in.  <a href="#a35b6dd3b80c03a713c7f160611d00455">More...</a><br /></td></tr>
<tr class="separator:a35b6dd3b80c03a713c7f160611d00455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecef5e7084a885aa97d2aedb9a0fe6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a3ecef5e7084a885aa97d2aedb9a0fe6e">buf_page_make_young</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a3ecef5e7084a885aa97d2aedb9a0fe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a page to the start of the buffer pool LRU list.  <a href="#a3ecef5e7084a885aa97d2aedb9a0fe6e">More...</a><br /></td></tr>
<tr class="separator:a3ecef5e7084a885aa97d2aedb9a0fe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce975aae00f09fe4f8d97d0b5fd2d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9ce975aae00f09fe4f8d97d0b5fd2d8f">buf_page_make_old</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a9ce975aae00f09fe4f8d97d0b5fd2d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moved a page to the end of the buffer pool LRU list so that it can be flushed out at the earliest.  <a href="#a9ce975aae00f09fe4f8d97d0b5fd2d8f">More...</a><br /></td></tr>
<tr class="separator:a9ce975aae00f09fe4f8d97d0b5fd2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03ec3da38f4ad513f96d7d71663e7d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae03ec3da38f4ad513f96d7d71663e7d8">buf_page_make_young_if_needed</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ae03ec3da38f4ad513f96d7d71663e7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a page to the start of the buffer pool LRU list if it is too old.  <a href="#ae03ec3da38f4ad513f96d7d71663e7d8">More...</a><br /></td></tr>
<tr class="separator:ae03ec3da38f4ad513f96d7d71663e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed26a402a24afefb51d6d7945647bd30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aed26a402a24afefb51d6d7945647bd30">buf_page_set_file_page_was_freed</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:aed26a402a24afefb51d6d7945647bd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets file_page_was_freed TRUE if the page is found in the buffer pool.  <a href="#aed26a402a24afefb51d6d7945647bd30">More...</a><br /></td></tr>
<tr class="separator:aed26a402a24afefb51d6d7945647bd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f64c5e7568dbfc7c7a868943f8c3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae3f64c5e7568dbfc7c7a868943f8c3f7">buf_page_reset_file_page_was_freed</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:ae3f64c5e7568dbfc7c7a868943f8c3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets file_page_was_freed FALSE if the page is found in the buffer pool.  <a href="#ae3f64c5e7568dbfc7c7a868943f8c3f7">More...</a><br /></td></tr>
<tr class="separator:ae3f64c5e7568dbfc7c7a868943f8c3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80972df4f173cf11ba19125a28030a5c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a80972df4f173cf11ba19125a28030a5c">buf_block_try_discard_uncompressed</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a80972df4f173cf11ba19125a28030a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to discard the uncompressed frame of a compressed page.  <a href="#a80972df4f173cf11ba19125a28030a5c">More...</a><br /></td></tr>
<tr class="separator:a80972df4f173cf11ba19125a28030a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1b136191a6e34494318af4a7066b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7a1b136191a6e34494318af4a7066b64">buf_page_get_zip</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size)</td></tr>
<tr class="memdesc:a7a1b136191a6e34494318af4a7066b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read access to a compressed page (usually of type FIL_PAGE_TYPE_ZBLOB or FIL_PAGE_TYPE_ZBLOB2).  <a href="#a7a1b136191a6e34494318af4a7066b64">More...</a><br /></td></tr>
<tr class="separator:a7a1b136191a6e34494318af4a7066b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d87b3ccb53d066f14f66b68de8e6dd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa3d87b3ccb53d066f14f66b68de8e6dd">buf_block_init_low</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:aa3d87b3ccb53d066f14f66b68de8e6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize some fields of a control block.  <a href="#aa3d87b3ccb53d066f14f66b68de8e6dd">More...</a><br /></td></tr>
<tr class="separator:aa3d87b3ccb53d066f14f66b68de8e6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532b24c23776dee3f4a4635e38417378"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a532b24c23776dee3f4a4635e38417378">buf_zip_decompress</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ibool check)</td></tr>
<tr class="memdesc:a532b24c23776dee3f4a4635e38417378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a block.  <a href="#a532b24c23776dee3f4a4635e38417378">More...</a><br /></td></tr>
<tr class="separator:a532b24c23776dee3f4a4635e38417378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e67247bf34c56e00cfe1915c47abf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ac2e67247bf34c56e00cfe1915c47abf0">buf_block_from_ahi</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr)</td></tr>
<tr class="memdesc:ac2e67247bf34c56e00cfe1915c47abf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a buffer block from an adaptive hash index pointer.  <a href="#ac2e67247bf34c56e00cfe1915c47abf0">More...</a><br /></td></tr>
<tr class="separator:ac2e67247bf34c56e00cfe1915c47abf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0cbe211bba9dba91be1e38e584e18f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7c0cbe211bba9dba91be1e38e584e18f">buf_is_block_in_instance</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *ptr)</td></tr>
<tr class="memdesc:a7c0cbe211bba9dba91be1e38e584e18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if a block pointer points into one of currently used chunks of the buffer pool.  <a href="#a7c0cbe211bba9dba91be1e38e584e18f">More...</a><br /></td></tr>
<tr class="separator:a7c0cbe211bba9dba91be1e38e584e18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1182b6898944c6ca9334cac3b22345"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9e1182b6898944c6ca9334cac3b22345">buf_debug_execute_is_force_flush</a> ()</td></tr>
<tr class="memdesc:a9e1182b6898944c6ca9334cac3b22345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if probe is enabled.  <a href="#a9e1182b6898944c6ca9334cac3b22345">More...</a><br /></td></tr>
<tr class="separator:a9e1182b6898944c6ca9334cac3b22345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d073376daf32f894c496cd3b6f61cd4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a4d073376daf32f894c496cd3b6f61cd4">buf_wait_for_read</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a4d073376daf32f894c496cd3b6f61cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the block to be read in.  <a href="#a4d073376daf32f894c496cd3b6f61cd4">More...</a><br /></td></tr>
<tr class="separator:a4d073376daf32f894c496cd3b6f61cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ee967ac8f4fcbce415c09cb10c12a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a05ee967ac8f4fcbce415c09cb10c12a8">buf_page_get_gen</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *guess, <a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a> mode, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dirty_with_no_latch)</td></tr>
<tr class="memdesc:a05ee967ac8f4fcbce415c09cb10c12a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general function used to get access to a database page.  <a href="#a05ee967ac8f4fcbce415c09cb10c12a8">More...</a><br /></td></tr>
<tr class="separator:a05ee967ac8f4fcbce415c09cb10c12a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569b18490ab03d0b30a22dfd9f9fdb07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a569b18490ab03d0b30a22dfd9f9fdb07">buf_page_optimistic_get</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, uint64_t modify_clock, <a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a> fetch_mode, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a569b18490ab03d0b30a22dfd9f9fdb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general function used to get optimistic access to a database page.  <a href="#a569b18490ab03d0b30a22dfd9f9fdb07">More...</a><br /></td></tr>
<tr class="separator:a569b18490ab03d0b30a22dfd9f9fdb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c9e8bd857ceefd7ea974ab65c84a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ab1c9e8bd857ceefd7ea974ab65c84a85">buf_page_get_known_nowait</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdba">Cache_hint</a> hint, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab1c9e8bd857ceefd7ea974ab65c84a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to get access to a known database page, when no waiting can be done.  <a href="#ab1c9e8bd857ceefd7ea974ab65c84a85">More...</a><br /></td></tr>
<tr class="separator:ab1c9e8bd857ceefd7ea974ab65c84a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2805ff54abe4adb4a918c41a2f9ed0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aba2805ff54abe4adb4a918c41a2f9ed0">buf_page_try_get_func</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aba2805ff54abe4adb4a918c41a2f9ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tablespace id and page number tries to get that page.  <a href="#aba2805ff54abe4adb4a918c41a2f9ed0">More...</a><br /></td></tr>
<tr class="separator:aba2805ff54abe4adb4a918c41a2f9ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36e120d41b65fc009f011a62dc107e5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#af36e120d41b65fc009f011a62dc107e5">buf_page_init_low</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:af36e120d41b65fc009f011a62dc107e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize some fields of a control block.  <a href="#af36e120d41b65fc009f011a62dc107e5">More...</a><br /></td></tr>
<tr class="separator:af36e120d41b65fc009f011a62dc107e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7de083ca6c8834b498a5d69a1cd10b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a8a7de083ca6c8834b498a5d69a1cd10b">buf_page_init</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a8a7de083ca6c8834b498a5d69a1cd10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits a page to the buffer buf_pool.  <a href="#a8a7de083ca6c8834b498a5d69a1cd10b">More...</a><br /></td></tr>
<tr class="separator:a8a7de083ca6c8834b498a5d69a1cd10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efca615726ffc1dfc6c2ed05612ccd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2efca615726ffc1dfc6c2ed05612ccd0">buf_page_init_for_read</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *err, ulint mode, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ibool unzip)</td></tr>
<tr class="memdesc:a2efca615726ffc1dfc6c2ed05612ccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits a page for read to the buffer buf_pool.  <a href="#a2efca615726ffc1dfc6c2ed05612ccd0">More...</a><br /></td></tr>
<tr class="separator:a2efca615726ffc1dfc6c2ed05612ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d8481358bda6d6826d9b997ce51c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a86d8481358bda6d6826d9b997ce51c16">buf_page_create</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a> rw_latch, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a86d8481358bda6d6826d9b997ce51c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a page to the buffer buf_pool.  <a href="#a86d8481358bda6d6826d9b997ce51c16">More...</a><br /></td></tr>
<tr class="separator:a86d8481358bda6d6826d9b997ce51c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6373a18fab2a1df7def6fd06d0efba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#afe6373a18fab2a1df7def6fd06d0efba">buf_page_monitor</a> (const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> io_type)</td></tr>
<tr class="memdesc:afe6373a18fab2a1df7def6fd06d0efba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor the buffer page read/write activity, and increment corresponding counter value if MONITOR_MODULE_BUF_PAGE (module_buf_page) module is enabled.  <a href="#afe6373a18fab2a1df7def6fd06d0efba">More...</a><br /></td></tr>
<tr class="separator:afe6373a18fab2a1df7def6fd06d0efba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753d780aa84a242710866eed7bcc32c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a753d780aa84a242710866eed7bcc32c0">buf_read_page_handle_error</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a753d780aa84a242710866eed7bcc32c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unfixes the page, unlatches the page, removes it from page_hash and removes it from LRU.  <a href="#a753d780aa84a242710866eed7bcc32c0">More...</a><br /></td></tr>
<tr class="separator:a753d780aa84a242710866eed7bcc32c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc2cc72f66548f1e67ad61e8e8769a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6fc2cc72f66548f1e67ad61e8e8769a1">buf_page_io_complete</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> evict)</td></tr>
<tr class="memdesc:a6fc2cc72f66548f1e67ad61e8e8769a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes an asynchronous read or write request of a file page to or from the buffer pool.  <a href="#a6fc2cc72f66548f1e67ad61e8e8769a1">More...</a><br /></td></tr>
<tr class="separator:a6fc2cc72f66548f1e67ad61e8e8769a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd59cd5da6fcbc4adf6eb5a2bba6e6ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#afd59cd5da6fcbc4adf6eb5a2bba6e6ac">buf_must_be_all_freed_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:afd59cd5da6fcbc4adf6eb5a2bba6e6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that all file pages in the buffer are in a replaceable state.  <a href="#afd59cd5da6fcbc4adf6eb5a2bba6e6ac">More...</a><br /></td></tr>
<tr class="separator:afd59cd5da6fcbc4adf6eb5a2bba6e6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad964582ff883657e0b0848867bc63f14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ad964582ff883657e0b0848867bc63f14">buf_refresh_io_stats</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:ad964582ff883657e0b0848867bc63f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refreshes the statistics used to print per-second averages.  <a href="#ad964582ff883657e0b0848867bc63f14">More...</a><br /></td></tr>
<tr class="separator:ad964582ff883657e0b0848867bc63f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b96a1551d95ca86c218cc9b4e48e80"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a55b96a1551d95ca86c218cc9b4e48e80">buf_pool_invalidate_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a55b96a1551d95ca86c218cc9b4e48e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates file pages in one buffer pool instance.  <a href="#a55b96a1551d95ca86c218cc9b4e48e80">More...</a><br /></td></tr>
<tr class="separator:a55b96a1551d95ca86c218cc9b4e48e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cee70fe0ea742c8a909aaa3bce3f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ad4cee70fe0ea742c8a909aaa3bce3f59">buf_pool_invalidate</a> (void)</td></tr>
<tr class="memdesc:ad4cee70fe0ea742c8a909aaa3bce3f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the file pages in the buffer pool when an archive recovery is completed.  <a href="#ad4cee70fe0ea742c8a909aaa3bce3f59">More...</a><br /></td></tr>
<tr class="separator:ad4cee70fe0ea742c8a909aaa3bce3f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a664ed871c41382ade64a132801fd0b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9a664ed871c41382ade64a132801fd0b">buf_pool_validate_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a9a664ed871c41382ade64a132801fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates data in one buffer pool instance.  <a href="#a9a664ed871c41382ade64a132801fd0b">More...</a><br /></td></tr>
<tr class="separator:a9a664ed871c41382ade64a132801fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fa041692f236bcd8e2fd5e0a575fbc"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ab5fa041692f236bcd8e2fd5e0a575fbc">buf_validate</a> (void)</td></tr>
<tr class="memdesc:ab5fa041692f236bcd8e2fd5e0a575fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the buffer buf_pool data structure.  <a href="#ab5fa041692f236bcd8e2fd5e0a575fbc">More...</a><br /></td></tr>
<tr class="separator:ab5fa041692f236bcd8e2fd5e0a575fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f47d49bbb1ebb9c2f27458ee14251e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2f47d49bbb1ebb9c2f27458ee14251e4">buf_print_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a2f47d49bbb1ebb9c2f27458ee14251e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of the buffer buf_pool data structure for one instance.  <a href="#a2f47d49bbb1ebb9c2f27458ee14251e4">More...</a><br /></td></tr>
<tr class="separator:a2f47d49bbb1ebb9c2f27458ee14251e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913c2499ec503eea58a7dbb0c6b93d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9913c2499ec503eea58a7dbb0c6b93d8">buf_print</a> (void)</td></tr>
<tr class="memdesc:a9913c2499ec503eea58a7dbb0c6b93d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of the buffer buf_pool data structure.  <a href="#a9913c2499ec503eea58a7dbb0c6b93d8">More...</a><br /></td></tr>
<tr class="separator:a9913c2499ec503eea58a7dbb0c6b93d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596f12a16d5e22c6268cb016bf8c0695"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a596f12a16d5e22c6268cb016bf8c0695">buf_get_latched_pages_number_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a596f12a16d5e22c6268cb016bf8c0695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of latched pages in the buffer pool.  <a href="#a596f12a16d5e22c6268cb016bf8c0695">More...</a><br /></td></tr>
<tr class="separator:a596f12a16d5e22c6268cb016bf8c0695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb34869722879443008e408b4ae6eb8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a8bb34869722879443008e408b4ae6eb8">buf_get_latched_pages_number</a> (void)</td></tr>
<tr class="memdesc:a8bb34869722879443008e408b4ae6eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of latched pages in all the buffer pools.  <a href="#a8bb34869722879443008e408b4ae6eb8">More...</a><br /></td></tr>
<tr class="separator:a8bb34869722879443008e408b4ae6eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10701cd6691bc47c29bf117375fccc14"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a10701cd6691bc47c29bf117375fccc14">buf_get_n_pending_read_ios</a> (void)</td></tr>
<tr class="memdesc:a10701cd6691bc47c29bf117375fccc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pending buf pool read ios.  <a href="#a10701cd6691bc47c29bf117375fccc14">More...</a><br /></td></tr>
<tr class="separator:a10701cd6691bc47c29bf117375fccc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee530ab11507348f9c9e303341634b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#adee530ab11507348f9c9e303341634b7">buf_get_modified_ratio_pct</a> (void)</td></tr>
<tr class="memdesc:adee530ab11507348f9c9e303341634b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool.  <a href="#adee530ab11507348f9c9e303341634b7">More...</a><br /></td></tr>
<tr class="separator:adee530ab11507348f9c9e303341634b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5418342f432074305965a75c1fedc7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a3b5418342f432074305965a75c1fedc7">buf_stats_aggregate_pool_info</a> (<a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *total_info, const <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *pool_info)</td></tr>
<tr class="memdesc:a3b5418342f432074305965a75c1fedc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates a pool stats information with the total buffer pool stats.  <a href="#a3b5418342f432074305965a75c1fedc7">More...</a><br /></td></tr>
<tr class="separator:a3b5418342f432074305965a75c1fedc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94add70baf8e2ee67299e346bbb47965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a94add70baf8e2ee67299e346bbb47965">buf_stats_get_pool_info</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint pool_id, <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *all_pool_info)</td></tr>
<tr class="memdesc:a94add70baf8e2ee67299e346bbb47965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect buffer pool stats information for a buffer pool.  <a href="#a94add70baf8e2ee67299e346bbb47965">More...</a><br /></td></tr>
<tr class="separator:a94add70baf8e2ee67299e346bbb47965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ee567ec9a8bd47c647ab1dc8fa2524"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ac2ee567ec9a8bd47c647ab1dc8fa2524">buf_print_io_instance</a> (<a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *pool_info, FILE *file)</td></tr>
<tr class="memdesc:ac2ee567ec9a8bd47c647ab1dc8fa2524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of the buffer i/o.  <a href="#ac2ee567ec9a8bd47c647ab1dc8fa2524">More...</a><br /></td></tr>
<tr class="separator:ac2ee567ec9a8bd47c647ab1dc8fa2524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940342731a901c4a6171de07be118f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a940342731a901c4a6171de07be118f57">buf_print_io</a> (FILE *file)</td></tr>
<tr class="memdesc:a940342731a901c4a6171de07be118f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of the buffer i/o.  <a href="#a940342731a901c4a6171de07be118f57">More...</a><br /></td></tr>
<tr class="separator:a940342731a901c4a6171de07be118f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e94539bff73e687c3c528e81b724fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6e94539bff73e687c3c528e81b724fd5">buf_refresh_io_stats_all</a> (void)</td></tr>
<tr class="memdesc:a6e94539bff73e687c3c528e81b724fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refreshes the statistics used to print per-second averages.  <a href="#a6e94539bff73e687c3c528e81b724fd5">More...</a><br /></td></tr>
<tr class="separator:a6e94539bff73e687c3c528e81b724fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cbbcf6846efae5345f9e560e02fe1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa4cbbcf6846efae5345f9e560e02fe1c">buf_must_be_all_freed</a> (void)</td></tr>
<tr class="memdesc:aa4cbbcf6846efae5345f9e560e02fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the current process if there is any page in other state.  <a href="#aa4cbbcf6846efae5345f9e560e02fe1c">More...</a><br /></td></tr>
<tr class="separator:aa4cbbcf6846efae5345f9e560e02fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de522312135372e9204158db79f015"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ab0de522312135372e9204158db79f015">buf_pool_check_no_pending_io</a> (void)</td></tr>
<tr class="memdesc:ab0de522312135372e9204158db79f015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that there currently are no pending i/o-operations for the buffer pool.  <a href="#ab0de522312135372e9204158db79f015">More...</a><br /></td></tr>
<tr class="separator:ab0de522312135372e9204158db79f015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fefbabeb6b422a2baeae7758d16a7d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa7fefbabeb6b422a2baeae7758d16a7d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> &amp;buf_pool)</td></tr>
<tr class="memdesc:aa7fefbabeb6b422a2baeae7758d16a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given buf_pool_t object.  <a href="#aa7fefbabeb6b422a2baeae7758d16a7d">More...</a><br /></td></tr>
<tr class="separator:aa7fefbabeb6b422a2baeae7758d16a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3b9b346f49593dc6d435d4a88d6d7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7f3b9b346f49593dc6d435d4a88d6d7f">buf_pool_free_all</a> ()</td></tr>
<tr class="memdesc:a7f3b9b346f49593dc6d435d4a88d6d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the buffer pool instances and the global data structures.  <a href="#a7f3b9b346f49593dc6d435d4a88d6d7f">More...</a><br /></td></tr>
<tr class="separator:a7f3b9b346f49593dc6d435d4a88d6d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae252c6f42e712b83871abe3faeea7093"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae252c6f42e712b83871abe3faeea7093">WAIT_FOR_READ</a> = 100</td></tr>
<tr class="memdesc:ae252c6f42e712b83871abe3faeea7093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value in microseconds.  <a href="#ae252c6f42e712b83871abe3faeea7093">More...</a><br /></td></tr>
<tr class="separator:ae252c6f42e712b83871abe3faeea7093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb68ab1d33974dd5d02d56933a14287"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a0eb68ab1d33974dd5d02d56933a14287">WAIT_FOR_WRITE</a> = 100</td></tr>
<tr class="separator:a0eb68ab1d33974dd5d02d56933a14287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7076240d95384c7a4b81433a490fe3c2"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7076240d95384c7a4b81433a490fe3c2">BUF_PAGE_READ_MAX_RETRIES</a> = 100</td></tr>
<tr class="memdesc:a7076240d95384c7a4b81433a490fe3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attempts made to read in a page in the buffer pool.  <a href="#a7076240d95384c7a4b81433a490fe3c2">More...</a><br /></td></tr>
<tr class="separator:a7076240d95384c7a4b81433a490fe3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1aa28e86a9882e3de615f874604ae0"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9e1aa28e86a9882e3de615f874604ae0">BUF_READ_AHEAD_PAGES</a> = 64</td></tr>
<tr class="memdesc:a9e1aa28e86a9882e3de615f874604ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of pages to read ahead.  <a href="#a9e1aa28e86a9882e3de615f874604ae0">More...</a><br /></td></tr>
<tr class="separator:a9e1aa28e86a9882e3de615f874604ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e768c888ebf1dd9549598ff961433b"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a81e768c888ebf1dd9549598ff961433b">BUF_READ_AHEAD_PORTION</a> = 32</td></tr>
<tr class="memdesc:a81e768c888ebf1dd9549598ff961433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum portion of the buffer pool that can be used for the read-ahead buffer.  <a href="#a81e768c888ebf1dd9549598ff961433b">More...</a><br /></td></tr>
<tr class="separator:a81e768c888ebf1dd9549598ff961433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdf9e142c6096556e3722d7c91b9065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a3fdf9e142c6096556e3722d7c91b9065">buf_pool_ptr</a></td></tr>
<tr class="memdesc:a3fdf9e142c6096556e3722d7c91b9065"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer pools of the database.  <a href="#a3fdf9e142c6096556e3722d7c91b9065">More...</a><br /></td></tr>
<tr class="separator:a3fdf9e142c6096556e3722d7c91b9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480d1db8e2baa0e8bf8cd877e4811f72"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a480d1db8e2baa0e8bf8cd877e4811f72">buf_pool_resizing</a></td></tr>
<tr class="memdesc:a480d1db8e2baa0e8bf8cd877e4811f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">true when resizing buffer pool is in the critical path.  <a href="#a480d1db8e2baa0e8bf8cd877e4811f72">More...</a><br /></td></tr>
<tr class="separator:a480d1db8e2baa0e8bf8cd877e4811f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7930f6f7a939dac6e06fb9990e65feed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="buf0buf_8cc.html#ab2e5308b1379f4316b26358f2d7f39b1">buf_pool_chunk_map_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7930f6f7a939dac6e06fb9990e65feed">buf_chunk_map_reg</a></td></tr>
<tr class="separator:a7930f6f7a939dac6e06fb9990e65feed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db54f597ad6c97e025e653f3314da8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__stat__per__index__t.html">buf_stat_per_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a8db54f597ad6c97e025e653f3314da8d">buf_stat_per_index</a></td></tr>
<tr class="memdesc:a8db54f597ad6c97e025e653f3314da8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for how many pages from each index are contained in the buffer pool(s).  <a href="#a8db54f597ad6c97e025e653f3314da8d">More...</a><br /></td></tr>
<tr class="separator:a8db54f597ad6c97e025e653f3314da8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be5895208fc69ca2f5e972b8ad6e8b1"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a5be5895208fc69ca2f5e972b8ad6e8b1">buf_dbg_counter</a> = 0</td></tr>
<tr class="memdesc:a5be5895208fc69ca2f5e972b8ad6e8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to insert validation operations in execution in the debug version.  <a href="#a5be5895208fc69ca2f5e972b8ad6e8b1">More...</a><br /></td></tr>
<tr class="separator:a5be5895208fc69ca2f5e972b8ad6e8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc24929fce17db4c95c3b7ca56c01e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6fc24929fce17db4c95c3b7ca56c01e0">srv_buf_pool_debug</a></td></tr>
<tr class="memdesc:a6fc24929fce17db4c95c3b7ca56c01e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to enable multiple buffer pool instances with small buffer pool size.  <a href="#a6fc24929fce17db4c95c3b7ca56c01e0">More...</a><br /></td></tr>
<tr class="separator:a6fc24929fce17db4c95c3b7ca56c01e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9c8b00ed9b9b097c23147228ecad81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9c9c8b00ed9b9b097c23147228ecad81">buf_pool_should_madvise</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:a9c9c8b00ed9b9b097c23147228ecad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer buf_pool. </p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9747edc38b3e25bfc6042350dd40e30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9747edc38b3e25bfc6042350dd40e30b">&#9670;&nbsp;</a></span>MONITOR_RW_COUNTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MONITOR_RW_COUNTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">io_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((io_type == <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27a43879bd19d7f60caa87698730d08ffcd">BUF_IO_READ</a>) ? (<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>##_READ) : (<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>##_WRITTEN))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to determine whether the read of write counter is used depending on the io_type. </p>

</div>
</div>
<a id="a9b6f47970d11da3cda7d05cbd5200d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6f47970d11da3cda7d05cbd5200d19">&#9670;&nbsp;</a></span>NUMA_MEMPOLICY_INTERLEAVE_IN_SCOPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMA_MEMPOLICY_INTERLEAVE_IN_SCOPE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ee5983e657dc2cd2e8ecd1c0cebf68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee5983e657dc2cd2e8ecd1c0cebf68f">&#9670;&nbsp;</a></span>PAGE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PAGE_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">case</span> x:            \</div><div class="line">    return (#x);</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab2e5308b1379f4316b26358f2d7f39b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e5308b1379f4316b26358f2d7f39b1">&#9670;&nbsp;</a></span>buf_pool_chunk_map_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *, buf_chunk_t *, std::less&lt;const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt;std::pair&lt;const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *const, buf_chunk_t *&gt; &gt; &gt; <a class="el" href="buf0buf_8cc.html#ab2e5308b1379f4316b26358f2d7f39b1">buf_pool_chunk_map_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map of buffer pool chunks by its first frame address This is newly made by initialization of buffer pool and buf_resize_thread. </p>
<p>Note: mutex protection is required when creating multiple buffer pools in parallel. We don't use a mutex during resize because that is still single threaded. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adbbea556516137bbb04568f60d7811e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbea556516137bbb04568f60d7811e3">&#9670;&nbsp;</a></span>buf_block_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>own: the allocated block, in state BUF_BLOCK_MEMORY </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance, or NULL for round-robin selection of the buffer pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e67247bf34c56e00cfe1915c47abf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e67247bf34c56e00cfe1915c47abf0">&#9670;&nbsp;</a></span>buf_block_from_ahi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_from_ahi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a buffer block from an adaptive hash index pointer. </p>
<p>This function does not return if the block is not identified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to within a page frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block, never NULL </dd></dl>

</div>
</div>
<a id="a945adb066f000ee33cd26fcae9d943c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945adb066f000ee33cd26fcae9d943c5">&#9670;&nbsp;</a></span>buf_block_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_block_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a buffer control block when the buf_pool is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in: pointer to control block </td></tr>
    <tr><td class="paramname">frame</td><td>in: pointer to buffer frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3d87b3ccb53d066f14f66b68de8e6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d87b3ccb53d066f14f66b68de8e6dd">&#9670;&nbsp;</a></span>buf_block_init_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_init_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize some fields of a control block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block to init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80972df4f173cf11ba19125a28030a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80972df4f173cf11ba19125a28030a5c">&#9670;&nbsp;</a></span>buf_block_try_discard_uncompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_block_try_discard_uncompressed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to discard the uncompressed frame of a compressed page. </p>
<p>The caller should not be holding any mutexes when this function is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ca75ba503d2ad232adbff2b0585bc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca75ba503d2ad232adbff2b0585bc66">&#9670;&nbsp;</a></span>buf_block_will_withdrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_block_will_withdrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a block is intended to be withdrawn. </p>
<p>The caller must ensure that there was a sufficient memory barrier to read curr_size and old_size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>pointer to control block </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if will be withdrawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89c5092b736dd6853e2560d5d81c2264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c5092b736dd6853e2560d5d81c2264">&#9670;&nbsp;</a></span>buf_chunk_contains_zip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_chunk_contains_zip </td>
          <td>(</td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a block in the given buffer chunk that points to a given compressed page. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer block pointing to the compressed page, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>in: chunk being checked </td></tr>
    <tr><td class="paramname">data</td><td>in: pointer to compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b9b6a47345319a6ff87840d47bfeb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9b6a47345319a6ff87840d47bfeb06">&#9670;&nbsp;</a></span>buf_chunk_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static buf_chunk_t* buf_chunk_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">std::mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a chunk of buffer frames. </p>
<p>If called for an existing buf_pool, its free_list_mutex must be locked. </p><dl class="section return"><dt>Returns</dt><dd>chunk, or NULL on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">chunk</td><td>out: chunk of buffers </td></tr>
    <tr><td class="paramname">mem_size</td><td>in: requested size in bytes </td></tr>
    <tr><td class="paramname">mutex</td><td>in,out: Mutex protecting chunk map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9c83103459c7d5ed0fed83b35eaf1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c83103459c7d5ed0fed83b35eaf1b6">&#9670;&nbsp;</a></span>buf_chunk_not_freed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_chunk_not_freed </td>
          <td>(</td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that all file pages in the buffer chunk are in a replaceable state. </p>
<dl class="section return"><dt>Returns</dt><dd>address of a non-free block, or NULL if all freed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>in: chunk being checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e1182b6898944c6ca9334cac3b22345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1182b6898944c6ca9334cac3b22345">&#9670;&nbsp;</a></span>buf_debug_execute_is_force_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_debug_execute_is_force_flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if probe is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if probe enabled. </dd></dl>

</div>
</div>
<a id="a2d4f29f5614d709fd4fceb970ebd19be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4f29f5614d709fd4fceb970ebd19be">&#9670;&nbsp;</a></span>buf_frame_will_withdrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_frame_will_withdrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a frame is intended to be withdrawn. </p>
<p>The caller must ensure that there was a sufficient memory barrier to read curr_size and old_size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to a frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if will be withdrawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb34869722879443008e408b4ae6eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb34869722879443008e408b4ae6eb8">&#9670;&nbsp;</a></span>buf_get_latched_pages_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_get_latched_pages_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of latched pages in all the buffer pools. </p>
<p>Returns the number of latched pages in the buffer pool.</p>
<dl class="section return"><dt>Returns</dt><dd>number of latched pages </dd></dl>

</div>
</div>
<a id="a596f12a16d5e22c6268cb016bf8c0695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596f12a16d5e22c6268cb016bf8c0695">&#9670;&nbsp;</a></span>buf_get_latched_pages_number_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_get_latched_pages_number_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of latched pages in the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of latched pages </dd></dl>

</div>
</div>
<a id="adee530ab11507348f9c9e303341634b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee530ab11507348f9c9e303341634b7">&#9670;&nbsp;</a></span>buf_get_modified_ratio_pct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double buf_get_modified_ratio_pct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool. </p>
<p>Return the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool.</p>
<dl class="section return"><dt>Returns</dt><dd>modified page percentage ratio </dd></dl>

</div>
</div>
<a id="a10701cd6691bc47c29bf117375fccc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10701cd6691bc47c29bf117375fccc14">&#9670;&nbsp;</a></span>buf_get_n_pending_read_ios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_get_n_pending_read_ios </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of pending buf pool read ios. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pending read I/O operations </dd></dl>

</div>
</div>
<a id="afc7560004e8ceba1e2a2089bd67371bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7560004e8ceba1e2a2089bd67371bd">&#9670;&nbsp;</a></span>buf_get_total_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_get_total_list_len </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>LRU_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>free_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>flush_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total buffer pool statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">LRU_len</td><td>Length of all lru lists </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">free_len</td><td>Length of all free lists </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flush_list_len</td><td>Length of all flush lists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7dd922a4f122cd1870fbc8cdec76620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7dd922a4f122cd1870fbc8cdec76620">&#9670;&nbsp;</a></span>buf_get_total_list_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_get_total_list_size_in_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pools_list_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total list size in bytes from all buffer pools. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pools_list_size</td><td>out: list sizes in all buffer pools </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a451851befdfc82765a869314cdd073e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451851befdfc82765a869314cdd073e6">&#9670;&nbsp;</a></span>buf_get_total_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_get_total_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *&#160;</td>
          <td class="paramname"><em>tot_stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get total buffer pool statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tot_stat</td><td>out: buffer pool stats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c0cbe211bba9dba91be1e38e584e18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0cbe211bba9dba91be1e38e584e18f">&#9670;&nbsp;</a></span>buf_is_block_in_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_is_block_in_instance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if a block pointer points into one of currently used chunks of the buffer pool. </p>
<p>This is useful if you stored the pointer some time ago, and want to dereference it now, and are afraid that buffer pool resize could free the memory pointed by it. Thus calling this function requires holding at least one of the latches which prevent freeing memory from buffer pool for the duration of the call and until you pin the block in some other way, as otherwise the result of this function might be obsolete by the time you dereference the block (an s-latch on buf_page_hash_lock_get for any bucket is enough). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>The buffer pool instance to search in. </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer which you want to check. This function will not dereference it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <code>block</code> points inside one of the chunks of the <code>buf_pool</code> </dd></dl>

</div>
</div>
<a id="aa4cbbcf6846efae5345f9e560e02fe1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cbbcf6846efae5345f9e560e02fe1c">&#9670;&nbsp;</a></span>buf_must_be_all_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_must_be_all_freed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the current process if there is any page in other state. </p>
<p>Assert that all file pages in the buffer are in a replaceable state.</p>

</div>
</div>
<a id="afd59cd5da6fcbc4adf6eb5a2bba6e6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd59cd5da6fcbc4adf6eb5a2bba6e6ac">&#9670;&nbsp;</a></span>buf_must_be_all_freed_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_must_be_all_freed_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asserts that all file pages in the buffer are in a replaceable state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86d8481358bda6d6826d9b997ce51c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d8481358bda6d6826d9b997ce51c16">&#9670;&nbsp;</a></span>buf_page_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a>&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a page to the buffer buf_pool. </p>
<p>The page is usually not read from a file even if it cannot be found in the buffer buf_pool. This is one of the functions which perform to a block a state transition NOT_USED =&gt; FILE_PAGE (the other is buf_page_get_gen). The page is latched by passed mtr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_SX_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block, page bufferfixed </dd></dl>

</div>
</div>
<a id="a05ee967ac8f4fcbce415c09cb10c12a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ee967ac8f4fcbce415c09cb10c12a8">&#9670;&nbsp;</a></span>buf_page_get_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_get_gen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dirty_with_no_latch</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the general function used to get access to a database page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guess</td><td>Guessed block or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Fetch mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirty_with_no_latch</td><td>Mark page as dirty even if page is being pinned without any latch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL </dd></dl>

</div>
</div>
<a id="ab1c9e8bd857ceefd7ea974ab65c84a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c9e8bd857ceefd7ea974ab65c84a85">&#9670;&nbsp;</a></span>buf_page_get_known_nowait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_get_known_nowait </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0buf_8h.html#a0056c362020ff9e840fb48cb94c3cdba">Cache_hint</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to get access to a known database page, when no waiting can be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_S_LATCH or RW_X_LATCH. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>The known page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>Cache_hint::MAKE_YOUNG or Cache_hint::KEEP_OLD </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name from where it was called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line from where it was called. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction covering the fetch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>

</div>
</div>
<a id="a7a1b136191a6e34494318af4a7066b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1b136191a6e34494318af4a7066b64">&#9670;&nbsp;</a></span>buf_page_get_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_get_zip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get read access to a compressed page (usually of type FIL_PAGE_TYPE_ZBLOB or FIL_PAGE_TYPE_ZBLOB2). </p>
<p>The page must be released with buf_page_release_zip(). NOTE: the page is not protected by any latch. Mutual exclusion has to be implemented at a higher level. In other words, all possible accesses to a given page through this function must be protected by the same set of mutexes or latches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block </dd></dl>

</div>
</div>
<a id="a8a7de083ca6c8834b498a5d69a1cd10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7de083ca6c8834b498a5d69a1cd10b">&#9670;&nbsp;</a></span>buf_page_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_page_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inits a page to the buffer buf_pool. </p>
<p>The block pointer must be private to the calling thread at the start of this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>block to init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2efca615726ffc1dfc6c2ed05612ccd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efca615726ffc1dfc6c2ed05612ccd0">&#9670;&nbsp;</a></span>buf_page_init_for_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_init_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>unzip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inits a page for read to the buffer buf_pool. </p>
<p>If the page is (1) already in buf_pool, or (2) if we specify to read only ibuf pages and the page is not an ibuf page, or (3) if the space is deleted or being deleted, then this function does nothing. Sets the io_fix flag to BUF_IO_READ and sets a non-recursive exclusive lock on the buffer frame. The io-handler must take care that the flag is cleared and the lock released later. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>DB_SUCCESS or DB_TABLESPACE_DELETED </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>BUF_READ_IBUF_PAGES_ONLY, ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unzip</td><td>TRUE=request uncompressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL </dd></dl>

</div>
</div>
<a id="af36e120d41b65fc009f011a62dc107e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36e120d41b65fc009f011a62dc107e5">&#9670;&nbsp;</a></span>buf_page_init_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_init_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize some fields of a control block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block to init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fc2cc72f66548f1e67ad61e8e8769a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc2cc72f66548f1e67ad61e8e8769a1">&#9670;&nbsp;</a></span>buf_page_io_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_io_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>evict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes an asynchronous read or write request of a file page to or from the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evict</td><td>whether or not to evict the page from LRU list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a id="a9ce975aae00f09fe4f8d97d0b5fd2d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce975aae00f09fe4f8d97d0b5fd2d8f">&#9670;&nbsp;</a></span>buf_page_make_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_page_make_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moved a page to the end of the buffer pool LRU list so that it can be flushed out at the earliest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer block of a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ecef5e7084a885aa97d2aedb9a0fe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecef5e7084a885aa97d2aedb9a0fe6e">&#9670;&nbsp;</a></span>buf_page_make_young()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_page_make_young </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a page to the start of the buffer pool LRU list. </p>
<p>This high-level function can be used to prevent an important page from slipping out of the buffer pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>buffer block of a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae03ec3da38f4ad513f96d7d71663e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03ec3da38f4ad513f96d7d71663e7d8">&#9670;&nbsp;</a></span>buf_page_make_young_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_page_make_young_if_needed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves a page to the start of the buffer pool LRU list if it is too old. </p>
<p>This high-level function can be used to prevent an important page from slipping out of the buffer pool. The page must be fixed to the buffer pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>buffer block of a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe6373a18fab2a1df7def6fd06d0efba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6373a18fab2a1df7def6fd06d0efba">&#9670;&nbsp;</a></span>buf_page_monitor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_page_monitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td>
          <td class="paramname"><em>io_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monitor the buffer page read/write activity, and increment corresponding counter value if MONITOR_MODULE_BUF_PAGE (module_buf_page) module is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block </td></tr>
    <tr><td class="paramname">io_type</td><td>in: io_fix types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a569b18490ab03d0b30a22dfd9f9fdb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569b18490ab03d0b30a22dfd9f9fdb07">&#9670;&nbsp;</a></span>buf_page_optimistic_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_optimistic_get </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modify_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0buf_8h.html#aa4ef74186b9c9937976a7d022cfa12c7">Page_fetch</a>&#160;</td>
          <td class="paramname"><em>fetch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the general function used to get optimistic access to a database page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rw_latch</td><td>RW_S_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>Guessed block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify_clock</td><td>Modify clock value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fetch_mode</td><td>Fetch mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>

</div>
</div>
<a id="a0feb3f11f6a58e81598bf92d7b435500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0feb3f11f6a58e81598bf92d7b435500">&#9670;&nbsp;</a></span>buf_page_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_page_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a page to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_buf</td><td>a database page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>0 or BUF_PAGE_PRINT_NO_CRASH or BUF_PAGE_PRINT_NO_FULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1c1191fd056e70491b80b5c889ecf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c1191fd056e70491b80b5c889ecf8b">&#9670;&nbsp;</a></span>buf_page_realloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_page_realloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate a control block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>pointer to control block </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if succeeded or if failed because the block was fixed </td></tr>
    <tr><td class="paramname">false</td><td>if failed because of no free blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3f64c5e7568dbfc7c7a868943f8c3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f64c5e7568dbfc7c7a868943f8c3f7">&#9670;&nbsp;</a></span>buf_page_reset_file_page_was_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_reset_file_page_was_freed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets file_page_was_freed FALSE if the page is found in the buffer pool. </p>
<p>This function should be called when we free a file page and want the debug version to check that it is not accessed any more unless reallocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>control block if found in page hash table, otherwise NULL </dd></dl>

</div>
</div>
<a id="aed26a402a24afefb51d6d7945647bd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed26a402a24afefb51d6d7945647bd30">&#9670;&nbsp;</a></span>buf_page_set_file_page_was_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_page_set_file_page_was_freed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets file_page_was_freed TRUE if the page is found in the buffer pool. </p>
<p>This function should be called when we free a file page and want the debug version to check that it is not accessed any more unless reallocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>control block if found in page hash table, otherwise NULL </dd></dl>

</div>
</div>
<a id="aba2805ff54abe4adb4a918c41a2f9ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2805ff54abe4adb4a918c41a2f9ed0">&#9670;&nbsp;</a></span>buf_page_try_get_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_try_get_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a tablespace id and page number tries to get that page. </p>
<p>If the page is not in the buffer pool it is not loaded and NULL is returned. Suitable for using when holding the lock_sys latches (as it avoids deadlock). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page Id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a page or NULL </dd></dl>

</div>
</div>
<a id="a2fdc4c9f9a04819fb962432b2c0b8e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc4c9f9a04819fb962432b2c0b8e8f">&#9670;&nbsp;</a></span>buf_pool_adjust_chunk_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> buf_pool_adjust_chunk_unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the proposed chunk unit size so that it satisfies all invariants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>proposed size of buffer pool chunk unit in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>adjusted size which meets invariants </dd></dl>

</div>
</div>
<a id="ab0de522312135372e9204158db79f015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0de522312135372e9204158db79f015">&#9670;&nbsp;</a></span>buf_pool_check_no_pending_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_check_no_pending_io </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that there currently are no pending i/o-operations for the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pending i/o </dd></dl>

</div>
</div>
<a id="a42bed44f93d9f9850ad30d4900164174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bed44f93d9f9850ad30d4900164174">&#9670;&nbsp;</a></span>buf_pool_clear_hash_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_clear_hash_index </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the adaptive hash index on all pages in the buffer pool. </p>

</div>
</div>
<a id="a8239011f74f17732794942ff891bfbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8239011f74f17732794942ff891bfbf3">&#9670;&nbsp;</a></span>buf_pool_contains_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_pool_contains_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a block in the buffer pool that points to a given compressed page. </p>
<p>Used only to confirm that buffer pool does not contain a given pointer, thus protected by zip_free_mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to compressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer block pointing to the compressed page, or NULL </dd></dl>

</div>
</div>
<a id="aef4fc143128704b800deb7997e699857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4fc143128704b800deb7997e699857">&#9670;&nbsp;</a></span>buf_pool_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_pool_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>instance_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">std::mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool_size</td><td>size in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instance_no</td><td>id of the instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td>Mutex to protect common data structures </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">err</td><td>DB_SUCCESS if all goes well </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3fc8e6cd97f295e76cbab520c126c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fc8e6cd97f295e76cbab520c126c10">&#9670;&nbsp;</a></span>buf_pool_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the buffer pool global data structures. </p>

</div>
</div>
<a id="a7f3b9b346f49593dc6d435d4a88d6d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3b9b346f49593dc6d435d4a88d6d7f">&#9670;&nbsp;</a></span>buf_pool_free_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_free_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the buffer pool instances and the global data structures. </p>
<p>Frees the buffer pool at shutdown.</p>

</div>
</div>
<a id="a5cac1411711bbe034e1d6742c5ab6f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cac1411711bbe034e1d6742c5ab6f63">&#9670;&nbsp;</a></span>buf_pool_free_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_free_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free one buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa18483f39367e4be86099560cd0cb938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18483f39367e4be86099560cd0cb938">&#9670;&nbsp;</a></span>buf_pool_get_oldest_modification_approx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_pool_get_oldest_modification_approx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the smallest oldest_modification lsn among all of the earliest added pages in flush lists. </p>
<p>In other words - takes the last dirty page from each flush list, and calculates minimum oldest_modification among all of them. Does not acquire global lock for the whole process, so the result might come from inconsistent view on flush lists.</p>
<dl class="section note"><dt>Note</dt><dd>Note that because of the relaxed order in each flush list, this functions no longer returns the smallest oldest_modification among all of the dirty pages. If you wanted to have a safe lsn, which is smaller than every oldest_modification, you would need to use another function: buf_pool_get_oldest_modification_lwm().</dd></dl>
<p>Returns zero if there were no dirty pages (flush lists were empty).</p>
<dl class="section return"><dt>Returns</dt><dd>minimum oldest_modification of last pages from flush lists, zero if flush lists were empty </dd></dl>

</div>
</div>
<a id="a274d89180ba0679ad7b31453f3dddbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274d89180ba0679ad7b31453f3dddbf6">&#9670;&nbsp;</a></span>buf_pool_get_oldest_modification_lwm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_pool_get_oldest_modification_lwm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a safe low watermark for oldest_modification. </p>
<p>It's guaranteed that there were no dirty pages with smaller oldest_modification in the whole flush lists.</p>
<p>Returns zero if flush lists were empty, be careful in such case, because taking the newest lsn is probably not a good idea. If you wanted to rely on some lsn in such case, you would need to follow pattern: </p><pre class="fragment">    dpa_lsn = log_buffer_dirty_pages_added_up_to_lsn(*log_sys);

    lwm_lsn = buf_pool_get_oldest_modification_lwm();

    if (lwm_lsn == 0) lwm_lsn = dpa_lsn;
</pre><p>The order is important to avoid race conditions.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It's guaranteed that the returned value will not be smaller than the last checkpoint lsn. It's not guaranteed that the returned value is the maximum possible. It's just the best effort for the low cost. It basically takes result of buf_pool_get_oldest_modification_approx() and subtracts maximum possible lag introduced by relaxed order in flush lists (srv_log_recent_closed_size).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>safe low watermark for oldest_modification of dirty pages, or zero if flush lists were empty; if non-zero, it is then guaranteed not to be at block boundary (and it points to lsn inside data fragment of block) </dd></dl>

</div>
</div>
<a id="a0ec7d5de1f91e878e799748d903fb71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec7d5de1f91e878e799748d903fb71b">&#9670;&nbsp;</a></span>buf_pool_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> buf_pool_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>total_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">total_size</td><td>Size of the total pool in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_instances</td><td>Number of buffer pool instances to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if success, DB_ERROR if not enough memory or error </dd></dl>

</div>
</div>
<a id="ad4cee70fe0ea742c8a909aaa3bce3f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cee70fe0ea742c8a909aaa3bce3f59">&#9670;&nbsp;</a></span>buf_pool_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_invalidate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates the file pages in the buffer pool when an archive recovery is completed. </p>
<p>All the file pages buffered must be in a replaceable state when this function is called: not latched and not modified. </p>

</div>
</div>
<a id="a55b96a1551d95ca86c218cc9b4e48e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b96a1551d95ca86c218cc9b4e48e80">&#9670;&nbsp;</a></span>buf_pool_invalidate_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_invalidate_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates file pages in one buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a047fc26680ad517bffc30da26e6bc402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047fc26680ad517bffc30da26e6bc402">&#9670;&nbsp;</a></span>buf_pool_register_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_register_chunk </td>
          <td>(</td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a chunk to buf_pool_chunk_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>chunk of buffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca1d119a3c91bee1e488b0957ed4eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca1d119a3c91bee1e488b0957ed4eed">&#9670;&nbsp;</a></span>buf_pool_resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_resize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the buffer pool based on srv_buf_pool_size from srv_buf_pool_old_size. </p>

</div>
</div>
<a id="a58476968445da673d8803816b32ec229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58476968445da673d8803816b32ec229">&#9670;&nbsp;</a></span>buf_pool_resize_chunk_make_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_resize_chunk_make_null </td>
          <td>(</td>
          <td class="paramtype">buf_chunk_t **&#160;</td>
          <td class="paramname"><em>new_chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a debug routine to inject an memory allocation failure error. </p>

</div>
</div>
<a id="a635283cf84c099ad42d89d4dc050ca40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635283cf84c099ad42d89d4dc050ca40">&#9670;&nbsp;</a></span>buf_pool_resize_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_resize_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resize page_hash and zip_hash for a buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaf95ed2818750214caab3fa60a4541a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf95ed2818750214caab3fa60a4541a">&#9670;&nbsp;</a></span>buf_pool_set_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_set_sizes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set buffer pool size variables Note: It's safe without mutex protection because of startup only. </p>

</div>
</div>
<a id="a2ee39fa7dde2fd24069257650c8c73e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee39fa7dde2fd24069257650c8c73e2">&#9670;&nbsp;</a></span>buf_pool_update_madvise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_update_madvise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if innobase_should_madvise_buf_pool() value has changed since we've last check and if so, then updates buf_pool_should_madvise and calls madvise for all chunks in all srv_buf_pool_instances. </p>
<dl class="section see"><dt>See also</dt><dd>buf_pool_should_madvise comment for a longer explanation. </dd></dl>

</div>
</div>
<a id="a9a664ed871c41382ade64a132801fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a664ed871c41382ade64a132801fd0b">&#9670;&nbsp;</a></span>buf_pool_validate_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_pool_validate_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates data in one buffer pool instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="ae799641f6fffb0ac145542154be08361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae799641f6fffb0ac145542154be08361">&#9670;&nbsp;</a></span>buf_pool_watch_is_sentinel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_pool_watch_is_sentinel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a block is a sentinel for a buffer pool watch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a sentinel for a buffer pool watch, false if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35b6dd3b80c03a713c7f160611d00455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b6dd3b80c03a713c7f160611d00455">&#9670;&nbsp;</a></span>buf_pool_watch_occurred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_pool_watch_occurred </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the page has been read in. </p>
<p>This may only be called after buf_pool_watch_set(same_page_id) has returned NULL and before invoking buf_pool_watch_unset(same_page_id). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the given page was not read in, true if it was </dd></dl>

</div>
</div>
<a id="a7832111496d8a89a6eff6191aa7bfa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7832111496d8a89a6eff6191aa7bfa94">&#9670;&nbsp;</a></span>buf_pool_watch_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_watch_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>watch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the sentinel block for the watch before replacing it with a real block. </p>
<p>buf_page_watch_unset() or buf_page_watch_occurred() will notice that the block has been replaced with the real block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">watch</td><td>sentinel for watch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a937f25b54f0325b08e0e57d5df7a7c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937f25b54f0325b08e0e57d5df7a7c0a">&#9670;&nbsp;</a></span>buf_pool_watch_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_pool_watch_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> **&#160;</td>
          <td class="paramname"><em>hash_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add watch for the given page to be read in. </p>
<p>Caller must have appropriate hash_lock for the bpage and hold the LRU list mutex to avoid a race condition with buf_LRU_free_page inserting the same page into the page hash. This function may release the hash_lock and reacquire it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_lock</td><td>hash_lock currently latched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if watch set, block if the page is in the buffer pool </dd></dl>

</div>
</div>
<a id="a607741f6ab261487ea1e2efef4d7640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607741f6ab261487ea1e2efef4d7640e">&#9670;&nbsp;</a></span>buf_pool_watch_unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_watch_unset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop watching if the page has been read in. </p>
<p>buf_pool_watch_set(same_page_id) must have returned NULL before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c7ca6aafcc2908bed941c08e770027f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7ca6aafcc2908bed941c08e770027f">&#9670;&nbsp;</a></span>buf_pool_withdraw_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_pool_withdraw_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Withdraw the buffer pool blocks from end of the buffer pool instance until withdrawn by buf_pool-&gt;withdraw_target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if retry is needed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9913c2499ec503eea58a7dbb0c6b93d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913c2499ec503eea58a7dbb0c6b93d8">&#9670;&nbsp;</a></span>buf_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of the buffer buf_pool data structure. </p>
<p>Prints info of the buffer pool data structure.</p>

</div>
</div>
<a id="a2f47d49bbb1ebb9c2f27458ee14251e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f47d49bbb1ebb9c2f27458ee14251e4">&#9670;&nbsp;</a></span>buf_print_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_print_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints info of the buffer buf_pool data structure for one instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a940342731a901c4a6171de07be118f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940342731a901c4a6171de07be118f57">&#9670;&nbsp;</a></span>buf_print_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_print_io </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of the buffer i/o. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in/out: buffer where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2ee567ec9a8bd47c647ab1dc8fa2524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ee567ec9a8bd47c647ab1dc8fa2524">&#9670;&nbsp;</a></span>buf_print_io_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_print_io_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>pool_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints info of the buffer i/o. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool_info</td><td>in: buffer pool info </td></tr>
    <tr><td class="paramname">file</td><td>in/out: buffer where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a753d780aa84a242710866eed7bcc32c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753d780aa84a242710866eed7bcc32c0">&#9670;&nbsp;</a></span>buf_read_page_handle_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_read_page_handle_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unfixes the page, unlatches the page, removes it from page_hash and removes it from LRU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>pointer to the block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad964582ff883657e0b0848867bc63f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad964582ff883657e0b0848867bc63f14">&#9670;&nbsp;</a></span>buf_refresh_io_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_refresh_io_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refreshes the statistics used to print per-second averages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e94539bff73e687c3c528e81b724fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e94539bff73e687c3c528e81b724fd5">&#9670;&nbsp;</a></span>buf_refresh_io_stats_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_refresh_io_stats_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refreshes the statistics used to print per-second averages. </p>
<p>Refresh the statistics used to print per-second averages.</p>

</div>
</div>
<a id="a3510a63046d01ab7904e34c76e6713be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3510a63046d01ab7904e34c76e6713be">&#9670;&nbsp;</a></span>buf_relocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_relocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relocate a buffer control block. </p>
<p>Relocates the block on the LRU list and in buf_pool-&gt;page_hash. Does not relocate bpage-&gt;list. The caller must take care of relocating bpage-&gt;list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bpage</td><td>control block being relocated, buf_page_get_state() must be BUF_BLOCK_ZIP_DIRTY or BUF_BLOCK_ZIP_PAGE </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dpage</td><td>destination control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f1e628479afa1dea626e85e8e6e3066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1e628479afa1dea626e85e8e6e3066">&#9670;&nbsp;</a></span>buf_resize_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_resize_status </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the global variable that feeds MySQL's innodb_buffer_pool_resize_status to the specified string. </p>
<p>The format and the following parameters are the same as the ones used for printf(3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>extra parameters according to fmt </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9781b154f5eb92bbc15d0c4538e46124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9781b154f5eb92bbc15d0c4538e46124">&#9670;&nbsp;</a></span>buf_resize_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_resize_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the thread for resizing buffer pool. </p>
<p>It waits for an event and when waked up either performs a resizing and sleeps again. </p>

</div>
</div>
<a id="a3b5418342f432074305965a75c1fedc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5418342f432074305965a75c1fedc7">&#9670;&nbsp;</a></span>buf_stats_aggregate_pool_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_stats_aggregate_pool_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>total_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>pool_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aggregates a pool stats information with the total buffer pool stats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_info</td><td>in/out: the buffer pool info to store aggregated result </td></tr>
    <tr><td class="paramname">pool_info</td><td>in: individual buffer pool stats info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94add70baf8e2ee67299e346bbb47965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94add70baf8e2ee67299e346bbb47965">&#9670;&nbsp;</a></span>buf_stats_get_pool_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_stats_get_pool_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pool_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>all_pool_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect buffer pool stats information for a buffer pool. </p>
<p>Also record aggregated stats if there are more than one buffer pool in the server </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
    <tr><td class="paramname">pool_id</td><td>in: buffer pool ID </td></tr>
    <tr><td class="paramname">all_pool_info</td><td>in/out: buffer pool info to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5fa041692f236bcd8e2fd5e0a575fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fa041692f236bcd8e2fd5e0a575fbc">&#9670;&nbsp;</a></span>buf_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the buffer buf_pool data structure. </p>
<p>Validates the buffer pool data structure.</p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="a4d073376daf32f894c496cd3b6f61cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d073376daf32f894c496cd3b6f61cd4">&#9670;&nbsp;</a></span>buf_wait_for_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_wait_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the block to be read in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>The block to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a532b24c23776dee3f4a4635e38417378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532b24c23776dee3f4a4635e38417378">&#9670;&nbsp;</a></span>buf_zip_decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_zip_decompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompress a block. </p>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: block </td></tr>
    <tr><td class="paramname">check</td><td>in: TRUE=verify the page checksum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7fefbabeb6b422a2baeae7758d16a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fefbabeb6b422a2baeae7758d16a7d">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the given buf_pool_t object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>the buf_pool_t object to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7930f6f7a939dac6e06fb9990e65feed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7930f6f7a939dac6e06fb9990e65feed">&#9670;&nbsp;</a></span>buf_chunk_map_reg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0buf_8cc.html#ab2e5308b1379f4316b26358f2d7f39b1">buf_pool_chunk_map_t</a>* buf_chunk_map_reg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5be5895208fc69ca2f5e972b8ad6e8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be5895208fc69ca2f5e972b8ad6e8b1">&#9670;&nbsp;</a></span>buf_dbg_counter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_dbg_counter = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to insert validation operations in execution in the debug version. </p>

</div>
</div>
<a id="a7076240d95384c7a4b81433a490fe3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7076240d95384c7a4b81433a490fe3c2">&#9670;&nbsp;</a></span>BUF_PAGE_READ_MAX_RETRIES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_PAGE_READ_MAX_RETRIES = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of attempts made to read in a page in the buffer pool. </p>

</div>
</div>
<a id="a3fdf9e142c6096556e3722d7c91b9065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdf9e142c6096556e3722d7c91b9065">&#9670;&nbsp;</a></span>buf_pool_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The buffer pools of the database. </p>

</div>
</div>
<a id="a480d1db8e2baa0e8bf8cd877e4811f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480d1db8e2baa0e8bf8cd877e4811f72">&#9670;&nbsp;</a></span>buf_pool_resizing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_pool_resizing</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true when resizing buffer pool is in the critical path. </p>

</div>
</div>
<a id="a9c9c8b00ed9b9b097c23147228ecad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9c8b00ed9b9b097c23147228ecad81">&#9670;&nbsp;</a></span>buf_pool_should_madvise</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_pool_should_madvise = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e1aa28e86a9882e3de615f874604ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1aa28e86a9882e3de615f874604ae0">&#9670;&nbsp;</a></span>BUF_READ_AHEAD_PAGES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_READ_AHEAD_PAGES = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of pages to read ahead. </p>

</div>
</div>
<a id="a81e768c888ebf1dd9549598ff961433b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e768c888ebf1dd9549598ff961433b">&#9670;&nbsp;</a></span>BUF_READ_AHEAD_PORTION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_READ_AHEAD_PORTION = 32</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum portion of the buffer pool that can be used for the read-ahead buffer. </p>
<p>(Divide buf_pool size by this amount) </p>

</div>
</div>
<a id="a8db54f597ad6c97e025e653f3314da8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db54f597ad6c97e025e653f3314da8d">&#9670;&nbsp;</a></span>buf_stat_per_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__stat__per__index__t.html">buf_stat_per_index_t</a>* buf_stat_per_index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container for how many pages from each index are contained in the buffer pool(s). </p>

</div>
</div>
<a id="a6fc24929fce17db4c95c3b7ca56c01e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc24929fce17db4c95c3b7ca56c01e0">&#9670;&nbsp;</a></span>srv_buf_pool_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> srv_buf_pool_debug</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used to enable multiple buffer pool instances with small buffer pool size. </p>

</div>
</div>
<a id="ae252c6f42e712b83871abe3faeea7093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae252c6f42e712b83871abe3faeea7093">&#9670;&nbsp;</a></span>WAIT_FOR_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int WAIT_FOR_READ = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value in microseconds. </p>

</div>
</div>
<a id="a0eb68ab1d33974dd5d02d56933a14287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb68ab1d33974dd5d02d56933a14287">&#9670;&nbsp;</a></span>WAIT_FOR_WRITE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int WAIT_FOR_WRITE = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_19e7dc57837d445aa8a255d4d3e40a16.html">buf</a></li><li class="navelem"><a class="el" href="buf0buf_8cc.html">buf0buf.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
