<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Gcs_async_buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classGcs__async__buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classGcs__async__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gcs_async_buffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Circular buffer that can be used to asynchronously feed a sink.  
 <a href="classGcs__async__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gcs__logging__system_8h_source.html">gcs_logging_system.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac28c8a7561cce16b6b7ffc834b1bd183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#ac28c8a7561cce16b6b7ffc834b1bd183">Gcs_async_buffer</a> (<a class="el" href="classSink__interface.html">Sink_interface</a> *sink, const int buffer_size=<a class="el" href="gcs__logging__system_8h.html#ac4c9919c142fa5ef044681051bbde59f">DEFAULT_ASYNC_BUFFERS</a>)</td></tr>
<tr class="separator:ac28c8a7561cce16b6b7ffc834b1bd183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3e1730c780977b3f04827e3180e986"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#aea3e1730c780977b3f04827e3180e986">~Gcs_async_buffer</a> ()</td></tr>
<tr class="separator:aea3e1730c780977b3f04827e3180e986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82222c546990757dcf52092475f5ba45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a82222c546990757dcf52092475f5ba45">initialize</a> ()</td></tr>
<tr class="memdesc:a82222c546990757dcf52092475f5ba45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous circular buffer initialization method.  <a href="#a82222c546990757dcf52092475f5ba45">More...</a><br /></td></tr>
<tr class="separator:a82222c546990757dcf52092475f5ba45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3358aa6af3a3d14ab6c30eff3a2e4396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a3358aa6af3a3d14ab6c30eff3a2e4396">finalize</a> ()</td></tr>
<tr class="memdesc:a3358aa6af3a3d14ab6c30eff3a2e4396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous circular buffer finalization method.  <a href="#a3358aa6af3a3d14ab6c30eff3a2e4396">More...</a><br /></td></tr>
<tr class="separator:a3358aa6af3a3d14ab6c30eff3a2e4396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa417a25c1edd4251311f608633afe5b4"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#aa417a25c1edd4251311f608633afe5b4">get_information</a> () const</td></tr>
<tr class="memdesc:aa417a25c1edd4251311f608633afe5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this method is to return information on the associated sink such as its location.  <a href="#aa417a25c1edd4251311f608633afe5b4">More...</a><br /></td></tr>
<tr class="separator:aa417a25c1edd4251311f608633afe5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886cfc503d8aad4c47880858e8e0ab7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a886cfc503d8aad4c47880858e8e0ab7a">consume_events</a> ()</td></tr>
<tr class="memdesc:a886cfc503d8aad4c47880858e8e0ab7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer thread invokes this method to process log events until it is terminated.  <a href="#a886cfc503d8aad4c47880858e8e0ab7a">More...</a><br /></td></tr>
<tr class="separator:a886cfc503d8aad4c47880858e8e0ab7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5444c4dad4d75e354ade47d3ae76c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a7b5444c4dad4d75e354ade47d3ae76c4">produce_events</a> (const char *message, size_t message_size)</td></tr>
<tr class="memdesc:a7b5444c4dad4d75e354ade47d3ae76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Producer threads invoke this method to log events (i.e.  <a href="#a7b5444c4dad4d75e354ade47d3ae76c4">More...</a><br /></td></tr>
<tr class="separator:a7b5444c4dad4d75e354ade47d3ae76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca80e4727f41427e7a19ee2b517a7d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#aca80e4727f41427e7a19ee2b517a7d52">produce_events</a> (const std::string &amp;message)</td></tr>
<tr class="memdesc:aca80e4727f41427e7a19ee2b517a7d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Producer threads invoke this method to log events (i.e.  <a href="#aca80e4727f41427e7a19ee2b517a7d52">More...</a><br /></td></tr>
<tr class="separator:aca80e4727f41427e7a19ee2b517a7d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80455134605f0afd74cef06fd118c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGcs__log__event.html">Gcs_log_event</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#ad80455134605f0afd74cef06fd118c63">get_entry</a> ()</td></tr>
<tr class="memdesc:ad80455134605f0afd74cef06fd118c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an in-memory buffer where a message content will be written to.  <a href="#ad80455134605f0afd74cef06fd118c63">More...</a><br /></td></tr>
<tr class="separator:ad80455134605f0afd74cef06fd118c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c157e9db9729bf71236e07ab14a04f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a8c157e9db9729bf71236e07ab14a04f2">notify_entry</a> (<a class="el" href="classGcs__log__event.html">Gcs_log_event</a> &amp;buffer_entry)</td></tr>
<tr class="memdesc:a8c157e9db9729bf71236e07ab14a04f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify that an in-memory buffer was filled in and is ready to be consumed.  <a href="#a8c157e9db9729bf71236e07ab14a04f2">More...</a><br /></td></tr>
<tr class="separator:a8c157e9db9729bf71236e07ab14a04f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614fac76b81ab496eb7cd1e92141b0c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSink__interface.html">Sink_interface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a614fac76b81ab496eb7cd1e92141b0c2">get_sink</a> () const</td></tr>
<tr class="separator:a614fac76b81ab496eb7cd1e92141b0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8ce178ab7c449eed47ef16e50e0a24af"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a8ce178ab7c449eed47ef16e50e0a24af">get_index</a> (int64_t <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>) const</td></tr>
<tr class="memdesc:a8ce178ab7c449eed47ef16e50e0a24af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the correct index to an entry according to the buffer size.  <a href="#a8ce178ab7c449eed47ef16e50e0a24af">More...</a><br /></td></tr>
<tr class="separator:a8ce178ab7c449eed47ef16e50e0a24af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d83a2d70b4303ab44cebc384f6d7952"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a3d83a2d70b4303ab44cebc384f6d7952">get_write_index</a> ()</td></tr>
<tr class="memdesc:a3d83a2d70b4303ab44cebc384f6d7952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an index entry to an in-memory buffer where a message content will be written to.  <a href="#a3d83a2d70b4303ab44cebc384f6d7952">More...</a><br /></td></tr>
<tr class="separator:a3d83a2d70b4303ab44cebc384f6d7952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd8cb7cba3e2948ad3ee20b3c13f39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a6dd8cb7cba3e2948ad3ee20b3c13f39f">sleep_consumer</a> () const</td></tr>
<tr class="memdesc:a6dd8cb7cba3e2948ad3ee20b3c13f39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the consumer sleep while there is no entry to be consumed.  <a href="#a6dd8cb7cba3e2948ad3ee20b3c13f39f">More...</a><br /></td></tr>
<tr class="separator:a6dd8cb7cba3e2948ad3ee20b3c13f39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a7017162f613356526f49c1e98b2d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#af4a7017162f613356526f49c1e98b2d4">wake_up_consumer</a> () const</td></tr>
<tr class="memdesc:af4a7017162f613356526f49c1e98b2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up the consumer thread so that it can write whatever was added to the asynchronous buffer to a sink.  <a href="#af4a7017162f613356526f49c1e98b2d4">More...</a><br /></td></tr>
<tr class="separator:af4a7017162f613356526f49c1e98b2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9814583a8a577a0da3a800e9fb22ece"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#ae9814583a8a577a0da3a800e9fb22ece">Gcs_async_buffer</a> (<a class="el" href="classGcs__async__buffer.html">Gcs_async_buffer</a> &amp;l)</td></tr>
<tr class="separator:ae9814583a8a577a0da3a800e9fb22ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae224d76a4e62bb88f5a50f23a3e6a2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGcs__async__buffer.html">Gcs_async_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#ae224d76a4e62bb88f5a50f23a3e6a2b5">operator=</a> (const <a class="el" href="classGcs__async__buffer.html">Gcs_async_buffer</a> &amp;l)</td></tr>
<tr class="separator:ae224d76a4e62bb88f5a50f23a3e6a2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acd446956637a436bf54afe58f47607f9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classGcs__log__event.html">Gcs_log_event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#acd446956637a436bf54afe58f47607f9">m_buffer</a></td></tr>
<tr class="memdesc:acd446956637a436bf54afe58f47607f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slots where messages will be copied to before a consumer thread writes them to a sink.  <a href="#acd446956637a436bf54afe58f47607f9">More...</a><br /></td></tr>
<tr class="separator:acd446956637a436bf54afe58f47607f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6168d0412356ce76a729d8e2c838f83f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a6168d0412356ce76a729d8e2c838f83f">m_buffer_size</a></td></tr>
<tr class="memdesc:a6168d0412356ce76a729d8e2c838f83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of avaiable slots in the buffer.  <a href="#a6168d0412356ce76a729d8e2c838f83f">More...</a><br /></td></tr>
<tr class="separator:a6168d0412356ce76a729d8e2c838f83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6f517257089f008e57ae6a1fee9460"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a7f6f517257089f008e57ae6a1fee9460">m_write_index</a></td></tr>
<tr class="memdesc:a7f6f517257089f008e57ae6a1fee9460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next entry in the buffer where producers will write their messages to.  <a href="#a7f6f517257089f008e57ae6a1fee9460">More...</a><br /></td></tr>
<tr class="separator:a7f6f517257089f008e57ae6a1fee9460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d9c8a3d49d33236656fdb4677e03bc"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a29d9c8a3d49d33236656fdb4677e03bc">m_read_index</a></td></tr>
<tr class="memdesc:a29d9c8a3d49d33236656fdb4677e03bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next entry in the buffer that will be read by the consumer.  <a href="#a29d9c8a3d49d33236656fdb4677e03bc">More...</a><br /></td></tr>
<tr class="separator:a29d9c8a3d49d33236656fdb4677e03bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7e0c98236dd2a425c4b65f6b6f2a24"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#adc7e0c98236dd2a425c4b65f6b6f2a24">m_number_entries</a></td></tr>
<tr class="memdesc:adc7e0c98236dd2a425c4b65f6b6f2a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries written by producers and not yet consumed.  <a href="#adc7e0c98236dd2a425c4b65f6b6f2a24">More...</a><br /></td></tr>
<tr class="separator:adc7e0c98236dd2a425c4b65f6b6f2a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274c0d6ef91389d177ec6b10f3758e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a274c0d6ef91389d177ec6b10f3758e04">m_terminated</a></td></tr>
<tr class="memdesc:a274c0d6ef91389d177ec6b10f3758e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the asynchronous circular buffer has been stopped or not.  <a href="#a274c0d6ef91389d177ec6b10f3758e04">More...</a><br /></td></tr>
<tr class="separator:a274c0d6ef91389d177ec6b10f3758e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e1decaf3fbbedde8b75879279b816a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a34e1decaf3fbbedde8b75879279b816a">m_initialized</a></td></tr>
<tr class="memdesc:a34e1decaf3fbbedde8b75879279b816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the asynchronous circular buffer has been started or not.  <a href="#a34e1decaf3fbbedde8b75879279b816a">More...</a><br /></td></tr>
<tr class="separator:a34e1decaf3fbbedde8b75879279b816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f31daf814676b3f362029a0bf826e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSink__interface.html">Sink_interface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a28f31daf814676b3f362029a0bf826e4">m_sink</a></td></tr>
<tr class="memdesc:a28f31daf814676b3f362029a0bf826e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink where the consumer will write messages to.  <a href="#a28f31daf814676b3f362029a0bf826e4">More...</a><br /></td></tr>
<tr class="separator:a28f31daf814676b3f362029a0bf826e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179897630bff5dfcdb7ff0a860f41db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMy__xp__thread.html">My_xp_thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#a179897630bff5dfcdb7ff0a860f41db5">m_consumer</a></td></tr>
<tr class="memdesc:a179897630bff5dfcdb7ff0a860f41db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer thread that is responsible for reading the entries in the circular buffer.  <a href="#a179897630bff5dfcdb7ff0a860f41db5">More...</a><br /></td></tr>
<tr class="separator:a179897630bff5dfcdb7ff0a860f41db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49971370167ba1a34593dc38c8c5e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMy__xp__cond.html">My_xp_cond</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#ac49971370167ba1a34593dc38c8c5e78">m_wait_for_events_cond</a></td></tr>
<tr class="memdesc:ac49971370167ba1a34593dc38c8c5e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional variable that is used by the producer to notify the consumer that it should wake up.  <a href="#ac49971370167ba1a34593dc38c8c5e78">More...</a><br /></td></tr>
<tr class="separator:ac49971370167ba1a34593dc38c8c5e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23131d3a4aa6e945dc302d1fe06eaa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMy__xp__cond.html">My_xp_cond</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#aa23131d3a4aa6e945dc302d1fe06eaa3">m_free_buffer_cond</a></td></tr>
<tr class="memdesc:aa23131d3a4aa6e945dc302d1fe06eaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional variable that is used by the consumer to notify the producer that there are free slots.  <a href="#aa23131d3a4aa6e945dc302d1fe06eaa3">More...</a><br /></td></tr>
<tr class="separator:aa23131d3a4aa6e945dc302d1fe06eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c968f226dbcce217fda2fe81a2c48a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMy__xp__mutex.html">My_xp_mutex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__async__buffer.html#ae0c968f226dbcce217fda2fe81a2c48a">m_free_buffer_mutex</a></td></tr>
<tr class="memdesc:ae0c968f226dbcce217fda2fe81a2c48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex variable that is used to synchronize access to the circular buffer in particular the m_number_entries, m_write_index and m_terminated shared variables.  <a href="#ae0c968f226dbcce217fda2fe81a2c48a">More...</a><br /></td></tr>
<tr class="separator:ae0c968f226dbcce217fda2fe81a2c48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Circular buffer that can be used to asynchronously feed a sink. </p>
<p>In this, messages are temporarily stored in-memory and asynchronously written to the sink. Using this in-memory intermediate buffer is possible to minimize performance drawbacks associated with the direct access to the sink which is usually the terminal, a file or a remote process.</p>
<p>By default, the circular buffer has DEFAULT_ASYNC_BUFFERS entries and this value can be changed by providing different contructor's paramaters. Note that, however, this is not currently exposed to the end-user. If there is no free slot available, the caller thread will be temporarily blocked until it can copy its message into a free slot. Only one thread will read the entries in the circular buffer and write them to a sink.</p>
<p>Concurrent access to the buffer is controlled by using a mutex and atomic variables. If you are tempted to change this, please, measure the performance first before changing anything. We have done so and the bulk of the time is spent in formatting the messages and for that reason a simple circular buffer implementation is enough.</p>
<p>Another alternative would be to format the message within the consumer but this would require to always pass information by value. In order to give users flexibility, we have decided not to do this. Besides, XCOM almost always formats its messages within the context of the caller thread. For those reasons, we kept the current behavior but we might revisit this in the future. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac28c8a7561cce16b6b7ffc834b1bd183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28c8a7561cce16b6b7ffc834b1bd183">&#9670;&nbsp;</a></span>Gcs_async_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gcs_async_buffer::Gcs_async_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSink__interface.html">Sink_interface</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code><a class="el" href="gcs__logging__system_8h.html#ac4c9919c142fa5ef044681051bbde59f">DEFAULT_ASYNC_BUFFERS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea3e1730c780977b3f04827e3180e986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3e1730c780977b3f04827e3180e986">&#9670;&nbsp;</a></span>~Gcs_async_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gcs_async_buffer::~Gcs_async_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9814583a8a577a0da3a800e9fb22ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9814583a8a577a0da3a800e9fb22ece">&#9670;&nbsp;</a></span>Gcs_async_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gcs_async_buffer::Gcs_async_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__async__buffer.html">Gcs_async_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a886cfc503d8aad4c47880858e8e0ab7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886cfc503d8aad4c47880858e8e0ab7a">&#9670;&nbsp;</a></span>consume_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_async_buffer::consume_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumer thread invokes this method to process log events until it is terminated. </p>

</div>
</div>
<a id="a3358aa6af3a3d14ab6c30eff3a2e4396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3358aa6af3a3d14ab6c30eff3a2e4396">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a> Gcs_async_buffer::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous circular buffer finalization method. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">GCS_OK</td><td>in case everything goes well. Any other value of gcs_error in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad80455134605f0afd74cef06fd118c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80455134605f0afd74cef06fd118c63">&#9670;&nbsp;</a></span>get_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGcs__log__event.html">Gcs_log_event</a> &amp; Gcs_async_buffer::get_entry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to an in-memory buffer where a message content will be written to. </p>

</div>
</div>
<a id="a8ce178ab7c449eed47ef16e50e0a24af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce178ab7c449eed47ef16e50e0a24af">&#9670;&nbsp;</a></span>get_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Gcs_async_buffer::get_index </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the correct index to an entry according to the buffer size. </p>

</div>
</div>
<a id="aa417a25c1edd4251311f608633afe5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa417a25c1edd4251311f608633afe5b4">&#9670;&nbsp;</a></span>get_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string Gcs_async_buffer::get_information </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this method is to return information on the associated sink such as its location. </p>
<p>In this particular case, it will return the string "asynchronous" along with the information returned by then sink in use.</p>
<p>Calling this method would return "asynchronous::output" if the sink in use was the standard output. </p>

</div>
</div>
<a id="a614fac76b81ab496eb7cd1e92141b0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614fac76b81ab496eb7cd1e92141b0c2">&#9670;&nbsp;</a></span>get_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSink__interface.html">Sink_interface</a> * Gcs_async_buffer::get_sink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d83a2d70b4303ab44cebc384f6d7952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d83a2d70b4303ab44cebc384f6d7952">&#9670;&nbsp;</a></span>get_write_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Gcs_async_buffer::get_write_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an index entry to an in-memory buffer where a message content will be written to. </p>

</div>
</div>
<a id="a82222c546990757dcf52092475f5ba45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82222c546990757dcf52092475f5ba45">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a> Gcs_async_buffer::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous circular buffer initialization method. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">GCS_OK</td><td>in case everything goes well. Any other value of gcs_error in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c157e9db9729bf71236e07ab14a04f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c157e9db9729bf71236e07ab14a04f2">&#9670;&nbsp;</a></span>notify_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_async_buffer::notify_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__log__event.html">Gcs_log_event</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer_entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify that an in-memory buffer was filled in and is ready to be consumed. </p>

</div>
</div>
<a id="ae224d76a4e62bb88f5a50f23a3e6a2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae224d76a4e62bb88f5a50f23a3e6a2b5">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGcs__async__buffer.html">Gcs_async_buffer</a>&amp; Gcs_async_buffer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGcs__async__buffer.html">Gcs_async_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b5444c4dad4d75e354ade47d3ae76c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5444c4dad4d75e354ade47d3ae76c4">&#9670;&nbsp;</a></span>produce_events() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_async_buffer::produce_events </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>message_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Producer threads invoke this method to log events (i.e. </p>
<p>messages).</p>
<p>This method is only provided for the sake of completeness and is currently not used because the message would have to be copied into the circular buffer and usually it is necessary to compose the message first thus incurring an extra copy.</p>
<p>Currently, a producer calls directly the get_entry() and notify_entry() methods directly. </p>

</div>
</div>
<a id="aca80e4727f41427e7a19ee2b517a7d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca80e4727f41427e7a19ee2b517a7d52">&#9670;&nbsp;</a></span>produce_events() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_async_buffer::produce_events </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Producer threads invoke this method to log events (i.e. </p>
<p>messages).</p>
<p>This method is only provided for the sake of completeness and is currently not used because the message would have to be copied into the circular buffer and usually it is necessary to compose the message first thus incurring an extra copy.</p>
<p>Currently, a producer calls directly the get_entry() and notify_entry() methods directly </p>

</div>
</div>
<a id="a6dd8cb7cba3e2948ad3ee20b3c13f39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd8cb7cba3e2948ad3ee20b3c13f39f">&#9670;&nbsp;</a></span>sleep_consumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_async_buffer::sleep_consumer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the consumer sleep while there is no entry to be consumed. </p>

</div>
</div>
<a id="af4a7017162f613356526f49c1e98b2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a7017162f613356526f49c1e98b2d4">&#9670;&nbsp;</a></span>wake_up_consumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_async_buffer::wake_up_consumer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wake up the consumer thread so that it can write whatever was added to the asynchronous buffer to a sink. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acd446956637a436bf54afe58f47607f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd446956637a436bf54afe58f47607f9">&#9670;&nbsp;</a></span>m_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classGcs__log__event.html">Gcs_log_event</a>&gt; Gcs_async_buffer::m_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slots where messages will be copied to before a consumer thread writes them to a sink. </p>

</div>
</div>
<a id="a6168d0412356ce76a729d8e2c838f83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6168d0412356ce76a729d8e2c838f83f">&#9670;&nbsp;</a></span>m_buffer_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Gcs_async_buffer::m_buffer_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of avaiable slots in the buffer. </p>

</div>
</div>
<a id="a179897630bff5dfcdb7ff0a860f41db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179897630bff5dfcdb7ff0a860f41db5">&#9670;&nbsp;</a></span>m_consumer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMy__xp__thread.html">My_xp_thread</a>* Gcs_async_buffer::m_consumer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumer thread that is responsible for reading the entries in the circular buffer. </p>

</div>
</div>
<a id="aa23131d3a4aa6e945dc302d1fe06eaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23131d3a4aa6e945dc302d1fe06eaa3">&#9670;&nbsp;</a></span>m_free_buffer_cond</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMy__xp__cond.html">My_xp_cond</a>* Gcs_async_buffer::m_free_buffer_cond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional variable that is used by the consumer to notify the producer that there are free slots. </p>

</div>
</div>
<a id="ae0c968f226dbcce217fda2fe81a2c48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c968f226dbcce217fda2fe81a2c48a">&#9670;&nbsp;</a></span>m_free_buffer_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMy__xp__mutex.html">My_xp_mutex</a>* Gcs_async_buffer::m_free_buffer_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex variable that is used to synchronize access to the circular buffer in particular the m_number_entries, m_write_index and m_terminated shared variables. </p>

</div>
</div>
<a id="a34e1decaf3fbbedde8b75879279b816a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e1decaf3fbbedde8b75879279b816a">&#9670;&nbsp;</a></span>m_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_async_buffer::m_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the asynchronous circular buffer has been started or not. </p>

</div>
</div>
<a id="adc7e0c98236dd2a425c4b65f6b6f2a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7e0c98236dd2a425c4b65f6b6f2a24">&#9670;&nbsp;</a></span>m_number_entries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Gcs_async_buffer::m_number_entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of entries written by producers and not yet consumed. </p>

</div>
</div>
<a id="a29d9c8a3d49d33236656fdb4677e03bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d9c8a3d49d33236656fdb4677e03bc">&#9670;&nbsp;</a></span>m_read_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Gcs_async_buffer::m_read_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Next entry in the buffer that will be read by the consumer. </p>

</div>
</div>
<a id="a28f31daf814676b3f362029a0bf826e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f31daf814676b3f362029a0bf826e4">&#9670;&nbsp;</a></span>m_sink</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSink__interface.html">Sink_interface</a>* Gcs_async_buffer::m_sink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sink where the consumer will write messages to. </p>

</div>
</div>
<a id="a274c0d6ef91389d177ec6b10f3758e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274c0d6ef91389d177ec6b10f3758e04">&#9670;&nbsp;</a></span>m_terminated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_async_buffer::m_terminated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the asynchronous circular buffer has been stopped or not. </p>

</div>
</div>
<a id="ac49971370167ba1a34593dc38c8c5e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49971370167ba1a34593dc38c8c5e78">&#9670;&nbsp;</a></span>m_wait_for_events_cond</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMy__xp__cond.html">My_xp_cond</a>* Gcs_async_buffer::m_wait_for_events_cond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditional variable that is used by the producer to notify the consumer that it should wake up. </p>

</div>
</div>
<a id="a7f6f517257089f008e57ae6a1fee9460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6f517257089f008e57ae6a1fee9460">&#9670;&nbsp;</a></span>m_write_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Gcs_async_buffer::m_write_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Next entry in the buffer where producers will write their messages to. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>plugin/group_replication/libmysqlgcs/include/mysql/gcs/<a class="el" href="gcs__logging__system_8h_source.html">gcs_logging_system.h</a></li>
<li>plugin/group_replication/libmysqlgcs/src/interface/<a class="el" href="gcs__logging__system_8cc.html">gcs_logging_system.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classGcs__async__buffer.html">Gcs_async_buffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
