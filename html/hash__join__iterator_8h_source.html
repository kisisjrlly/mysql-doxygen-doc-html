<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: sql/hash_join_iterator.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hash__join__iterator_8h_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">hash_join_iterator.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="hash__join__iterator_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#ifndef SQL_HASH_JOIN_ITERATOR_H_</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#define SQL_HASH_JOIN_ITERATOR_H_</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">/* Copyright (c) 2019, 2020, Oracle and/or its affiliates.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">   This program is free software; you can redistribute it and/or modify</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">   it under the terms of the GNU General Public License, version 2.0,</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">   as published by the Free Software Foundation.</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">   This program is also distributed with certain software (including</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">   but not limited to OpenSSL) that is licensed under separate terms,</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">   as designated in a particular file or component or in included license</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">   documentation.  The authors of MySQL hereby grant you an additional</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">   permission to link the program and your derivative works with the</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">   separately licensed software that they have included with MySQL.</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">   This program is distributed in the hope that it will be useful,</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">   GNU General Public License, version 2.0, for more details.</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">   You should have received a copy of the GNU General Public License</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">   along with this program; if not, write to the Free Software</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="my__alloc_8h.html">my_alloc.h</a>&quot;</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="my__inttypes_8h.html">my_inttypes.h</a>&quot;</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="hash__join__buffer_8h.html">sql/hash_join_buffer.h</a>&quot;</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="hash__join__chunk_8h.html">sql/hash_join_chunk.h</a>&quot;</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="item__cmpfunc_8h.html">sql/item_cmpfunc.h</a>&quot;</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="mem__root__array_8h.html">sql/mem_root_array.h</a>&quot;</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="row__iterator_8h.html">sql/row_iterator.h</a>&quot;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="sql_2table_8h.html">sql/table.h</a>&quot;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="sql__string_8h.html">sql_string.h</a>&quot;</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="keyword">class </span><a class="code" href="classTHD.html">THD</a>;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="keyword">class </span><a class="code" href="classQEP__TAB.html">QEP_TAB</a>;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno"><a class="line" href="structChunkPair.html">   45</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structChunkPair.html">ChunkPair</a> {</div><div class="line"><a name="l00046"></a><span class="lineno"><a class="line" href="structChunkPair.html#a03ebfbdc602a35ab0aa0d1b8adb6a53d">   46</a></span>&#160;  <a class="code" href="classHashJoinChunk.html">HashJoinChunk</a> <a class="code" href="structChunkPair.html#a03ebfbdc602a35ab0aa0d1b8adb6a53d">probe_chunk</a>;</div><div class="line"><a name="l00047"></a><span class="lineno"><a class="line" href="structChunkPair.html#a5697ea7476720dc8b055ca20f4e52d19">   47</a></span>&#160;  <a class="code" href="classHashJoinChunk.html">HashJoinChunk</a> <a class="code" href="structChunkPair.html#a5697ea7476720dc8b055ca20f4e52d19">build_chunk</a>;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;};</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">/// @file</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">/// An iterator for joining two inputs by using hashing to match rows from</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">/// the inputs.</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">/// The iterator starts out by doing everything in-memory. If everything fits</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">/// into memory, the joining algorithm for inner joins works like this:</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">/// 1) Designate one input as the &quot;build&quot; input and one input as the &quot;probe&quot;</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">/// input. Ideally, the smallest input measured in total size (not number of</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">/// rows) should be designated as the build input.</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">/// 2) Read all the rows from the build input into an in-memory hash table.</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">/// The hash key used in the hash table is calculated from the join attributes,</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">/// e.g., if we have the following query where &quot;orders&quot; is designated as the</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">/// build input:</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">///   SELECT * FROM lineitem</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">///     INNER JOIN orders ON orders.o_orderkey = lineitem.l_orderkey;</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">/// the hash value will be calculated from the values in the column</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">/// orders.o_orderkey. Note that the optimizer recognizes implicit join</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">/// conditions, so this also works for SQL statements like:</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">///   SELECT * FROM orders, lineitem</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">///     WHERE orders.o_orderkey = lineitem.l_orderkey;</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">/// 3) Then, we read the rows from the probe input, one by one. For each row,</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">/// a hash key is calculated for the other side of the join (the probe input)</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">/// using the join attribute (lineitem.l_orderkey in the above example) and the</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">/// same hash function as in step 2. This hash key is used to do a lookup in the</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">/// hash table, and for each match, an output row is produced. Note that the row</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">/// from the probe input is already located in the table record buffers, and the</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">/// matching row stored in the hash table is restored back to the record buffers</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">/// where it originally came from. For details around how rows are stored and</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">/// restored, see comments on hash_join_buffer::StoreFromTableBuffers.</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">/// The size of the in-memory hash table is controlled by the system variable</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">/// join_buffer_size. If we run out of memory during step 2, we degrade into a</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">/// hybrid hash join. The data already in memory is processed using regular hash</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">/// join, and the remainder is processed using on-disk hash join. It works like</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">/// this:</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">/// 1) The rest of the rows in the build input that did not fit into the hash</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">/// table are partitioned out into a given amount of files, represented by</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">/// HashJoinChunks. We create an equal number of chunk files for both the probe</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">/// and build input. We determine which file to put a row in by calculating a</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">/// hash from the join attribute like in step 2 above, but using a different</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">/// hash function.</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">/// 2) Then, we read the rows from the probe input, one by one. We look for a</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">/// match in the hash table as described above, but the row is also written out</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment">/// to the chunk file on disk, since it might match a row from the build input</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">/// that we&#39;ve written to disk.</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment">/// 3) When the entire probe input is read, we run the &quot;classic&quot; hash join on</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">/// each of the corresponding chunk file probe/build pairs. Since the rows are</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">/// partitioned using the same hash function for probe and build inputs, we know</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">/// that matching rows must be located in the same pair of chunk files.</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">/// The algorithm for semijoin is quite similar to inner joins:</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">/// 1) Designate the inner table (i.e. the IN-side of a semijoin) as the build</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">/// input. As semijoins only needs the first matching row from the inner table,</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">/// we do not store duplicate keys in the hash table.</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">/// 2) Output all rows from the probe input where there is at least one matching</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">/// row in the hash table. In case we have degraded into on-disk hash join, we</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">/// write the probe row out to chunk file only if we did not find a matching row</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">/// in the hash table.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">/// The optimizer may set up semijoins with conditions that are not pure join</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">/// conditions, but that must be attached to the hash join iterator anyways.</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">/// Consider the following query and (slightly modified) execution plan:</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">///   SELECT c FROM t WHERE 1 IN (SELECT t.c = col1 FROM t1);</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">///   -&gt; Hash semijoin (no condition), extra conditions: (1 = (t.c = t1.col1))</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">///       -&gt; Table scan on t</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">///       -&gt; Hash</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">///           -&gt; Table scan on t1</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">/// In this query, the optimizer has set up the condition (1 = (t.c = t1.col1))</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">/// as the semijoin condition. We cannot use this as a join condition, since</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">/// hash join only supports equi-join conditions. However, we cannot attach this</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">/// as a filter after the join, as that would cause wrong results. We attach</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">/// these conditions as &quot;extra&quot; conditions to the hash join iterator, and causes</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">/// these notable behaviors:</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment">/// a. If we have any extra conditions, we cannot reject duplicate keys in the</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment">///    hash table: the first row matching the join condition could fail the</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">///    extra condition(s).</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">/// b. We can only output rows if all extra conditions pass. If any of the extra</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">///    conditions fail, we must go to the next matching row in the hash table.</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">/// c. In case of on-disk hash join, we must write the probe row to disk _after_</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">///    we have checked that there are no rows in the hash table that match any</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">///    of the extra conditions.</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">/// If we are able to execute the hash join in memory (classic hash join),</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">/// the output will be sorted the same as the left (probe) input. If we start</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">/// spilling to disk, we lose any reasonable ordering properties.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">/// Note that we still might end up in a case where a single chunk file from</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">/// disk won&#39;t fit into memory. This is resolved by reading as much as possible</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">/// into the hash table, and then reading the entire probe chunk file for each</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">/// time the hash table is reloaded. This might happen if we have a very skewed</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">/// data set, for instance.</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">/// When we start spilling to disk, we allocate a maximum of &quot;kMaxChunks&quot;</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">/// chunk files on disk for each of the two inputs. The reason for having an</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">/// upper limit is to avoid running out of file descriptors.</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">/// There is also a flag we can set to avoid hash join spilling to disk</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">/// regardless of the input size. If the flag is set, the join algorithm works</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">/// like this:</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">/// 1) Read as many rows as possible from the build input into an in-memory hash</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">/// table.</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">/// 2) When the hash table is full (we have reached the limit set by the system</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">/// variable join_buffer_size), start reading from the beginning of the probe</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment">/// input, probing for matches in the hash table. Output a row for each match</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">/// found.</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment">/// 3) When the probe input is empty, see if there are any remaining rows in the</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment">/// build input. If so, clear the in-memory hash table and go to step 1,</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment">/// continuing from the build input where we stopped the last time. If not, the</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">/// join is done.</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">/// Doing everything in memory can be beneficial in a few cases. Currently, it</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">/// is used when we have a LIMIT without sorting or grouping in the query. The</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">/// gain is that we start producing output rows a lot earlier than if we were to</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">/// spill both inputs out to disk. It could also be beneficial if the build</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">/// input _almost_ fits in memory; it would likely be better to read the probe</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">/// input twice instead of writing both inputs out to disk. However, we do not</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">/// currently do any such cost based optimization.</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">/// There is a concept called &quot;probe row saving&quot; in the iterator. This is a</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">/// technique that is enabled in two different scenarios: when a hash join build</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">/// chunk does not fit entirely in memory and when hash join is not allowed to</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">/// spill to disk. Common for these two scenarios is that a probe row will be</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">/// read multiple times. For certain join types (semijoin), we must take care so</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">/// that the same probe row is not sent to the client multiple times. Probe row</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">/// saving takes care of this by doing the following:</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment">/// - If we realize that we are going to read the same probe row multiple times,</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">///   we enable probe row saving.</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">/// - When a probe row is read, we write the row out to a probe row saving write</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment">///   file, given that it matches certain conditions (for semijoin we only save</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">///   unmatched probe rows).</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">/// - After the probe input is consumed, we will swap the probe row saving</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">///   _write_ file and the probe row saving _read_ file, making the write file</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">///   available for writing again.</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">/// - When we are to read the probe input again, we read the probe rows from the</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment">///   probe row saving read file. This ensures that we i.e. do not output the</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment">///   same probe row twice for semijoin. Note that if the rows we read from the</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">///   probe row saving read file will be read again (e.g., we have a big hash</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment">///   join build chunk that is many times bigger than the available hash table</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment">///   memory, causing us to process the chunk file in chunks), we will again</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment">///   write the rows to a new probe row saving write file. This reading from the</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">///   read file and writing to a new write file continues until we know that we</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">///   are seeing the probe rows for the last time.</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">/// We use the same methods as on-disk hash join (HashJoinChunk) for reading and</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">/// writing rows to files. Note that probe row saving is never enabled for inner</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">/// joins, since we do want to output the same probe row multiple times if it</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">/// matches muliple rows from the build input. There are some differences</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">/// regarding when probe row saving is enabled, depending on the hash join type</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">/// (see enum HashJoinType):</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">/// - IN_MEMORY: Probe row saving is never activated, since the probe input is</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">///   read only once.</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">/// - SPILL_TO_DISK: If a build chunk file does not fit in memory (may happen</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">///   with skewed data set), we will have to read the corresponding probe chunk</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">///   multiple times. In this case, probe row saving is enabled as soon as we</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">///   see that the build chunk does not fit in memory, and remains active until</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">///   the entire build chunk is consumed. After the probe chunk is read once,</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">///   we swap the probe row saving write file and probe row saving read file so</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">///   that probe rows will be read from the probe row saving read file. Probe</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">///   row saving is deactivated once we move to the next pair of chunk files.</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">/// - IN_MEMORY_WITH_HASH_TABLE_REFILL: Probe row saving is activated when we</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">///   see that the build input is too large to fit in memory. Once the probe</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">///   iterator has been consumed once, we swap the probe row saving write file</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">///   and probe row saving read file so that probe rows will be read from the</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">///   probe row saving read file. As long as the build input is not fully</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">///   consumed, we write probe rows from the read file out to a new write file,</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">///   swapping these files for every hash table refill. Probe row saving is</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">///   never deactivated in this hash join type.</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">/// Note that we always write the entire row when writing to probe row saving</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">/// file. It would be possible to only write the match flag, but this is tricky</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">/// as long as we have the hash join type IN_MEMORY_WITH_HASH_TABLE_REFILL. If</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">/// we were to write only match flags in this hash join type, we would have to</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">/// read the probe iterator multiple times. But there is no guarantee that rows</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">/// will come in the same order when reading an iterator multiple times (e.g.</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">/// NDB does not guarantee this), so it would require us to store match flags in</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">/// a lookup structure using a row ID as the key. Due to this, we will</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">/// reconsider this if the hash join type IN_MEMORY_WITH_HASH_TABLE_REFILL goes</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">/// away.</span></div><div class="line"><a name="l00249"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html">  249</a></span>&#160;<span class="comment"></span><span class="keyword">class </span><a class="code" href="classHashJoinIterator.html">HashJoinIterator</a> <a class="code" href="hash_8c.html#ab4646d77540701d2eb2c877effbe5739">final</a> : <span class="keyword">public</span> <a class="code" href="classRowIterator.html">RowIterator</a> {</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160; <span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">  /// Construct a HashJoinIterator.</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">  /// @param thd</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">  ///   the thread handle</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">  /// @param build_input</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">  ///   the iterator for the build input</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">  /// @param build_input_tables</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">  ///   a bitmap of all the tables in the build input. The tables are needed for</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">  ///   two things:</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">  ///   1) Accessing the columns when creating the join key during creation of</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">  ///   the hash table,</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">  ///   2) and accessing the column data when creating the row to be stored in</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">  ///   the hash table and/or the chunk file on disk.</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment">  /// @param estimated_build_rows</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">  ///   How many rows we assume there will be when reading the build input.</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">  ///   This is used to choose how many chunks we break it into on disk.</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">  /// @param probe_input</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">  ///   the iterator for the probe input</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">  /// @param probe_input_tables</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">  ///   the probe input tables. Needed for the same reasons as</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">  ///   build_input_tables.</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">  /// @param store_rowids whether we need to make sure row ids are available</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">  ///   for all tables below us, after Read() has been called. used only if</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">  ///   we are below a weedout operation.</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">  /// @param tables_to_get_rowid_for a map of which tables we need to call</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">  ///   position() for ourselves. tables that are in build_input_tables</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">  ///   but not in this map, are expected to be handled by some other iterator.</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">  ///   tables that are in this map but not in build_input_tables will be</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">  ///   ignored.</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">  /// @param max_memory_available</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">  ///   the amount of memory available, in bytes, for this hash join iterator.</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">  ///   This can be user-controlled by setting the system variable</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">  ///   join_buffer_size.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment">  /// @param join_conditions</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">  ///   a list of all the join conditions between the two inputs</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">  /// @param allow_spill_to_disk</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">  ///   whether the hash join can spill to disk. This is set to false in some</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">  ///   cases where we have a LIMIT in the query</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">  /// @param join_type</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment">  ///   The join type.</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment">  /// @param join</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment">  ///   The join we are a part of.</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment">  /// @param extra_conditions</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">  ///   A list of extra conditions that the iterator will evaluate after a</span></div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">  ///   lookup in the hash table is done, but before the row is returned. The</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">  ///   conditions are AND-ed together into a single Item.</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment">  /// @param probe_input_batch_mode</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">  ///   Whether we need to enable batch mode on the probe input table.</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment">  ///   Only make sense if it is a single table, and we are not on the</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment">  ///   outer side of any nested loop join.</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment"></span>  <a class="code" href="classHashJoinIterator.html">HashJoinIterator</a>(<a class="code" href="classTHD.html">THD</a> *thd, <a class="code" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only&lt;RowIterator&gt;</a> build_input,</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                   <a class="code" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> build_input_tables, <span class="keywordtype">double</span> estimated_build_rows,</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                   <a class="code" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only&lt;RowIterator&gt;</a> probe_input,</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                   <a class="code" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> probe_input_tables, <span class="keywordtype">bool</span> store_rowids,</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                   <a class="code" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tables_to_get_rowid_for,</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                   <span class="keywordtype">size_t</span> max_memory_available,</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                   <span class="keyword">const</span> std::vector&lt;HashJoinCondition&gt; &amp;join_conditions,</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                   <span class="keywordtype">bool</span> allow_spill_to_disk, <a class="code" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="code" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>,</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                   <span class="keyword">const</span> <a class="code" href="classJOIN.html">JOIN</a> *<a class="code" href="namespacemysql__harness.html#aa60f40b3ee1134f2fe7f1f72c16bd1d3">join</a>,</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                   <span class="keyword">const</span> <a class="code" href="classMem__root__array.html">Mem_root_array&lt;Item *&gt;</a> &amp;extra_conditions,</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                   <span class="keywordtype">bool</span> probe_input_batch_mode);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="ha__mock_8cc.html#a06a8aebe91dc89036b9f1ffe684e6c10">Init</a>() <span class="keyword">override</span>;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="keywordtype">int</span> Read() <span class="keyword">override</span>;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a6b76cb096411f024ea982f52d11bae20">  317</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classHashJoinIterator.html#a6b76cb096411f024ea982f52d11bae20">SetNullRowFlag</a>(<span class="keywordtype">bool</span> is_null_row)<span class="keyword"> override </span>{</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    m_build_input-&gt;SetNullRowFlag(is_null_row);</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    m_probe_input-&gt;SetNullRowFlag(is_null_row);</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  }</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div><div class="line"><a name="l00322"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a0b9774fdfa99d6756188184897ea1023">  322</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classHashJoinIterator.html#a0b9774fdfa99d6756188184897ea1023">EndPSIBatchModeIfStarted</a>()<span class="keyword"> override </span>{</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    m_build_input-&gt;EndPSIBatchModeIfStarted();</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    m_probe_input-&gt;EndPSIBatchModeIfStarted();</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  }</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a2bd6a56878b6693c43a28094c1e01712">  327</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classHashJoinIterator.html#a2bd6a56878b6693c43a28094c1e01712">UnlockRow</a>()<span class="keyword"> override </span>{</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="comment">// Since both inputs may have been materialized to disk, we cannot unlock</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="comment">// them.</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  }</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160; <span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">  /// Read all rows from the build input and store the rows into the in-memory</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">  /// hash table. If the hash table goes full, the rest of the rows are written</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">  /// out to chunk files on disk. See the class comment for more details.</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment">  /// @retval true in case of error</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> BuildHashTable();</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment">  /// Read all rows from the next chunk file into the in-memory hash table.</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">  /// See the class comment for details.</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment">  /// @retval true in case of error</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> ReadNextHashJoinChunk();</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">  /// Read a single row from the probe iterator input into the tables&#39; record</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment">  /// buffers. If we have started spilling to disk, the row is written out to a</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment">  /// chunk file on disk as well.</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">  /// The end condition is that either:</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">  /// a) a row is ready in the tables&#39; record buffers, and the state will be set</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">  ///    to READING_FIRST_ROW_FROM_HASH_TABLE.</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">  /// b) There are no more rows to process from the probe input, so the iterator</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">  ///    state will be LOADING_NEXT_CHUNK_PAIR.</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">  /// @retval true in case of error</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> ReadRowFromProbeIterator();</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">  /// Read a single row from the current probe chunk file into the tables&#39;</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">  /// record buffers. The end conditions are the same as for</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">  /// ReadRowFromProbeIterator().</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">  /// @retval true in case of error</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> ReadRowFromProbeChunkFile();</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment">  /// Read a single row from the probe row saving file into the tables&#39; record</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment">  /// buffers.</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment">  /// @retval true in case of error</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> ReadRowFromProbeRowSavingFile();</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="comment">// Do a lookup in the hash table for matching rows from the build input.</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  <span class="comment">// The lookup is done by computing the join key from the probe input, and</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  <span class="comment">// using that join key for doing a lookup in the hash table. If the join key</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <span class="comment">// contains one or more SQL NULLs, the row cannot match anything and will be</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  <span class="comment">// skipped, and the iterator state will be READING_ROW_FROM_PROBE_INPUT. If</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <span class="comment">// not, the iterator state will be READING_FIRST_ROW_FROM_HASH_TABLE.</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  <span class="comment">// After this function is called, ReadJoinedRow() will return false until</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <span class="comment">// there are no more matching rows for the computed join key.</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keywordtype">void</span> LookupProbeRowInHashTable();</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment">  /// Take the next matching row from the hash table, and put the row into the</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment">  /// build tables&#39; record buffers. The function expects that</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment">  /// LookupProbeRowInHashTable() has been called up-front. The user must</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment">  /// call ReadJoinedRow() as long as it returns false, as there may be</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment">  /// multiple matching rows from the hash table. It is up to the caller to set</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment">  /// a new state in case of EOF.</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment">  /// @retval 0 if a match was found and the row is put in the build tables&#39;</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">  ///         record buffers</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment">  /// @retval -1 if there are no more matching rows in the hash table</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment"></span>  <span class="keywordtype">int</span> ReadJoinedRow();</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="comment">// Have we degraded into on-disk hash join?</span></div><div class="line"><a name="l00396"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ae4a09cafcb3285668234707b90b996ed">  396</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classHashJoinIterator.html#ae4a09cafcb3285668234707b90b996ed">on_disk_hash_join</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !m_chunk_files_on_disk.empty(); }</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment">  /// Write the last row read from the probe input out to chunk files on disk,</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="comment">  /// if applicable.</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment">  /// For inner joins, we must write all probe rows to chunk files, since we</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment">  /// need to match the row against rows from the build input that are written</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">  /// out to chunk files. For semijoin, we can only write probe rows that do not</span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">  /// match any of the rows in the hash table. Writing a probe row with a</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">  /// matching row in the hash table could cause the row to be returned multiple</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">  /// times.</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">  /// @retval true in case of errors.</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> WriteProbeRowToDiskIfApplicable();</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">  /// @retval true if the last joined row passes all of the extra conditions.</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> JoinedRowPassesExtraConditions() <span class="keyword">const</span>;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">  /// If true, reject duplicate keys in the hash table.</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">  /// Semijoins/antijoins are only interested in the first matching row from the</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">  /// hash table, so we can avoid storing duplicate keys in order to save some</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">  /// memory. However, this cannot be applied if we have any &quot;extra&quot; conditions:</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment">  /// the first matching row in the hash table may fail the extra condition(s).</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="comment">  /// @retval true if we can reject duplicate keys in the hash table.</span></div><div class="line"><a name="l00422"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#aabd92af6528c7c8fd54b2e91b165279b">  422</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classHashJoinIterator.html#aabd92af6528c7c8fd54b2e91b165279b">RejectDuplicateKeys</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keywordflow">return</span> m_extra_condition == <span class="keyword">nullptr</span> &amp;&amp;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;           (m_join_type == <a class="code" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395da69465caf22e5d212cbe4bbc87b1bf770">JoinType::SEMI</a> || m_join_type == <a class="code" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395da26eaf1d67c3441d6af2af64e29094d63">JoinType::ANTI</a>);</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  }</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment">  /// Clear the row buffer and reset all iterators pointing to it. This may be</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">  /// called multiple times to re-init the row buffer.</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">  /// @retval true in case of error. my_error has been called</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> InitRowBuffer();</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="comment">  /// Prepare to read the probe iterator from the beginning, and enable batch</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="comment">  /// mode if applicable. The iterator state will remain unchanged.</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="comment">  /// @retval true in case of error. my_error has been called.</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> InitProbeIterator();</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment">  /// Mark that probe row saving is enabled, and prepare the probe row saving</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">  /// file for writing.</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">  /// @see m_write_to_probe_row_saving</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">  /// @retval true in case of error. my_error has been called.</span></div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> InitWritingToProbeRowSavingFile();</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment">  /// Mark that we should read from the probe row saving file. The probe row</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment">  /// saving file is rewinded to the beginning.</span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment">  /// @see m_read_from_probe_row_saving</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="comment">  /// @retval true in case of error. my_error has been called.</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> InitReadingFromProbeRowSavingFile();</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">  /// Set the iterator state to the correct READING_ROW_FROM_PROBE_*-state.</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment">  /// Which state we end up in depends on which hash join type we are executing</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">  /// (in-memory, on-disk or in-memory with hash table refill).</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> SetReadingProbeRowState();</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">  /// Read a joined row from the hash table, and see if it passes any extra</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">  /// conditions. The last probe row read will also be written do disk if needed</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">  /// (see WriteProbeRowToDiskIfApplicable).</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="comment">  /// @retval -1 There are no more matching rows in the hash table.</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment">  /// @retval 0 A joined row is ready.</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">  /// @retval 1 An error occured.</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="comment"></span>  <span class="keywordtype">int</span> ReadNextJoinedRowFromHashTable();</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a22cdd3bb268e8404cc45c3857d9a9b69">  467</a></span>&#160;  <span class="keyword">enum class</span> <a class="code" href="classHashJoinIterator.html#a22cdd3bb268e8404cc45c3857d9a9b69">State</a> {</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    <span class="comment">// We are reading a row from the probe input, where the row comes from</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="comment">// the iterator.</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    READING_ROW_FROM_PROBE_ITERATOR,</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="comment">// We are reading a row from the probe input, where the row comes from a</span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="comment">// chunk file.</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    READING_ROW_FROM_PROBE_CHUNK_FILE,</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="comment">// We are reading a row from the probe input, where the row comes from a</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">// probe row saving file.</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    READING_ROW_FROM_PROBE_ROW_SAVING_FILE,</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    <span class="comment">// The iterator is moving to the next pair of chunk files, where the chunk</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="comment">// file from the build input will be loaded into the hash table.</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    LOADING_NEXT_CHUNK_PAIR,</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="comment">// We are reading the first row returned from the hash table lookup that</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="comment">// also passes extra conditions.</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    READING_FIRST_ROW_FROM_HASH_TABLE,</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="comment">// We are reading the remaining rows returned from the hash table lookup.</span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    READING_FROM_HASH_TABLE,</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="comment">// No more rows, both inputs are empty.</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    END_OF_ROWS</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;  };</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a74bcdbf9d941a8d2daa0764dc8dc2240">  489</a></span>&#160;  <a class="code" href="classHashJoinIterator.html#a22cdd3bb268e8404cc45c3857d9a9b69">State</a> <a class="code" href="classHashJoinIterator.html#a74bcdbf9d941a8d2daa0764dc8dc2240">m_state</a>;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a123a122fcb7cafa60c1a940c1826c0c8">  491</a></span>&#160;  <span class="keyword">const</span> <a class="code" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only&lt;RowIterator&gt;</a> <a class="code" href="classHashJoinIterator.html#a123a122fcb7cafa60c1a940c1826c0c8">m_build_input</a>;</div><div class="line"><a name="l00492"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ac0a50b13495cf950893e7fda4a904302">  492</a></span>&#160;  <span class="keyword">const</span> <a class="code" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only&lt;RowIterator&gt;</a> <a class="code" href="classHashJoinIterator.html#ac0a50b13495cf950893e7fda4a904302">m_probe_input</a>;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;  <span class="comment">// An iterator for reading rows from the hash table.</span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  <span class="comment">// hash_join_buffer::HashJoinRowBuffer::Iterator m_hash_map_iterator;</span></div><div class="line"><a name="l00496"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a645c7be4673d66997bddd9f36a1f575c">  496</a></span>&#160;  <a class="code" href="classhash__join__buffer_1_1HashJoinRowBuffer.html#a20b896bb1e0a61c1a2b51dd0d7dc6276">hash_join_buffer::HashJoinRowBuffer::hash_map_iterator</a> <a class="code" href="classHashJoinIterator.html#a645c7be4673d66997bddd9f36a1f575c">m_hash_map_iterator</a>;</div><div class="line"><a name="l00497"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a6c147d927e7c7b522c06493f3ef1e14e">  497</a></span>&#160;  <a class="code" href="classhash__join__buffer_1_1HashJoinRowBuffer.html#a20b896bb1e0a61c1a2b51dd0d7dc6276">hash_join_buffer::HashJoinRowBuffer::hash_map_iterator</a> <a class="code" href="classHashJoinIterator.html#a6c147d927e7c7b522c06493f3ef1e14e">m_hash_map_end</a>;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;  <span class="comment">// These structures holds the tables and columns that are needed for the hash</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;  <span class="comment">// join. Rows/columns that are not needed are filtered out in the constructor.</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  <span class="comment">// We need to know which tables that belong to each iterator, so that we can</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  <span class="comment">// compute the join key when needed.</span></div><div class="line"><a name="l00503"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#af33771359621d508df174c6cd46828b4">  503</a></span>&#160;  <a class="code" href="classhash__join__buffer_1_1TableCollection.html">hash_join_buffer::TableCollection</a> <a class="code" href="classHashJoinIterator.html#af33771359621d508df174c6cd46828b4">m_probe_input_tables</a>;</div><div class="line"><a name="l00504"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a3a935b889b14ebd33bd7db7129632d08">  504</a></span>&#160;  <a class="code" href="classhash__join__buffer_1_1TableCollection.html">hash_join_buffer::TableCollection</a> <a class="code" href="classHashJoinIterator.html#a3a935b889b14ebd33bd7db7129632d08">m_build_input_tables</a>;</div><div class="line"><a name="l00505"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ae99844f9e2f3d07d0753cea4857bc1a2">  505</a></span>&#160;  <span class="keyword">const</span> <a class="code" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> <a class="code" href="classHashJoinIterator.html#ae99844f9e2f3d07d0753cea4857bc1a2">m_tables_to_get_rowid_for</a>;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  <span class="comment">// An in-memory hash table that holds rows from the build input (directly from</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  <span class="comment">// the build input iterator, or from a chunk file). See the class comment for</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  <span class="comment">// details on how and when this is used.</span></div><div class="line"><a name="l00510"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#aede521acd60579e8b47bb66451915185">  510</a></span>&#160;  <a class="code" href="classhash__join__buffer_1_1HashJoinRowBuffer.html">hash_join_buffer::HashJoinRowBuffer</a> <a class="code" href="classHashJoinIterator.html#aede521acd60579e8b47bb66451915185">m_row_buffer</a>;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  <span class="comment">// A list of the join conditions (all of them are equi-join conditions).</span></div><div class="line"><a name="l00513"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a44e3734230ff2358d8fddf322750eb95">  513</a></span>&#160;  <a class="code" href="classPrealloced__array.html">Prealloced_array&lt;HashJoinCondition, 4&gt;</a> <a class="code" href="classHashJoinIterator.html#a44e3734230ff2358d8fddf322750eb95">m_join_conditions</a>;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;  <span class="comment">// Array to hold the list of chunk files on disk in case we degrade into</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  <span class="comment">// on-disk hash join.</span></div><div class="line"><a name="l00517"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a53027dd19d11a9f50115c80b9f2024e1">  517</a></span>&#160;  <a class="code" href="classMem__root__array.html">Mem_root_array&lt;ChunkPair&gt;</a> <a class="code" href="classHashJoinIterator.html#a53027dd19d11a9f50115c80b9f2024e1">m_chunk_files_on_disk</a>;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;  <span class="comment">// Which HashJoinChunk, if any, we are currently reading from, in both</span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;  <span class="comment">// LOADING_NEXT_CHUNK_PAIR and READING_ROW_FROM_PROBE_CHUNK_FILE.</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;  <span class="comment">// It is incremented during the state LOADING_NEXT_CHUNK_PAIR.</span></div><div class="line"><a name="l00522"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ad7b6023e378163f02d7ad62e3f561983">  522</a></span>&#160;  <span class="keywordtype">int</span> m_current_chunk{-1};</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  <span class="comment">// The seeds that are used by xxHash64 when calculating the hash from a join</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;  <span class="comment">// key. We need one seed for the hashing done in the in-memory hash table,</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  <span class="comment">// and one seed when calculating the hash that is used for determining which</span></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;  <span class="comment">// chunk file a row should be placed in (in case of on-disk hash join). If we</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;  <span class="comment">// were to use the same seed for both operations, we would get a really bad</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;  <span class="comment">// hash table when loading a chunk file to the hash table. The numbers are</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;  <span class="comment">// chosen randomly and have no special meaning.</span></div><div class="line"><a name="l00531"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ab2c05f4078060cd2665d88851a5aadc3">  531</a></span>&#160;  <span class="keyword">static</span> constexpr uint32_t kHashTableSeed{156211};</div><div class="line"><a name="l00532"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#aab44cf3f23e040ac719a59bbb0d11c97">  532</a></span>&#160;  <span class="keyword">static</span> constexpr uint32_t kChunkPartitioningHashSeed{899339};</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  <span class="comment">// Which row we currently are reading from each of the hash join chunk file.</span></div><div class="line"><a name="l00535"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a948f5525b188c28a9a27e314e2309a56">  535</a></span>&#160;  <a class="code" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> m_build_chunk_current_row = 0;</div><div class="line"><a name="l00536"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ac55f2abf9b310e270243b35fc1440885">  536</a></span>&#160;  <a class="code" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> m_probe_chunk_current_row = 0;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="comment">// How many rows we assume there will be when reading the build input.</span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  <span class="comment">// This is used to choose how many chunks we break it into on disk.</span></div><div class="line"><a name="l00540"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ad1ddccf127599ec2857101d40d16c152">  540</a></span>&#160;  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classHashJoinIterator.html#ad1ddccf127599ec2857101d40d16c152">m_estimated_build_rows</a>;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  <span class="comment">// The maximum number of HashJoinChunks that is allocated for each of the</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  <span class="comment">// inputs in case we spill to disk. We might very well end up with an amount</span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  <span class="comment">// less than this number, but we keep an upper limit so we don&#39;t risk running</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;  <span class="comment">// out of file descriptors. We always use a power of two number of files,</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  <span class="comment">// which allows us to do some optimizations when calculating which chunk a row</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="comment">// should be placed in.</span></div><div class="line"><a name="l00548"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a80bb4279be186eb42a2ecac416d68221">  548</a></span>&#160;  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> kMaxChunks = 128;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="comment">// A buffer that is used during two phases:</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <span class="comment">// 1) when constructing a join key from join conditions.</span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  <span class="comment">// 2) when moving a row between tables&#39; record buffers and the hash table.</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  <span class="comment">// There are two functions that needs this buffer; ConstructJoinKey() and</span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  <span class="comment">// StoreFromTableBuffers(). After calling one of these functions, the user</span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  <span class="comment">// must take responsiblity of the data if it is needed for a longer lifetime.</span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  <span class="comment">// If there are no BLOB/TEXT column in the join, we calculate an upper bound</span></div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;  <span class="comment">// of the row size that is used to preallocate this buffer. In the case of</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  <span class="comment">// BLOB/TEXT columns, we cannot calculate a reasonable upper bound, and the</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;  <span class="comment">// row size is calculated per row. The allocated memory is kept for the</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;  <span class="comment">// duration of the iterator, so that we (most likely) avoid reallocations.</span></div><div class="line"><a name="l00563"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a6a321906387244097e7249a3c320b8f2">  563</a></span>&#160;  <a class="code" href="classString.html">String</a> <a class="code" href="classHashJoinIterator.html#a6a321906387244097e7249a3c320b8f2">m_temporary_row_and_join_key_buffer</a>;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  <span class="comment">// Whether we should turn on batch mode for the probe input. Batch mode is</span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  <span class="comment">// enabled if the probe input consists of exactly one table, and said table</span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  <span class="comment">// can return more than one row and has no associated subquery condition.</span></div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  <span class="comment">// (See ShouldEnableBatchMode().)</span></div><div class="line"><a name="l00569"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#aa0ed892ae812e1aff735c72c47b9e605">  569</a></span>&#160;  <span class="keywordtype">bool</span> m_probe_input_batch_mode{<span class="keyword">false</span>};</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;  <span class="comment">// Whether we are allowed to spill to disk.</span></div><div class="line"><a name="l00572"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ae0383219f700aee671d9f6d117301605">  572</a></span>&#160;  <span class="keywordtype">bool</span> m_allow_spill_to_disk{<span class="keyword">true</span>};</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  <span class="comment">// Whether the build iterator has more rows. This is used to stop the hash</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;  <span class="comment">// join iterator asking for more rows when we know for sure that the entire</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  <span class="comment">// build input is consumed. The variable is only used if m_allow_spill_to_disk</span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;  <span class="comment">// is false, as we have to see if there are more rows in the build input after</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  <span class="comment">// the probe input is consumed.</span></div><div class="line"><a name="l00579"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a4820e17c05538a43d6d55ed51f17b383">  579</a></span>&#160;  <span class="keywordtype">bool</span> m_build_iterator_has_more_rows{<span class="keyword">true</span>};</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;  <span class="comment">// What kind of join the iterator should execute.</span></div><div class="line"><a name="l00582"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#adf53410253bc2573453d5b806d8b0f47">  582</a></span>&#160;  <span class="keyword">const</span> <a class="code" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="code" href="classHashJoinIterator.html#adf53410253bc2573453d5b806d8b0f47">m_join_type</a>;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  <span class="comment">// If not nullptr, an extra condition that the iterator will evaluate after a</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;  <span class="comment">// lookup in the hash table is done, but before the row is returned. This is</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  <span class="comment">// needed in case we have a semijoin condition that is not an equi-join</span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  <span class="comment">// condition (i.e. &#39;t1.col1 &lt; t2.col1&#39;).</span></div><div class="line"><a name="l00588"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#aec122fb5062e0b3d56cdc33777ae4525">  588</a></span>&#160;  <a class="code" href="classItem.html">Item</a> *m_extra_condition{<span class="keyword">nullptr</span>};</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  <span class="comment">// Whether we should write rows from the probe input to the probe row saving</span></div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  <span class="comment">// write file. See the class comment on HashJoinIterator for details around</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;  <span class="comment">// probe row saving.</span></div><div class="line"><a name="l00593"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#afccc443e1cace4b9a1d63ca487b20517">  593</a></span>&#160;  <span class="keywordtype">bool</span> m_write_to_probe_row_saving{<span class="keyword">false</span>};</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;  <span class="comment">// Whether we should read rows from the probe row saving read file. See the</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;  <span class="comment">// class comment on HashJoinIterator for details around probe row saving.</span></div><div class="line"><a name="l00597"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a8c00332c59dfa388c9a43c1536b38111">  597</a></span>&#160;  <span class="keywordtype">bool</span> m_read_from_probe_row_saving{<span class="keyword">false</span>};</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  <span class="comment">// The probe row saving files where unmatched probe rows are written to and</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;  <span class="comment">// read from.</span></div><div class="line"><a name="l00601"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a49d9cd2bd9f891a18d1e8570f8b77093">  601</a></span>&#160;  <a class="code" href="classHashJoinChunk.html">HashJoinChunk</a> <a class="code" href="classHashJoinIterator.html#a49d9cd2bd9f891a18d1e8570f8b77093">m_probe_row_saving_write_file</a>;</div><div class="line"><a name="l00602"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ac62f2872e9725e23b7c539f7a47707f4">  602</a></span>&#160;  <a class="code" href="classHashJoinChunk.html">HashJoinChunk</a> <a class="code" href="classHashJoinIterator.html#ac62f2872e9725e23b7c539f7a47707f4">m_probe_row_saving_read_file</a>;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  <span class="comment">// Which row we currently are reading from in the probe row saving read file.</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  <span class="comment">// Used to know whether we have reached the end of the file. How many files</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  <span class="comment">// the probe row saving read file contains is contained in the HashJoinChunk</span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;  <span class="comment">// (see m_probe_row_saving_read_file).</span></div><div class="line"><a name="l00608"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ad16a498be6d9fa42f698da7a75a04455">  608</a></span>&#160;  <a class="code" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> m_probe_row_saving_read_file_current_row{0};</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;  <span class="comment">// The &quot;type&quot; of hash join we are executing. We currently have three different</span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;  <span class="comment">// types of hash join:</span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;  <span class="comment">// - In memory: We do everything in memory without any refills of the hash</span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;  <span class="comment">//   table. Each input is read only once, and nothing is written to disk.</span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  <span class="comment">// - Spill to disk: If the build input does not fit in memory, we write both</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;  <span class="comment">//   inputs out to a set of chunk files. Both inputs are partitioned using a</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  <span class="comment">//   hash function over the join attribute, ensuring that matching rows can be</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;  <span class="comment">//   found in the same set of chunk files. Each pair of chunk file is then</span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;  <span class="comment">//   processed as an in-memory hash join.</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;  <span class="comment">// - In memory with hash table refill: This is enabled if we are not allowed</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;  <span class="comment">//   to spill to disk, and the build input does not fit in memory. We read as</span></div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;  <span class="comment">//   much as possible from the build input into the hash table. We then read</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  <span class="comment">//   the entire probe input, probing for matching rows in the hash table.</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;  <span class="comment">//   When the probe input returns EOF, the hash table is refilled with the</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;  <span class="comment">//   rows that did not fit the first time. The entire probe input is read</span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;  <span class="comment">//   again, and this is repeated until the entire build input is consumed.</span></div><div class="line"><a name="l00626"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#a95ea0a9e8e5352c5e67a59bff4bdae58">  626</a></span>&#160;  <span class="keyword">enum class</span> <a class="code" href="classHashJoinIterator.html#a95ea0a9e8e5352c5e67a59bff4bdae58">HashJoinType</a> {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    IN_MEMORY,</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    SPILL_TO_DISK,</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    IN_MEMORY_WITH_HASH_TABLE_REFILL</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;  };</div><div class="line"><a name="l00631"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#aa3c1fe9c3fb1f17ecbd7e31458b6db31">  631</a></span>&#160;  <a class="code" href="classHashJoinIterator.html#a95ea0a9e8e5352c5e67a59bff4bdae58">HashJoinType</a> m_hash_join_type{HashJoinType::IN_MEMORY};</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  <span class="comment">// The match flag for the last probe row read from chunk file.</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  <span class="comment">// This is needed if a outer join spills to disk; a probe row can match a row</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  <span class="comment">// from the build input we haven&#39;t seen yet (it&#39;s been written out to disk</span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  <span class="comment">// because the hash table was full). So when reading a probe row from a chunk</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  <span class="comment">// file, this variable holds the match flag. This flag must be a class member,</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <span class="comment">// since one probe row may match multiple rows from the hash table; the</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <span class="comment">// execution will go out of HashJoinIterator::Read() between each matching</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;  <span class="comment">// row, causing any local match flag to lose the match flag info from the last</span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="comment">// probe row read.</span></div><div class="line"><a name="l00643"></a><span class="lineno"><a class="line" href="classHashJoinIterator.html#ab4f977de38936afdabff05450a841b28">  643</a></span>&#160;  <span class="keywordtype">bool</span> m_probe_row_match_flag{<span class="keyword">false</span>};</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;};</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="comment">/// For each of the given tables, request that the row ID is filled in</span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="comment">/// (the equivalent of calling file-&gt;position()) if needed.</span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment">/// @param tables All tables involved in the hash join.</span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="comment">/// @param tables_to_get_rowid_for A bitmap of which tables to actually</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment">///     get row IDs for. (A table needs to be in both sets to be processed.)</span></div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="hash__join__iterator_8h.html#a58edec84e0035d9b5e1ef87578584d28">RequestRowId</a>(<span class="keyword">const</span> <a class="code" href="classPrealloced__array.html">Prealloced_array&lt;hash_join_buffer::Table, 4&gt;</a> &amp;tables,</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                  <a class="code" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tables_to_get_rowid_for);</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="keywordtype">void</span> <a class="code" href="hash__join__iterator_8h.html#aea611897987e142685cef4c57532ceb1">PrepareForRequestRowId</a>(</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    <span class="keyword">const</span> <a class="code" href="classPrealloced__array.html">Prealloced_array&lt;hash_join_buffer::Table, 4&gt;</a> &amp;tables,</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    <a class="code" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tables_to_get_rowid_for);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="preprocessor">#endif  // SQL_HASH_JOIN_ITERATOR_H_</span></div><div class="ttc" id="classHashJoinIterator_html_a645c7be4673d66997bddd9f36a1f575c"><div class="ttname"><a href="classHashJoinIterator.html#a645c7be4673d66997bddd9f36a1f575c">HashJoinIterator::m_hash_map_iterator</a></div><div class="ttdeci">hash_join_buffer::HashJoinRowBuffer::hash_map_iterator m_hash_map_iterator</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:496</div></div>
<div class="ttc" id="classHashJoinIterator_html_af33771359621d508df174c6cd46828b4"><div class="ttname"><a href="classHashJoinIterator.html#af33771359621d508df174c6cd46828b4">HashJoinIterator::m_probe_input_tables</a></div><div class="ttdeci">hash_join_buffer::TableCollection m_probe_input_tables</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:503</div></div>
<div class="ttc" id="classJOIN_html"><div class="ttname"><a href="classJOIN.html">JOIN</a></div><div class="ttdef"><b>Definition:</b> sql_optimizer.h:125</div></div>
<div class="ttc" id="sql__string_8h_html"><div class="ttname"><a href="sql__string_8h.html">sql_string.h</a></div><div class="ttdoc">Our own string classes, used pervasively throughout the executor. </div></div>
<div class="ttc" id="classHashJoinIterator_html_a22cdd3bb268e8404cc45c3857d9a9b69"><div class="ttname"><a href="classHashJoinIterator.html#a22cdd3bb268e8404cc45c3857d9a9b69">HashJoinIterator::State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:467</div></div>
<div class="ttc" id="classHashJoinIterator_html_a0b9774fdfa99d6756188184897ea1023"><div class="ttname"><a href="classHashJoinIterator.html#a0b9774fdfa99d6756188184897ea1023">HashJoinIterator::EndPSIBatchModeIfStarted</a></div><div class="ttdeci">void EndPSIBatchModeIfStarted() override</div><div class="ttdoc">Ends performance schema batch mode, if started. </div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:322</div></div>
<div class="ttc" id="classHashJoinIterator_html_a6c147d927e7c7b522c06493f3ef1e14e"><div class="ttname"><a href="classHashJoinIterator.html#a6c147d927e7c7b522c06493f3ef1e14e">HashJoinIterator::m_hash_map_end</a></div><div class="ttdeci">hash_join_buffer::HashJoinRowBuffer::hash_map_iterator m_hash_map_end</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:497</div></div>
<div class="ttc" id="hash__join__iterator_8h_html_aea611897987e142685cef4c57532ceb1"><div class="ttname"><a href="hash__join__iterator_8h.html#aea611897987e142685cef4c57532ceb1">PrepareForRequestRowId</a></div><div class="ttdeci">void PrepareForRequestRowId(const Prealloced_array&lt; hash_join_buffer::Table, 4 &gt; &amp;tables, table_map tables_to_get_rowid_for)</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.cc:309</div></div>
<div class="ttc" id="my__inttypes_8h_html"><div class="ttname"><a href="my__inttypes_8h.html">my_inttypes.h</a></div><div class="ttdoc">Some integer typedefs for easier portability. </div></div>
<div class="ttc" id="row__iterator_8h_html_aef400c43b34e3ecc3f7b342aa821395d"><div class="ttname"><a href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a></div><div class="ttdeci">JoinType</div><div class="ttdef"><b>Definition:</b> row_iterator.h:218</div></div>
<div class="ttc" id="classRowIterator_html"><div class="ttname"><a href="classRowIterator.html">RowIterator</a></div><div class="ttdoc">A context for reading through a single table using a chosen access method: index read, scan, etc, use of cache, etc. </div><div class="ttdef"><b>Definition:</b> row_iterator.h:61</div></div>
<div class="ttc" id="classHashJoinIterator_html_a2bd6a56878b6693c43a28094c1e01712"><div class="ttname"><a href="classHashJoinIterator.html#a2bd6a56878b6693c43a28094c1e01712">HashJoinIterator::UnlockRow</a></div><div class="ttdeci">void UnlockRow() override</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:327</div></div>
<div class="ttc" id="classHashJoinIterator_html_adf53410253bc2573453d5b806d8b0f47"><div class="ttname"><a href="classHashJoinIterator.html#adf53410253bc2573453d5b806d8b0f47">HashJoinIterator::m_join_type</a></div><div class="ttdeci">const JoinType m_join_type</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:582</div></div>
<div class="ttc" id="classHashJoinIterator_html_a6b76cb096411f024ea982f52d11bae20"><div class="ttname"><a href="classHashJoinIterator.html#a6b76cb096411f024ea982f52d11bae20">HashJoinIterator::SetNullRowFlag</a></div><div class="ttdeci">void SetNullRowFlag(bool is_null_row) override</div><div class="ttdoc">Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag...</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:317</div></div>
<div class="ttc" id="hash__join__chunk_8h_html"><div class="ttname"><a href="hash__join__chunk_8h.html">hash_join_chunk.h</a></div></div>
<div class="ttc" id="classHashJoinIterator_html_ac0a50b13495cf950893e7fda4a904302"><div class="ttname"><a href="classHashJoinIterator.html#ac0a50b13495cf950893e7fda4a904302">HashJoinIterator::m_probe_input</a></div><div class="ttdeci">const unique_ptr_destroy_only&lt; RowIterator &gt; m_probe_input</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:492</div></div>
<div class="ttc" id="structChunkPair_html"><div class="ttname"><a href="structChunkPair.html">ChunkPair</a></div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:45</div></div>
<div class="ttc" id="namespacemysql__harness_html_aa60f40b3ee1134f2fe7f1f72c16bd1d3"><div class="ttname"><a href="namespacemysql__harness.html#aa60f40b3ee1134f2fe7f1f72c16bd1d3">mysql_harness::join</a></div><div class="ttdeci">std::string join(Container cont, const std::string &amp;delim)</div><div class="ttdoc">join elements of an container into a string seperated by a delimiter. </div><div class="ttdef"><b>Definition:</b> string.h:144</div></div>
<div class="ttc" id="classString_html"><div class="ttname"><a href="classString.html">String</a></div><div class="ttdoc">Using this class is fraught with peril, and you need to be very careful when doing so...</div><div class="ttdef"><b>Definition:</b> sql_string.h:164</div></div>
<div class="ttc" id="hash__join__iterator_8h_html_a58edec84e0035d9b5e1ef87578584d28"><div class="ttname"><a href="hash__join__iterator_8h.html#a58edec84e0035d9b5e1ef87578584d28">RequestRowId</a></div><div class="ttdeci">void RequestRowId(const Prealloced_array&lt; hash_join_buffer::Table, 4 &gt; &amp;tables, table_map tables_to_get_rowid_for)</div><div class="ttdoc">For each of the given tables, request that the row ID is filled in (the equivalent of calling file-&gt;p...</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.cc:298</div></div>
<div class="ttc" id="structChunkPair_html_a03ebfbdc602a35ab0aa0d1b8adb6a53d"><div class="ttname"><a href="structChunkPair.html#a03ebfbdc602a35ab0aa0d1b8adb6a53d">ChunkPair::probe_chunk</a></div><div class="ttdeci">HashJoinChunk probe_chunk</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:46</div></div>
<div class="ttc" id="classHashJoinIterator_html_ae99844f9e2f3d07d0753cea4857bc1a2"><div class="ttname"><a href="classHashJoinIterator.html#ae99844f9e2f3d07d0753cea4857bc1a2">HashJoinIterator::m_tables_to_get_rowid_for</a></div><div class="ttdeci">const table_map m_tables_to_get_rowid_for</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:505</div></div>
<div class="ttc" id="classHashJoinIterator_html_a3a935b889b14ebd33bd7db7129632d08"><div class="ttname"><a href="classHashJoinIterator.html#a3a935b889b14ebd33bd7db7129632d08">HashJoinIterator::m_build_input_tables</a></div><div class="ttdeci">hash_join_buffer::TableCollection m_build_input_tables</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:504</div></div>
<div class="ttc" id="row__iterator_8h_html"><div class="ttname"><a href="row__iterator_8h.html">row_iterator.h</a></div></div>
<div class="ttc" id="mem__root__array_8h_html"><div class="ttname"><a href="mem__root__array_8h.html">mem_root_array.h</a></div></div>
<div class="ttc" id="classHashJoinIterator_html_a49d9cd2bd9f891a18d1e8570f8b77093"><div class="ttname"><a href="classHashJoinIterator.html#a49d9cd2bd9f891a18d1e8570f8b77093">HashJoinIterator::m_probe_row_saving_write_file</a></div><div class="ttdeci">HashJoinChunk m_probe_row_saving_write_file</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:601</div></div>
<div class="ttc" id="classPrealloced__array_html"><div class="ttname"><a href="classPrealloced__array.html">Prealloced_array&lt; HashJoinCondition, 4 &gt;</a></div></div>
<div class="ttc" id="classhash__join__buffer_1_1HashJoinRowBuffer_html_a20b896bb1e0a61c1a2b51dd0d7dc6276"><div class="ttname"><a href="classhash__join__buffer_1_1HashJoinRowBuffer.html#a20b896bb1e0a61c1a2b51dd0d7dc6276">hash_join_buffer::HashJoinRowBuffer::hash_map_iterator</a></div><div class="ttdeci">hash_map_type::const_iterator hash_map_iterator</div><div class="ttdef"><b>Definition:</b> hash_join_buffer.h:315</div></div>
<div class="ttc" id="hash__join__buffer_8h_html"><div class="ttname"><a href="hash__join__buffer_8h.html">hash_join_buffer.h</a></div><div class="ttdoc">This file contains the HashJoinRowBuffer class and related functions/classes. </div></div>
<div class="ttc" id="classHashJoinIterator_html_aabd92af6528c7c8fd54b2e91b165279b"><div class="ttname"><a href="classHashJoinIterator.html#aabd92af6528c7c8fd54b2e91b165279b">HashJoinIterator::RejectDuplicateKeys</a></div><div class="ttdeci">bool RejectDuplicateKeys() const</div><div class="ttdoc">If true, reject duplicate keys in the hash table. </div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:422</div></div>
<div class="ttc" id="classItem_html"><div class="ttname"><a href="classItem.html">Item</a></div><div class="ttdef"><b>Definition:</b> item.h:775</div></div>
<div class="ttc" id="hash_8c_html_ab4646d77540701d2eb2c877effbe5739"><div class="ttname"><a href="hash_8c.html#ab4646d77540701d2eb2c877effbe5739">final</a></div><div class="ttdeci">#define final(a, b, c)</div><div class="ttdef"><b>Definition:</b> hash.c:109</div></div>
<div class="ttc" id="classHashJoinIterator_html_a6a321906387244097e7249a3c320b8f2"><div class="ttname"><a href="classHashJoinIterator.html#a6a321906387244097e7249a3c320b8f2">HashJoinIterator::m_temporary_row_and_join_key_buffer</a></div><div class="ttdeci">String m_temporary_row_and_join_key_buffer</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:563</div></div>
<div class="ttc" id="structChunkPair_html_a5697ea7476720dc8b055ca20f4e52d19"><div class="ttname"><a href="structChunkPair.html#a5697ea7476720dc8b055ca20f4e52d19">ChunkPair::build_chunk</a></div><div class="ttdeci">HashJoinChunk build_chunk</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:47</div></div>
<div class="ttc" id="row__iterator_8h_html_aef400c43b34e3ecc3f7b342aa821395da26eaf1d67c3441d6af2af64e29094d63"><div class="ttname"><a href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395da26eaf1d67c3441d6af2af64e29094d63">JoinType::ANTI</a></div></div>
<div class="ttc" id="classhash__join__buffer_1_1HashJoinRowBuffer_html"><div class="ttname"><a href="classhash__join__buffer_1_1HashJoinRowBuffer.html">hash_join_buffer::HashJoinRowBuffer</a></div><div class="ttdef"><b>Definition:</b> hash_join_buffer.h:278</div></div>
<div class="ttc" id="classHashJoinIterator_html_ad1ddccf127599ec2857101d40d16c152"><div class="ttname"><a href="classHashJoinIterator.html#ad1ddccf127599ec2857101d40d16c152">HashJoinIterator::m_estimated_build_rows</a></div><div class="ttdeci">const double m_estimated_build_rows</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:540</div></div>
<div class="ttc" id="classMem__root__array_html"><div class="ttname"><a href="classMem__root__array.html">Mem_root_array</a></div><div class="ttdoc">A typesafe replacement for DYNAMIC_ARRAY. </div><div class="ttdef"><b>Definition:</b> mem_root_array.h:416</div></div>
<div class="ttc" id="classHashJoinIterator_html"><div class="ttname"><a href="classHashJoinIterator.html">HashJoinIterator</a></div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:249</div></div>
<div class="ttc" id="classQEP__TAB_html"><div class="ttname"><a href="classQEP__TAB.html">QEP_TAB</a></div><div class="ttdef"><b>Definition:</b> sql_executor.h:276</div></div>
<div class="ttc" id="classHashJoinIterator_html_a53027dd19d11a9f50115c80b9f2024e1"><div class="ttname"><a href="classHashJoinIterator.html#a53027dd19d11a9f50115c80b9f2024e1">HashJoinIterator::m_chunk_files_on_disk</a></div><div class="ttdeci">Mem_root_array&lt; ChunkPair &gt; m_chunk_files_on_disk</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:517</div></div>
<div class="ttc" id="classHashJoinIterator_html_a44e3734230ff2358d8fddf322750eb95"><div class="ttname"><a href="classHashJoinIterator.html#a44e3734230ff2358d8fddf322750eb95">HashJoinIterator::m_join_conditions</a></div><div class="ttdeci">Prealloced_array&lt; HashJoinCondition, 4 &gt; m_join_conditions</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:513</div></div>
<div class="ttc" id="my__alloc_8h_html_aefc3f0449dec4e54570dcfe7f33f23ba"><div class="ttname"><a href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a></div><div class="ttdeci">std::unique_ptr&lt; T, Destroy_only&lt; T &gt; &gt; unique_ptr_destroy_only</div><div class="ttdoc">std::unique_ptr, but only destroying. </div><div class="ttdef"><b>Definition:</b> my_alloc.h:409</div></div>
<div class="ttc" id="classHashJoinIterator_html_a74bcdbf9d941a8d2daa0764dc8dc2240"><div class="ttname"><a href="classHashJoinIterator.html#a74bcdbf9d941a8d2daa0764dc8dc2240">HashJoinIterator::m_state</a></div><div class="ttdeci">State m_state</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:489</div></div>
<div class="ttc" id="classHashJoinIterator_html_ae4a09cafcb3285668234707b90b996ed"><div class="ttname"><a href="classHashJoinIterator.html#ae4a09cafcb3285668234707b90b996ed">HashJoinIterator::on_disk_hash_join</a></div><div class="ttdeci">bool on_disk_hash_join() const</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:396</div></div>
<div class="ttc" id="classhash__join__buffer_1_1TableCollection_html"><div class="ttname"><a href="classhash__join__buffer_1_1TableCollection.html">hash_join_buffer::TableCollection</a></div><div class="ttdoc">A structure that contains a list of tables for the hash join operation, and some pre-computed propert...</div><div class="ttdef"><b>Definition:</b> hash_join_buffer.h:112</div></div>
<div class="ttc" id="classHashJoinIterator_html_a123a122fcb7cafa60c1a940c1826c0c8"><div class="ttname"><a href="classHashJoinIterator.html#a123a122fcb7cafa60c1a940c1826c0c8">HashJoinIterator::m_build_input</a></div><div class="ttdeci">const unique_ptr_destroy_only&lt; RowIterator &gt; m_build_input</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:491</div></div>
<div class="ttc" id="item__cmpfunc_8h_html"><div class="ttname"><a href="item__cmpfunc_8h.html">item_cmpfunc.h</a></div></div>
<div class="ttc" id="row__iterator_8h_html_aef400c43b34e3ecc3f7b342aa821395da69465caf22e5d212cbe4bbc87b1bf770"><div class="ttname"><a href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395da69465caf22e5d212cbe4bbc87b1bf770">JoinType::SEMI</a></div></div>
<div class="ttc" id="classHashJoinIterator_html_a95ea0a9e8e5352c5e67a59bff4bdae58"><div class="ttname"><a href="classHashJoinIterator.html#a95ea0a9e8e5352c5e67a59bff4bdae58">HashJoinIterator::HashJoinType</a></div><div class="ttdeci">HashJoinType</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:626</div></div>
<div class="ttc" id="classHashJoinIterator_html_ac62f2872e9725e23b7c539f7a47707f4"><div class="ttname"><a href="classHashJoinIterator.html#ac62f2872e9725e23b7c539f7a47707f4">HashJoinIterator::m_probe_row_saving_read_file</a></div><div class="ttdeci">HashJoinChunk m_probe_row_saving_read_file</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:602</div></div>
<div class="ttc" id="my__table__map_8h_html_a82b78abeba8cfb8e3df3e082f42b6cff"><div class="ttname"><a href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a></div><div class="ttdeci">uint64_t table_map</div><div class="ttdef"><b>Definition:</b> my_table_map.h:29</div></div>
<div class="ttc" id="sql_2table_8h_html"><div class="ttname"><a href="sql_2table_8h.html">table.h</a></div></div>
<div class="ttc" id="classHashJoinIterator_html_aede521acd60579e8b47bb66451915185"><div class="ttname"><a href="classHashJoinIterator.html#aede521acd60579e8b47bb66451915185">HashJoinIterator::m_row_buffer</a></div><div class="ttdeci">hash_join_buffer::HashJoinRowBuffer m_row_buffer</div><div class="ttdef"><b>Definition:</b> hash_join_iterator.h:510</div></div>
<div class="ttc" id="sql__opt__exec__shared_8h_html_a1aa258a4b1427766c283c1ae9ea81f05"><div class="ttname"><a href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a></div><div class="ttdeci">join_type</div><div class="ttdef"><b>Definition:</b> sql_opt_exec_shared.h:178</div></div>
<div class="ttc" id="my__base_8h_html_a8e16914016eb2acc5eefdbbcad5d9eb5"><div class="ttname"><a href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a></div><div class="ttdeci">my_off_t ha_rows</div><div class="ttdef"><b>Definition:</b> my_base.h:1136</div></div>
<div class="ttc" id="my__alloc_8h_html"><div class="ttname"><a href="my__alloc_8h.html">my_alloc.h</a></div><div class="ttdoc">This file follows Google coding style, except for the name MEM_ROOT (which is kept for historical rea...</div></div>
<div class="ttc" id="classTHD_html"><div class="ttname"><a href="classTHD.html">THD</a></div><div class="ttdoc">For each client connection we create a separate thread with THD serving as a thread/connection descri...</div><div class="ttdef"><b>Definition:</b> sql_class.h:803</div></div>
<div class="ttc" id="classHashJoinChunk_html"><div class="ttname"><a href="classHashJoinChunk.html">HashJoinChunk</a></div><div class="ttdef"><b>Definition:</b> hash_join_chunk.h:70</div></div>
<div class="ttc" id="ha__mock_8cc_html_a06a8aebe91dc89036b9f1ffe684e6c10"><div class="ttname"><a href="ha__mock_8cc.html#a06a8aebe91dc89036b9f1ffe684e6c10">Init</a></div><div class="ttdeci">static int Init(MYSQL_PLUGIN p)</div><div class="ttdef"><b>Definition:</b> ha_mock.cc:303</div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5bd71961b401a432086d0fb290a87f3f.html">sql</a></li><li class="navelem"><a class="el" href="hash__join__iterator_8h.html">hash_join_iterator.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
