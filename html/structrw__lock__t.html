<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: rw_lock_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structrw__lock__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structrw__lock__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rw_lock_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The structure used in the spin lock implementation of a read-write lock.  
 <a href="structrw__lock__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rw_lock_t:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structrw__lock__t.png" usemap="#rw_5Flock_5Ft_map" alt=""/>
  <map id="rw_5Flock_5Ft_map" name="rw_5Flock_5Ft_map">
<area href="structlatch__t.html" title="All (ordered) latches, used in debugging, must derive from this class. " alt="latch_t" shape="rect" coords="0,0,66,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2889a88f9c99ead5834f25647430a1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#aa2889a88f9c99ead5834f25647430a1c">rw_lock_t</a> ()=default</td></tr>
<tr class="separator:aa2889a88f9c99ead5834f25647430a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6c5f67a92cf908d6f086208de40efd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a8b6c5f67a92cf908d6f086208de40efd">rw_lock_t</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> &amp;)=delete</td></tr>
<tr class="memdesc:a8b6c5f67a92cf908d6f086208de40efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">rw_lock_t is not a copyable object, the reasoning behind this is the same as the reasoning behind why std::mutex is not copyable.  <a href="#a8b6c5f67a92cf908d6f086208de40efd">More...</a><br /></td></tr>
<tr class="separator:a8b6c5f67a92cf908d6f086208de40efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fbe28640e973114259840204da6b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a64fbe28640e973114259840204da6b8d">operator=</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> &amp;)=delete</td></tr>
<tr class="separator:a64fbe28640e973114259840204da6b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9707b2e08e20d7b496f7ddd5fdd1d6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#ad9707b2e08e20d7b496f7ddd5fdd1d6a">UT_LIST_NODE_T</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a>) <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">list</a></td></tr>
<tr class="memdesc:ad9707b2e08e20d7b496f7ddd5fdd1d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">All allocated rw locks are put into a list.  <a href="#ad9707b2e08e20d7b496f7ddd5fdd1d6a">More...</a><br /></td></tr>
<tr class="separator:ad9707b2e08e20d7b496f7ddd5fdd1d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bb140e65999223137034e53431f2d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#ac5bb140e65999223137034e53431f2d9">~rw_lock_t</a> () override</td></tr>
<tr class="memdesc:ac5bb140e65999223137034e53431f2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac5bb140e65999223137034e53431f2d9">More...</a><br /></td></tr>
<tr class="separator:ac5bb140e65999223137034e53431f2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab765265c74a0fa8db248b0079d768f7c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#ab765265c74a0fa8db248b0079d768f7c">to_string</a> () const override</td></tr>
<tr class="memdesc:ab765265c74a0fa8db248b0079d768f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the rw-lock information.  <a href="#ab765265c74a0fa8db248b0079d768f7c">More...</a><br /></td></tr>
<tr class="separator:ab765265c74a0fa8db248b0079d768f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3776b1287c2df4dd7f5a236c7e2dd676"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a3776b1287c2df4dd7f5a236c7e2dd676">locked_from</a> () const override</td></tr>
<tr class="memdesc:a3776b1287c2df4dd7f5a236c7e2dd676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print where it was locked from.  <a href="#a3776b1287c2df4dd7f5a236c7e2dd676">More...</a><br /></td></tr>
<tr class="separator:a3776b1287c2df4dd7f5a236c7e2dd676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3d4f6113fa66b7653162dfb13235ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a3b3d4f6113fa66b7653162dfb13235ed">UT_LIST_BASE_NODE_T</a> (<a class="el" href="structrw__lock__debug__t.html">rw_lock_debug_t</a>) debug_list</td></tr>
<tr class="memdesc:a3b3d4f6113fa66b7653162dfb13235ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the debug version: pointer to the debug info list of the lock.  <a href="#a3b3d4f6113fa66b7653162dfb13235ed">More...</a><br /></td></tr>
<tr class="separator:a3b3d4f6113fa66b7653162dfb13235ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structlatch__t"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structlatch__t')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structlatch__t.html">latch_t</a></td></tr>
<tr class="memitem:af2d6a410dd7b8be83c4b36b891d8dc85 inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#af2d6a410dd7b8be83c4b36b891d8dc85">latch_t</a> (<a class="el" href="sync0types_8h.html#a8441672e9204b0e9ae343d68861a3118">latch_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>=<a class="el" href="sync0types_8h.html#a8441672e9204b0e9ae343d68861a3118ac4db3d2061853796b31251c09c3d2b66">LATCH_ID_NONE</a>) 1</td></tr>
<tr class="memdesc:af2d6a410dd7b8be83c4b36b891d8dc85 inherit pub_methods_structlatch__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="structlatch__t.html#af2d6a410dd7b8be83c4b36b891d8dc85">More...</a><br /></td></tr>
<tr class="separator:af2d6a410dd7b8be83c4b36b891d8dc85 inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22cf2133d5745822dc5721b61ea370c inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlatch__t.html">latch_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#af22cf2133d5745822dc5721b61ea370c">operator=</a> (const <a class="el" href="structlatch__t.html">latch_t</a> &amp;)=default</td></tr>
<tr class="separator:af22cf2133d5745822dc5721b61ea370c inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87077ee92ccb107bd6f559d6dde5188 inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#ae87077ee92ccb107bd6f559d6dde5188">~latch_t</a> () 1</td></tr>
<tr class="memdesc:ae87077ee92ccb107bd6f559d6dde5188 inherit pub_methods_structlatch__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="structlatch__t.html#ae87077ee92ccb107bd6f559d6dde5188">More...</a><br /></td></tr>
<tr class="separator:ae87077ee92ccb107bd6f559d6dde5188 inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdab37000c1bf14e06d3b2ab606d14db inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sync0types_8h.html#a8441672e9204b0e9ae343d68861a3118">latch_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#acdab37000c1bf14e06d3b2ab606d14db">get_id</a> () const</td></tr>
<tr class="separator:acdab37000c1bf14e06d3b2ab606d14db inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18af86278e4cf37c3493dbfadd17ff52 inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#a18af86278e4cf37c3493dbfadd17ff52">is_rw_lock</a> () const 1</td></tr>
<tr class="separator:a18af86278e4cf37c3493dbfadd17ff52 inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6dcdfad2cc6674e0d8bdfdd0b15b31 inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89">latch_level_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#a0d6dcdfad2cc6674e0d8bdfdd0b15b31">get_level</a> () const 1</td></tr>
<tr class="separator:a0d6dcdfad2cc6674e0d8bdfdd0b15b31 inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab390d2fcdee79e345bba09965180c3ff inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#ab390d2fcdee79e345bba09965180c3ff">is_temp_fsp</a> () const 1</td></tr>
<tr class="separator:ab390d2fcdee79e345bba09965180c3ff inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382cd210364082e2f4bf1e7ee3d6e050 inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#a382cd210364082e2f4bf1e7ee3d6e050">set_temp_fsp</a> () 1</td></tr>
<tr class="memdesc:a382cd210364082e2f4bf1e7ee3d6e050 inherit pub_methods_structlatch__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the temporary tablespace flag.  <a href="structlatch__t.html#a382cd210364082e2f4bf1e7ee3d6e050">More...</a><br /></td></tr>
<tr class="separator:a382cd210364082e2f4bf1e7ee3d6e050 inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac412ef3661e129b045b906c928c6efb inherit pub_methods_structlatch__t"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#aac412ef3661e129b045b906c928c6efb">get_name</a> () const 1</td></tr>
<tr class="separator:aac412ef3661e129b045b906c928c6efb inherit pub_methods_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a27674049fdc48cf15e5f2cf6ed7297b8"><td class="memItemLeft" align="right" valign="top">volatile lint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a27674049fdc48cf15e5f2cf6ed7297b8">lock_word</a></td></tr>
<tr class="memdesc:a27674049fdc48cf15e5f2cf6ed7297b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the state of the lock.  <a href="#a27674049fdc48cf15e5f2cf6ed7297b8">More...</a><br /></td></tr>
<tr class="separator:a27674049fdc48cf15e5f2cf6ed7297b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13331c41c505a694820ef9a5103cf331"><td class="memItemLeft" align="right" valign="top">volatile ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a13331c41c505a694820ef9a5103cf331">waiters</a></td></tr>
<tr class="memdesc:a13331c41c505a694820ef9a5103cf331"><td class="mdescLeft">&#160;</td><td class="mdescRight">1: there are waiters  <a href="#a13331c41c505a694820ef9a5103cf331">More...</a><br /></td></tr>
<tr class="separator:a13331c41c505a694820ef9a5103cf331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfcc8cce28e3b1732ef4be8cfba7860"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#afcfcc8cce28e3b1732ef4be8cfba7860">recursive</a></td></tr>
<tr class="memdesc:afcfcc8cce28e3b1732ef4be8cfba7860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value FALSE which means the lock is non-recursive.  <a href="#afcfcc8cce28e3b1732ef4be8cfba7860">More...</a><br /></td></tr>
<tr class="separator:afcfcc8cce28e3b1732ef4be8cfba7860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784f70aedec3eaba4a5ed40ec41ea1b4"><td class="memItemLeft" align="right" valign="top">volatile ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a784f70aedec3eaba4a5ed40ec41ea1b4">sx_recursive</a></td></tr>
<tr class="memdesc:a784f70aedec3eaba4a5ed40ec41ea1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of granted SX locks.  <a href="#a784f70aedec3eaba4a5ed40ec41ea1b4">More...</a><br /></td></tr>
<tr class="separator:a784f70aedec3eaba4a5ed40ec41ea1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc48f3ad85e97d5096ab0b3223bab75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#adfc48f3ad85e97d5096ab0b3223bab75">writer_is_wait_ex</a></td></tr>
<tr class="memdesc:adfc48f3ad85e97d5096ab0b3223bab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is TRUE if the writer field is RW_LOCK_X_WAIT; this field is located far from the memory update hotspot fields which are at the start of this struct, thus we can peek this field without causing much memory bus traffic.  <a href="#adfc48f3ad85e97d5096ab0b3223bab75">More...</a><br /></td></tr>
<tr class="separator:adfc48f3ad85e97d5096ab0b3223bab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7343a5e0aa838bc7eaf40d96af8649b8"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="os0thread_8h.html#ab8ad022ed5dafb1f9defb66ac1b6a62a">os_thread_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a7343a5e0aa838bc7eaf40d96af8649b8">writer_thread</a></td></tr>
<tr class="memdesc:a7343a5e0aa838bc7eaf40d96af8649b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread id of writer thread.  <a href="#a7343a5e0aa838bc7eaf40d96af8649b8">More...</a><br /></td></tr>
<tr class="separator:a7343a5e0aa838bc7eaf40d96af8649b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa382fc2d173f94864e88057aaa15e09b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#aa382fc2d173f94864e88057aaa15e09b">event</a></td></tr>
<tr class="memdesc:aa382fc2d173f94864e88057aaa15e09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by sync0arr.cc for thread queueing.  <a href="#aa382fc2d173f94864e88057aaa15e09b">More...</a><br /></td></tr>
<tr class="separator:aa382fc2d173f94864e88057aaa15e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782d7ac356b97fee7edec4681dd22391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a782d7ac356b97fee7edec4681dd22391">wait_ex_event</a></td></tr>
<tr class="memdesc:a782d7ac356b97fee7edec4681dd22391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event for next-writer to wait on.  <a href="#a782d7ac356b97fee7edec4681dd22391">More...</a><br /></td></tr>
<tr class="separator:a782d7ac356b97fee7edec4681dd22391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e6a454de925915243d64a3d2ce0730"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a63e6a454de925915243d64a3d2ce0730">cfile_name</a></td></tr>
<tr class="memdesc:a63e6a454de925915243d64a3d2ce0730"><td class="mdescLeft">&#160;</td><td class="mdescRight">File name where lock created.  <a href="#a63e6a454de925915243d64a3d2ce0730">More...</a><br /></td></tr>
<tr class="separator:a63e6a454de925915243d64a3d2ce0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a498a7f33893e3c31d8147b1a9bd5f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a73a498a7f33893e3c31d8147b1a9bd5f">last_s_file_name</a></td></tr>
<tr class="memdesc:a73a498a7f33893e3c31d8147b1a9bd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">last s-lock file/line is not guaranteed to be correct  <a href="#a73a498a7f33893e3c31d8147b1a9bd5f">More...</a><br /></td></tr>
<tr class="separator:a73a498a7f33893e3c31d8147b1a9bd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa001b622f460caca77cd274f84a5c00"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#aaa001b622f460caca77cd274f84a5c00">last_x_file_name</a></td></tr>
<tr class="memdesc:aaa001b622f460caca77cd274f84a5c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">File name where last x-locked.  <a href="#aaa001b622f460caca77cd274f84a5c00">More...</a><br /></td></tr>
<tr class="separator:aaa001b622f460caca77cd274f84a5c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe5bdcaddb99c722fe45aea9a1cae40"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#abbe5bdcaddb99c722fe45aea9a1cae40">cline</a>: 13</td></tr>
<tr class="memdesc:abbe5bdcaddb99c722fe45aea9a1cae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line where created.  <a href="#abbe5bdcaddb99c722fe45aea9a1cae40">More...</a><br /></td></tr>
<tr class="separator:abbe5bdcaddb99c722fe45aea9a1cae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ce9ca4d19d518cdc57636fb205697f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a35ce9ca4d19d518cdc57636fb205697f">is_block_lock</a>: 1</td></tr>
<tr class="memdesc:a35ce9ca4d19d518cdc57636fb205697f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 1 then the rw-lock is a block lock.  <a href="#a35ce9ca4d19d518cdc57636fb205697f">More...</a><br /></td></tr>
<tr class="separator:a35ce9ca4d19d518cdc57636fb205697f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c8fb39c75f22fe02cf117fcbc5e1eb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#af1c8fb39c75f22fe02cf117fcbc5e1eb">last_s_line</a>: 14</td></tr>
<tr class="memdesc:af1c8fb39c75f22fe02cf117fcbc5e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line number where last time s-locked.  <a href="#af1c8fb39c75f22fe02cf117fcbc5e1eb">More...</a><br /></td></tr>
<tr class="separator:af1c8fb39c75f22fe02cf117fcbc5e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07965f511a71db9887f00ad223c593f4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a07965f511a71db9887f00ad223c593f4">last_x_line</a>: 14</td></tr>
<tr class="memdesc:a07965f511a71db9887f00ad223c593f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line number where last time x-locked.  <a href="#a07965f511a71db9887f00ad223c593f4">More...</a><br /></td></tr>
<tr class="separator:a07965f511a71db9887f00ad223c593f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c513115a9a789823867248a1df86ca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a83c513115a9a789823867248a1df86ca">count_os_wait</a></td></tr>
<tr class="memdesc:a83c513115a9a789823867248a1df86ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of os_waits.  <a href="#a83c513115a9a789823867248a1df86ca">More...</a><br /></td></tr>
<tr class="separator:a83c513115a9a789823867248a1df86ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced05bdef63646e45941e3a622fa5eb"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__psi__abi__rwlock.html#gaed6f27d4e7ccbaf85f850a72d6ac03c0">PSI_rwlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a9ced05bdef63646e45941e3a622fa5eb">pfs_psi</a></td></tr>
<tr class="memdesc:a9ced05bdef63646e45941e3a622fa5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The instrumentation hook.  <a href="#a9ced05bdef63646e45941e3a622fa5eb">More...</a><br /></td></tr>
<tr class="separator:a9ced05bdef63646e45941e3a622fa5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136a4534c654942c2d24bd1960fbddcb"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a136a4534c654942c2d24bd1960fbddcb">mutex</a></td></tr>
<tr class="memdesc:a136a4534c654942c2d24bd1960fbddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mutex protecting rw_lock_t.  <a href="#a136a4534c654942c2d24bd1960fbddcb">More...</a><br /></td></tr>
<tr class="separator:a136a4534c654942c2d24bd1960fbddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5827c1b958fcdfd06045a030cd4b466"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#ae5827c1b958fcdfd06045a030cd4b466">magic_n</a> = {<a class="el" href="structrw__lock__t.html#a344e0235524a8f0247c17010b528fc45">MAGIC_N</a>}</td></tr>
<tr class="separator:ae5827c1b958fcdfd06045a030cd4b466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadee20484063fc70052b786904a4189e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89">latch_level_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#aadee20484063fc70052b786904a4189e">level</a></td></tr>
<tr class="memdesc:aadee20484063fc70052b786904a4189e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level in the global latching order.  <a href="#aadee20484063fc70052b786904a4189e">More...</a><br /></td></tr>
<tr class="separator:aadee20484063fc70052b786904a4189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_structlatch__t"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_structlatch__t')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="structlatch__t.html">latch_t</a></td></tr>
<tr class="memitem:a1c76c13f8a9020414e5eb563959ac9cc inherit pub_attribs_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sync0types_8h.html#a8441672e9204b0e9ae343d68861a3118">latch_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#a1c76c13f8a9020414e5eb563959ac9cc">m_id</a></td></tr>
<tr class="memdesc:a1c76c13f8a9020414e5eb563959ac9cc inherit pub_attribs_structlatch__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latch ID.  <a href="structlatch__t.html#a1c76c13f8a9020414e5eb563959ac9cc">More...</a><br /></td></tr>
<tr class="separator:a1c76c13f8a9020414e5eb563959ac9cc inherit pub_attribs_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabfb847fb1ec82affff42f14f88f25b inherit pub_attribs_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#acabfb847fb1ec82affff42f14f88f25b">m_rw_lock</a></td></tr>
<tr class="memdesc:acabfb847fb1ec82affff42f14f88f25b inherit pub_attribs_structlatch__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if it is a rw-lock.  <a href="structlatch__t.html#acabfb847fb1ec82affff42f14f88f25b">More...</a><br /></td></tr>
<tr class="separator:acabfb847fb1ec82affff42f14f88f25b inherit pub_attribs_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9213b3a3403a6c0f2400a13ca7d7e5 inherit pub_attribs_structlatch__t"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlatch__t.html#a1a9213b3a3403a6c0f2400a13ca7d7e5">m_temp_fsp</a></td></tr>
<tr class="memdesc:a1a9213b3a3403a6c0f2400a13ca7d7e5 inherit pub_attribs_structlatch__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if it is an temporary space latch  <a href="structlatch__t.html#a1a9213b3a3403a6c0f2400a13ca7d7e5">More...</a><br /></td></tr>
<tr class="separator:a1a9213b3a3403a6c0f2400a13ca7d7e5 inherit pub_attribs_structlatch__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a344e0235524a8f0247c17010b528fc45"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a344e0235524a8f0247c17010b528fc45">MAGIC_N</a> = 22643</td></tr>
<tr class="memdesc:a344e0235524a8f0247c17010b528fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">For checking memory corruption.  <a href="#a344e0235524a8f0247c17010b528fc45">More...</a><br /></td></tr>
<tr class="separator:a344e0235524a8f0247c17010b528fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The structure used in the spin lock implementation of a read-write lock. </p>
<p>Several threads may have a shared lock simultaneously in this lock, but only one writer may have an exclusive lock, in which case no shared locks are allowed. To prevent starving of a writer blocked by readers, a writer may queue for x-lock by decrementing lock_word: no new readers will be let in while the thread waits for readers to exit. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa2889a88f9c99ead5834f25647430a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2889a88f9c99ead5834f25647430a1c">&#9670;&nbsp;</a></span>rw_lock_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rw_lock_t::rw_lock_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b6c5f67a92cf908d6f086208de40efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6c5f67a92cf908d6f086208de40efd">&#9670;&nbsp;</a></span>rw_lock_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rw_lock_t::rw_lock_t </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rw_lock_t is not a copyable object, the reasoning behind this is the same as the reasoning behind why std::mutex is not copyable. </p>
<p>It is supposed to represent a synchronization primitive for which copying semantics do not make sense. </p>

</div>
</div>
<a id="ac5bb140e65999223137034e53431f2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bb140e65999223137034e53431f2d9">&#9670;&nbsp;</a></span>~rw_lock_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rw_lock_t::~rw_lock_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3776b1287c2df4dd7f5a236c7e2dd676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3776b1287c2df4dd7f5a236c7e2dd676">&#9670;&nbsp;</a></span>locked_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string rw_lock_t::locked_from </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print where it was locked from. </p>
<dl class="section return"><dt>Returns</dt><dd>the string representation </dd></dl>

<p>Implements <a class="el" href="structlatch__t.html#ac70a7e33fb515e666c15633b2d10a186">latch_t</a>.</p>

</div>
</div>
<a id="a64fbe28640e973114259840204da6b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fbe28640e973114259840204da6b8d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>&amp; rw_lock_t::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab765265c74a0fa8db248b0079d768f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab765265c74a0fa8db248b0079d768f7c">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string rw_lock_t::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the rw-lock information. </p>
<dl class="section return"><dt>Returns</dt><dd>the string representation </dd></dl>

<p>Implements <a class="el" href="structlatch__t.html#ae03c22d3fd5419124300f53024e182ac">latch_t</a>.</p>

</div>
</div>
<a id="a3b3d4f6113fa66b7653162dfb13235ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3d4f6113fa66b7653162dfb13235ed">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rw_lock_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__debug__t.html">rw_lock_debug_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the debug version: pointer to the debug info list of the lock. </p>

</div>
</div>
<a id="ad9707b2e08e20d7b496f7ddd5fdd1d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9707b2e08e20d7b496f7ddd5fdd1d6a">&#9670;&nbsp;</a></span>UT_LIST_NODE_T()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rw_lock_t::UT_LIST_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All allocated rw locks are put into a list. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a63e6a454de925915243d64a3d2ce0730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e6a454de925915243d64a3d2ce0730">&#9670;&nbsp;</a></span>cfile_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rw_lock_t::cfile_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File name where lock created. </p>

</div>
</div>
<a id="abbe5bdcaddb99c722fe45aea9a1cae40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe5bdcaddb99c722fe45aea9a1cae40">&#9670;&nbsp;</a></span>cline</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rw_lock_t::cline</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Line where created. </p>

</div>
</div>
<a id="a83c513115a9a789823867248a1df86ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c513115a9a789823867248a1df86ca">&#9670;&nbsp;</a></span>count_os_wait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rw_lock_t::count_os_wait</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count of os_waits. </p>
<p>May not be accurate </p>

</div>
</div>
<a id="aa382fc2d173f94864e88057aaa15e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa382fc2d173f94864e88057aaa15e09b">&#9670;&nbsp;</a></span>event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> rw_lock_t::event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used by sync0arr.cc for thread queueing. </p>

</div>
</div>
<a id="a35ce9ca4d19d518cdc57636fb205697f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ce9ca4d19d518cdc57636fb205697f">&#9670;&nbsp;</a></span>is_block_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rw_lock_t::is_block_lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 1 then the rw-lock is a block lock. </p>

</div>
</div>
<a id="a73a498a7f33893e3c31d8147b1a9bd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a498a7f33893e3c31d8147b1a9bd5f">&#9670;&nbsp;</a></span>last_s_file_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rw_lock_t::last_s_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>last s-lock file/line is not guaranteed to be correct </p>

</div>
</div>
<a id="af1c8fb39c75f22fe02cf117fcbc5e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c8fb39c75f22fe02cf117fcbc5e1eb">&#9670;&nbsp;</a></span>last_s_line</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rw_lock_t::last_s_line</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Line number where last time s-locked. </p>

</div>
</div>
<a id="aaa001b622f460caca77cd274f84a5c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa001b622f460caca77cd274f84a5c00">&#9670;&nbsp;</a></span>last_x_file_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rw_lock_t::last_x_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File name where last x-locked. </p>

</div>
</div>
<a id="a07965f511a71db9887f00ad223c593f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07965f511a71db9887f00ad223c593f4">&#9670;&nbsp;</a></span>last_x_line</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rw_lock_t::last_x_line</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Line number where last time x-locked. </p>

</div>
</div>
<a id="aadee20484063fc70052b786904a4189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadee20484063fc70052b786904a4189e">&#9670;&nbsp;</a></span>level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sync0types_8h.html#a90b80adb6be14e0e67189518b5185e89">latch_level_t</a> rw_lock_t::level</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Level in the global latching order. </p>

</div>
</div>
<a id="a27674049fdc48cf15e5f2cf6ed7297b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27674049fdc48cf15e5f2cf6ed7297b8">&#9670;&nbsp;</a></span>lock_word</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile lint rw_lock_t::lock_word</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Holds the state of the lock. </p>

</div>
</div>
<a id="a344e0235524a8f0247c17010b528fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344e0235524a8f0247c17010b528fc45">&#9670;&nbsp;</a></span>MAGIC_N</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t rw_lock_t::MAGIC_N = 22643</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For checking memory corruption. </p>

</div>
</div>
<a id="ae5827c1b958fcdfd06045a030cd4b466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5827c1b958fcdfd06045a030cd4b466">&#9670;&nbsp;</a></span>magic_n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rw_lock_t::magic_n = {<a class="el" href="structrw__lock__t.html#a344e0235524a8f0247c17010b528fc45">MAGIC_N</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a136a4534c654942c2d24bd1960fbddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136a4534c654942c2d24bd1960fbddcb">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t rw_lock_t::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mutex protecting rw_lock_t. </p>

</div>
</div>
<a id="a9ced05bdef63646e45941e3a622fa5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ced05bdef63646e45941e3a622fa5eb">&#9670;&nbsp;</a></span>pfs_psi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__psi__abi__rwlock.html#gaed6f27d4e7ccbaf85f850a72d6ac03c0">PSI_rwlock</a>* rw_lock_t::pfs_psi</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The instrumentation hook. </p>

</div>
</div>
<a id="afcfcc8cce28e3b1732ef4be8cfba7860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfcc8cce28e3b1732ef4be8cfba7860">&#9670;&nbsp;</a></span>recursive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&gt; rw_lock_t::recursive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default value FALSE which means the lock is non-recursive. </p>
<p>The value is typically set to TRUE making normal rw_locks recursive. In case of asynchronous IO, when a non-zero value of 'pass' is passed then we keep the lock non-recursive.</p>
<p>This flag also tells us about the state of writer_thread field. If this flag is set then writer_thread MUST contain the thread id of the current x-holder or wait-x thread. This flag must be reset in x_unlock functions before incrementing the lock_word </p>

</div>
</div>
<a id="a784f70aedec3eaba4a5ed40ec41ea1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784f70aedec3eaba4a5ed40ec41ea1b4">&#9670;&nbsp;</a></span>sx_recursive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ulint rw_lock_t::sx_recursive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of granted SX locks. </p>

</div>
</div>
<a id="a782d7ac356b97fee7edec4681dd22391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782d7ac356b97fee7edec4681dd22391">&#9670;&nbsp;</a></span>wait_ex_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> rw_lock_t::wait_ex_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event for next-writer to wait on. </p>
<p>A thread must decrement lock_word before waiting. </p>

</div>
</div>
<a id="a13331c41c505a694820ef9a5103cf331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13331c41c505a694820ef9a5103cf331">&#9670;&nbsp;</a></span>waiters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ulint rw_lock_t::waiters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1: there are waiters </p>

</div>
</div>
<a id="adfc48f3ad85e97d5096ab0b3223bab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc48f3ad85e97d5096ab0b3223bab75">&#9670;&nbsp;</a></span>writer_is_wait_ex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> rw_lock_t::writer_is_wait_ex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is TRUE if the writer field is RW_LOCK_X_WAIT; this field is located far from the memory update hotspot fields which are at the start of this struct, thus we can peek this field without causing much memory bus traffic. </p>

</div>
</div>
<a id="a7343a5e0aa838bc7eaf40d96af8649b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7343a5e0aa838bc7eaf40d96af8649b8">&#9670;&nbsp;</a></span>writer_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="os0thread_8h.html#ab8ad022ed5dafb1f9defb66ac1b6a62a">os_thread_id_t</a>&gt; rw_lock_t::writer_thread</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread id of writer thread. </p>
<p>Is only guaranteed to have non-stale value if recursive flag is set, otherwise it may contain native thread handle of a thread which already released or passed the lock. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>storage/innobase/include/<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a></li>
<li>storage/innobase/sync/<a class="el" href="sync0rw_8cc.html">sync0rw.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structrw__lock__t.html">rw_lock_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
