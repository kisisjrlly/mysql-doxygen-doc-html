<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Innodb Lock-sys</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PAGE_INNODB_LOCK_SYS.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Innodb Lock-sys </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sect_lock_sys_introduction"></a>
Introduction</h1>
<p>The Lock-sys orchestrates access to tables and rows. Each table, and each row, can be thought of as a resource, and a transaction may request access right for a resource. As two transactions operating on a single resource can lead to problems if the two operations conflict with each other, each lock request also specifies the way the transaction intends to use it, by providing a <code>mode</code>. For example a LOCK_X mode, means that transaction needs exclusive access (presumably, it will modify the resource), and LOCK_S mode means that a transaction can share the resource with other transaction which also use LOCK_S mode. There are many different possible modes beside these two, and the logic of checking if given two modes are in conflict is a responsibility of the Lock-sys. A lock request, is called "a lock" for short. A lock can be WAITING or GRANTED.</p>
<p>So, a lock, conceptually is a tuple identifying:</p><ul>
<li>requesting transaction</li>
<li>resource (a particular row, a particular table)</li>
<li>mode (LOCK_X, LOCK_S,...)</li>
<li>state (WAITING or GRANTED)</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>In current implementation the "resource" and "mode" are not cleanly separated as for example LOCK_GAP and LOCK_REC_NOT_GAP are often called "modes" even though their semantic is to specify which "sub-resource" (the gap before the row, or the row itself) the transaction needs to access.</dd>
<dd>
The Lock-sys identifies records by their page_no (the identifier of the page which contains the record) and the heap_no (the position in page's internal array of allocated records), as opposed to table, index and primary key. This becomes important in case of B-tree merges, splits, or reallocation of variable- length records, all of which need to notify the Lock-sys to reflect the change.</dd></dl>
<p>Conceptually, the Lock-sys maintains a separate queue for each resource, thus one can analyze and reason about its operations in the scope of a single queue.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In practice, locks for gaps and rows are treated as belonging to the same queue. Moreover, to save space locks of a transaction which refer to several rows on the same page might be stored in a single data structure, and thus the physical queue corresponds to a whole page, and not to a single row. Also, each predicate lock (from GIS) is tied to a page, not a record. Finally, the lock queue is implemented by reusing chain links in the hash table, which means that pages with equal hash are held together in a single linked list for their hash bucket. Therefore care must be taken to filter the subset of locks which refer to a given resource when accessing these data structures.</dd></dl>
<p>The life cycle of a lock is usually as follows:</p>
<ol type="1">
<li>The transaction requests the lock, which can either be immediately GRANTED, or, in case of a conflict with an existing lock, goes to the WAITING state.</li>
<li>In case the lock is WAITING the thread (voluntarily) goes to sleep.</li>
<li>A WAITING lock either becomes GRANTED (once the conflicting transactions finished and it is our turn) or (in case of a rollback) it gets canceled.</li>
<li>Once the transaction is finishing (due to commit or rollback) it releases all of its locks.</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>For performance reasons, in Read Committed and weaker Isolation Levels there is also a Step in between 3 and 4 in which we release some of the read locks on gaps, which is done to minimize risk of deadlocks during replication.</dd></dl>
<p>When a lock is released (due to cancellation in Step 3, or clean up in Step 4), the Lock-sys inspects the corresponding lock queue to see if one or more of the WAITING locks in it can now be granted. If so, some locks become GRANTED and the Lock-sys signals their threads to wake up.</p>
<h1><a class="anchor" id="sect_lock_sys_scheduling"></a>
The scheduling algorithm</h1>
<p>We use a variant of the algorithm described in paper "Contention-Aware Lock
Scheduling for Transactional Databases" by Boyu Tian, Jiamin Huang, Barzan Mozafari and Grant Schoenebeck. The algorithm, "CATS" for short, analyzes the Wait-for graph, and assigns a weight to each WAITING transaction, equal to the number of transactions which it (transitively) blocks. The idea being that favoring heavy transactions will help to make more progress by helping more transactions to become eventually runnable.</p>
<p>The actual implementation of this theoretical idea is currently as follows.</p>
<ol type="1">
<li>Locks can be thought of being in 2 logical groups (Granted &amp; Waiting) maintained in the same queue.<ol type="a">
<li>Granted locks are added at the HEAD of the queue.</li>
<li>Waiting locks are added at the TAIL of the queue.</li>
</ol>
The queue looks like: <div class="fragment"><div class="line">                                           |</div><div class="line">Grows &lt;---- [HEAD] [G7 -- G3 -- G2 -- G1] -|- [W4 -- W5 -- W6] [TAIL] ---&gt; Grows</div><div class="line">                         Grant Group       |         Wait Group</div><div class="line"></div><div class="line">        G - Granted W - waiting,</div><div class="line">        suffix number is the chronological order of requests.</div></div><!-- fragment --> <dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>In the Wait Group the locks are in chronological order. We will not assert this invariant as there is no significance of the order (and hence the position) as the locks are re-ordered based on CATS weight while making a choice for grant, and CATS weights change constantly to reflect current shape of the Wait-for graph.</li>
<li>In the Grant Group the locks are in reverse chronological order. We will assert this invariant. CATS algorithm doesn't need it, but deadlock detection does, as explained further below.</li>
</ul>
</dd></dl>
</li>
<li>When a new lock request comes, we check for conflict with all (GRANTED and WAITING) locks already in the queue.<ol type="a">
<li>If there is a conflicting lock already in the queue, then the new lock request is put into WAITING state and appended at the TAIL. The transaction which requested the conflicting lock found is said to be the Blocking Transaction for the incoming transaction. As each transaction can have at most one WAITING lock, it also can have at most one Blocking Transaction, and thus we store the information about Blocking Transaction (if any) in the transaction object itself (as opposed to: separately for each lock request).</li>
<li>If there is no conflict, the request can be GRANTED, and lock is prepended at the HEAD.</li>
</ol>
</li>
<li>When we release a lock, locks which conflict with it need to be checked again if they can now be granted. Note that if there are multiple locks which could be granted, the order in which we decide to grant has an impact on who will have to wait: granting a lock to one transaction, can prevent another waiting transaction from being granted if their request conflict with each other. At the minimum, the Lock-sys must guarantee that a newly GRANTED lock, does not conflict with any other GRANTED lock. Therefore, we will specify the order in which the Lock-sys checks the WAITING locks one by one, and assume that such check involves checking if there is any conflict with already GRANTED locks - if so, the lock remains WAITING, we update the Blocking Transaction of the lock to be the newly identified conflicting transaction, and we check a next lock from the sorted list, otherwise, we grant it (and thus it is checked against in subsequent checks). The Lock-sys uses CATS weight for ordering: it favors transactions with highest CATS weight. Moreover, only the locks which point to the transaction currently releasing the lock as their Blocking Transaction participate as candidates for granting a lock.</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>For each WAITING lock the Blocking Transaction always points to a transaction which has a conflicting lock request, so if the Blocking Transaction is not the one which releases the lock right now, then we know that there is still at least one conflicting transaction. However, there is a subtle issue here: when we request a lock in point 2. we check for conflicts with both GRANTED and WAITING locks, while in point 3. we only check for conflicts with GRANTED locks. So, the Blocking Transaction might be a WAITING one identified in point 2., so we might be tempted to ignore it in point 3. Such "bypassing of waiters" is intentionally prevented to avoid starvation of a WAITING LOCK_X, by a steady stream of LOCK_S requests. Respecting the rule that a Blocking Transaction has to finish before a lock can be granted implies that at least one of WAITING LOCK_Xs will be granted before a LOCK_S can be granted.</dd>
<dd>
High Priority transactions in Wait Group are unconditionally kept ahead while sorting the wait queue. The HP is a concept related to Group Replication, and currently has nothing to do with CATS weight.</dd></dl>
<h2><a class="anchor" id="subsect_lock_sys_blocking"></a>
How do we choose the Blocking Transaction?</h2>
<p>It is done differently for new lock requests in point 2. and differently for old lock requests in point 3.</p>
<p>For new lock requests, we simply scan the whole queue in its natural order, and the first conflicting lock is chosen. In particular, a WAITING transaction can be chosen, if it is conflicting, and there are no GRATNED conflicting locks.</p>
<p>For old lock requests we scan only the Grant Group, and we do so in the chronological order, starting from the oldest lock requests [G1,G2,G3,G7] that is from the middle of the queue towards HEAD. In particular we also check against the locks which recently become GRANTED as they were processed before us in the sorting order, and we do so in a chronological order as well.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The idea here is that if we chose G1 as the Blocking Transaction and if there existed a dead lock with another conflicting transaction G3, the deadlock detection would not be postponed indefinitely while new GRANTED locks are added as they are going to be added to HEAD only. In other words: each of the conflicting locks in the Grant Group will eventually be set as the Blocking Transaction at some point in time, and thus it will become visible for the deadlock detection. If, by contrast, we were always picking the first one in the natural order, it might happen that we never get to assign G3 as the Blocking Transaction because new conflicting locks appear in front of the queue (and are released). That might lead to the deadlock with G3 never being noticed. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_STORAGE.html">Data Storage</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
