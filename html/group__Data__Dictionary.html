<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Data Dictionary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Data__Dictionary.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Data Dictionary</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__deadlock__handler.html">MDL_deadlock_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler which converts, if possible, ER_LOCK_DEADLOCK error that can occur when we are trying to acquire a metadata lock to a request for back-off and re-start of open_tables() process.  <a href="classMDL__deadlock__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFix__row__type__error__handler.html">Fix_row_type_error_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handler class for supressing HA_ERR_ROW_FORMAT_CHANGED errors from SE.  <a href="classFix__row__type__error__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__deadlock__discovery__repair__handler.html">MDL_deadlock_discovery_repair_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler to mark transaction to rollback on DEADLOCK error during DISCOVER / REPAIR.  <a href="classMDL__deadlock__discovery__repair__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTables__in__user__order__iterator.html">Tables_in_user_order_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an iterator which emits leaf TABLE_LIST nodes in an order suitable for expansion of 'table_name.  <a href="classTables__in__user__order__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9103f1fde040b45e171c6df146d812f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9103f1fde040b45e171c6df146d812f1">WRONG_GRANT</a>&#160;&#160;&#160;(<a class="el" href="classField.html">Field</a> *)-1</td></tr>
<tr class="separator:ga9103f1fde040b45e171c6df146d812f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3b7c6aa52a5b59656690aa16217d036e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga3b7c6aa52a5b59656690aa16217d036e">Table_definition_cache</a> = <a class="el" href="classmalloc__unordered__map.html">malloc_unordered_map</a>&lt; std::string, std::unique_ptr&lt; <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>, <a class="el" href="structTable__share__deleter.html">Table_share_deleter</a> &gt; &gt;</td></tr>
<tr class="separator:ga3b7c6aa52a5b59656690aa16217d036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab014a92f1538e370072fd987e2257a12"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab014a92f1538e370072fd987e2257a12">init_tdc_psi_keys</a> (void)</td></tr>
<tr class="memdesc:gab014a92f1538e370072fd987e2257a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize performance schema instrumentation points used by the table cache.  <a href="#gab014a92f1538e370072fd987e2257a12">More...</a><br /></td></tr>
<tr class="separator:gab014a92f1538e370072fd987e2257a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab721de91242bfd20abab6c96d7d766f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab721de91242bfd20abab6c96d7d766f8">check_and_update_table_version</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table_share)</td></tr>
<tr class="memdesc:gab721de91242bfd20abab6c96d7d766f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare metadata versions of an element obtained from the table definition cache and its corresponding node in the parse tree.  <a href="#gab721de91242bfd20abab6c96d7d766f8">More...</a><br /></td></tr>
<tr class="separator:gab721de91242bfd20abab6c96d7d766f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e75c08f95c113dd784ea916cea012a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9e75c08f95c113dd784ea916cea012a9">open_table_entry_fini</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *table, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>)</td></tr>
<tr class="memdesc:ga9e75c08f95c113dd784ea916cea012a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the process of TABLE creation by loading table triggers and taking action if a HEAP table content was emptied implicitly.  <a href="#ga9e75c08f95c113dd784ea916cea012a9">More...</a><br /></td></tr>
<tr class="separator:ga9e75c08f95c113dd784ea916cea012a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ee1005814f445715e7c0ef76cfaa45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaa0ee1005814f445715e7c0ef76cfaa45">auto_repair_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="memdesc:gaa0ee1005814f445715e7c0ef76cfaa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary routine which is used for performing automatical table repair.  <a href="#gaa0ee1005814f445715e7c0ef76cfaa45">More...</a><br /></td></tr>
<tr class="separator:gaa0ee1005814f445715e7c0ef76cfaa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9577a1bd28172eb346ef13e464328e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gabd9577a1bd28172eb346ef13e464328e">find_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *table_key, size_t table_key_length)</td></tr>
<tr class="memdesc:gabd9577a1bd28172eb346ef13e464328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a temporary table specified by a key in the THD::temporary_tables list.  <a href="#gabd9577a1bd28172eb346ef13e464328e">More...</a><br /></td></tr>
<tr class="separator:gabd9577a1bd28172eb346ef13e464328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa566184d7e951dc20b5c2548023f4817"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaa566184d7e951dc20b5c2548023f4817">tdc_open_view</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *cache_key, size_t cache_key_length)</td></tr>
<tr class="memdesc:gaa566184d7e951dc20b5c2548023f4817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open view by getting its definition from disk (and table cache in future).  <a href="#gaa566184d7e951dc20b5c2548023f4817">More...</a><br /></td></tr>
<tr class="separator:gaa566184d7e951dc20b5c2548023f4817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7494505ae9ba0f97d266a5fd6b258d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gafa7494505ae9ba0f97d266a5fd6b258d">add_view_place_holder</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="memdesc:gafa7494505ae9ba0f97d266a5fd6b258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a dummy LEX object for a view.  <a href="#gafa7494505ae9ba0f97d266a5fd6b258d">More...</a><br /></td></tr>
<tr class="separator:gafa7494505ae9ba0f97d266a5fd6b258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa191bd24f43a69fa5d4f135c68a2b8c6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaa191bd24f43a69fa5d4f135c68a2b8c6">create_table_def_key</a> (const char *db_name, const char *table_name, char *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:gaa191bd24f43a69fa5d4f135c68a2b8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table cache/table definition cache key for a table.  <a href="#gaa191bd24f43a69fa5d4f135c68a2b8c6">More...</a><br /></td></tr>
<tr class="separator:gaa191bd24f43a69fa5d4f135c68a2b8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef12ee9072d2159d93b2c549df409a62"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaef12ee9072d2159d93b2c549df409a62">create_table_def_key_tmp</a> (const <a class="el" href="classTHD.html">THD</a> *thd, const char *db_name, const char *table_name, char *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:gaef12ee9072d2159d93b2c549df409a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table cache/table definition cache key for a temporary table.  <a href="#gaef12ee9072d2159d93b2c549df409a62">More...</a><br /></td></tr>
<tr class="separator:gaef12ee9072d2159d93b2c549df409a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a44b976efc63423f6993c14d5ea61cd"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga6a44b976efc63423f6993c14d5ea61cd">create_table_def_key_secondary</a> (const char *db_name, const char *table_name)</td></tr>
<tr class="memdesc:ga6a44b976efc63423f6993c14d5ea61cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table cache/table definition cache key for a table in a secondary storage engine.  <a href="#ga6a44b976efc63423f6993c14d5ea61cd">More...</a><br /></td></tr>
<tr class="separator:ga6a44b976efc63423f6993c14d5ea61cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14224b18bb5f7e175fde6932a590defa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga14224b18bb5f7e175fde6932a590defa">get_table_def_key</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char **<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>)</td></tr>
<tr class="memdesc:ga14224b18bb5f7e175fde6932a590defa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get table cache key for a table list element.  <a href="#ga14224b18bb5f7e175fde6932a590defa">More...</a><br /></td></tr>
<tr class="separator:ga14224b18bb5f7e175fde6932a590defa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f57ec544a178c11c18d6900e2dcf6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gad9f57ec544a178c11c18d6900e2dcf6c">table_def_init</a> (void)</td></tr>
<tr class="separator:gad9f57ec544a178c11c18d6900e2dcf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb94e7a0682741b06d662be41fae480f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gabb94e7a0682741b06d662be41fae480f">table_def_start_shutdown</a> (void)</td></tr>
<tr class="memdesc:gabb94e7a0682741b06d662be41fae480f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify table definition cache that process of shutting down server has started so it has to keep number of TABLE and TABLE_SHARE objects minimal in order to reduce number of references to pluggable engines.  <a href="#gabb94e7a0682741b06d662be41fae480f">More...</a><br /></td></tr>
<tr class="separator:gabb94e7a0682741b06d662be41fae480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b09d5446051abdac04bf96a4d6a0c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8b09d5446051abdac04bf96a4d6a0c12">table_def_free</a> (void)</td></tr>
<tr class="separator:ga8b09d5446051abdac04bf96a4d6a0c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb76a30ed423c4cb98689fcedae48c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gabb76a30ed423c4cb98689fcedae48c60">cached_table_definitions</a> (void)</td></tr>
<tr class="separator:gabb76a30ed423c4cb98689fcedae48c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d20bdc45dfafc1da5d10d03b6ce9b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae0d20bdc45dfafc1da5d10d03b6ce9b7">process_found_table_share</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_view)</td></tr>
<tr class="separator:gae0d20bdc45dfafc1da5d10d03b6ce9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec778106e0e06da7a389939084452ff7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaec778106e0e06da7a389939084452ff7">read_histograms</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, const <a class="el" href="classdd_1_1Schema.html">dd::Schema</a> *schema, const <a class="el" href="classdd_1_1Abstract__table.html">dd::Abstract_table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:gaec778106e0e06da7a389939084452ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any existing histogram statistics from the data dictionary and store a copy of them in the TABLE_SHARE.  <a href="#gaec778106e0e06da7a389939084452ff7">More...</a><br /></td></tr>
<tr class="separator:gaec778106e0e06da7a389939084452ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab27cdf8db464ef0409b68730da644e32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab27cdf8db464ef0409b68730da644e32">update_schema_options</a> (const <a class="el" href="classdd_1_1Schema.html">dd::Schema</a> *sch_obj, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="memdesc:gab27cdf8db464ef0409b68730da644e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update TABLE_SHARE with options from dd::Schema object.  <a href="#gab27cdf8db464ef0409b68730da644e32">More...</a><br /></td></tr>
<tr class="separator:gab27cdf8db464ef0409b68730da644e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785c560f809f5dbb644f3f1190d905f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga785c560f809f5dbb644f3f1190d905f1">get_table_share</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db, const char *table_name, const char *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, size_t <a class="el" href="mi__test1_8cc.html#ae8c61f1c9b2c2ce361a5ea70ad97b577">key_length</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_view, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_secondary)</td></tr>
<tr class="memdesc:ga785c560f809f5dbb644f3f1190d905f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TABLE_SHARE for a table.  <a href="#ga785c560f809f5dbb644f3f1190d905f1">More...</a><br /></td></tr>
<tr class="separator:ga785c560f809f5dbb644f3f1190d905f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d2ac38799538eae4c4050765bb71c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga86d2ac38799538eae4c4050765bb71c0">get_table_share_with_discover</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, size_t <a class="el" href="mi__test1_8cc.html#ae8c61f1c9b2c2ce361a5ea70ad97b577">key_length</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_secondary, int *error)</td></tr>
<tr class="memdesc:ga86d2ac38799538eae4c4050765bb71c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a table share.  <a href="#ga86d2ac38799538eae4c4050765bb71c0">More...</a><br /></td></tr>
<tr class="separator:ga86d2ac38799538eae4c4050765bb71c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f27eb7444d2cec48296785a54e229f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0f27eb7444d2cec48296785a54e229f2">release_table_share</a> (<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="memdesc:ga0f27eb7444d2cec48296785a54e229f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that we are not using table share anymore.  <a href="#ga0f27eb7444d2cec48296785a54e229f2">More...</a><br /></td></tr>
<tr class="separator:ga0f27eb7444d2cec48296785a54e229f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da69eeda10a9b209a7daccf71afeb48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0da69eeda10a9b209a7daccf71afeb48">get_cached_table_share</a> (const char *db, const char *table_name)</td></tr>
<tr class="memdesc:ga0da69eeda10a9b209a7daccf71afeb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an existing table definition from the table definition cache.  <a href="#ga0da69eeda10a9b209a7daccf71afeb48">More...</a><br /></td></tr>
<tr class="separator:ga0da69eeda10a9b209a7daccf71afeb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b0693677aeecf9a38e98f36d3d31eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structOPEN__TABLE__LIST.html">OPEN_TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga54b0693677aeecf9a38e98f36d3d31eb">list_open_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db, const char *wild)</td></tr>
<tr class="separator:ga54b0693677aeecf9a38e98f36d3d31eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2849c2d4c8cec7a89054e0033a8707"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaff2849c2d4c8cec7a89054e0033a8707">intern_close_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:gaff2849c2d4c8cec7a89054e0033a8707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga055df8e4470e8dfd7f8b41f4402f6774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga055df8e4470e8dfd7f8b41f4402f6774">free_io_cache</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga055df8e4470e8dfd7f8b41f4402f6774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8504b9f30ae84e60749639a2d03bc0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8504b9f30ae84e60749639a2d03bc0d0">close_cached_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> wait_for_refresh, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> timeout)</td></tr>
<tr class="separator:ga8504b9f30ae84e60749639a2d03bc0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec5ae1a68fd60a81532c4560500e318"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga7ec5ae1a68fd60a81532c4560500e318">mark_temp_tables_as_free_for_reuse</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga7ec5ae1a68fd60a81532c4560500e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all temporary tables which were used by the current statement or substatement as free for reuse, but only if the query_id can be cleared.  <a href="#ga7ec5ae1a68fd60a81532c4560500e318">More...</a><br /></td></tr>
<tr class="separator:ga7ec5ae1a68fd60a81532c4560500e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cc536b80faf27a1017cf4ddcc988ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae2cc536b80faf27a1017cf4ddcc988ad">mark_tmp_table_for_reuse</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:gae2cc536b80faf27a1017cf4ddcc988ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a single temporary table.  <a href="#gae2cc536b80faf27a1017cf4ddcc988ad">More...</a><br /></td></tr>
<tr class="separator:gae2cc536b80faf27a1017cf4ddcc988ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1466eeeedbb2386ac9d5f9950a0cbcd8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga1466eeeedbb2386ac9d5f9950a0cbcd8">mark_used_tables_as_free_for_reuse</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga1466eeeedbb2386ac9d5f9950a0cbcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889e504f17316df5db4d2a980b025398"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga889e504f17316df5db4d2a980b025398">close_open_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga889e504f17316df5db4d2a980b025398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to close all tables in the open_tables list.  <a href="#ga889e504f17316df5db4d2a980b025398">More...</a><br /></td></tr>
<tr class="separator:ga889e504f17316df5db4d2a980b025398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga207faca14a1dbfdf182503ade0e3ce81"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga207faca14a1dbfdf182503ade0e3ce81">close_all_tables_for_name</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, size_t <a class="el" href="mi__test1_8cc.html#ae8c61f1c9b2c2ce361a5ea70ad97b577">key_length</a>, const char *db, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> remove_from_locked_tables, <a class="el" href="structTABLE.html">TABLE</a> *skip_table)</td></tr>
<tr class="memdesc:ga207faca14a1dbfdf182503ade0e3ce81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all open instances of the table but keep the MDL lock.  <a href="#ga207faca14a1dbfdf182503ade0e3ce81">More...</a><br /></td></tr>
<tr class="separator:ga207faca14a1dbfdf182503ade0e3ce81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86713fadf907edf57606406a10c1f994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga86713fadf907edf57606406a10c1f994">close_all_tables_for_name</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> remove_from_locked_tables, <a class="el" href="structTABLE.html">TABLE</a> *skip_table)</td></tr>
<tr class="memdesc:ga86713fadf907edf57606406a10c1f994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all open instances of the table but keep the MDL lock.  <a href="#ga86713fadf907edf57606406a10c1f994">More...</a><br /></td></tr>
<tr class="separator:ga86713fadf907edf57606406a10c1f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fc55840b97b62f5a5c0a51fec0bb7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga60fc55840b97b62f5a5c0a51fec0bb7b">close_all_tables_for_name</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> remove_from_locked_tables)</td></tr>
<tr class="memdesc:ga60fc55840b97b62f5a5c0a51fec0bb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all open instances of the table but keep the MDL lock.  <a href="#ga60fc55840b97b62f5a5c0a51fec0bb7b">More...</a><br /></td></tr>
<tr class="separator:ga60fc55840b97b62f5a5c0a51fec0bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4988d6e5a588b697a9614d35e67a43b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaf4988d6e5a588b697a9614d35e67a43b">in_LTM</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="separator:gaf4988d6e5a588b697a9614d35e67a43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7bb43d2603048aff8a2ca95b9ba714"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5b7bb43d2603048aff8a2ca95b9ba714">belongs_to_dd_table</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:ga5b7bb43d2603048aff8a2ca95b9ba714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given TABLE_LIST belongs to a DD table.  <a href="#ga5b7bb43d2603048aff8a2ca95b9ba714">More...</a><br /></td></tr>
<tr class="separator:ga5b7bb43d2603048aff8a2ca95b9ba714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ded5accefd985fce6ed115038ea92f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga3ded5accefd985fce6ed115038ea92f7">close_thread_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga3ded5accefd985fce6ed115038ea92f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all tables used by the current substatement, or all tables used by this thread if we are on the outer-most level.  <a href="#ga3ded5accefd985fce6ed115038ea92f7">More...</a><br /></td></tr>
<tr class="separator:ga3ded5accefd985fce6ed115038ea92f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab092f047cc15a6e99a876f56ab738390"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab092f047cc15a6e99a876f56ab738390">release_or_close_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:gab092f047cc15a6e99a876f56ab738390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function which returns TABLE to Table Cache or closes if table is marked as needing re-open.  <a href="#gab092f047cc15a6e99a876f56ab738390">More...</a><br /></td></tr>
<tr class="separator:gab092f047cc15a6e99a876f56ab738390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52b8d7410875b0048421f9386b4b6bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac52b8d7410875b0048421f9386b4b6bd">close_thread_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> **table_ptr)</td></tr>
<tr class="separator:gac52b8d7410875b0048421f9386b4b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa843875426f66cde0829e5d8d6dd546"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaaa843875426f66cde0829e5d8d6dd546">tmpkeyval</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:gaaa843875426f66cde0829e5d8d6dd546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4991367acddcb2b2a0edeb169029917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaa4991367acddcb2b2a0edeb169029917">close_temporary_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="separator:gaa4991367acddcb2b2a0edeb169029917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6949d4bdcb266c5fd678cab14928c73d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga6949d4bdcb266c5fd678cab14928c73d">find_table_in_global_list</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, const char *db_name, const char *table_name)</td></tr>
<tr class="memdesc:ga6949d4bdcb266c5fd678cab14928c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find table in global list.  <a href="#ga6949d4bdcb266c5fd678cab14928c73d">More...</a><br /></td></tr>
<tr class="separator:ga6949d4bdcb266c5fd678cab14928c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae739cd1eae234e4c3abac511af639692"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae739cd1eae234e4c3abac511af639692">find_dup_table</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_alias)</td></tr>
<tr class="memdesc:gae739cd1eae234e4c3abac511af639692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that table is unique (It's only exists once in the table list)  <a href="#gae739cd1eae234e4c3abac511af639692">More...</a><br /></td></tr>
<tr class="separator:gae739cd1eae234e4c3abac511af639692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2ea646b8928d2d6fabd5e114751547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga2d2ea646b8928d2d6fabd5e114751547">unique_table</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_alias)</td></tr>
<tr class="memdesc:ga2d2ea646b8928d2d6fabd5e114751547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the subject table of INSERT/UPDATE/DELETE/CREATE or (in case of MyISAMMRG) one of its children are not used later in the query.  <a href="#ga2d2ea646b8928d2d6fabd5e114751547">More...</a><br /></td></tr>
<tr class="separator:ga2d2ea646b8928d2d6fabd5e114751547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62ea49fa4b58a38f20af4754928e1be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaa62ea49fa4b58a38f20af4754928e1be">update_non_unique_table_error</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, const char *operation, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *duplicate)</td></tr>
<tr class="memdesc:gaa62ea49fa4b58a38f20af4754928e1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue correct error message in case we found 2 duplicate tables which prevent some update operation.  <a href="#gaa62ea49fa4b58a38f20af4754928e1be">More...</a><br /></td></tr>
<tr class="separator:gaa62ea49fa4b58a38f20af4754928e1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0734400e8b6f0dab464f0da0f177086b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0734400e8b6f0dab464f0da0f177086b">find_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db, const char *table_name)</td></tr>
<tr class="memdesc:ga0734400e8b6f0dab464f0da0f177086b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find temporary table specified by database and table names in the THD::temporary_tables list.  <a href="#ga0734400e8b6f0dab464f0da0f177086b">More...</a><br /></td></tr>
<tr class="separator:ga0734400e8b6f0dab464f0da0f177086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d31aeecf54e9bf14d05fa8a6478b7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4d31aeecf54e9bf14d05fa8a6478b7e0">find_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:ga4d31aeecf54e9bf14d05fa8a6478b7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a temporary table specified by TABLE_LIST instance in the THD::temporary_tables list.  <a href="#ga4d31aeecf54e9bf14d05fa8a6478b7e0">More...</a><br /></td></tr>
<tr class="separator:ga4d31aeecf54e9bf14d05fa8a6478b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70df85ebdb0080a97f7233ae8d269d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga70df85ebdb0080a97f7233ae8d269d0e">drop_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="memdesc:ga70df85ebdb0080a97f7233ae8d269d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a temporary table.  <a href="#ga70df85ebdb0080a97f7233ae8d269d0e">More...</a><br /></td></tr>
<tr class="separator:ga70df85ebdb0080a97f7233ae8d269d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f62c19b7f434d061bee6a75402aca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga62f62c19b7f434d061bee6a75402aca1">close_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="ha__innodb_8cc.html#acb549c4785c91921c339ba3f5180186b">free_share</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> delete_table)</td></tr>
<tr class="separator:ga62f62c19b7f434d061bee6a75402aca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a85ac16e4b359599ef5a21f923261e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga37a85ac16e4b359599ef5a21f923261e">close_temporary</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="ha__innodb_8cc.html#acb549c4785c91921c339ba3f5180186b">free_share</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> delete_table)</td></tr>
<tr class="separator:ga37a85ac16e4b359599ef5a21f923261e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f79c4227effeafa7bad8b4582682e9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga1f79c4227effeafa7bad8b4582682e9a">rename_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const char *db, const char *table_name)</td></tr>
<tr class="separator:ga1f79c4227effeafa7bad8b4582682e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19a8c14e089f35b82dc7a2ded67ea4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac19a8c14e089f35b82dc7a2ded67ea4b">wait_while_table_is_used</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a> function)</td></tr>
<tr class="memdesc:gac19a8c14e089f35b82dc7a2ded67ea4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force all other threads to stop using the table by upgrading metadata lock on it and remove unused TABLE instances from cache.  <a href="#gac19a8c14e089f35b82dc7a2ded67ea4b">More...</a><br /></td></tr>
<tr class="separator:gac19a8c14e089f35b82dc7a2ded67ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5afba64853740882233ea3fd3cff08ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5afba64853740882233ea3fd3cff08ff">check_if_table_exists</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *<a class="el" href="node__list_8cc.html#a2a69ef21c288de06dce6727ceb310909">exists</a>)</td></tr>
<tr class="memdesc:ga5afba64853740882233ea3fd3cff08ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that table exists in data-dictionary or in some storage engine.  <a href="#ga5afba64853740882233ea3fd3cff08ff">More...</a><br /></td></tr>
<tr class="separator:ga5afba64853740882233ea3fd3cff08ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220a2fbe9ad9cf09296fb29aaa06e537"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga220a2fbe9ad9cf09296fb29aaa06e537">open_table_get_mdl_lock</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classOpen__table__context.html">Open_table_context</a> *ot_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classMDL__ticket.html">MDL_ticket</a> **mdl_ticket)</td></tr>
<tr class="memdesc:ga220a2fbe9ad9cf09296fb29aaa06e537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to acquire an MDL lock for a table being opened.  <a href="#ga220a2fbe9ad9cf09296fb29aaa06e537">More...</a><br /></td></tr>
<tr class="separator:ga220a2fbe9ad9cf09296fb29aaa06e537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2ecba52b01f35d1ad6aa39d4ce15e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gafa2ecba52b01f35d1ad6aa39d4ce15e8">tdc_wait_for_old_version</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db, const char *table_name, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> wait_timeout, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> deadlock_weight)</td></tr>
<tr class="memdesc:gafa2ecba52b01f35d1ad6aa39d4ce15e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if table's share is being removed from the table definition cache and, if yes, wait until the flush is complete.  <a href="#gafa2ecba52b01f35d1ad6aa39d4ce15e8">More...</a><br /></td></tr>
<tr class="separator:gafa2ecba52b01f35d1ad6aa39d4ce15e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cb5a9ba1064a36db89ad5c4d645528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="classOpen__table__context.html">Open_table_context</a> *ot_ctx)</td></tr>
<tr class="memdesc:ga43cb5a9ba1064a36db89ad5c4d645528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a base table.  <a href="#ga43cb5a9ba1064a36db89ad5c4d645528">More...</a><br /></td></tr>
<tr class="separator:ga43cb5a9ba1064a36db89ad5c4d645528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4458592b1c4d9ed293e5b2033349c3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4458592b1c4d9ed293e5b2033349c3fb">find_locked_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">list</a>, const char *db, const char *table_name)</td></tr>
<tr class="memdesc:ga4458592b1c4d9ed293e5b2033349c3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find table in the list of open tables.  <a href="#ga4458592b1c4d9ed293e5b2033349c3fb">More...</a><br /></td></tr>
<tr class="separator:ga4458592b1c4d9ed293e5b2033349c3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8692f5ebd7f6483f1dcc576eb2346f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8692f5ebd7f6483f1dcc576eb2346f52">find_table_for_mdl_upgrade</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *db, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> no_error)</td></tr>
<tr class="memdesc:ga8692f5ebd7f6483f1dcc576eb2346f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find instance of TABLE with upgradable or exclusive metadata lock from the list of open tables, emit error if no such table found.  <a href="#ga8692f5ebd7f6483f1dcc576eb2346f52">More...</a><br /></td></tr>
<tr class="separator:ga8692f5ebd7f6483f1dcc576eb2346f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098cb47bbc8bbdb790fcf28c253ab2b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga098cb47bbc8bbdb790fcf28c253ab2b6">assign_new_table_id</a> (<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:ga098cb47bbc8bbdb790fcf28c253ab2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6d716c2b2fbaec9eb41e9e18c9bef3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0d6d716c2b2fbaec9eb41e9e18c9bef3">check_and_update_routine_version</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp)</td></tr>
<tr class="memdesc:ga0d6d716c2b2fbaec9eb41e9e18c9bef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares versions of a stored routine obtained from the sp cache and the version used at prepare.  <a href="#ga0d6d716c2b2fbaec9eb41e9e18c9bef3">More...</a><br /></td></tr>
<tr class="separator:ga0d6d716c2b2fbaec9eb41e9e18c9bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0cd1dd224a3bb2c450ba3568dd9398"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga1d0cd1dd224a3bb2c450ba3568dd9398">fix_row_type</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="memdesc:ga1d0cd1dd224a3bb2c450ba3568dd9398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary routine for automatically updating row format for the table.  <a href="#ga1d0cd1dd224a3bb2c450ba3568dd9398">More...</a><br /></td></tr>
<tr class="separator:ga1d0cd1dd224a3bb2c450ba3568dd9398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fe4cc1a004bb6b5f07556a182f945b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga24fe4cc1a004bb6b5f07556a182f945b">read_lock_type_for_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> routine_modifies_data)</td></tr>
<tr class="separator:ga24fe4cc1a004bb6b5f07556a182f945b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga507062befa21005f1f5029af0f332c45"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga507062befa21005f1f5029af0f332c45">process_table_fks</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_insert, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_update, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_delete, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *belong_to_view, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking)</td></tr>
<tr class="memdesc:ga507062befa21005f1f5029af0f332c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process table's foreign keys (if any) by prelocking algorithm.  <a href="#ga507062befa21005f1f5029af0f332c45">More...</a><br /></td></tr>
<tr class="separator:ga507062befa21005f1f5029af0f332c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ccfe40b5eb69eade8b02ded8236a8e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae6ccfe40b5eb69eade8b02ded8236a8e">open_and_process_routine</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> has_prelocking_list, <a class="el" href="classOpen__table__context.html">Open_table_context</a> *ot_ctx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *routine_modifies_data)</td></tr>
<tr class="memdesc:gae6ccfe40b5eb69eade8b02ded8236a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle element of prelocking set other than table.  <a href="#gae6ccfe40b5eb69eade8b02ded8236a8e">More...</a><br /></td></tr>
<tr class="separator:gae6ccfe40b5eb69eade8b02ded8236a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bde544f5ea99298b67e368da5dd9ca9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga6bde544f5ea99298b67e368da5dd9ca9">open_and_process_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structLEX.html">LEX</a> *lex, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *const tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> has_prelocking_list, <a class="el" href="classOpen__table__context.html">Open_table_context</a> *ot_ctx)</td></tr>
<tr class="memdesc:ga6bde544f5ea99298b67e368da5dd9ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle table list element by obtaining metadata lock, opening table or view and, if prelocking strategy prescribes so, extending the prelocking set with tables and routines used by it.  <a href="#ga6bde544f5ea99298b67e368da5dd9ca9">More...</a><br /></td></tr>
<tr class="separator:ga6bde544f5ea99298b67e368da5dd9ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed504cf321c7fd98175f80785f6be954"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaed504cf321c7fd98175f80785f6be954">run_before_dml_hook</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gaed504cf321c7fd98175f80785f6be954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the server hook called "before_dml".  <a href="#gaed504cf321c7fd98175f80785f6be954">More...</a><br /></td></tr>
<tr class="separator:gaed504cf321c7fd98175f80785f6be954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747bf44763db37285677c195ca412245"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga747bf44763db37285677c195ca412245">is_temporary_table_being_opened</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table)</td></tr>
<tr class="memdesc:ga747bf44763db37285677c195ca412245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a table being opened is a temporary table.  <a href="#ga747bf44763db37285677c195ca412245">More...</a><br /></td></tr>
<tr class="separator:ga747bf44763db37285677c195ca412245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10fb14711ec9756d3acf79df11c16216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga10fb14711ec9756d3acf79df11c16216">get_and_lock_tablespace_names</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_start, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_end, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> lock_wait_timeout, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:ga10fb14711ec9756d3acf79df11c16216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire IX metadata locks on tablespace names used by LOCK TABLES or by a DDL statement.  <a href="#ga10fb14711ec9756d3acf79df11c16216">More...</a><br /></td></tr>
<tr class="separator:ga10fb14711ec9756d3acf79df11c16216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga066d5c2d024747314c7e3d607c135743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga066d5c2d024747314c7e3d607c135743">lock_table_names</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_start, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_end, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> lock_wait_timeout, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classPrealloced__array.html">Prealloced_array</a>&lt; <a class="el" href="classMDL__request.html">MDL_request</a> *, 1 &gt; *schema_reqs)</td></tr>
<tr class="memdesc:ga066d5c2d024747314c7e3d607c135743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire "strong" (SRO, SNW, SNRW) metadata locks on tables used by LOCK TABLES or by a DDL statement.  <a href="#ga066d5c2d024747314c7e3d607c135743">More...</a><br /></td></tr>
<tr class="separator:ga066d5c2d024747314c7e3d607c135743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6110f4d5a33e22f209bf996dfcf8d57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab6110f4d5a33e22f209bf996dfcf8d57">open_tables_check_upgradable_mdl</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_start, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_end)</td></tr>
<tr class="memdesc:gab6110f4d5a33e22f209bf996dfcf8d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for upgradable (SNW, SNRW) metadata locks on tables to be opened for a DDL statement.  <a href="#gab6110f4d5a33e22f209bf996dfcf8d57">More...</a><br /></td></tr>
<tr class="separator:gab6110f4d5a33e22f209bf996dfcf8d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736af41f45cc26a912ff8d5dacca254a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga736af41f45cc26a912ff8d5dacca254a">acquire_backup_lock_in_lock_tables_mode</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_start, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_end)</td></tr>
<tr class="memdesc:ga736af41f45cc26a912ff8d5dacca254a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate along a list of tables and acquire BACKUP LOCK in shared mode in case a strong MDL request (DDL/LOCK TABLES-type) was specified for a table.  <a href="#ga736af41f45cc26a912ff8d5dacca254a">More...</a><br /></td></tr>
<tr class="separator:ga736af41f45cc26a912ff8d5dacca254a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fdd979f7573b1d7a50cb49936bccf5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga13fdd979f7573b1d7a50cb49936bccf5">set_non_locking_read_for_IS_view</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:ga13fdd979f7573b1d7a50cb49936bccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this is a DD table used under a I_S view then request InnoDB to do non-locking reads on the table.  <a href="#ga13fdd979f7573b1d7a50cb49936bccf5">More...</a><br /></td></tr>
<tr class="separator:ga13fdd979f7573b1d7a50cb49936bccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82dfde867b0b829b1c992b9e7f8e38b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga82dfde867b0b829b1c992b9e7f8e38b5">is_acl_table_in_non_LTM</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl, enum <a class="el" href="locked__tables__list_8h.html#a77fee489173235058762d07e721b7476">enum_locked_tables_mode</a> ltm)</td></tr>
<tr class="memdesc:ga82dfde867b0b829b1c992b9e7f8e38b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given TABLE_LIST is a acl table and is being read and not in LOCK TABLE mode.  <a href="#ga82dfde867b0b829b1c992b9e7f8e38b5">More...</a><br /></td></tr>
<tr class="separator:ga82dfde867b0b829b1c992b9e7f8e38b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452af2f8cc8e98c4a0be26673ae98530"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga452af2f8cc8e98c4a0be26673ae98530">set_non_locking_read_for_ACL_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;issue_warning)</td></tr>
<tr class="memdesc:ga452af2f8cc8e98c4a0be26673ae98530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this is a ACL table is requested for read and then request InnoDB to do non-locking reads on the table.  <a href="#ga452af2f8cc8e98c4a0be26673ae98530">More...</a><br /></td></tr>
<tr class="separator:ga452af2f8cc8e98c4a0be26673ae98530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e488af7a3f47be08fad22370de07c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **<a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="memdesc:ga59e488af7a3f47be08fad22370de07c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open all tables in list.  <a href="#ga59e488af7a3f47be08fad22370de07c5">More...</a><br /></td></tr>
<tr class="separator:ga59e488af7a3f47be08fad22370de07c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e7c03bbd0b12e11920783cd5161eef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga26e7c03bbd0b12e11920783cd5161eef">check_lock_and_start_stmt</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="memdesc:ga26e7c03bbd0b12e11920783cd5161eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that lock is ok for tables; Call start stmt if ok.  <a href="#ga26e7c03bbd0b12e11920783cd5161eef">More...</a><br /></td></tr>
<tr class="separator:ga26e7c03bbd0b12e11920783cd5161eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a68932d1c35b3fd820c99d185d7888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga86a68932d1c35b3fd820c99d185d7888">open_n_lock_single_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_l, <a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a> lock_type, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="memdesc:ga86a68932d1c35b3fd820c99d185d7888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and lock one table.  <a href="#ga86a68932d1c35b3fd820c99d185d7888">More...</a><br /></td></tr>
<tr class="separator:ga86a68932d1c35b3fd820c99d185d7888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5263e110baf47c9fe2f820bc649be5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga3b5263e110baf47c9fe2f820bc649be5">open_ltable</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a> lock_type, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> lock_flags)</td></tr>
<tr class="separator:ga3b5263e110baf47c9fe2f820bc649be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab469748dd06a6477d4ce23f742af0794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab469748dd06a6477d4ce23f742af0794">open_and_lock_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="memdesc:gab469748dd06a6477d4ce23f742af0794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open all tables in list, locks them and optionally process derived tables.  <a href="#gab469748dd06a6477d4ce23f742af0794">More...</a><br /></td></tr>
<tr class="separator:gab469748dd06a6477d4ce23f742af0794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cb52c7e762297f8ee4e716cc8bf2ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga38cb52c7e762297f8ee4e716cc8bf2ab">open_secondary_engine_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:ga38cb52c7e762297f8ee4e716cc8bf2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a secondary engine can be used to execute the current statement, and if so, replace the opened tables with their secondary counterparts.  <a href="#ga38cb52c7e762297f8ee4e716cc8bf2ab">More...</a><br /></td></tr>
<tr class="separator:ga38cb52c7e762297f8ee4e716cc8bf2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b93d2956c1e654ebe0e48ab3503410d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga6b93d2956c1e654ebe0e48ab3503410d">open_tables_for_query</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:ga6b93d2956c1e654ebe0e48ab3503410d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open all tables for a query or statement, in list started by "tables".  <a href="#ga6b93d2956c1e654ebe0e48ab3503410d">More...</a><br /></td></tr>
<tr class="separator:ga6b93d2956c1e654ebe0e48ab3503410d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44874f07fb6dca6eb396c66116429d14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga44874f07fb6dca6eb396c66116429d14">mark_real_tables_as_free_for_reuse</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="separator:ga44874f07fb6dca6eb396c66116429d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399ec28859bb54829b1cabbeed845f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="myisam__ftdump_8cc.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:ga399ec28859bb54829b1cabbeed845f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock all tables in a list.  <a href="#ga399ec28859bb54829b1cabbeed845f78">More...</a><br /></td></tr>
<tr class="separator:ga399ec28859bb54829b1cabbeed845f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bec964ecaaa7270a429e664643b746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **tables, const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;start_of_statement_svp)</td></tr>
<tr class="memdesc:ga92bec964ecaaa7270a429e664643b746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare statement for reopening of tables and recalculation of set of prelocked tables.  <a href="#ga92bec964ecaaa7270a429e664643b746">More...</a><br /></td></tr>
<tr class="separator:ga92bec964ecaaa7270a429e664643b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf067903168fe13a1f93d20e2b3cc816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gacf067903168fe13a1f93d20e2b3cc816">open_table_uncached</a> (<a class="el" href="classTHD.html">THD</a> *thd, const char *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>, const char *db, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_to_temporary_tables_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_in_engine, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> &amp;<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:gacf067903168fe13a1f93d20e2b3cc816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a single table without table caching and don't add it to THD::open_tables.  <a href="#gacf067903168fe13a1f93d20e2b3cc816">More...</a><br /></td></tr>
<tr class="separator:gacf067903168fe13a1f93d20e2b3cc816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f17b7fae33a7238e2f2387570bc4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga46f17b7fae33a7238e2f2387570bc4c5">rm_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structhandlerton.html">handlerton</a> *base, const char *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>, const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *<a class="el" href="classtable__def.html">table_def</a>)</td></tr>
<tr class="memdesc:ga46f17b7fae33a7238e2f2387570bc4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a temporary table.  <a href="#ga46f17b7fae33a7238e2f2387570bc4c5">More...</a><br /></td></tr>
<tr class="separator:ga46f17b7fae33a7238e2f2387570bc4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c68673b37e4f394de31ffe4ac80fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab5c68673b37e4f394de31ffe4ac80fcc">open_temporary_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:gab5c68673b37e4f394de31ffe4ac80fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a temporary table specified by TABLE_LIST instance in the cache and prepare its TABLE instance for use.  <a href="#gab5c68673b37e4f394de31ffe4ac80fcc">More...</a><br /></td></tr>
<tr class="separator:gab5c68673b37e4f394de31ffe4ac80fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c1cb71807d09d53273048447abf301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl_list)</td></tr>
<tr class="memdesc:gac4c1cb71807d09d53273048447abf301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-open temporary tables corresponding to table list elements.  <a href="#gac4c1cb71807d09d53273048447abf301">More...</a><br /></td></tr>
<tr class="separator:gac4c1cb71807d09d53273048447abf301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed43ab5a9aafdf78fcfa92c43c2ad943"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaed43ab5a9aafdf78fcfa92c43c2ad943">find_field_in_view</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="classItem.html">Item</a> **ref, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> register_tree_change)</td></tr>
<tr class="separator:gaed43ab5a9aafdf78fcfa92c43c2ad943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae05851375a773f5cd27bcabc84566488"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae05851375a773f5cd27bcabc84566488">find_field_in_natural_join</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, <a class="el" href="classItem.html">Item</a> **ref, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> register_tree_change, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **actual_table)</td></tr>
<tr class="memdesc:gae05851375a773f5cd27bcabc84566488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find field by name in a NATURAL/USING join table reference.  <a href="#gae05851375a773f5cd27bcabc84566488">More...</a><br /></td></tr>
<tr class="separator:gae05851375a773f5cd27bcabc84566488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1471acedfd6ad06e532a34cc8c90db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaf1471acedfd6ad06e532a34cc8c90db7">find_field_in_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, size_t length, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> allow_rowid, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *field_index_ptr)</td></tr>
<tr class="memdesc:gaf1471acedfd6ad06e532a34cc8c90db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find field by name in a base table.  <a href="#gaf1471acedfd6ad06e532a34cc8c90db7">More...</a><br /></td></tr>
<tr class="separator:gaf1471acedfd6ad06e532a34cc8c90db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5a396726b2c948aadb2ad1b1b37992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5a5a396726b2c948aadb2ad1b1b37992">find_field_in_table_ref</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>, size_t length, const char *item_name, const char *db_name, const char *table_name, <a class="el" href="classItem.html">Item</a> **ref, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> want_privilege, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> allow_rowid, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *field_index_ptr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> register_tree_change, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **actual_table)</td></tr>
<tr class="memdesc:ga5a5a396726b2c948aadb2ad1b1b37992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find field in a table reference.  <a href="#ga5a5a396726b2c948aadb2ad1b1b37992">More...</a><br /></td></tr>
<tr class="separator:ga5a5a396726b2c948aadb2ad1b1b37992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795c727f9014b6fd6d0eed974e26c5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga795c727f9014b6fd6d0eed974e26c5c3">find_field_in_table_sef</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *<a class="el" href="persisted__variable_8cc.html#a02b8247840db27f85191d734d51598fa">name</a>)</td></tr>
<tr class="separator:ga795c727f9014b6fd6d0eed974e26c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40da7d22bc6c9c596a10e723d1dd5b71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga40da7d22bc6c9c596a10e723d1dd5b71">find_field_in_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem__ident.html">Item_ident</a> *item, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *first_table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *last_table, <a class="el" href="classItem.html">Item</a> **ref, <a class="el" href="sql__base_8h.html#a3fcc0de90fa4a236da8b41896c7f29f7">find_item_error_report_type</a> <a class="el" href="sql__plugin_8cc.html#af55751b4db2d8bdaafbfae001f3f108f">report_error</a>, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> want_privilege, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> register_tree_change)</td></tr>
<tr class="separator:ga40da7d22bc6c9c596a10e723d1dd5b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae875b54581b1984be5e9d11b580ac8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae875b54581b1984be5e9d11b580ac8f5">find_item_in_list</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *find, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *<a class="el" href="structitems.html">items</a>, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>, <a class="el" href="sql__base_8h.html#a3fcc0de90fa4a236da8b41896c7f29f7">find_item_error_report_type</a> <a class="el" href="sql__plugin_8cc.html#af55751b4db2d8bdaafbfae001f3f108f">report_error</a>, <a class="el" href="sql__const_8h.html#a833661fc49e81da0c12a200f414ccf34">enum_resolution_type</a> *resolution)</td></tr>
<tr class="separator:gae875b54581b1984be5e9d11b580ac8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7829391d90c080cebbd2ef415179e65b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga7829391d90c080cebbd2ef415179e65b">test_if_string_in_list</a> (const char *find, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *str_list)</td></tr>
<tr class="separator:ga7829391d90c080cebbd2ef415179e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59f6a54c7e4f0c4f0bca9b030fde625"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab59f6a54c7e4f0c4f0bca9b030fde625">set_new_item_local_context</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem__ident.html">Item_ident</a> *item, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref)</td></tr>
<tr class="separator:gab59f6a54c7e4f0c4f0bca9b030fde625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d86e270cafa0948c88e0263c6de67f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga24d86e270cafa0948c88e0263c6de67f">mark_common_columns</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref_1, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref_2, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *using_fields, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *found_using_fields)</td></tr>
<tr class="separator:ga24d86e270cafa0948c88e0263c6de67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43aae24b1aed0c36e6fb1b370e4be230"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga43aae24b1aed0c36e6fb1b370e4be230">store_natural_using_join_columns</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *natural_using_join, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref_1, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref_2, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *using_fields, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> found_using_fields)</td></tr>
<tr class="separator:ga43aae24b1aed0c36e6fb1b370e4be230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bcb0af6f38b4d3c27aa82d9916cc8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga72bcb0af6f38b4d3c27aa82d9916cc8a">store_top_level_join_columns</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *left_neighbor, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *right_neighbor)</td></tr>
<tr class="separator:ga72bcb0af6f38b4d3c27aa82d9916cc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78aaa1c511d27ca98bafa279aed43c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga78aaa1c511d27ca98bafa279aed43c08">setup_natural_join_row_types</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *from_clause, <a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *context)</td></tr>
<tr class="separator:ga78aaa1c511d27ca98bafa279aed43c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13fc559f211cc8c19fdfcfcfa65ce5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac13fc559f211cc8c19fdfcfcfa65ce5c">resolve_var_assignments</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structLEX.html">LEX</a> *lex)</td></tr>
<tr class="memdesc:gac13fc559f211cc8c19fdfcfcfa65ce5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve variable assignments from LEX object.  <a href="#gac13fc559f211cc8c19fdfcfcfa65ce5c">More...</a><br /></td></tr>
<tr class="separator:gac13fc559f211cc8c19fdfcfcfa65ce5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d98aadd638466cac7244e320c773d7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga7d98aadd638466cac7244e320c773d7d">setup_fields</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> want_privilege, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> allow_sum_func, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> split_sum_funcs, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> column_update, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *typed_items, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array)</td></tr>
<tr class="memdesc:ga7d98aadd638466cac7244e320c773d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a list of expressions and setup appropriate data.  <a href="#ga7d98aadd638466cac7244e320c773d7d">More...</a><br /></td></tr>
<tr class="separator:ga7d98aadd638466cac7244e320c773d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10e6afa3aa87d8a1961d7ee76d5f9ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae10e6afa3aa87d8a1961d7ee76d5f9ed">insert_fields</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex, const char *db_name, const char *table_name, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt;::iterator *it, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> any_privileges)</td></tr>
<tr class="separator:gae10e6afa3aa87d8a1961d7ee76d5f9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7396c104008e6bb1f148658c741ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga6a7396c104008e6bb1f148658c741ad9">fill_record</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;values, <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *bitmap, <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *insert_into_fields_bitmap, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> raise_autoinc_has_expl_non_null_val)</td></tr>
<tr class="memdesc:ga6a7396c104008e6bb1f148658c741ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill fields with given items.  <a href="#ga6a7396c104008e6bb1f148658c741ad9">More...</a><br /></td></tr>
<tr class="separator:ga6a7396c104008e6bb1f148658c741ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9398bbcc51c37725ba46de50a9a40a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9d9398bbcc51c37725ba46de50a9a40a">check_record</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields)</td></tr>
<tr class="memdesc:ga9d9398bbcc51c37725ba46de50a9a40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the NOT NULL constraint on all the fields of the current record.  <a href="#ga9d9398bbcc51c37725ba46de50a9a40a">More...</a><br /></td></tr>
<tr class="separator:ga9d9398bbcc51c37725ba46de50a9a40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a03ad3f42501f08c42bc3ab9b5eb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga46a03ad3f42501f08c42bc3ab9b5eb51">check_record</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classField.html">Field</a> **ptr)</td></tr>
<tr class="memdesc:ga46a03ad3f42501f08c42bc3ab9b5eb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the NOT NULL constraint on all the fields of the current record.  <a href="#ga46a03ad3f42501f08c42bc3ab9b5eb51">More...</a><br /></td></tr>
<tr class="separator:ga46a03ad3f42501f08c42bc3ab9b5eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab982d1b18f0e0e543a61e808ee30e562"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab982d1b18f0e0e543a61e808ee30e562">check_inserting_record</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classField.html">Field</a> **ptr)</td></tr>
<tr class="memdesc:gab982d1b18f0e0e543a61e808ee30e562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the NOT NULL constraint on all the fields explicitly set in INSERT INTO statement or implicitly set in BEFORE trigger.  <a href="#gab982d1b18f0e0e543a61e808ee30e562">More...</a><br /></td></tr>
<tr class="separator:gab982d1b18f0e0e543a61e808ee30e562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfafa0701c1dfa674565f260cd89cc66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gadfafa0701c1dfa674565f260cd89cc66">invoke_table_check_constraints</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:gadfafa0701c1dfa674565f260cd89cc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke check constraints defined on the table.  <a href="#gadfafa0701c1dfa674565f260cd89cc66">More...</a><br /></td></tr>
<tr class="separator:gadfafa0701c1dfa674565f260cd89cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77127faaee6e8eb68255f3011a198835"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga77127faaee6e8eb68255f3011a198835">command_can_invoke_insert_triggers</a> (enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a> event, <a class="el" href="my__sqlcommand_8h.html#a46bba265a20f1784df6b9802aec4122a">enum_sql_command</a> sql_command)</td></tr>
<tr class="memdesc:ga77127faaee6e8eb68255f3011a198835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if SQL-statement is INSERT/INSERT SELECT/REPLACE/REPLACE SELECT and trigger event is ON INSERT.  <a href="#ga77127faaee6e8eb68255f3011a198835">More...</a><br /></td></tr>
<tr class="separator:ga77127faaee6e8eb68255f3011a198835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f73b6e4ed87676502d07bd58eba7590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga1f73b6e4ed87676502d07bd58eba7590">call_before_insert_triggers</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a> event, <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *insert_into_fields_bitmap)</td></tr>
<tr class="memdesc:ga1f73b6e4ed87676502d07bd58eba7590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute BEFORE INSERT trigger.  <a href="#ga1f73b6e4ed87676502d07bd58eba7590">More...</a><br /></td></tr>
<tr class="separator:ga1f73b6e4ed87676502d07bd58eba7590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2c99290caaf71188355638d0c2a168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8e2c99290caaf71188355638d0c2a168">fill_record_n_invoke_before_triggers</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classCOPY__INFO.html">COPY_INFO</a> *optype_info, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;values, <a class="el" href="structTABLE.html">TABLE</a> *table, enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a> event, int num_fields, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> raise_autoinc_has_expl_non_null_val, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *is_row_changed)</td></tr>
<tr class="memdesc:ga8e2c99290caaf71188355638d0c2a168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill fields in list with values from the list of items and invoke before triggers.  <a href="#ga8e2c99290caaf71188355638d0c2a168">More...</a><br /></td></tr>
<tr class="separator:ga8e2c99290caaf71188355638d0c2a168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5259b4d5c1dbf8da2fac73fab214035c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5259b4d5c1dbf8da2fac73fab214035c">fill_record</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classField.html">Field</a> **ptr, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;values, <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *bitmap, <a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *insert_into_fields_bitmap, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> raise_autoinc_has_expl_non_null_val)</td></tr>
<tr class="memdesc:ga5259b4d5c1dbf8da2fac73fab214035c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill field buffer with values from Field list.  <a href="#ga5259b4d5c1dbf8da2fac73fab214035c">More...</a><br /></td></tr>
<tr class="separator:ga5259b4d5c1dbf8da2fac73fab214035c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c46795d715f3eb8338a5f36540466c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5c46795d715f3eb8338a5f36540466c9">fill_record_n_invoke_before_triggers</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classField.html">Field</a> **ptr, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;values, <a class="el" href="structTABLE.html">TABLE</a> *table, enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a> event, int num_fields)</td></tr>
<tr class="memdesc:ga5c46795d715f3eb8338a5f36540466c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill fields in array with values from the list of items and invoke before triggers.  <a href="#ga5c46795d715f3eb8338a5f36540466c9">More...</a><br /></td></tr>
<tr class="separator:ga5c46795d715f3eb8338a5f36540466c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd1268060cd8a88f03cdfdd91281a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga2fd1268060cd8a88f03cdfdd91281a1c">mysql_rm_tmp_tables</a> (void)</td></tr>
<tr class="memdesc:ga2fd1268060cd8a88f03cdfdd91281a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop all temporary tables which have been left from previous server run.  <a href="#ga2fd1268060cd8a88f03cdfdd91281a1c">More...</a><br /></td></tr>
<tr class="separator:ga2fd1268060cd8a88f03cdfdd91281a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae1459addd4c75ddbf76468ba9a26a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaaae1459addd4c75ddbf76468ba9a26a6">tdc_flush_unused_tables</a> ()</td></tr>
<tr class="separator:gaaae1459addd4c75ddbf76468ba9a26a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8faf6c6118b6677394e14994ae614075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8faf6c6118b6677394e14994ae614075">tdc_remove_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="sql__base_8h.html#a66f633a9b4298fd58b5e6f22df6fbb65">enum_tdc_remove_table_type</a> remove_type, const char *db, const char *table_name, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> has_lock)</td></tr>
<tr class="memdesc:ga8faf6c6118b6677394e14994ae614075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all or some (depending on parameter) instances of TABLE and TABLE_SHARE from the table definition cache.  <a href="#ga8faf6c6118b6677394e14994ae614075">More...</a><br /></td></tr>
<tr class="separator:ga8faf6c6118b6677394e14994ae614075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fae60571f4ec1c1e733911087a5f5ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4fae60571f4ec1c1e733911087a5f5ab">setup_ftfuncs</a> (const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex)</td></tr>
<tr class="separator:ga4fae60571f4ec1c1e733911087a5f5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673bd1c3a18bccbfeeaedccdc1434d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga673bd1c3a18bccbfeeaedccdc1434d8c">init_ftfuncs</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex)</td></tr>
<tr class="separator:ga673bd1c3a18bccbfeeaedccdc1434d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac315ba0102697b41bdeeff67a61240eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac315ba0102697b41bdeeff67a61240eb">open_trans_system_tables_for_read</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="memdesc:gac315ba0102697b41bdeeff67a61240eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and lock transactional system tables for read.  <a href="#gac315ba0102697b41bdeeff67a61240eb">More...</a><br /></td></tr>
<tr class="separator:gac315ba0102697b41bdeeff67a61240eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ca9600b012ffde28a4a0360e91c0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga94ca9600b012ffde28a4a0360e91c0e8">close_trans_system_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga94ca9600b012ffde28a4a0360e91c0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close transactional system tables, opened with open_trans_system_tables_for_read().  <a href="#ga94ca9600b012ffde28a4a0360e91c0e8">More...</a><br /></td></tr>
<tr class="separator:ga94ca9600b012ffde28a4a0360e91c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9467ef8e03a8afbe8b937d699a0537f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9467ef8e03a8afbe8b937d699a0537f2">close_mysql_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga9467ef8e03a8afbe8b937d699a0537f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to close a mysql.  <a href="#ga9467ef8e03a8afbe8b937d699a0537f2">More...</a><br /></td></tr>
<tr class="separator:ga9467ef8e03a8afbe8b937d699a0537f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga065f6a0326ab135938fb38fd371dace5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *one_table, <a class="el" href="classOpen__tables__backup.html">Open_tables_backup</a> *<a class="el" href="myisampack_8cc.html#ac9a4b7317723254f2c79bffcd3265666">backup</a>)</td></tr>
<tr class="memdesc:ga065f6a0326ab135938fb38fd371dace5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a log table.  <a href="#ga065f6a0326ab135938fb38fd371dace5">More...</a><br /></td></tr>
<tr class="separator:ga065f6a0326ab135938fb38fd371dace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f22fa867e1bb56d350834b5497c9d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classOpen__tables__backup.html">Open_tables_backup</a> *<a class="el" href="myisampack_8cc.html#ac9a4b7317723254f2c79bffcd3265666">backup</a>)</td></tr>
<tr class="memdesc:ga8f22fa867e1bb56d350834b5497c9d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a log table.  <a href="#ga8f22fa867e1bb56d350834b5497c9d6d">More...</a><br /></td></tr>
<tr class="separator:ga8f22fa867e1bb56d350834b5497c9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711108427e8243b5b9a1af8bb89b84c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga711108427e8243b5b9a1af8bb89b84c9">Table_share_deleter::operator()</a> (<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="separator:ga711108427e8243b5b9a1af8bb89b84c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaa3b1fdce29eac72028f96c55607d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8eaa3b1fdce29eac72028f96c55607d3">Open_table_context::Open_table_context</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:ga8eaa3b1fdce29eac72028f96c55607d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open_table_context.  <a href="#ga8eaa3b1fdce29eac72028f96c55607d3">More...</a><br /></td></tr>
<tr class="separator:ga8eaa3b1fdce29eac72028f96c55607d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35889f70c8719510fb76899cf9cf20b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaf35889f70c8719510fb76899cf9cf20b">Open_table_context::request_backoff_action</a> (<a class="el" href="classOpen__table__context.html#a598143ade01c51a46534ce06fbb9bbab">enum_open_table_action</a> action_arg, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table)</td></tr>
<tr class="memdesc:gaf35889f70c8719510fb76899cf9cf20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we can back-off and set back off action if we can.  <a href="#gaf35889f70c8719510fb76899cf9cf20b">More...</a><br /></td></tr>
<tr class="separator:gaf35889f70c8719510fb76899cf9cf20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade48892bc4607303f7f4d3d6df4c39de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gade48892bc4607303f7f4d3d6df4c39de">Open_table_context::recover_from_failed_open</a> ()</td></tr>
<tr class="memdesc:gade48892bc4607303f7f4d3d6df4c39de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover from failed attempt of open table by performing requested action.  <a href="#gade48892bc4607303f7f4d3d6df4c39de">More...</a><br /></td></tr>
<tr class="separator:gade48892bc4607303f7f4d3d6df4c39de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb088116a3379bebb9239a2ae50eb7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gacb088116a3379bebb9239a2ae50eb7f3">DML_prelocking_strategy::handle_routine</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking) override</td></tr>
<tr class="memdesc:gacb088116a3379bebb9239a2ae50eb7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how prelocking algorithm for DML statements should handle routines:  <a href="#gacb088116a3379bebb9239a2ae50eb7f3">More...</a><br /></td></tr>
<tr class="separator:gacb088116a3379bebb9239a2ae50eb7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad363558ff64c10dc12a491bd61059f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0ad363558ff64c10dc12a491bd61059f">DML_prelocking_strategy::handle_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking) override</td></tr>
<tr class="memdesc:ga0ad363558ff64c10dc12a491bd61059f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how prelocking algorithm for DML statements should handle table list elements:  <a href="#ga0ad363558ff64c10dc12a491bd61059f">More...</a><br /></td></tr>
<tr class="separator:ga0ad363558ff64c10dc12a491bd61059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5811c3af47db089759894ccdc8312110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5811c3af47db089759894ccdc8312110">DML_prelocking_strategy::handle_view</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking) override</td></tr>
<tr class="memdesc:ga5811c3af47db089759894ccdc8312110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how prelocking algorithm for DML statements should handle view - all view routines should be added to the prelocking set.  <a href="#ga5811c3af47db089759894ccdc8312110">More...</a><br /></td></tr>
<tr class="separator:ga5811c3af47db089759894ccdc8312110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b63bc4e37e85d1a9048f9842dc3072a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9b63bc4e37e85d1a9048f9842dc3072a">Lock_tables_prelocking_strategy::handle_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking) override</td></tr>
<tr class="memdesc:ga9b63bc4e37e85d1a9048f9842dc3072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how prelocking algorithm for LOCK TABLES statement should handle table list elements.  <a href="#ga9b63bc4e37e85d1a9048f9842dc3072a">More...</a><br /></td></tr>
<tr class="separator:ga9b63bc4e37e85d1a9048f9842dc3072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6419a79127f2b24c3f8cce60980676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaaf6419a79127f2b24c3f8cce60980676">Alter_table_prelocking_strategy::handle_routine</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking) override</td></tr>
<tr class="memdesc:gaaf6419a79127f2b24c3f8cce60980676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how prelocking algorithm for ALTER TABLE statement should handle routines - do nothing as this statement is not supposed to call routines.  <a href="#gaaf6419a79127f2b24c3f8cce60980676">More...</a><br /></td></tr>
<tr class="separator:gaaf6419a79127f2b24c3f8cce60980676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba540ab03944861b2d21475cb4b6aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gadba540ab03944861b2d21475cb4b6aac">Alter_table_prelocking_strategy::handle_table</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking) override</td></tr>
<tr class="memdesc:gadba540ab03944861b2d21475cb4b6aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how prelocking algorithm for ALTER TABLE statement should handle table list elements.  <a href="#gadba540ab03944861b2d21475cb4b6aac">More...</a><br /></td></tr>
<tr class="separator:gadba540ab03944861b2d21475cb4b6aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd941274d044b0aee36cb06e657a8c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gafd941274d044b0aee36cb06e657a8c79">Alter_table_prelocking_strategy::handle_view</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *need_prelocking) override</td></tr>
<tr class="memdesc:gafd941274d044b0aee36cb06e657a8c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how prelocking algorithm for ALTER TABLE statement should handle view - do nothing.  <a href="#gafd941274d044b0aee36cb06e657a8c79">More...</a><br /></td></tr>
<tr class="separator:gafd941274d044b0aee36cb06e657a8c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga99c8e1e3e72cd74032d5f11c486911fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga99c8e1e3e72cd74032d5f11c486911fd">LOCK_open</a></td></tr>
<tr class="memdesc:ga99c8e1e3e72cd74032d5f11c486911fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOCK_open protects the following variables/objects:  <a href="#ga99c8e1e3e72cd74032d5f11c486911fd">More...</a><br /></td></tr>
<tr class="separator:ga99c8e1e3e72cd74032d5f11c486911fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a682517d27176617b45212332a96a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga7a682517d27176617b45212332a96a9d">COND_open</a></td></tr>
<tr class="memdesc:ga7a682517d27176617b45212332a96a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">COND_open synchronizes concurrent opening of the same share:  <a href="#ga7a682517d27176617b45212332a96a9d">More...</a><br /></td></tr>
<tr class="separator:ga7a682517d27176617b45212332a96a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60dca1b3b1af3495883d46a09c15158"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab60dca1b3b1af3495883d46a09c15158">key_LOCK_open</a></td></tr>
<tr class="separator:gab60dca1b3b1af3495883d46a09c15158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8a60d06af3d959e5c31e88d654ef5d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__psi__abi__cond.html#gad83033d86d97d0b965b0257be7674a51">PSI_cond_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9a8a60d06af3d959e5c31e88d654ef5d">key_COND_open</a></td></tr>
<tr class="separator:ga9a8a60d06af3d959e5c31e88d654ef5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb159f64cc354aa5df114e242b98bc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__psi__abi__mutex.html#gae85aba8881825be6e570cca2ba38da7e">PSI_mutex_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gadbb159f64cc354aa5df114e242b98bc8">all_tdc_mutexes</a> []</td></tr>
<tr class="separator:gadbb159f64cc354aa5df114e242b98bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cca55f5a645f0c01750de1cd4d4fe6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__psi__abi__cond.html#ga7ea3e090ab413e4c5828699163a2f67d">PSI_cond_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga97cca55f5a645f0c01750de1cd4d4fe6">all_tdc_conds</a> []</td></tr>
<tr class="separator:ga97cca55f5a645f0c01750de1cd4d4fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41488f3f139629fcf539c519408a7ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Data__Dictionary.html#ga3b7c6aa52a5b59656690aa16217d036e">Table_definition_cache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga41488f3f139629fcf539c519408a7ae2">table_def_cache</a></td></tr>
<tr class="separator:ga41488f3f139629fcf539c519408a7ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a357928bde371591f69e67d651f291"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga99a357928bde371591f69e67d651f291">oldest_unused_share</a></td></tr>
<tr class="separator:ga99a357928bde371591f69e67d651f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae404dad30542c069f3db869c8cb4d5e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae404dad30542c069f3db869c8cb4d5e6">end_of_unused_share</a></td></tr>
<tr class="separator:gae404dad30542c069f3db869c8cb4d5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d84d00803df58397d89f86a2610f67"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga09d84d00803df58397d89f86a2610f67">table_def_shutdown_in_progress</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:ga09d84d00803df58397d89f86a2610f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41c271d6f3b49310f4797fcb8b40431"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTable__id.html">Table_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gad41c271d6f3b49310f4797fcb8b40431">last_table_id</a></td></tr>
<tr class="separator:gad41c271d6f3b49310f4797fcb8b40431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9133e87930df59fe74ca492acf5295f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9133e87930df59fe74ca492acf5295f7">not_found_field</a> = (<a class="el" href="classField.html">Field</a> *)0x1</td></tr>
<tr class="separator:ga9133e87930df59fe74ca492acf5295f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba50986729b2cfd3be1c762e666d3d18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaba50986729b2cfd3be1c762e666d3d18">view_ref_found</a> = (<a class="el" href="classField.html">Field</a> *)0x2</td></tr>
<tr class="separator:gaba50986729b2cfd3be1c762e666d3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac130a94f4d55acec35aa42626af9f37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac130a94f4d55acec35aa42626af9f37f">not_found_item</a> = (<a class="el" href="classItem.html">Item</a> **)0x1</td></tr>
<tr class="separator:gac130a94f4d55acec35aa42626af9f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga9103f1fde040b45e171c6df146d812f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9103f1fde040b45e171c6df146d812f1">&#9670;&nbsp;</a></span>WRONG_GRANT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRONG_GRANT&#160;&#160;&#160;(<a class="el" href="classField.html">Field</a> *)-1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3b7c6aa52a5b59656690aa16217d036e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b7c6aa52a5b59656690aa16217d036e">&#9670;&nbsp;</a></span>Table_definition_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Data__Dictionary.html#ga3b7c6aa52a5b59656690aa16217d036e">Table_definition_cache</a> =  <a class="el" href="classmalloc__unordered__map.html">malloc_unordered_map</a>&lt;std::string, std::unique_ptr&lt;<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>, <a class="el" href="structTable__share__deleter.html">Table_share_deleter</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8eaa3b1fdce29eac72028f96c55607d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eaa3b1fdce29eac72028f96c55607d3">&#9670;&nbsp;</a></span>Open_table_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Open_table_context::Open_table_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open_table_context. </p>

</div>
</div>
<a id="ga736af41f45cc26a912ff8d5dacca254a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736af41f45cc26a912ff8d5dacca254a">&#9670;&nbsp;</a></span>acquire_backup_lock_in_lock_tables_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> acquire_backup_lock_in_lock_tables_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate along a list of tables and acquire BACKUP LOCK in shared mode in case a strong MDL request (DDL/LOCK TABLES-type) was specified for a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tables_start</td><td>Pointer to a start of a list of tables to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tables_end</td><td>Pointer to a end of a list of tables where to stop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error. </dd></dl>

</div>
</div>
<a id="gafa7494505ae9ba0f97d266a5fd6b258d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa7494505ae9ba0f97d266a5fd6b258d">&#9670;&nbsp;</a></span>add_view_place_holder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_view_place_holder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a dummy LEX object for a view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">table_list</td><td>The list of tables in the view</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>error occurred </td></tr>
    <tr><td class="paramname">false</td><td>view place holder successfully added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga098cb47bbc8bbdb790fcf28c253ab2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga098cb47bbc8bbdb790fcf28c253ab2b6">&#9670;&nbsp;</a></span>assign_new_table_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assign_new_table_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa0ee1005814f445715e7c0ef76cfaa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0ee1005814f445715e7c0ef76cfaa45">&#9670;&nbsp;</a></span>auto_repair_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> auto_repair_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary routine which is used for performing automatical table repair. </p>

</div>
</div>
<a id="ga5b7bb43d2603048aff8a2ca95b9ba714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b7bb43d2603048aff8a2ca95b9ba714">&#9670;&nbsp;</a></span>belongs_to_dd_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> belongs_to_dd_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given TABLE_LIST belongs to a DD table. </p>
<p>The function checks whether the table is a DD table being used in the context of a DD transaction, or whether it is referred by a system view. Then, it implies that if either of these two conditions hold, then this is a DD table. If in case this is a DD table being used in some other situation, then this function does not return 'true'. We do not know if there is such a situation right now.</p>
<p>This function ignores TABLE_LIST's that is created by optimizer when processing a system view.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tl</td><td>TABLE_LIST point to the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If table belongs to a DD table. </td></tr>
    <tr><td class="paramname">false</td><td>If table does not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb76a30ed423c4cb98689fcedae48c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb76a30ed423c4cb98689fcedae48c60">&#9670;&nbsp;</a></span>cached_table_definitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> cached_table_definitions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1f73b6e4ed87676502d07bd58eba7590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f73b6e4ed87676502d07bd58eba7590">&#9670;&nbsp;</a></span>call_before_insert_triggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> call_before_insert_triggers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *&#160;</td>
          <td class="paramname"><em>insert_into_fields_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute BEFORE INSERT trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread context </td></tr>
    <tr><td class="paramname">table</td><td>TABLE-object holding list of triggers to be invoked </td></tr>
    <tr><td class="paramname">event</td><td>event type for triggers to be invoked </td></tr>
    <tr><td class="paramname">insert_into_fields_bitmap</td><td>Bitmap for fields that is set in fill_record</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d6d716c2b2fbaec9eb41e9e18c9bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d6d716c2b2fbaec9eb41e9e18c9bef3">&#9670;&nbsp;</a></span>check_and_update_routine_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_and_update_routine_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares versions of a stored routine obtained from the sp cache and the version used at prepare. </p>
<p>If the new and the old values mismatch, invoke Metadata_version_observer. At prepared statement prepare, all Sroutine_hash_entry version values are NULL and we always have a mismatch. But there is no observer set in THD, and therefore no error is reported. Instead, we update the value in Sroutine_hash_entry, effectively recording the original version. At prepared statement execute, an observer may be installed. If there is a version mismatch, we push an error and return true.</p>
<p>For conventional execution (no prepared statements), the observer is never installed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>used to report errors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rt</td><td>pointer to stored routine entry in the parse tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>pointer to stored routine cache entry. Can be NULL if there is no such routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>an error, which has been reported </td></tr>
    <tr><td class="paramname">false</td><td>success, version in Sroutine_hash_entry has been updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab721de91242bfd20abab6c96d7d766f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab721de91242bfd20abab6c96d7d766f8">&#9670;&nbsp;</a></span>check_and_update_table_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_and_update_table_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>table_share</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare metadata versions of an element obtained from the table definition cache and its corresponding node in the parse tree. </p>
<p>If the new and the old values mismatch, invoke Metadata_version_observer. At prepared statement prepare, all TABLE_LIST version values are NULL and we always have a mismatch. But there is no observer set in THD, and therefore no error is reported. Instead, we update the value in the parse tree, effectively recording the original version. At prepared statement execute, an observer may be installed. If there is a version mismatch, we push an error and return true.</p>
<p>For conventional execution (no prepared statements), the observer is never installed.</p>
<dl class="section see"><dt>See also</dt><dd>Execute_observer </dd>
<dd>
check_prepared_statement() to see cases when an observer is installed </dd>
<dd>
TABLE_LIST::is_table_ref_id_equal() </dd>
<dd>
TABLE_SHARE::get_table_ref_id()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>used to report errors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tables</td><td>TABLE_LIST instance created by the parser Metadata version information in this object is updated upon success. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_share</td><td>an element from the table definition cache</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>an error, which has been reported </td></tr>
    <tr><td class="paramname">false</td><td>success, version in TABLE_LIST has been updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5afba64853740882233ea3fd3cff08ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5afba64853740882233ea3fd3cff08ff">&#9670;&nbsp;</a></span>check_if_table_exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_if_table_exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that table exists in data-dictionary or in some storage engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table list element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exists</td><td>Out parameter which is set to true if table exists and to false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is no table in data-dictionary but it exists in one of engines (e.g. it was created on another node of NDB cluster) this function will fetch and add proper table description to the data-dictionary.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Some error occurred </td></tr>
    <tr><td class="paramname">false</td><td>No error. 'exists' out parameter set accordingly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab982d1b18f0e0e543a61e808ee30e562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab982d1b18f0e0e543a61e808ee30e562">&#9670;&nbsp;</a></span>check_inserting_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_inserting_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the NOT NULL constraint on all the fields explicitly set in INSERT INTO statement or implicitly set in BEFORE trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">ptr</td><td>Fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ga26e7c03bbd0b12e11920783cd5161eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e7c03bbd0b12e11920783cd5161eef">&#9670;&nbsp;</a></span>check_lock_and_start_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_lock_and_start_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that lock is ok for tables; Call start stmt if ok. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle. </td></tr>
    <tr><td class="paramname">prelocking_ctx</td><td>Prelocking context. </td></tr>
    <tr><td class="paramname">table_list</td><td>Table list element for table to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- Ok. </td></tr>
    <tr><td class="paramname">true</td><td>- Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d9398bbcc51c37725ba46de50a9a40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d9398bbcc51c37725ba46de50a9a40a">&#9670;&nbsp;</a></span>check_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the NOT NULL constraint on all the fields of the current record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">fields</td><td>Collection of fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ga46a03ad3f42501f08c42bc3ab9b5eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a03ad3f42501f08c42bc3ab9b5eb51">&#9670;&nbsp;</a></span>check_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the NOT NULL constraint on all the fields of the current record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">ptr</td><td>Fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ga207faca14a1dbfdf182503ade0e3ce81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga207faca14a1dbfdf182503ade0e3ce81">&#9670;&nbsp;</a></span>close_all_tables_for_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void close_all_tables_for_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>remove_from_locked_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>skip_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close all open instances of the table but keep the MDL lock. </p>
<p>Works both under LOCK TABLES and in the normal mode. Removes all closed instances of the table from the table cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">key</td><td>TC/TDC key identifying the table. </td></tr>
    <tr><td class="paramname">key_length</td><td>Length of TC/TDC key identifying the table. </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">remove_from_locked_tables</td><td>True if the table is being dropped. In that case the documented behaviour is to implicitly remove the table from LOCK TABLES list. </td></tr>
    <tr><td class="paramname">skip_table</td><td>TABLE instance that should be kept open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called with an X MDL lock on the table. </dd></dl>

</div>
</div>
<a id="ga86713fadf907edf57606406a10c1f994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86713fadf907edf57606406a10c1f994">&#9670;&nbsp;</a></span>close_all_tables_for_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_all_tables_for_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>remove_from_locked_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>skip_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close all open instances of the table but keep the MDL lock. </p>
<p>Works both under LOCK TABLES and in the normal mode. Removes all closed instances of the table from the table cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">share</td><td>Table share, but is just a handy way to access the table cache key. </td></tr>
    <tr><td class="paramname">remove_from_locked_tables</td><td>True if the table is being dropped. In that case the documented behaviour is to implicitly remove the table from LOCK TABLES list. </td></tr>
    <tr><td class="paramname">skip_table</td><td>TABLE instance that should be kept open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called with an X MDL lock on the table. </dd></dl>

</div>
</div>
<a id="ga60fc55840b97b62f5a5c0a51fec0bb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60fc55840b97b62f5a5c0a51fec0bb7b">&#9670;&nbsp;</a></span>close_all_tables_for_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_all_tables_for_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>remove_from_locked_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close all open instances of the table but keep the MDL lock. </p>
<p>Works both under LOCK TABLES and in the normal mode. Removes all closed instances of the table from the table cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">remove_from_locked_tables</td><td>True if the table is being dropped. In that case the documented behaviour is to implicitly remove the table from LOCK TABLES list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called with an X MDL lock on the table. </dd></dl>

</div>
</div>
<a id="ga8504b9f30ae84e60749639a2d03bc0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8504b9f30ae84e60749639a2d03bc0d0">&#9670;&nbsp;</a></span>close_cached_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> close_cached_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>wait_for_refresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8f22fa867e1bb56d350834b5497c9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f22fa867e1bb56d350834b5497c9d6d">&#9670;&nbsp;</a></span>close_log_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_log_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__tables__backup.html">Open_tables_backup</a> *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a log table. </p>
<p>The last table opened by open_log_table() is closed, then the thread context is restored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">backup</td><td>The context to restore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9467ef8e03a8afbe8b937d699a0537f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9467ef8e03a8afbe8b937d699a0537f2">&#9670;&nbsp;</a></span>close_mysql_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_mysql_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function to close a mysql. </p>
<ul>
<li>table opened in an auxiliary THD during bootstrap or in the main connection, when we know that there are no locks held by the connection due to a preceding implicit commit.</li>
</ul>
<p>This function assumes that there is no statement transaction started for the operation itself, since mysql.* tables are not transactional and when they are used the binlog is off (DDL binlogging is always statement-based.</p>
<p>We need this function since we'd like to not just close the system table, but also release the metadata lock on it.</p>
<p>Note, that in LOCK TABLES mode this function does not release the metadata lock. But in this mode the table can be opened only if it is locked explicitly with LOCK TABLES. </p>

</div>
</div>
<a id="ga889e504f17316df5db4d2a980b025398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga889e504f17316df5db4d2a980b025398">&#9670;&nbsp;</a></span>close_open_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void close_open_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function to close all tables in the open_tables list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It should not ordinarily be called directly. </dd></dl>

</div>
</div>
<a id="ga92bec964ecaaa7270a429e664643b746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bec964ecaaa7270a429e664643b746">&#9670;&nbsp;</a></span>close_tables_for_reopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_tables_for_reopen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>start_of_statement_svp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare statement for reopening of tables and recalculation of set of prelocked tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tables</td><td>List of tables which we were trying to open and lock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_of_statement_svp</td><td>MDL savepoint which represents the set of metadata locks which the current transaction managed to acquire before execution of the current statement and to which we should revert before trying to reopen tables. NULL if no metadata locks were held and thus all metadata locks should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37a85ac16e4b359599ef5a21f923261e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37a85ac16e4b359599ef5a21f923261e">&#9670;&nbsp;</a></span>close_temporary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_temporary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>free_share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>delete_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga62f62c19b7f434d061bee6a75402aca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62f62c19b7f434d061bee6a75402aca1">&#9670;&nbsp;</a></span>close_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>free_share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>delete_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa4991367acddcb2b2a0edeb169029917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4991367acddcb2b2a0edeb169029917">&#9670;&nbsp;</a></span>close_temporary_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> close_temporary_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac52b8d7410875b0048421f9386b4b6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac52b8d7410875b0048421f9386b4b6bd">&#9670;&nbsp;</a></span>close_thread_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_thread_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> **&#160;</td>
          <td class="paramname"><em>table_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3ded5accefd985fce6ed115038ea92f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ded5accefd985fce6ed115038ea92f7">&#9670;&nbsp;</a></span>close_thread_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_thread_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close all tables used by the current substatement, or all tables used by this thread if we are on the outer-most level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler</td></tr>
  </table>
  </dd>
</dl>
<p>Unlocks all open persistent and temporary base tables. Put all persistent base tables used by thread in free list.</p>
<p>It will only close/mark as free for reuse tables opened by this substatement, it will also check if we are closing tables after execution of complete query (i.e. we are on outer-most level) and will leave prelocked mode if needed. </p>

</div>
</div>
<a id="ga94ca9600b012ffde28a4a0360e91c0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ca9600b012ffde28a4a0360e91c0e8">&#9670;&nbsp;</a></span>close_trans_system_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_trans_system_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close transactional system tables, opened with open_trans_system_tables_for_read(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77127faaee6e8eb68255f3011a198835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77127faaee6e8eb68255f3011a198835">&#9670;&nbsp;</a></span>command_can_invoke_insert_triggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> command_can_invoke_insert_triggers </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__sqlcommand_8h.html#a46bba265a20f1784df6b9802aec4122a">enum_sql_command</a>&#160;</td>
          <td class="paramname"><em>sql_command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if SQL-statement is INSERT/INSERT SELECT/REPLACE/REPLACE SELECT and trigger event is ON INSERT. </p>
<p>When this condition is true that means that the statement basically can invoke BEFORE INSERT trigger if it was created before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>event type for triggers to be invoked </td></tr>
    <tr><td class="paramname">sql_command</td><td>Type of SQL statement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Test result </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>SQL-statement is INSERT/INSERT SELECT/REPLACE/REPLACE SELECT and trigger event is ON INSERT </td></tr>
    <tr><td class="paramname">false</td><td>Either SQL-statement is not INSERT/INSERT SELECT/REPLACE/REPLACE SELECT or trigger event is not ON INSERT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa191bd24f43a69fa5d4f135c68a2b8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa191bd24f43a69fa5d4f135c68a2b8c6">&#9670;&nbsp;</a></span>create_table_def_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t create_table_def_key </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table cache/table definition cache key for a table. </p>
<p>The table is neither a temporary table nor a table in a secondary storage engine.</p>
<dl class="section note"><dt>Note</dt><dd>The table cache_key is created from: <pre class="fragment">db_name + \0
table_name + \0
</pre></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">db_name</td><td>the database name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_name</td><td>the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>buffer for the key to be created (must be of size MAX_DBKEY_LENGTH) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the key </dd></dl>

</div>
</div>
<a id="ga6a44b976efc63423f6993c14d5ea61cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a44b976efc63423f6993c14d5ea61cd">&#9670;&nbsp;</a></span>create_table_def_key_secondary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string create_table_def_key_secondary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table cache/table definition cache key for a table in a secondary storage engine. </p>
<p>The key is constructed by appending a single byte with the value 1 to the key generated by create_table_def_key().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db_name</td><td>the database name </td></tr>
    <tr><td class="paramname">table_name</td><td>the table name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the key </dd></dl>

</div>
</div>
<a id="gaef12ee9072d2159d93b2c549df409a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef12ee9072d2159d93b2c549df409a62">&#9670;&nbsp;</a></span>create_table_def_key_tmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t create_table_def_key_tmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a table cache/table definition cache key for a temporary table. </p>
<p>The key is constructed by appending the following to the key generated by create_table_def_key():</p>
<ul>
<li>4 bytes for master thread id</li>
<li>4 bytes pseudo thread id</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">db_name</td><td>the database name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_name</td><td>the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>buffer for the key to be created (must be of size MAX_DBKEY_LENGTH) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the key </dd></dl>

</div>
</div>
<a id="ga70df85ebdb0080a97f7233ae8d269d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70df85ebdb0080a97f7233ae8d269d0e">&#9670;&nbsp;</a></span>drop_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drop_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a temporary table. </p>
<ul>
<li>If the table is locked with LOCK TABLES or by prelocking, unlock it and remove it from the list of locked tables (THD::lock). Currently only transactional temporary tables are locked.</li>
<li>Close the temporary table.</li>
<li>Remove the table from the list of temporary tables. </li>
</ul>

</div>
</div>
<a id="ga6a7396c104008e6bb1f148658c741ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a7396c104008e6bb1f148658c741ad9">&#9670;&nbsp;</a></span>fill_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> fill_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *&#160;</td>
          <td class="paramname"><em>insert_into_fields_bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>raise_autoinc_has_expl_non_null_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill fields with given items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler. </td></tr>
    <tr><td class="paramname">table</td><td>Table reference. </td></tr>
    <tr><td class="paramname">fields</td><td>Item_fields list to be filled </td></tr>
    <tr><td class="paramname">values</td><td>Values to fill with. </td></tr>
    <tr><td class="paramname">bitmap</td><td>Bitmap over fields to fill. </td></tr>
    <tr><td class="paramname">insert_into_fields_bitmap</td><td>Bitmap for fields that is set in fill_record. </td></tr>
    <tr><td class="paramname">raise_autoinc_has_expl_non_null_val</td><td>Set corresponding flag in TABLE object to true if non-NULL value is explicitly assigned to auto-increment field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>fill_record() may set TABLE::autoinc_field_has_explicit_non_null_value to true (even in case of failure!) and its caller should make sure that it is reset before next call to this function (i.e. before processing next row) and/or before TABLE instance is returned to table cache. One can use helper Auto_increment_field_not_null_reset_guard class to do this.</dd>
<dd>
In order to simplify implementation this call is allowed to reset TABLE::autoinc_field_has_explicit_non_null_value flag even in case when raise_autoinc_has_expl_non_null_val is false. However, this should be fine since this flag is supposed to be reset already in such cases.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5259b4d5c1dbf8da2fac73fab214035c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5259b4d5c1dbf8da2fac73fab214035c">&#9670;&nbsp;</a></span>fill_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> fill_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMY__BITMAP.html">MY_BITMAP</a> *&#160;</td>
          <td class="paramname"><em>insert_into_fields_bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>raise_autoinc_has_expl_non_null_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill field buffer with values from Field list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler. </td></tr>
    <tr><td class="paramname">table</td><td>Table reference. </td></tr>
    <tr><td class="paramname">ptr</td><td>Array of fields to fill in. </td></tr>
    <tr><td class="paramname">values</td><td>List of values to fill with. </td></tr>
    <tr><td class="paramname">bitmap</td><td>Bitmap over fields to fill. </td></tr>
    <tr><td class="paramname">insert_into_fields_bitmap</td><td>Bitmap for fields that is set in fill_record. </td></tr>
    <tr><td class="paramname">raise_autoinc_has_expl_non_null_val</td><td>Set corresponding flag in TABLE object to true if non-NULL value is explicitly assigned to auto-increment field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>fill_record() may set TABLE::autoinc_field_has_explicit_non_null_value to true (even in case of failure!) and its caller should make sure that it is reset before next call to this function (i.e. before processing next row) and/or before TABLE instance is returned to table cache. One can use helper Auto_increment_field_not_null_reset_guard class to do this.</dd>
<dd>
In order to simplify implementation this call is allowed to reset TABLE::autoinc_field_has_explicit_non_null_value flag even in case when raise_autoinc_has_expl_non_null_val is false. However, this should be fine since this flag is supposed to be reset already in such cases.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e2c99290caaf71188355638d0c2a168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e2c99290caaf71188355638d0c2a168">&#9670;&nbsp;</a></span>fill_record_n_invoke_before_triggers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> fill_record_n_invoke_before_triggers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOPY__INFO.html">COPY_INFO</a> *&#160;</td>
          <td class="paramname"><em>optype_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>raise_autoinc_has_expl_non_null_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>is_row_changed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill fields in list with values from the list of items and invoke before triggers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">optype_info</td><td>COPY_INFO structure used for default values handling. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fields</td><td>Item_fields list to be filled. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">values</td><td>Values to fill with. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>TABLE-object for the table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">event</td><td>Event type for triggers to be invoked. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_fields</td><td>Number of fields in table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">raise_autoinc_has_expl_non_null_val</td><td>Set corresponding flag in TABLE to true if non-NULL value is explicitly assigned to auto-increment field. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_row_changed</td><td>Set to true if a row is changed after filling record and invoking before triggers for UPDATE operation. Otherwise set to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that fields which values will be set and triggers to be invoked belong to the same table, and that TABLE::record[0] and record[1] buffers correspond to new and old versions of row respectively.</dd>
<dd>
This call may set TABLE::autoinc_field_has_explicit_non_null_value to true (even in case of failure!) and its caller should make sure that it is reset appropriately (</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fill_record()).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c46795d715f3eb8338a5f36540466c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c46795d715f3eb8338a5f36540466c9">&#9670;&nbsp;</a></span>fill_record_n_invoke_before_triggers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> fill_record_n_invoke_before_triggers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill fields in array with values from the list of items and invoke before triggers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">ptr</td><td>NULL-ended array of fields to be filled. </td></tr>
    <tr><td class="paramname">values</td><td>Values to fill with. </td></tr>
    <tr><td class="paramname">table</td><td>TABLE-object holding list of triggers to be invoked. </td></tr>
    <tr><td class="paramname">event</td><td>Event type for triggers to be invoked. </td></tr>
    <tr><td class="paramname">num_fields</td><td>Number of fields in table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that fields which values will be set and triggers to be invoked belong to the same table, and that TABLE::record[0] and record[1] buffers correspond to new and old versions of row respectively. </dd>
<dd>
This function is called during handling of statements INSERT/ INSERT SELECT/CREATE SELECT. It means that the only trigger's type that can be invoked when this function is called is a BEFORE INSERT trigger so we don't need to make branching based on the result of execution function command_can_invoke_insert_triggers().</dd>
<dd>
Unlike another version of fill_record_n_invoke_before_triggers() this call tries to set TABLE::autoinc_field_has_explicit_non_null_value to correct value unconditionally. So this flag can be set to true (even in case of failure!) and the caller should make sure that it is reset appropriately (</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fill_record()).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae739cd1eae234e4c3abac511af639692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae739cd1eae234e4c3abac511af639692">&#9670;&nbsp;</a></span>find_dup_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>* find_dup_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>check_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that table is unique (It's only exists once in the table list) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>table to be checked (must be updatable base table) </td></tr>
    <tr><td class="paramname">table_list</td><td>list of tables </td></tr>
    <tr><td class="paramname">check_alias</td><td>whether to check tables' aliases</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: to exclude derived tables from check we use following mechanism: a) during derived table processing set THD::derived_tables_processing b) SELECT_LEX::prepare set SELECT::exclude_from_table_unique_test if THD::derived_tables_processing set. (we can't use JOIN::execute because for PS we perform only SELECT_LEX::prepare, but we can't set this flag in SELECT_LEX::prepare if we are not sure that we are in derived table processing loop, because multi-update call fix_fields() for some its items (which mean SELECT_LEX::prepare for subqueries) before unique_table call to detect which tables should be locked for write). c) find_dup_table skip all tables which belong to SELECT with SELECT::exclude_from_table_unique_test set. Also SELECT::exclude_from_table_unique_test used to exclude from check tables of main SELECT of multi-delete and multi-update</p>
<p>We also skip tables with TABLE_LIST::prelocking_placeholder set, because we want to allow SELECTs from them, and their modification will rise the error anyway.</p>
<p>TODO: when we will have table/view change detection we can do this check only once for PS/SP</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">!=0</td><td>found duplicate </td></tr>
    <tr><td class="paramname">0</td><td>if table is unique </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae05851375a773f5cd27bcabc84566488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae05851375a773f5cd27bcabc84566488">&#9670;&nbsp;</a></span>find_field_in_natural_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classField.html">Field</a>* find_field_in_natural_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>register_tree_change</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>actual_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find field by name in a NATURAL/USING join table reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_ref</td><td>table reference to search </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>name of field </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref</td><td>if 'name' is resolved to a view field, ref is set to point to the found view field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">register_tree_change</td><td>true if ref is not stack variable and we need register changes in item tree </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">actual_table</td><td>The original table reference where the field belongs - differs from 'table_list' only for NATURAL/USING joins</td></tr>
  </table>
  </dd>
</dl>
<p>DESCRIPTION Search for a field among the result fields of a NATURAL/USING join. Notice that this procedure is called only for non-qualified field names. In the case of qualified fields, we search directly the base tables of a natural join.</p>
<p>Sometimes when a field is found, it is checked for privileges according to THD::want_privilege and marked according to THD::mark_used_columns. But it is unclear when, so caller generally has to do the same.</p>
<p>RETURN NULL if the field was not found WRONG_GRANT if no access rights to the found field </p><h1>Pointer to the found Field</h1>

</div>
</div>
<a id="gaf1471acedfd6ad06e532a34cc8c90db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1471acedfd6ad06e532a34cc8c90db7">&#9670;&nbsp;</a></span>find_field_in_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* find_field_in_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>allow_rowid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>field_index_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find field by name in a base table. </p>
<p>No privileges are checked, and the column is not marked in read_set/write_set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>table where to search for the field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>name of field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>length of name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_rowid</td><td>do allow finding of "_rowid" field? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field_index_ptr</td><td>position in field list (used to speedup lookup for fields in prepared tables)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>field is not found </td></tr>
    <tr><td class="paramname">!=</td><td>NULL pointer to field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a5a396726b2c948aadb2ad1b1b37992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a5a396726b2c948aadb2ad1b1b37992">&#9670;&nbsp;</a></span>find_field_in_table_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* find_field_in_table_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>item_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>want_privilege</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>allow_rowid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>field_index_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>register_tree_change</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>actual_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find field in a table reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_list</td><td>table reference to search </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>name of field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>length of field name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">item_name</td><td>name of item if it will be created (VIEW) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">db_name</td><td>optional database name that qualifies the field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_name</td><td>optional table name that qualifies the field </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref</td><td>if 'name' is resolved to a view field, ref is set to point to the found view field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">want_privilege</td><td>privileges to check for column = 0: no privilege checking is needed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_rowid</td><td>do allow finding of "_rowid" field? </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">field_index_ptr</td><td>position in field list (used to speedup lookup for fields in prepared tables) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">register_tree_change</td><td>TRUE if ref is not stack variable and we need register changes in item tree </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">actual_table</td><td>the original table reference where the field belongs - differs from 'table_list' only for NATURAL_USING joins.</td></tr>
  </table>
  </dd>
</dl>
<p>Find a field in a table reference depending on the type of table reference. There are three types of table references with respect to the representation of their result columns:</p><ul>
<li>an array of Field_translator objects for MERGE views and some information_schema tables,</li>
<li>an array of Field objects (and possibly a name hash) for stored tables,</li>
<li>a list of Natural_join_column objects for NATURAL/USING joins. This procedure detects the type of the table reference 'table_list' and calls the corresponding search routine.</li>
</ul>
<p>The function checks column-level privileges for the found field according to argument want_privilege.</p>
<p>The function marks the column in corresponding table's read set or write set according to THD::mark_used_columns.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>field is not found </td></tr>
    <tr><td class="paramname">view_ref_found</td><td>found value in VIEW (real result is in *ref) </td></tr>
    <tr><td class="paramname">otherwise</td><td>pointer to field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga795c727f9014b6fd6d0eed974e26c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga795c727f9014b6fd6d0eed974e26c5c3">&#9670;&nbsp;</a></span>find_field_in_table_sef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* find_field_in_table_sef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga40da7d22bc6c9c596a10e723d1dd5b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40da7d22bc6c9c596a10e723d1dd5b71">&#9670;&nbsp;</a></span>find_field_in_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* find_field_in_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__ident.html">Item_ident</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>first_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>last_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__base_8h.html#a3fcc0de90fa4a236da8b41896c7f29f7">find_item_error_report_type</a>&#160;</td>
          <td class="paramname"><em>report_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>want_privilege</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>register_tree_change</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaed43ab5a9aafdf78fcfa92c43c2ad943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed43ab5a9aafdf78fcfa92c43c2ad943">&#9670;&nbsp;</a></span>find_field_in_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classField.html">Field</a>* find_field_in_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>register_tree_change</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gae875b54581b1984be5e9d11b580ac8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae875b54581b1984be5e9d11b580ac8f5">&#9670;&nbsp;</a></span>find_item_in_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>** find_item_in_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__base_8h.html#a3fcc0de90fa4a236da8b41896c7f29f7">find_item_error_report_type</a>&#160;</td>
          <td class="paramname"><em>report_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__const_8h.html#a833661fc49e81da0c12a200f414ccf34">enum_resolution_type</a> *&#160;</td>
          <td class="paramname"><em>resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4458592b1c4d9ed293e5b2033349c3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4458592b1c4d9ed293e5b2033349c3fb">&#9670;&nbsp;</a></span>find_locked_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_locked_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find table in the list of open tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>List of TABLE objects to be inspected. </td></tr>
    <tr><td class="paramname">db</td><td>Database name </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the TABLE object found, 0 if no table found. </dd></dl>

</div>
</div>
<a id="ga8692f5ebd7f6483f1dcc576eb2346f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8692f5ebd7f6483f1dcc576eb2346f52">&#9670;&nbsp;</a></span>find_table_for_mdl_upgrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_table_for_mdl_upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>no_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find instance of TABLE with upgradable or exclusive metadata lock from the list of open tables, emit error if no such table found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table. </td></tr>
    <tr><td class="paramname">no_error</td><td>Don't emit error if no suitable TABLE instance were found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function checks if the connection holds a global IX metadata lock. If no such lock is found, it is not safe to upgrade the lock and ER_TABLE_NOT_LOCKED_FOR_WRITE will be reported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to TABLE instance with MDL_SHARED_UPGRADABLE MDL_SHARED_NO_WRITE, MDL_SHARED_NO_READ_WRITE, or MDL_EXCLUSIVE metadata lock, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga6949d4bdcb266c5fd678cab14928c73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6949d4bdcb266c5fd678cab14928c73d">&#9670;&nbsp;</a></span>find_table_in_global_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>* find_table_in_global_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find table in global list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Pointer to table list </td></tr>
    <tr><td class="paramname">db_name</td><td>Data base name </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to found table. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>Table not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd9577a1bd28172eb346ef13e464328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9577a1bd28172eb346ef13e464328e">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structTABLE.html">TABLE</a> * find_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>table_key_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a temporary table specified by a key in the THD::temporary_tables list. </p>
<dl class="section return"><dt>Returns</dt><dd>TABLE instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga0734400e8b6f0dab464f0da0f177086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0734400e8b6f0dab464f0da0f177086b">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find temporary table specified by database and table names in the THD::temporary_tables list. </p>
<dl class="section return"><dt>Returns</dt><dd>TABLE instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga4d31aeecf54e9bf14d05fa8a6478b7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d31aeecf54e9bf14d05fa8a6478b7e0">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a temporary table specified by TABLE_LIST instance in the THD::temporary_tables list. </p>
<dl class="section return"><dt>Returns</dt><dd>TABLE instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga1d0cd1dd224a3bb2c450ba3568dd9398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0cd1dd224a3bb2c450ba3568dd9398">&#9670;&nbsp;</a></span>fix_row_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> fix_row_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary routine for automatically updating row format for the table. </p>

</div>
</div>
<a id="ga055df8e4470e8dfd7f8b41f4402f6774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga055df8e4470e8dfd7f8b41f4402f6774">&#9670;&nbsp;</a></span>free_io_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_io_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga10fb14711ec9756d3acf79df11c16216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10fb14711ec9756d3acf79df11c16216">&#9670;&nbsp;</a></span>get_and_lock_tablespace_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> get_and_lock_tablespace_names </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire IX metadata locks on tablespace names used by LOCK TABLES or by a DDL statement. </p>
<dl class="section note"><dt>Note</dt><dd>That the tablespace MDL locks are taken only after locks on tables are acquired. So it is recommended to maintain this same lock order across the server. It is very easy to break the this lock order if we invoke acquire_locks() with list of MDL requests which contain both MDL_key::TABLE and MDL_key::TABLESPACE. We would end-up in deadlock then.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables_start</td><td>Start of list of tables on which locks should be acquired. </td></tr>
    <tr><td class="paramname">tables_end</td><td>End of list of tables. </td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitmap of flags to modify how the tables will be open, see open_table() description for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure (e.g. connection was killed) </td></tr>
    <tr><td class="paramname">false</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0da69eeda10a9b209a7daccf71afeb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0da69eeda10a9b209a7daccf71afeb48">&#9670;&nbsp;</a></span>get_cached_table_share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* get_cached_table_share </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an existing table definition from the table definition cache. </p>
<p>Search the table definition cache for a share with the given key. If the share exists or if it is in the process of being opened by another thread (m_open_in_progress flag is true) return share. Do not wait for share opening to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>table name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nulltpr</td><td>a share for the table does not exist in the cache </td></tr>
    <tr><td class="paramname">!=</td><td>nulltpr pointer to existing share in the cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14224b18bb5f7e175fde6932a590defa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14224b18bb5f7e175fde6932a590defa">&#9670;&nbsp;</a></span>get_table_def_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_table_def_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get table cache key for a table list element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>On return points to table cache key for the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike create_table_def_key() call this function doesn't construct key in a buffer provider by caller. Instead it relies on the fact that table list element for which key is requested has properly initialized MDL_request object and the fact that table definition cache key is suffix of key used in MDL subsystem. So to get table definition key it simply needs to return pointer to appropriate part of MDL_key object nested in this table list element. Indeed, this means that lifetime of key produced by this call is limited by the lifetime of table list element which it got as parameter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Length of key. </dd></dl>

</div>
</div>
<a id="ga785c560f809f5dbb644f3f1190d905f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga785c560f809f5dbb644f3f1190d905f1">&#9670;&nbsp;</a></span>get_table_share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* get_table_share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>open_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>open_secondary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TABLE_SHARE for a table. </p>
<p>Get a table definition from the table definition cache. If the share does not exist, create a new one from the persistently stored table definition, and temporarily release LOCK_open while retrieving it. Re-lock LOCK_open when the table definition has been retrieved, and broadcast this to other threads waiting for the share to become opened.</p>
<p>If the share exists, and is in the process of being opened, wait for opening to complete before continuing.</p>
<dl class="section pre"><dt>Precondition</dt><dd>It is a precondition that the caller must own LOCK_open before calling this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Callers of this function cannot rely on LOCK_open being held for the duration of the call. It may be temporarily released while the table definition is opened, and it may be temporarily released while the thread is waiting for a different thread to finish opening it.</dd>
<dd>
After share-&gt;m_open_in_progress is set, there should be no wait for resources like row- or metadata locks, table flushes, etc. Otherwise, we may end up in deadlocks that will not be detected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">db</td><td>schema name </td></tr>
    <tr><td class="paramname">table_name</td><td>table name </td></tr>
    <tr><td class="paramname">key</td><td>table cache key </td></tr>
    <tr><td class="paramname">key_length</td><td>length of key </td></tr>
    <tr><td class="paramname">open_view</td><td>allow open of view </td></tr>
    <tr><td class="paramname">open_secondary</td><td>get the share for a table in a secondary storage engine</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new TABLE_SHARE, or NULL if there was an error </dd></dl>

</div>
</div>
<a id="ga86d2ac38799538eae4c4050765bb71c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d2ac38799538eae4c4050765bb71c0">&#9670;&nbsp;</a></span>get_table_share_with_discover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* get_table_share_with_discover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>open_secondary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a table share. </p>
<p>If it didn't exist, try creating it from engine</p>
<p>For arguments and return values, see get_table_share() </p>

</div>
</div>
<a id="gacb088116a3379bebb9239a2ae50eb7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb088116a3379bebb9239a2ae50eb7f3">&#9670;&nbsp;</a></span>handle_routine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> DML_prelocking_strategy::handle_routine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how prelocking algorithm for DML statements should handle routines: </p>
<ul>
<li>For CALL statements we do unrolling (i.e. open and lock tables for each sub-statement individually). So for such statements prelocking is enabled only if stored functions are used in parameter list and only for period during which we calculate values of parameters. Thus in this strategy we ignore procedure which is directly called by such statement and extend the prelocking set only with tables/functions used by SF called from the parameter list.</li>
<li>For any other statement any routine which is directly or indirectly called by statement is going to be executed in prelocked mode. So in this case we simply add all tables and routines used by it to the prelocking set.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rt</td><td>Prelocking set element describing routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to true if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html#aff816c4dc712af6528b676cede95c6c2">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="gaaf6419a79127f2b24c3f8cce60980676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf6419a79127f2b24c3f8cce60980676">&#9670;&nbsp;</a></span>handle_routine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Alter_table_prelocking_strategy::handle_routine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how prelocking algorithm for ALTER TABLE statement should handle routines - do nothing as this statement is not supposed to call routines. </p>
<p>We still can end up in this method when someone tries to define a foreign key referencing a view, and not just a simple view, but one that uses stored routines. </p>

<p>Implements <a class="el" href="classPrelocking__strategy.html#aff816c4dc712af6528b676cede95c6c2">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga0ad363558ff64c10dc12a491bd61059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad363558ff64c10dc12a491bd61059f">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> DML_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how prelocking algorithm for DML statements should handle table list elements: </p>
<ul>
<li>If table has triggers we should add all tables and routines used by them to the prelocking set.</li>
<li>If table participates in a foreign key we should add another table from it to the prelocking set with an appropriate metadata lock.</li>
</ul>
<p>We do not need to acquire metadata locks on trigger names in DML statements, since all DDL statements that change trigger metadata always lock their subject tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to true if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html#afbfc79c3385af9040226acc73920c4e7">Prelocking_strategy</a>.</p>

<p>Reimplemented in <a class="el" href="group__Data__Dictionary.html#ga9b63bc4e37e85d1a9048f9842dc3072a">Lock_tables_prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga9b63bc4e37e85d1a9048f9842dc3072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b63bc4e37e85d1a9048f9842dc3072a">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Lock_tables_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how prelocking algorithm for LOCK TABLES statement should handle table list elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to true if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__Data__Dictionary.html#ga0ad363558ff64c10dc12a491bd61059f">DML_prelocking_strategy</a>.</p>

</div>
</div>
<a id="gadba540ab03944861b2d21475cb4b6aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadba540ab03944861b2d21475cb4b6aac">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Alter_table_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how prelocking algorithm for ALTER TABLE statement should handle table list elements. </p>
<p>Unlike in DML, we do not process triggers here. </p>

<p>Implements <a class="el" href="classPrelocking__strategy.html#afbfc79c3385af9040226acc73920c4e7">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga5811c3af47db089759894ccdc8312110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5811c3af47db089759894ccdc8312110">&#9670;&nbsp;</a></span>handle_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> DML_prelocking_strategy::handle_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how prelocking algorithm for DML statements should handle view - all view routines should be added to the prelocking set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for view. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to true if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html#a6d65358a6a1c9d4d736f828e1ed9649e">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="gafd941274d044b0aee36cb06e657a8c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd941274d044b0aee36cb06e657a8c79">&#9670;&nbsp;</a></span>handle_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Alter_table_prelocking_strategy::handle_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how prelocking algorithm for ALTER TABLE statement should handle view - do nothing. </p>
<p>We don't need to add view routines to the prelocking set in this case as view is not going to be materialized. </p>

<p>Implements <a class="el" href="classPrelocking__strategy.html#a6d65358a6a1c9d4d736f828e1ed9649e">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="gaf4988d6e5a588b697a9614d35e67a43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4988d6e5a588b697a9614d35e67a43b">&#9670;&nbsp;</a></span>in_LTM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> in_LTM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga673bd1c3a18bccbfeeaedccdc1434d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga673bd1c3a18bccbfeeaedccdc1434d8c">&#9670;&nbsp;</a></span>init_ftfuncs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> init_ftfuncs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab014a92f1538e370072fd987e2257a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab014a92f1538e370072fd987e2257a12">&#9670;&nbsp;</a></span>init_tdc_psi_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void init_tdc_psi_keys </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize performance schema instrumentation points used by the table cache. </p>

</div>
</div>
<a id="gae10e6afa3aa87d8a1961d7ee76d5f9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae10e6afa3aa87d8a1961d7ee76d5f9ed">&#9670;&nbsp;</a></span>insert_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> insert_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt;::iterator *&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>any_privileges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaff2849c2d4c8cec7a89054e0033a8707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2849c2d4c8cec7a89054e0033a8707">&#9670;&nbsp;</a></span>intern_close_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intern_close_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadfafa0701c1dfa674565f260cd89cc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfafa0701c1dfa674565f260cd89cc66">&#9670;&nbsp;</a></span>invoke_table_check_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> invoke_table_check_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke check constraints defined on the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle. </td></tr>
    <tr><td class="paramname">table</td><td>Instance of TABLE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>If all enforced check constraints are satisfied. </td></tr>
    <tr><td class="paramname">true</td><td>Otherwise. THD::is_error() may be "true" in this case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82dfde867b0b829b1c992b9e7f8e38b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82dfde867b0b829b1c992b9e7f8e38b5">&#9670;&nbsp;</a></span>is_acl_table_in_non_LTM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_acl_table_in_non_LTM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="locked__tables__list_8h.html#a77fee489173235058762d07e721b7476">enum_locked_tables_mode</a>&#160;</td>
          <td class="paramname"><em>ltm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if given TABLE_LIST is a acl table and is being read and not in LOCK TABLE mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tl</td><td>TABLE_LIST pointing to the table. </td></tr>
    <tr><td class="paramname">ltm</td><td>THD-&gt;locked_tables_mode enum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if acl table is being read, otherwise false. </dd></dl>
<p>We ignore use of ACL table,</p><ul>
<li>Under LOCK TABLE modes.</li>
<li>Under system view. E.g., I_S.ROLE_* uses CTE where they use TL_READ_DEFAULT for ACL tables. We ignore them.</li>
<li>If the TABLE_LIST is used by optimizer as placeholder.</li>
</ul>

</div>
</div>
<a id="ga747bf44763db37285677c195ca412245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747bf44763db37285677c195ca412245">&#9670;&nbsp;</a></span>is_temporary_table_being_opened()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_temporary_table_being_opened </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a table being opened is a temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>table being opened</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a table is temporary table, else false </dd></dl>

</div>
</div>
<a id="ga54b0693677aeecf9a38e98f36d3d31eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54b0693677aeecf9a38e98f36d3d31eb">&#9670;&nbsp;</a></span>list_open_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOPEN__TABLE__LIST.html">OPEN_TABLE_LIST</a>* list_open_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga066d5c2d024747314c7e3d607c135743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga066d5c2d024747314c7e3d607c135743">&#9670;&nbsp;</a></span>lock_table_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_table_names </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrealloced__array.html">Prealloced_array</a>&lt; <a class="el" href="classMDL__request.html">MDL_request</a> *, 1 &gt; *&#160;</td>
          <td class="paramname"><em>schema_reqs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire "strong" (SRO, SNW, SNRW) metadata locks on tables used by LOCK TABLES or by a DDL statement. </p>
<p>Acquire lock "S" on table being created in CREATE TABLE statement.</p>
<dl class="section note"><dt>Note</dt><dd>Under LOCK TABLES, we can't take new locks, so use open_tables_check_upgradable_mdl() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables_start</td><td>Start of list of tables on which locks should be acquired. </td></tr>
    <tr><td class="paramname">tables_end</td><td>End of list of tables. </td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitmap of flags to modify how the tables will be open, see open_table() description for details. </td></tr>
    <tr><td class="paramname">schema_reqs</td><td>When non-nullptr, pointer to array in which pointers to MDL requests for acquired schema locks to be stored. It is guaranteed that each schema will be present in this array only once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (e.g. connection was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga399ec28859bb54829b1cabbeed845f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399ec28859bb54829b1cabbeed845f78">&#9670;&nbsp;</a></span>lock_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock all tables in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Tables to lock </td></tr>
    <tr><td class="paramname">count</td><td>Number of opened tables </td></tr>
    <tr><td class="paramname">flags</td><td>Options (see mysql_lock_tables() for details)</td></tr>
  </table>
  </dd>
</dl>
<p>You can't call lock_tables() while holding thr_lock locks, as this would break the dead-lock-free handling thr_lock gives us. You must always get all needed locks at once.</p>
<p>If the query for which we are calling this function is marked as requiring prelocking, this function will change locked_tables_mode to LTM_PRELOCKED.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>A lock wait timeout, deadlock or out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24d86e270cafa0948c88e0263c6de67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24d86e270cafa0948c88e0263c6de67f">&#9670;&nbsp;</a></span>mark_common_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> mark_common_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_ref_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_ref_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *&#160;</td>
          <td class="paramname"><em>using_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>found_using_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga44874f07fb6dca6eb396c66116429d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44874f07fb6dca6eb396c66116429d14">&#9670;&nbsp;</a></span>mark_real_tables_as_free_for_reuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mark_real_tables_as_free_for_reuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7ec5ae1a68fd60a81532c4560500e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec5ae1a68fd60a81532c4560500e318">&#9670;&nbsp;</a></span>mark_temp_tables_as_free_for_reuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mark_temp_tables_as_free_for_reuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark all temporary tables which were used by the current statement or substatement as free for reuse, but only if the query_id can be cleared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For temp tables associated with a open SQL HANDLER the query_id is not reset until the HANDLER is closed. </dd></dl>

</div>
</div>
<a id="gae2cc536b80faf27a1017cf4ddcc988ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cc536b80faf27a1017cf4ddcc988ad">&#9670;&nbsp;</a></span>mark_tmp_table_for_reuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_tmp_table_for_reuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a single temporary table. </p>
<p>Effectively this "closes" one temporary table, in a session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Temporary table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1466eeeedbb2386ac9d5f9950a0cbcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1466eeeedbb2386ac9d5f9950a0cbcd8">&#9670;&nbsp;</a></span>mark_used_tables_as_free_for_reuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mark_used_tables_as_free_for_reuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2fd1268060cd8a88f03cdfdd91281a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fd1268060cd8a88f03cdfdd91281a1c">&#9670;&nbsp;</a></span>mysql_rm_tmp_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> mysql_rm_tmp_tables </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop all temporary tables which have been left from previous server run. </p>
<p>Used on server start-up.</p>
<dl class="section return"><dt>Returns</dt><dd>False on success, true on error. </dd></dl>

</div>
</div>
<a id="gab469748dd06a6477d4ce23f742af0794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab469748dd06a6477d4ce23f742af0794">&#9670;&nbsp;</a></span>open_and_lock_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_and_lock_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open all tables in list, locks them and optionally process derived tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables</td><td>List of tables for open and locking. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitmap of options to be used to open and lock tables (see open_tables() and mysql_lock_tables() for details). </td></tr>
    <tr><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The thr_lock locks will automatically be freed by close_thread_tables().</dd>
<dd>
open_and_lock_tables() is not intended for open-and-locking system tables in those cases when execution of statement has started already and other tables have been opened. Use open_trans_system_tables_for_read() instead.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK. </td></tr>
    <tr><td class="paramname">true</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6ccfe40b5eb69eade8b02ded8236a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ccfe40b5eb69eade8b02ded8236a8e">&#9670;&nbsp;</a></span>open_and_process_routine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_and_process_routine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>has_prelocking_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>routine_modifies_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle element of prelocking set other than table. </p>
<p>E.g. cache routine and, if prelocking strategy prescribes so, extend the prelocking set with tables and routines used by it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rt</td><td>Element of prelocking set to be processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how the prelocking set should be extended when one of its elements is processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">has_prelocking_list</td><td>Indicates that prelocking set/list for this statement has already been built. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ot_ctx</td><td>Context of open_table used to recover from locking failures. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to true if it was detected that this statement will require prelocked mode for its execution, not touched otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">routine_modifies_data</td><td>Set to true if it was detected that this routine does modify table data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (Conflicting metadata lock, OOM, other errors). </td></tr>
  </table>
  </dd>
</dl>
<p>We add trigger entries to lex-&gt;sroutines_list, but we don't load them here. The trigger entry is only used when building a transitive closure of objects used in a statement, to avoid adding to this closure objects that are used in the trigger more than once. E.g. if a trigger trg refers to table t2, and the trigger table t1 is used multiple times in the statement (say, because it's used in function f1() twice), we will only add t2 once to the list of tables to prelock.</p>
<p>We don't take metadata locks on triggers either: they are protected by a respective lock on the table, on which the trigger is defined.</p>
<p>The only two cases which give "trouble" are SHOW CREATE TRIGGER and DROP TRIGGER statements. For these, statement syntax doesn't specify the table on which this trigger is defined, so we have to make a "dirty" read in the data dictionary to find out the table name. Once we discover the table name, we take a metadata lock on it, and this protects all trigger operations. Of course the table, in theory, may disappear between the dirty read and metadata lock acquisition, but in that case we just return a run-time error.</p>
<p>Grammar of other trigger DDL statements (CREATE, DROP) requires the table to be specified explicitly, so we use the table metadata lock to protect trigger metadata in these statements. Similarly, in DML we always use triggers together with their tables, and thus don't need to take separate metadata locks on them.</p>

</div>
</div>
<a id="ga6bde544f5ea99298b67e368da5dd9ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bde544f5ea99298b67e368da5dd9ca9">&#9670;&nbsp;</a></span>open_and_process_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_and_process_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLEX.html">LEX</a> *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *const&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>has_prelocking_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle table list element by obtaining metadata lock, opening table or view and, if prelocking strategy prescribes so, extending the prelocking set with tables and routines used by it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lex</td><td>LEX structure for statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tables</td><td>Table list element to be processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counter</td><td>Number of tables which are open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how the prelocking set should be extended when table or view is processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">has_prelocking_list</td><td>Indicates that prelocking set/list for this statement has already been built. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ot_ctx</td><td>Context used to recover from a failed open_table() attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Error, reported unless there is a chance to recover from it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga065f6a0326ab135938fb38fd371dace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga065f6a0326ab135938fb38fd371dace5">&#9670;&nbsp;</a></span>open_log_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* open_log_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>one_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__tables__backup.html">Open_tables_backup</a> *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a log table. </p>
<p>Opening such tables is performed internally in the server implementation, and is a 'nested' open, since some tables might be already opened by the current thread. The thread context before this call is saved, and is restored when calling close_log_table(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">one_table</td><td>Log table to open </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backup</td><td>Temporary storage used to save the thread context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b5263e110baf47c9fe2f820bc649be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b5263e110baf47c9fe2f820bc649be5">&#9670;&nbsp;</a></span>open_ltable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* open_ltable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a>&#160;</td>
          <td class="paramname"><em>lock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>lock_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga86a68932d1c35b3fd820c99d185d7888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86a68932d1c35b3fd820c99d185d7888">&#9670;&nbsp;</a></span>open_n_lock_single_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* open_n_lock_single_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a>&#160;</td>
          <td class="paramname"><em>lock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open and lock one table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_l</td><td>table to open is first table in this list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_type</td><td>lock to use for table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>options to be used while opening and locking table (see open_table(), mysql_lock_tables()) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">!=</td><td>NULL OK, opened table returned </td></tr>
    <tr><td class="paramname">NULL</td><td>Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If ok, the following are also set: table_list-&gt;lock_type lock_type table_list-&gt;table table</dd>
<dd>
If table_l is a list, not a single table, the list is temporarily broken.</dd></dl>
<p>This function is meant as a replacement for open_ltable() when MERGE tables can be opened. open_ltable() cannot open MERGE tables.</p>
<p>There may be more differences between open_n_lock_single_table() and open_ltable(). One known difference is that open_ltable() does neither call thd-&gt;decide_logging_format() nor handle some other logging and locking issues because it does not call lock_tables(). </p>

</div>
</div>
<a id="ga38cb52c7e762297f8ee4e716cc8bf2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38cb52c7e762297f8ee4e716cc8bf2ab">&#9670;&nbsp;</a></span>open_secondary_engine_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_secondary_engine_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a secondary engine can be used to execute the current statement, and if so, replace the opened tables with their secondary counterparts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">flags</td><td>bitmap of flags to pass to open_table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an error is raised, false otherwise </dd></dl>

</div>
</div>
<a id="ga43cb5a9ba1064a36db89ad5c4d645528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43cb5a9ba1064a36db89ad5c4d645528">&#9670;&nbsp;</a></span>open_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a base table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td>Open first table in list. </td></tr>
    <tr><td class="paramname">ot_ctx</td><td>Context with flags which modify how open works and which is used to recover from a failed open_table() attempt. Some examples of flags: MYSQL_OPEN_IGNORE_FLUSH - Open table even if someone has done a flush. No version number checking is done. MYSQL_OPEN_HAS_MDL_LOCK - instead of acquiring metadata locks rely on that caller already has appropriate ones.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses a cache of open tables to find a TABLE instance not in use.</p>
<p>If TABLE_LIST::open_strategy is set to OPEN_IF_EXISTS, the table is opened only if it exists. If the open strategy is OPEN_STUB, the underlying table is never opened. In both cases, metadata locks are always taken according to the lock strategy.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Open failed. "action" parameter may contain type of action needed to remedy problem before retrying again. </td></tr>
    <tr><td class="paramname">false</td><td>Success. Members of TABLE_LIST structure are filled properly (e.g. TABLE_LIST::table is set for real tables and TABLE_LIST::view is set for views). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e75c08f95c113dd784ea916cea012a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e75c08f95c113dd784ea916cea012a9">&#9670;&nbsp;</a></span>open_table_entry_fini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_table_entry_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalize the process of TABLE creation by loading table triggers and taking action if a HEAP table content was emptied implicitly. </p>

</div>
</div>
<a id="ga220a2fbe9ad9cf09296fb29aaa06e537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga220a2fbe9ad9cf09296fb29aaa06e537">&#9670;&nbsp;</a></span>open_table_get_mdl_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_table_get_mdl_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> **&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to acquire an MDL lock for a table being opened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thd</td><td>Session context, to report errors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ot_ctx</td><td>Open table context, to hold the back off state. If we failed to acquire a lock due to a lock conflict, we add the failed request to the open table context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_list</td><td>Table list element for the table being opened. Its "mdl_request" member specifies the MDL lock to be requested. If we managed to acquire a ticket (no errors or lock conflicts occurred), TABLE_LIST::mdl_request contains a reference to it on return. However, is not modified if MDL lock type- modifying flags were provided. We also use TABLE_LIST::lock_type member to detect cases when MDL_SHARED_WRITE_LOW_PRIO lock should be acquired instead of the normal MDL_SHARED_WRITE lock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>flags MYSQL_OPEN_FORCE_SHARED_MDL, MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL or MYSQL_OPEN_FAIL_ON_MDL_CONFLICT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>open_table(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mdl_ticket</td><td>Only modified if there was no error. If we managed to acquire an MDL lock, contains a reference to the ticket, otherwise is set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>An error occurred. </td></tr>
    <tr><td class="paramname">false</td><td>No error, but perhaps a lock conflict, check mdl_ticket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf067903168fe13a1f93d20e2b3cc816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf067903168fe13a1f93d20e2b3cc816">&#9670;&nbsp;</a></span>open_table_uncached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* open_table_uncached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>add_to_temporary_tables_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>open_in_engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a single table without table caching and don't add it to THD::open_tables. </p>
<p>Depending on the 'add_to_temporary_tables_list' value, the opened TABLE instance will be addded to THD::temporary_tables list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">path</td><td>Path (without .frm) </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">add_to_temporary_tables_list</td><td>Specifies if the opened TABLE instance should be linked into THD::temporary_tables list. </td></tr>
    <tr><td class="paramname">open_in_engine</td><td>Indicates that we need to open table in storage engine in addition to constructing TABLE object for it. </td></tr>
    <tr><td class="paramname">table_def</td><td>A data-dictionary Table-object describing table to be used for opening.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is used:<ul>
<li>by alter_table() to open a temporary table;</li>
<li>when creating a temporary table with CREATE TEMPORARY TABLE.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TABLE instance for opened table. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59e488af7a3f47be08fad22370de07c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e488af7a3f47be08fad22370de07c5">&#9670;&nbsp;</a></span>open_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open all tables in list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start</td><td>List of tables to be open (it can be adjusted for statement that uses tables only implicitly, e.g. for "SELECT f1()"). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter</td><td>Number of tables which were open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Bitmap of flags to modify how the tables will be open, see open_table() description for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unless we are already in prelocked mode and prelocking strategy prescribes so this function will also precache all SP/SFs explicitly or implicitly (via views and triggers) used by the query and add tables needed for their execution to table list. Statement that uses SFs, invokes triggers or requires foreign key checks will be marked as requiring prelocking. Prelocked mode will be enabled for such query during lock_tables() call.</dd></dl>
<p>If query for which we are opening tables is already marked as requiring prelocking it won't do such precaching and will simply reuse table list which is already built.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Error, reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6110f4d5a33e22f209bf996dfcf8d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6110f4d5a33e22f209bf996dfcf8d57">&#9670;&nbsp;</a></span>open_tables_check_upgradable_mdl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_tables_check_upgradable_mdl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for upgradable (SNW, SNRW) metadata locks on tables to be opened for a DDL statement. </p>
<p>Under LOCK TABLES, we can't take new locks, so we must check if appropriate locks were pre-acquired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables_start</td><td>Start of list of tables on which upgradable locks should be searched for. </td></tr>
    <tr><td class="paramname">tables_end</td><td>End of list of tables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (e.g. connection was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b93d2956c1e654ebe0e48ab3503410d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b93d2956c1e654ebe0e48ab3503410d">&#9670;&nbsp;</a></span>open_tables_for_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_tables_for_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open all tables for a query or statement, in list started by "tables". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>list of tables for open </td></tr>
    <tr><td class="paramname">flags</td><td>bitmap of flags to modify how the tables will be open: MYSQL_LOCK_IGNORE_FLUSH - open table even if someone has done a flush on it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- ok </td></tr>
    <tr><td class="paramname">true</td><td>- error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is to be used on prepare stage when you don't read any data from the tables.</dd>
<dd>
Updates Query_tables_list::table_count as side-effect. </dd></dl>

</div>
</div>
<a id="gab5c68673b37e4f394de31ffe4ac80fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c68673b37e4f394de31ffe4ac80fcc">&#9670;&nbsp;</a></span>open_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a temporary table specified by TABLE_LIST instance in the cache and prepare its TABLE instance for use. </p>
<p>This function tries to resolve this table in the list of temporary tables of this thread. Temporary tables are thread-local and "shadow" base tables with the same name.</p>
<dl class="section note"><dt>Note</dt><dd>In most cases one should use open_temporary_tables() instead of this call.</dd>
<dd>
One should finalize process of opening temporary table for table list element by calling open_and_process_table(). This function is responsible for table version checking and handling of merge tables.</dd>
<dd>
We used to check global_read_lock before opening temporary tables. However, that limitation was artificial and is removed now.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>On success. If a temporary table exists for the given key, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">true</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4c1cb71807d09d53273048447abf301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c1cb71807d09d53273048447abf301">&#9670;&nbsp;</a></span>open_temporary_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_temporary_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre-open temporary tables corresponding to table list elements. </p>
<dl class="section note"><dt>Note</dt><dd>One should finalize process of opening temporary tables by calling open_tables(). This function is responsible for table version checking and handling of merge tables.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>On success. If a temporary tables exists for the given element, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">true</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac315ba0102697b41bdeeff67a61240eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac315ba0102697b41bdeeff67a61240eb">&#9670;&nbsp;</a></span>open_trans_system_tables_for_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> open_trans_system_tables_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open and lock transactional system tables for read. </p>
<p>One must call close_trans_system_tables() to close systems tables opened with this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td>List of tables to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>THR_LOCK deadlocks are not possible here because of the restrictions we put on opening and locking of system tables for writing. Thus, the system tables can be opened and locked for reading even if some other tables have already been opened and locked.</dd>
<dd>
MDL-deadlocks are possible, but they are properly detected and reported.</dd>
<dd>
Row-level deadlocks should be either avoided altogether using non-locking reads (as it is done now for InnoDB), or should be correctly detected and reported (in case of other transactional SE).</dd>
<dd>
It is now technically possible to open non-transactional tables (MyISAM system tables) using this function. That situation might still happen if the user run the server on the elder data-directory or manually alters the system tables to reside in MyISAM instead of InnoDB. It will be forbidden in the future.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ga711108427e8243b5b9a1af8bb89b84c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga711108427e8243b5b9a1af8bb89b84c9">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Table_share_deleter::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae0d20bdc45dfafc1da5d10d03b6ce9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d20bdc45dfafc1da5d10d03b6ce9b7">&#9670;&nbsp;</a></span>process_found_table_share()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* process_found_table_share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>open_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga507062befa21005f1f5029af0f332c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga507062befa21005f1f5029af0f332c45">&#9670;&nbsp;</a></span>process_table_fks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void process_table_fks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_delete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>belong_to_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process table's foreign keys (if any) by prelocking algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">share</td><td>Table's share. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">is_insert</td><td>Indicates whether statement is going to INSERT into the table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">is_update</td><td>Indicates whether statement is going to UPDATE the table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">is_delete</td><td>Indicates whether statement is going to DELETE from the table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">belong_to_view</td><td>Uppermost view which uses this table element (nullptr - if it is not used by a view). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to true if method detects that prelocking required, not changed otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec778106e0e06da7a389939084452ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec778106e0e06da7a389939084452ff7">&#9670;&nbsp;</a></span>read_histograms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> read_histograms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Schema.html">dd::Schema</a> *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Abstract__table.html">dd::Abstract_table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read any existing histogram statistics from the data dictionary and store a copy of them in the TABLE_SHARE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">share</td><td>The table share where to store the histograms </td></tr>
    <tr><td class="paramname">schema</td><td>Schema definition </td></tr>
    <tr><td class="paramname">table_def</td><td>Table definition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>on error </td></tr>
    <tr><td class="paramname">false</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24fe4cc1a004bb6b5f07556a182f945b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24fe4cc1a004bb6b5f07556a182f945b">&#9670;&nbsp;</a></span>read_lock_type_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thr__lock_8h.html#a43801b0a0281484bf8f90c80d701ccb3">thr_lock_type</a> read_lock_type_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__tables__list.html">Query_tables_list</a> *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>routine_modifies_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gade48892bc4607303f7f4d3d6df4c39de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade48892bc4607303f7f4d3d6df4c39de">&#9670;&nbsp;</a></span>recover_from_failed_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Open_table_context::recover_from_failed_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover from failed attempt of open table by performing requested action. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This function should be called only with "action" != OT_NO_ACTION and after having called </dd></dl>
<dl class="section see"><dt>See also</dt><dd>close_tables_for_reopen().</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- Success. One should try to open tables once again. </td></tr>
    <tr><td class="paramname">true</td><td>- Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab092f047cc15a6e99a876f56ab738390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab092f047cc15a6e99a876f56ab738390">&#9670;&nbsp;</a></span>release_or_close_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void release_or_close_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function which returns TABLE to Table Cache or closes if table is marked as needing re-open. </p>

</div>
</div>
<a id="ga0f27eb7444d2cec48296785a54e229f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f27eb7444d2cec48296785a54e229f2">&#9670;&nbsp;</a></span>release_table_share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void release_table_share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that we are not using table share anymore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>Table share</td></tr>
  </table>
  </dd>
</dl>
<p>If the share has no open tables and (we have done a refresh or if we have already too many open table shares) then delete the definition. </p>

</div>
</div>
<a id="ga1f79c4227effeafa7bad8b4582682e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f79c4227effeafa7bad8b4582682e9a">&#9670;&nbsp;</a></span>rename_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> rename_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf35889f70c8719510fb76899cf9cf20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf35889f70c8719510fb76899cf9cf20b">&#9670;&nbsp;</a></span>request_backoff_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Open_table_context::request_backoff_action </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpen__table__context.html#a598143ade01c51a46534ce06fbb9bbab">enum_open_table_action</a>&#160;</td>
          <td class="paramname"><em>action_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we can back-off and set back off action if we can. </p>
<p>Otherwise report and return error.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if back-off is impossible. </td></tr>
    <tr><td class="paramname">false</td><td>if we can back off. Back off action has been set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac13fc559f211cc8c19fdfcfcfa65ce5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13fc559f211cc8c19fdfcfcfa65ce5c">&#9670;&nbsp;</a></span>resolve_var_assignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> resolve_var_assignments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLEX.html">LEX</a> *&#160;</td>
          <td class="paramname"><em>lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve variable assignments from LEX object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">lex</td><td>Lex object containing variable assignments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>set_entry() must be called before fix_fields() of the whole list of field items because:</dd></dl>
<p>1) the list of field items has same order as in the query, and the Item_func_get_user_var item may go before the Item_func_set_user_var:</p>
<pre class="fragment">      SELECT @a, @a := 10 FROM t;</pre><p>2) The entry-&gt;update_query_id value controls constantness of Item_func_get_user_var items, so in presence of Item_func_set_user_var items we have to refresh their entries before fixing of Item_func_get_user_var items. </p>

</div>
</div>
<a id="ga46f17b7fae33a7238e2f2387570bc4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f17b7fae33a7238e2f2387570bc4c5">&#9670;&nbsp;</a></span>rm_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> rm_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Table.html">dd::Table</a> *&#160;</td>
          <td class="paramname"><em>table_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">base</td><td>Handlerton for table to be deleted. </td></tr>
    <tr><td class="paramname">path</td><td>Path to the table to be deleted (without an extension). </td></tr>
    <tr><td class="paramname">table_def</td><td>dd::Table object describing temporary table to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- success. </td></tr>
    <tr><td class="paramname">true</td><td>- failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed504cf321c7fd98175f80785f6be954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed504cf321c7fd98175f80785f6be954">&#9670;&nbsp;</a></span>run_before_dml_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int run_before_dml_hook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the server hook called "before_dml". </p>
<p>This is a hook originated from replication that allow server plugins to execute code before any DML instruction is executed. In case of negative outcome, it will set my_error to ER_BEFORE_DML_VALIDATION_ERROR</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hook outcome </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Everything is fine </td></tr>
    <tr><td class="paramname">!=0</td><td>Error in the outcome of the hook. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab59f6a54c7e4f0c4f0bca9b030fde625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab59f6a54c7e4f0c4f0bca9b030fde625">&#9670;&nbsp;</a></span>set_new_item_local_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> set_new_item_local_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__ident.html">Item_ident</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga452af2f8cc8e98c4a0be26673ae98530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga452af2f8cc8e98c4a0be26673ae98530">&#9670;&nbsp;</a></span>set_non_locking_read_for_ACL_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> set_non_locking_read_for_ACL_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>issue_warning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this is a ACL table is requested for read and then request InnoDB to do non-locking reads on the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tl</td><td>TABLE_LIST pointing to table being checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">issue_warning</td><td>If true, issue warning irrespective of isolation level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error. </dd></dl>
<p>Issue a warning when,</p><ul>
<li>We are skipping the SE locks in serializable</li>
<li>We are skipping the SE locks for SELECT IN SHARE MODE in all isolation mode.</li>
<li>When ACL table is not used under I_S system view.</li>
</ul>

</div>
</div>
<a id="ga13fdd979f7573b1d7a50cb49936bccf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13fdd979f7573b1d7a50cb49936bccf5">&#9670;&nbsp;</a></span>set_non_locking_read_for_IS_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> set_non_locking_read_for_IS_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this is a DD table used under a I_S view then request InnoDB to do non-locking reads on the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tl</td><td>TABLE_LIST pointing to table being checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error. </dd></dl>

</div>
</div>
<a id="ga7d98aadd638466cac7244e320c773d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d98aadd638466cac7244e320c773d7d">&#9670;&nbsp;</a></span>setup_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>want_privilege</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>allow_sum_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>split_sum_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>column_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>typed_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve a list of expressions and setup appropriate data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">want_privilege</td><td>privilege representing desired operation. whether the expressions are selected, inserted or updated, or no operation is done. will also decide inclusion in read/write maps. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_sum_func</td><td>true if set operations are allowed in context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">column_update</td><td>if true, reject expressions that do not resolve to a base table column </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">split_sum_funcs</td><td>If true, Item::split_sum_func will add hidden items to "fields". See also description in its helper method Item::split_sum_func2. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">typed_items</td><td>List of reference items for type derivation May be nullptr. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fields</td><td>list of expressions, populated with resolved data about expressions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ref_item_array</td><td>filled in with references to items.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if success </td></tr>
    <tr><td class="paramname">true</td><td>if error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function checks updatability/insertability for the table before checking column privileges, for consistent error reporting. This has consequences for columns that are specified to be updated: The column is first resolved without privilege check. This check is followed by an updatablity/insertability check. Finally, a column privilege check is run, and the column is marked for update. </dd></dl>

</div>
</div>
<a id="ga4fae60571f4ec1c1e733911087a5f5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fae60571f4ec1c1e733911087a5f5ab">&#9670;&nbsp;</a></span>setup_ftfuncs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setup_ftfuncs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga78aaa1c511d27ca98bafa279aed43c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78aaa1c511d27ca98bafa279aed43c08">&#9670;&nbsp;</a></span>setup_natural_join_row_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_natural_join_row_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>from_clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga43aae24b1aed0c36e6fb1b370e4be230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43aae24b1aed0c36e6fb1b370e4be230">&#9670;&nbsp;</a></span>store_natural_using_join_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> store_natural_using_join_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>natural_using_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_ref_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_ref_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *&#160;</td>
          <td class="paramname"><em>using_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>found_using_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga72bcb0af6f38b4d3c27aa82d9916cc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72bcb0af6f38b4d3c27aa82d9916cc8a">&#9670;&nbsp;</a></span>store_top_level_join_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> store_top_level_join_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>left_neighbor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>right_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8b09d5446051abdac04bf96a4d6a0c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b09d5446051abdac04bf96a4d6a0c12">&#9670;&nbsp;</a></span>table_def_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void table_def_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad9f57ec544a178c11c18d6900e2dcf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f57ec544a178c11c18d6900e2dcf6c">&#9670;&nbsp;</a></span>table_def_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> table_def_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabb94e7a0682741b06d662be41fae480f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb94e7a0682741b06d662be41fae480f">&#9670;&nbsp;</a></span>table_def_start_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void table_def_start_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify table definition cache that process of shutting down server has started so it has to keep number of TABLE and TABLE_SHARE objects minimal in order to reduce number of references to pluggable engines. </p>

</div>
</div>
<a id="gaaae1459addd4c75ddbf76468ba9a26a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaae1459addd4c75ddbf76468ba9a26a6">&#9670;&nbsp;</a></span>tdc_flush_unused_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tdc_flush_unused_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa566184d7e951dc20b5c2548023f4817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa566184d7e951dc20b5c2548023f4817">&#9670;&nbsp;</a></span>tdc_open_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> tdc_open_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_key_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open view by getting its definition from disk (and table cache in future). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table_list</td><td>TABLE_LIST with db, table_name &amp; belong_to_view </td></tr>
    <tr><td class="paramname">cache_key</td><td>Key for table definition cache </td></tr>
    <tr><td class="paramname">cache_key_length</td><td>Length of cache_key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true - otherwise. </dd></dl>

</div>
</div>
<a id="ga8faf6c6118b6677394e14994ae614075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8faf6c6118b6677394e14994ae614075">&#9670;&nbsp;</a></span>tdc_remove_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tdc_remove_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__base_8h.html#a66f633a9b4298fd58b5e6f22df6fbb65">enum_tdc_remove_table_type</a>&#160;</td>
          <td class="paramname"><em>remove_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>has_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all or some (depending on parameter) instances of TABLE and TABLE_SHARE from the table definition cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">remove_type</td><td>Type of removal: TDC_RT_REMOVE_ALL - remove all TABLE instances and TABLE_SHARE instance. There should be no used TABLE objects and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_NOT_OWN - remove all TABLE instances except those that belong to this thread. There should be no TABLE objects used by other threads and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_UNUSED - remove all unused TABLE instances (if there are no used instances will also remove TABLE_SHARE). TDC_RT_REMOVE_NOT_OWN_KEEP_SHARE - remove all TABLE instances except those that belong to this thread, but don't mark TABLE_SHARE as old. There should be no TABLE objects used by other threads and caller should have exclusive metadata lock on the table. </td></tr>
    <tr><td class="paramname">db</td><td>Name of database </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table </td></tr>
    <tr><td class="paramname">has_lock</td><td>If true, LOCK_open is already acquired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It assumes that table instances are already not used by any (other) thread (this should be achieved by using meta-data locks). </dd></dl>

</div>
</div>
<a id="gafa2ecba52b01f35d1ad6aa39d4ce15e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa2ecba52b01f35d1ad6aa39d4ce15e8">&#9670;&nbsp;</a></span>tdc_wait_for_old_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> tdc_wait_for_old_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>wait_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>deadlock_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if table's share is being removed from the table definition cache and, if yes, wait until the flush is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">wait_timeout</td><td>Timeout for waiting. </td></tr>
    <tr><td class="paramname">deadlock_weight</td><td>Weight of this wait for deadlock detector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. Share is up to date or has been flushed. </td></tr>
    <tr><td class="paramname">true</td><td>Error (OOM, our was killed, the wait resulted in a deadlock or timeout). Reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7829391d90c080cebbd2ef415179e65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7829391d90c080cebbd2ef415179e65b">&#9670;&nbsp;</a></span>test_if_string_in_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> test_if_string_in_list </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *&#160;</td>
          <td class="paramname"><em>str_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaaa843875426f66cde0829e5d8d6dd546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa843875426f66cde0829e5d8d6dd546">&#9670;&nbsp;</a></span>tmpkeyval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> tmpkeyval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2d2ea646b8928d2d6fabd5e114751547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2ea646b8928d2d6fabd5e114751547">&#9670;&nbsp;</a></span>unique_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>* unique_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>check_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test that the subject table of INSERT/UPDATE/DELETE/CREATE or (in case of MyISAMMRG) one of its children are not used later in the query. </p>
<p>For MyISAMMRG tables, it is assumed that all the underlying tables of <code>table</code> (if any) are listed right after it and that their <code>parent_l</code> field points at the main table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>table to be checked (must be updatable base table) </td></tr>
    <tr><td class="paramname">table_list</td><td>List of tables to check against </td></tr>
    <tr><td class="paramname">check_alias</td><td>whether to check tables' aliases</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>The table list element for the table that represents the duplicate. </td></tr>
    <tr><td class="paramname">NULL</td><td>No duplicates found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa62ea49fa4b58a38f20af4754928e1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62ea49fa4b58a38f20af4754928e1be">&#9670;&nbsp;</a></span>update_non_unique_table_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_non_unique_table_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue correct error message in case we found 2 duplicate tables which prevent some update operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>table which we try to update </td></tr>
    <tr><td class="paramname">operation</td><td>name of update operation </td></tr>
    <tr><td class="paramname">duplicate</td><td>duplicate table which we found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>here we hide view underlying tables if we have them. </dd></dl>

</div>
</div>
<a id="gab27cdf8db464ef0409b68730da644e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab27cdf8db464ef0409b68730da644e32">&#9670;&nbsp;</a></span>update_schema_options()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void update_schema_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdd_1_1Schema.html">dd::Schema</a> *&#160;</td>
          <td class="paramname"><em>sch_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update TABLE_SHARE with options from dd::Schema object. </p>

</div>
</div>
<a id="gac19a8c14e089f35b82dc7a2ded67ea4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19a8c14e089f35b82dc7a2ded67ea4b">&#9670;&nbsp;</a></span>wait_while_table_is_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> wait_while_table_is_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="my__base_8h.html#aa20e98ce19941592d59972f5ae76d387">ha_extra_function</a>&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force all other threads to stop using the table by upgrading metadata lock on it and remove unused TABLE instances from cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>Table to remove from cache </td></tr>
    <tr><td class="paramname">function</td><td>HA_EXTRA_PREPARE_FOR_DROP if table is to be deleted HA_EXTRA_FORCE_REOPEN if table is not be used HA_EXTRA_PREPARE_FOR_RENAME if table is to be renamed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When returning, the table will be unusable for other threads until metadata lock is downgraded.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (e.g. because thread was killed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga97cca55f5a645f0c01750de1cd4d4fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97cca55f5a645f0c01750de1cd4d4fe6">&#9670;&nbsp;</a></span>all_tdc_conds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__cond.html#ga7ea3e090ab413e4c5828699163a2f67d">PSI_cond_info</a> all_tdc_conds[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {&amp;<a class="code" href="group__Data__Dictionary.html#ga9a8a60d06af3d959e5c31e88d654ef5d">key_COND_open</a>, <span class="stringliteral">&quot;COND_open&quot;</span>, 0, 0, <a class="code" href="component__common_8h.html#a679b965465d040402db452656f4b4239">PSI_DOCUMENT_ME</a>}}</div><div class="ttc" id="component__common_8h_html_a679b965465d040402db452656f4b4239"><div class="ttname"><a href="component__common_8h.html#a679b965465d040402db452656f4b4239">PSI_DOCUMENT_ME</a></div><div class="ttdeci">#define PSI_DOCUMENT_ME</div><div class="ttdef"><b>Definition:</b> component_common.h:28</div></div>
<div class="ttc" id="group__Data__Dictionary_html_ga9a8a60d06af3d959e5c31e88d654ef5d"><div class="ttname"><a href="group__Data__Dictionary.html#ga9a8a60d06af3d959e5c31e88d654ef5d">key_COND_open</a></div><div class="ttdeci">static PSI_cond_key key_COND_open</div><div class="ttdef"><b>Definition:</b> sql_base.cc:279</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gadbb159f64cc354aa5df114e242b98bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb159f64cc354aa5df114e242b98bc8">&#9670;&nbsp;</a></span>all_tdc_mutexes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__mutex.html#gae85aba8881825be6e570cca2ba38da7e">PSI_mutex_info</a> all_tdc_mutexes[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    {&amp;<a class="code" href="group__Data__Dictionary.html#gab60dca1b3b1af3495883d46a09c15158">key_LOCK_open</a>, <span class="stringliteral">&quot;LOCK_open&quot;</span>, <a class="code" href="component__common_8h.html#a691825419b870b15270171abf9df134f">PSI_FLAG_SINGLETON</a>, 0, <a class="code" href="component__common_8h.html#a679b965465d040402db452656f4b4239">PSI_DOCUMENT_ME</a>}}</div><div class="ttc" id="group__Data__Dictionary_html_gab60dca1b3b1af3495883d46a09c15158"><div class="ttname"><a href="group__Data__Dictionary.html#gab60dca1b3b1af3495883d46a09c15158">key_LOCK_open</a></div><div class="ttdeci">static PSI_mutex_key key_LOCK_open</div><div class="ttdef"><b>Definition:</b> sql_base.cc:278</div></div>
<div class="ttc" id="component__common_8h_html_a691825419b870b15270171abf9df134f"><div class="ttname"><a href="component__common_8h.html#a691825419b870b15270171abf9df134f">PSI_FLAG_SINGLETON</a></div><div class="ttdeci">#define PSI_FLAG_SINGLETON</div><div class="ttdoc">Singleton flag. </div><div class="ttdef"><b>Definition:</b> component_common.h:34</div></div>
<div class="ttc" id="component__common_8h_html_a679b965465d040402db452656f4b4239"><div class="ttname"><a href="component__common_8h.html#a679b965465d040402db452656f4b4239">PSI_DOCUMENT_ME</a></div><div class="ttdeci">#define PSI_DOCUMENT_ME</div><div class="ttdef"><b>Definition:</b> component_common.h:28</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7a682517d27176617b45212332a96a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a682517d27176617b45212332a96a9d">&#9670;&nbsp;</a></span>COND_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__cond__t.html">mysql_cond_t</a> COND_open</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COND_open synchronizes concurrent opening of the same share: </p>
<p>If a thread calls get_table_share, it releases the LOCK_open mutex while reading the definition from file. If a different thread calls get_table_share for the same share at this point in time, it will find the share in the TDC, but with the m_open_in_progress flag set to true. This will make the (second) thread wait for the COND_open condition, while the first thread completes opening the table definition.</p>
<p>When the first thread is done reading the table definition, it will set m_open_in_progress to false and broadcast the COND_open condition. Then, all threads waiting for COND_open will wake up and, re-search the TDC for the share, and:</p>
<p>1) If the share is gone, the thread will continue to allocate and open the table definition. This happens, e.g., if the first thread failed when opening the table defintion and had to destroy the share. 2) If the share is still in the cache, and m_open_in_progress is still true, the thread will wait for the condition again. This happens if a different thread finished opening a different share. 3) If the share is still in the cache, and m_open_in_progress has become false, the thread will check if the share is ok (no error), increment the ref counter, and return the share. </p>

</div>
</div>
<a id="gae404dad30542c069f3db869c8cb4d5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae404dad30542c069f3db869c8cb4d5e6">&#9670;&nbsp;</a></span>end_of_unused_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> end_of_unused_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9a8a60d06af3d959e5c31e88d654ef5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8a60d06af3d959e5c31e88d654ef5d">&#9670;&nbsp;</a></span>key_COND_open</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__cond.html#gad83033d86d97d0b965b0257be7674a51">PSI_cond_key</a> key_COND_open</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab60dca1b3b1af3495883d46a09c15158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab60dca1b3b1af3495883d46a09c15158">&#9670;&nbsp;</a></span>key_LOCK_open</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__mutex.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a> key_LOCK_open</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad41c271d6f3b49310f4797fcb8b40431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad41c271d6f3b49310f4797fcb8b40431">&#9670;&nbsp;</a></span>last_table_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable__id.html">Table_id</a> last_table_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga99c8e1e3e72cd74032d5f11c486911fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c8e1e3e72cd74032d5f11c486911fd">&#9670;&nbsp;</a></span>LOCK_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__mutex__t.html">mysql_mutex_t</a> LOCK_open</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LOCK_open protects the following variables/objects: </p>
<p>1) The table_def_cache This is the hash table mapping table name to a table share object. The hash table can only be manipulated while holding LOCK_open. 2) last_table_id Generation of a new unique table_map_id for a table share is done through incrementing last_table_id, a global variable used for this purpose. 3) LOCK_open protects the initialisation of the table share object and all its members, however, it does not protect reading the .frm file from where the table share is initialised. In get_table_share, the lock is temporarily released while opening the table definition in order to allow a higher degree of concurrency. Concurrent access to the same share is controlled by introducing a condition variable for signaling when opening the share is completed. 4) In particular the share-&gt;ref_count is updated each time a new table object is created that refers to a table share. This update is protected by LOCK_open. 5) oldest_unused_share, end_of_unused_share and share-&gt;next and share-&gt;prev are variables to handle the lists of table share objects, these can only be read and manipulated while holding the LOCK_open mutex. 6) table_def_shutdown_in_progress can be updated only while holding LOCK_open and ALL table cache mutexes. 7) refresh_version This variable can only be updated while holding LOCK_open AND all table cache mutexes. 8) share-&gt;version This variable is initialised while holding LOCK_open. It can only be updated while holding LOCK_open AND all table cache mutexes. So if a table share is found through a reference its version won't change if any of those mutexes are held. 9) share-&gt;m_flush_tickets </p>

</div>
</div>
<a id="ga9133e87930df59fe74ca492acf5295f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9133e87930df59fe74ca492acf5295f7">&#9670;&nbsp;</a></span>not_found_field</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* not_found_field = (<a class="el" href="classField.html">Field</a> *)0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac130a94f4d55acec35aa42626af9f37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac130a94f4d55acec35aa42626af9f37f">&#9670;&nbsp;</a></span>not_found_item</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>** not_found_item = (<a class="el" href="classItem.html">Item</a> **)0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga99a357928bde371591f69e67d651f291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99a357928bde371591f69e67d651f291">&#9670;&nbsp;</a></span>oldest_unused_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* oldest_unused_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga41488f3f139629fcf539c519408a7ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41488f3f139629fcf539c519408a7ae2">&#9670;&nbsp;</a></span>table_def_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Data__Dictionary.html#ga3b7c6aa52a5b59656690aa16217d036e">Table_definition_cache</a>* table_def_cache</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga09d84d00803df58397d89f86a2610f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d84d00803df58397d89f86a2610f67">&#9670;&nbsp;</a></span>table_def_shutdown_in_progress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> table_def_shutdown_in_progress = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaba50986729b2cfd3be1c762e666d3d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba50986729b2cfd3be1c762e666d3d18">&#9670;&nbsp;</a></span>view_ref_found</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* view_ref_found = (<a class="el" href="classField.html">Field</a> *)0x2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
