<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/buf/buf0flu.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('buf0flu_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0flu.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The database buffer buf_pool flush algorithm.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="service__thd__wait_8h_source.html">mysql/service_thd_wait.h</a>&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;<a class="el" href="time_8h_source.html">time.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0checksum_8h_source.html">buf0checksum.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0flu_8h_source.html">buf0flu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__inttypes_8h_source.html">my_inttypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__thd__internal__api_8h_source.html">sql_thd_internal_api.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="arch0arch_8h_source.html">arch0arch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0rea_8h_source.html">buf0rea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0sysspace_8h_source.html">fsp0sysspace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__compiler_8h_source.html">my_compiler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0file_8h_source.html">os0file.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0thread-create_8h_source.html">os0thread-create.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0stage_8h_source.html">ut0stage.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpage__cleaner__slot__t.html">page_cleaner_slot_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page cleaner request state for each buffer pool instance.  <a href="structpage__cleaner__slot__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpage__cleaner__t.html">page_cleaner_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page cleaner structure common for all threads.  <a href="structpage__cleaner__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheck.html">Check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to validate the flush list.  <a href="structCheck.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceAdaptive__flush"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html">Adaptive_flush</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa4ce9aa39c4345fc00d614f78fb37e8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aa4ce9aa39c4345fc00d614f78fb37e8d">BUF_LRU_MIN_LEN</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:aa4ce9aa39c4345fc00d614f78fb37e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If LRU list of a buf_pool is less than this size then LRU eviction should not happen.  <a href="#aa4ce9aa39c4345fc00d614f78fb37e8d">More...</a><br /></td></tr>
<tr class="separator:aa4ce9aa39c4345fc00d614f78fb37e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abe88c736f003292626dadb9b91520b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a1abe88c736f003292626dadb9b91520b">BUF_FLUSH_VALIDATE_SKIP</a>&#160;&#160;&#160;23</td></tr>
<tr class="separator:a1abe88c736f003292626dadb9b91520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8e017425a8d346943e46278e4c7c5092"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a8e017425a8d346943e46278e4c7c5092">page_cleaner_state_t</a> { <a class="el" href="buf0flu_8cc.html#a8e017425a8d346943e46278e4c7c5092a85e9e6ff2614662f242d60cc0142887a">PAGE_CLEANER_STATE_NONE</a> = 0, 
<a class="el" href="buf0flu_8cc.html#a8e017425a8d346943e46278e4c7c5092a58ea007d2d1530d0646c20247c161311">PAGE_CLEANER_STATE_REQUESTED</a>, 
<a class="el" href="buf0flu_8cc.html#a8e017425a8d346943e46278e4c7c5092af50bf1c4793e161cc2fb75fbda1ccb29">PAGE_CLEANER_STATE_FLUSHING</a>, 
<a class="el" href="buf0flu_8cc.html#a8e017425a8d346943e46278e4c7c5092a8f2907c833129d797c2abecd9b927fd5">PAGE_CLEANER_STATE_FINISHED</a>
 }<tr class="memdesc:a8e017425a8d346943e46278e4c7c5092"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for page cleaner array slot.  <a href="buf0flu_8cc.html#a8e017425a8d346943e46278e4c7c5092">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8e017425a8d346943e46278e4c7c5092"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac4e6017eaf88ff9cb026accfe5a438a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ac4e6017eaf88ff9cb026accfe5a438a4">buf_flush_sync_datafiles</a> ()</td></tr>
<tr class="memdesc:ac4e6017eaf88ff9cb026accfe5a438a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a batch of writes to the datafiles that have already been written to the dblwr buffer on disk.  <a href="#ac4e6017eaf88ff9cb026accfe5a438a4">More...</a><br /></td></tr>
<tr class="separator:ac4e6017eaf88ff9cb026accfe5a438a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2e611a0c9e59a7cde86a364d149319"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a8c2e611a0c9e59a7cde86a364d149319">buf_flush_page_coordinator_thread</a> (size_t n_page_cleaners)</td></tr>
<tr class="memdesc:a8c2e611a0c9e59a7cde86a364d149319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread tasked with flushing dirty pages from the buffer pools.  <a href="#a8c2e611a0c9e59a7cde86a364d149319">More...</a><br /></td></tr>
<tr class="separator:a8c2e611a0c9e59a7cde86a364d149319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2a3eca6d146ddd040858d5188813b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aae2a3eca6d146ddd040858d5188813b0">buf_flush_page_cleaner_thread</a> ()</td></tr>
<tr class="memdesc:aae2a3eca6d146ddd040858d5188813b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread of page_cleaner.  <a href="#aae2a3eca6d146ddd040858d5188813b0">More...</a><br /></td></tr>
<tr class="separator:aae2a3eca6d146ddd040858d5188813b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761e7586969f3f27fd95463f47b08223"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a761e7586969f3f27fd95463f47b08223">incr_flush_list_size_in_bytes</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a761e7586969f3f27fd95463f47b08223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases flush_list size in bytes with the page size in inline function.  <a href="#a761e7586969f3f27fd95463f47b08223">More...</a><br /></td></tr>
<tr class="separator:a761e7586969f3f27fd95463f47b08223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351f33bda26385a52dc973fd78674843"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a351f33bda26385a52dc973fd78674843">buf_flush_validate_low</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a351f33bda26385a52dc973fd78674843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a buffer pool instance flush list.  <a href="#a351f33bda26385a52dc973fd78674843">More...</a><br /></td></tr>
<tr class="separator:a351f33bda26385a52dc973fd78674843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57786441733f7f82c504d163720fd0"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a5b57786441733f7f82c504d163720fd0">buf_flush_validate_skip</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a5b57786441733f7f82c504d163720fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the flush list some of the time.  <a href="#a5b57786441733f7f82c504d163720fd0">More...</a><br /></td></tr>
<tr class="separator:a5b57786441733f7f82c504d163720fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c445e7d4386b79b9e58e6a902f6e1ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a1c445e7d4386b79b9e58e6a902f6e1ad">buf_flush_insert_in_flush_rbt</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a1c445e7d4386b79b9e58e6a902f6e1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a block in the flush_rbt and returns a pointer to its predecessor or NULL if no predecessor.  <a href="#a1c445e7d4386b79b9e58e6a902f6e1ad">More...</a><br /></td></tr>
<tr class="separator:a1c445e7d4386b79b9e58e6a902f6e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746dcfb3778cbdec70aef3e821bfb52"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#af746dcfb3778cbdec70aef3e821bfb52">buf_flush_delete_from_flush_rbt</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:af746dcfb3778cbdec70aef3e821bfb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a bpage from the flush_rbt.  <a href="#af746dcfb3778cbdec70aef3e821bfb52">More...</a><br /></td></tr>
<tr class="separator:af746dcfb3778cbdec70aef3e821bfb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3218423965865bfb20be90854fc67a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a0a3218423965865bfb20be90854fc67a">buf_flush_block_cmp</a> (const void *p1, const void *p2)</td></tr>
<tr class="memdesc:a0a3218423965865bfb20be90854fc67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two modified blocks in the buffer pool.  <a href="#a0a3218423965865bfb20be90854fc67a">More...</a><br /></td></tr>
<tr class="separator:a0a3218423965865bfb20be90854fc67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fee1529fdf99802a4d838f15e2e00f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a4fee1529fdf99802a4d838f15e2e00f4">buf_flush_init_flush_rbt</a> (void)</td></tr>
<tr class="memdesc:a4fee1529fdf99802a4d838f15e2e00f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the red-black tree to speed up insertions into the flush_list during recovery process.  <a href="#a4fee1529fdf99802a4d838f15e2e00f4">More...</a><br /></td></tr>
<tr class="separator:a4fee1529fdf99802a4d838f15e2e00f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7e668a2ff50fe0e70ec6514061315a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a9f7e668a2ff50fe0e70ec6514061315a">buf_flush_free_flush_rbt</a> (void)</td></tr>
<tr class="memdesc:a9f7e668a2ff50fe0e70ec6514061315a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up the red-black tree.  <a href="#a9f7e668a2ff50fe0e70ec6514061315a">More...</a><br /></td></tr>
<tr class="separator:a9f7e668a2ff50fe0e70ec6514061315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47d4eda20cf0af997a5689804836808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ae47d4eda20cf0af997a5689804836808">buf_are_flush_lists_empty_validate</a> (void)</td></tr>
<tr class="memdesc:ae47d4eda20cf0af997a5689804836808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all flush lists are empty.  <a href="#ae47d4eda20cf0af997a5689804836808">More...</a><br /></td></tr>
<tr class="separator:ae47d4eda20cf0af997a5689804836808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e531650b1d5374ecbaad42b4af62c78"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a2e531650b1d5374ecbaad42b4af62c78">buf_flush_list_order_validate</a> (<a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> earlier_added_lsn, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> new_added_lsn)</td></tr>
<tr class="memdesc:a2e531650b1d5374ecbaad42b4af62c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that order of two consecutive pages in flush list would be valid, according to their oldest_modification values.  <a href="#a2e531650b1d5374ecbaad42b4af62c78">More...</a><br /></td></tr>
<tr class="separator:a2e531650b1d5374ecbaad42b4af62c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9690c1c7fabb1d832db9269900805916"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a9690c1c7fabb1d832db9269900805916">buf_flush_borrow_lsn</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a9690c1c7fabb1d832db9269900805916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrows LSN from the recent added dirty page to the flush list.  <a href="#a9690c1c7fabb1d832db9269900805916">More...</a><br /></td></tr>
<tr class="separator:a9690c1c7fabb1d832db9269900805916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ba2a4149ff800fbc5b17c270f17b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ac3ba2a4149ff800fbc5b17c270f17b75">buf_flush_insert_into_flush_list</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> <a class="el" href="xcom__base_8cc.html#a0ce0765b958f7289d206f0c78bd105c7">lsn</a>)</td></tr>
<tr class="memdesc:ac3ba2a4149ff800fbc5b17c270f17b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a modified block into the flush list.  <a href="#ac3ba2a4149ff800fbc5b17c270f17b75">More...</a><br /></td></tr>
<tr class="separator:ac3ba2a4149ff800fbc5b17c270f17b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8081c6e4fff08f1e5a2e117bb845e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ac8081c6e4fff08f1e5a2e117bb845e43">buf_flush_insert_sorted_into_flush_list</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> <a class="el" href="xcom__base_8cc.html#a0ce0765b958f7289d206f0c78bd105c7">lsn</a>)</td></tr>
<tr class="memdesc:ac8081c6e4fff08f1e5a2e117bb845e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a modified block into the flush list in the right sorted position.  <a href="#ac8081c6e4fff08f1e5a2e117bb845e43">More...</a><br /></td></tr>
<tr class="separator:ac8081c6e4fff08f1e5a2e117bb845e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62dc5b248898f799ccc3efdfa91a1a5"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab62dc5b248898f799ccc3efdfa91a1a5">buf_flush_ready_for_replace</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ab62dc5b248898f799ccc3efdfa91a1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the file page block is immediately suitable for replacement, i.e., the transition FILE_PAGE =&gt; NOT_USED allowed.  <a href="#ab62dc5b248898f799ccc3efdfa91a1a5">More...</a><br /></td></tr>
<tr class="separator:ab62dc5b248898f799ccc3efdfa91a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecec14617af55f34859e552f9df967d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aecec14617af55f34859e552f9df967d9">buf_flush_ready_for_flush</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:aecec14617af55f34859e552f9df967d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the block is modified and ready for flushing.  <a href="#aecec14617af55f34859e552f9df967d9">More...</a><br /></td></tr>
<tr class="separator:aecec14617af55f34859e552f9df967d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ecfb0cf0b18959486e8f155f60fcaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a73ecfb0cf0b18959486e8f155f60fcaf">buf_flush_remove</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a73ecfb0cf0b18959486e8f155f60fcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block from the flush list of modified blocks.  <a href="#a73ecfb0cf0b18959486e8f155f60fcaf">More...</a><br /></td></tr>
<tr class="separator:a73ecfb0cf0b18959486e8f155f60fcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3be9763cec3cba165c7b9f4897ac382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab3be9763cec3cba165c7b9f4897ac382">buf_flush_relocate_on_flush_list</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *dpage)</td></tr>
<tr class="memdesc:ab3be9763cec3cba165c7b9f4897ac382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocates a buffer control block on the flush_list.  <a href="#ab3be9763cec3cba165c7b9f4897ac382">More...</a><br /></td></tr>
<tr class="separator:ab3be9763cec3cba165c7b9f4897ac382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e3dd9b538ed985dbb702a4963374a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a40e3dd9b538ed985dbb702a4963374a9">buf_flush_write_complete</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a40e3dd9b538ed985dbb702a4963374a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the flush system data structures when a write is completed.  <a href="#a40e3dd9b538ed985dbb702a4963374a9">More...</a><br /></td></tr>
<tr class="separator:a40e3dd9b538ed985dbb702a4963374a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eec07edc8c41c7b8d17b0053f28ffee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a1eec07edc8c41c7b8d17b0053f28ffee">buf_flush_update_zip_checksum</a> (<a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, ulint size, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> <a class="el" href="xcom__base_8cc.html#a0ce0765b958f7289d206f0c78bd105c7">lsn</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> skip_lsn_check)</td></tr>
<tr class="memdesc:a1eec07edc8c41c7b8d17b0053f28ffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the checksum of a page from compressed table and update the page.  <a href="#a1eec07edc8c41c7b8d17b0053f28ffee">More...</a><br /></td></tr>
<tr class="separator:a1eec07edc8c41c7b8d17b0053f28ffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe33c34fe5f19231976b9b60753f3599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#afe33c34fe5f19231976b9b60753f3599">page_is_uncompressed_type</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="memdesc:afe33c34fe5f19231976b9b60753f3599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if page type is uncompressed.  <a href="#afe33c34fe5f19231976b9b60753f3599">More...</a><br /></td></tr>
<tr class="separator:afe33c34fe5f19231976b9b60753f3599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0d8b9bbb44ab1ea73374bfba8d6417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#afb0d8b9bbb44ab1ea73374bfba8d6417">buf_flush_init_for_writing</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, void *page_zip_, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> newest_lsn, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> skip_checksum, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> skip_lsn_check)</td></tr>
<tr class="memdesc:afb0d8b9bbb44ab1ea73374bfba8d6417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a page for writing to the tablespace.  <a href="#afb0d8b9bbb44ab1ea73374bfba8d6417">More...</a><br /></td></tr>
<tr class="separator:afb0d8b9bbb44ab1ea73374bfba8d6417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1062d51b94e2b084c044e70f2ae88ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aa1062d51b94e2b084c044e70f2ae88ef">buf_flush_write_block_low</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync)</td></tr>
<tr class="memdesc:aa1062d51b94e2b084c044e70f2ae88ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an asynchronous write of a buffer page.  <a href="#aa1062d51b94e2b084c044e70f2ae88ef">More...</a><br /></td></tr>
<tr class="separator:aa1062d51b94e2b084c044e70f2ae88ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f35ed7b257e277bb3c8bdba954bcc"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aaa4f35ed7b257e277bb3c8bdba954bcc">buf_flush_page</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync)</td></tr>
<tr class="memdesc:aaa4f35ed7b257e277bb3c8bdba954bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a flushable page asynchronously from the buffer pool to a file.  <a href="#aaa4f35ed7b257e277bb3c8bdba954bcc">More...</a><br /></td></tr>
<tr class="separator:aaa4f35ed7b257e277bb3c8bdba954bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82378da645bc734469c6c11e24a15399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a82378da645bc734469c6c11e24a15399">buf_flush_page_try</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a82378da645bc734469c6c11e24a15399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a flushable page asynchronously from the buffer pool to a file.  <a href="#a82378da645bc734469c6c11e24a15399">More...</a><br /></td></tr>
<tr class="separator:a82378da645bc734469c6c11e24a15399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279873b4458c6992089a9cbfd7b93734"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a279873b4458c6992089a9cbfd7b93734">buf_flush_check_neighbor</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:a279873b4458c6992089a9cbfd7b93734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the page is in buffer pool and can be flushed.  <a href="#a279873b4458c6992089a9cbfd7b93734">More...</a><br /></td></tr>
<tr class="separator:a279873b4458c6992089a9cbfd7b93734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4e3e8acf4267d820ea1168e19de2fd"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#abe4e3e8acf4267d820ea1168e19de2fd">buf_flush_try_neighbors</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>, ulint n_flushed, ulint n_to_flush)</td></tr>
<tr class="memdesc:abe4e3e8acf4267d820ea1168e19de2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes to disk all flushable pages within the flush area.  <a href="#abe4e3e8acf4267d820ea1168e19de2fd">More...</a><br /></td></tr>
<tr class="separator:abe4e3e8acf4267d820ea1168e19de2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb23162e99c847670f4e120ef86cb07a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aeb23162e99c847670f4e120ef86cb07a">buf_flush_page_and_try_neighbors</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>, ulint n_to_flush, ulint *<a class="el" href="myisam__ftdump_8cc.html#ad43c3812e6d13e0518d9f8b8f463ffcf">count</a>)</td></tr>
<tr class="memdesc:aeb23162e99c847670f4e120ef86cb07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the block is modified and ready for flushing.  <a href="#aeb23162e99c847670f4e120ef86cb07a">More...</a><br /></td></tr>
<tr class="separator:aeb23162e99c847670f4e120ef86cb07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00eb217491a10ca7a1811570177bf30"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ad00eb217491a10ca7a1811570177bf30">buf_free_from_unzip_LRU_list_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint max)</td></tr>
<tr class="memdesc:ad00eb217491a10ca7a1811570177bf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility moves the uncompressed frames of pages to the free list.  <a href="#ad00eb217491a10ca7a1811570177bf30">More...</a><br /></td></tr>
<tr class="separator:ad00eb217491a10ca7a1811570177bf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aad352583b7bf98ccf0005d736e4ad"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab9aad352583b7bf98ccf0005d736e4ad">buf_flush_LRU_list_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint max)</td></tr>
<tr class="memdesc:ab9aad352583b7bf98ccf0005d736e4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility flushes dirty blocks from the end of the LRU list.  <a href="#ab9aad352583b7bf98ccf0005d736e4ad">More...</a><br /></td></tr>
<tr class="separator:ab9aad352583b7bf98ccf0005d736e4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb81af9d46be9ca6afe966c01a63c375"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aeb81af9d46be9ca6afe966c01a63c375">buf_do_LRU_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint max)</td></tr>
<tr class="memdesc:aeb81af9d46be9ca6afe966c01a63c375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush and move pages from LRU or unzip_LRU list to the free list.  <a href="#aeb81af9d46be9ca6afe966c01a63c375">More...</a><br /></td></tr>
<tr class="separator:aeb81af9d46be9ca6afe966c01a63c375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab380a24de97ba79d0e6db35c7e725b"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aeab380a24de97ba79d0e6db35c7e725b">buf_do_flush_list_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint min_n, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit)</td></tr>
<tr class="memdesc:aeab380a24de97ba79d0e6db35c7e725b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility flushes dirty blocks from the end of the flush_list.  <a href="#aeab380a24de97ba79d0e6db35c7e725b">More...</a><br /></td></tr>
<tr class="separator:aeab380a24de97ba79d0e6db35c7e725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5e7a3059daaf5c13a3892619494de3"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#acc5e7a3059daaf5c13a3892619494de3">buf_flush_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>, ulint min_n, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit)</td></tr>
<tr class="memdesc:acc5e7a3059daaf5c13a3892619494de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility flushes dirty blocks from the end of the LRU list or flush_list.  <a href="#acc5e7a3059daaf5c13a3892619494de3">More...</a><br /></td></tr>
<tr class="separator:acc5e7a3059daaf5c13a3892619494de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d623d465c442fde1ffee9b4feb9e228"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a9d623d465c442fde1ffee9b4feb9e228">buf_flush_stats</a> (ulint page_count_flush, ulint page_count_LRU)</td></tr>
<tr class="memdesc:a9d623d465c442fde1ffee9b4feb9e228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather the aggregated stats for both flush list and LRU list flushing.  <a href="#a9d623d465c442fde1ffee9b4feb9e228">More...</a><br /></td></tr>
<tr class="separator:a9d623d465c442fde1ffee9b4feb9e228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123e98bfe5f927a308226cb6d7fc1622"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a123e98bfe5f927a308226cb6d7fc1622">buf_flush_start</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:a123e98bfe5f927a308226cb6d7fc1622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a buffer flush batch for LRU or flush list.  <a href="#a123e98bfe5f927a308226cb6d7fc1622">More...</a><br /></td></tr>
<tr class="separator:a123e98bfe5f927a308226cb6d7fc1622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f046fa30d716082b81862a574b8643"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a04f046fa30d716082b81862a574b8643">buf_flush_end</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:a04f046fa30d716082b81862a574b8643"><td class="mdescLeft">&#160;</td><td class="mdescRight">End a buffer flush batch for LRU or flush list.  <a href="#a04f046fa30d716082b81862a574b8643">More...</a><br /></td></tr>
<tr class="separator:a04f046fa30d716082b81862a574b8643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b6769e4f299f9c14aa375bb9eab878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a25b6769e4f299f9c14aa375bb9eab878">buf_flush_wait_batch_end</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:a25b6769e4f299f9c14aa375bb9eab878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a flush batch of the given type ends.  <a href="#a25b6769e4f299f9c14aa375bb9eab878">More...</a><br /></td></tr>
<tr class="separator:a25b6769e4f299f9c14aa375bb9eab878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42235e1e34a9f14524c48935848d2686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a42235e1e34a9f14524c48935848d2686">buf_flush_do_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> type, ulint min_n, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit, ulint *n_processed)</td></tr>
<tr class="memdesc:a42235e1e34a9f14524c48935848d2686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do flushing batch of a given type.  <a href="#a42235e1e34a9f14524c48935848d2686">More...</a><br /></td></tr>
<tr class="separator:a42235e1e34a9f14524c48935848d2686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528025409ff3ed8503e172b8ae62a6be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a528025409ff3ed8503e172b8ae62a6be">buf_flush_lists</a> (ulint min_n, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit, ulint *n_processed)</td></tr>
<tr class="memdesc:a528025409ff3ed8503e172b8ae62a6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility flushes dirty blocks from the end of the flush list of all buffer pool instances.  <a href="#a528025409ff3ed8503e172b8ae62a6be">More...</a><br /></td></tr>
<tr class="separator:a528025409ff3ed8503e172b8ae62a6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a7147265a4e12b3bb5b6cea221caf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a43a7147265a4e12b3bb5b6cea221caf4">buf_flush_single_page_from_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a43a7147265a4e12b3bb5b6cea221caf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function picks up a single page from the tail of the LRU list, flushes it (if it is dirty), removes it from page_hash and LRU list and puts it on the free list.  <a href="#a43a7147265a4e12b3bb5b6cea221caf4">More...</a><br /></td></tr>
<tr class="separator:a43a7147265a4e12b3bb5b6cea221caf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bea250231bab014cc313a472185e46"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a88bea250231bab014cc313a472185e46">buf_flush_LRU_list</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a88bea250231bab014cc313a472185e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears up tail of the LRU list of a given buffer pool instance: Put replaceable pages at the tail of LRU to the free list Flush dirty pages at the tail of LRU to the disk The depth to which we scan each buffer pool is controlled by dynamic config parameter innodb_LRU_scan_depth.  <a href="#a88bea250231bab014cc313a472185e46">More...</a><br /></td></tr>
<tr class="separator:a88bea250231bab014cc313a472185e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a471a6e27bbe81f9ccb9f39943da47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab5a471a6e27bbe81f9ccb9f39943da47">buf_flush_wait_LRU_batch_end</a> (void)</td></tr>
<tr class="memdesc:ab5a471a6e27bbe81f9ccb9f39943da47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for any possible LRU flushes that are in progress to end.  <a href="#ab5a471a6e27bbe81f9ccb9f39943da47">More...</a><br /></td></tr>
<tr class="separator:ab5a471a6e27bbe81f9ccb9f39943da47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6894ab1d587b1fa53f0b702eef5e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a8c6894ab1d587b1fa53f0b702eef5e44">Adaptive_flush::initialize</a> (ulint n_pages_last)</td></tr>
<tr class="memdesc:a8c6894ab1d587b1fa53f0b702eef5e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize flush parameters for current iteration.  <a href="namespaceAdaptive__flush.html#a8c6894ab1d587b1fa53f0b702eef5e44">More...</a><br /></td></tr>
<tr class="separator:a8c6894ab1d587b1fa53f0b702eef5e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2cd2c5406b242b18802188b7027e02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a3a2cd2c5406b242b18802188b7027e02">Adaptive_flush::set_average</a> ()</td></tr>
<tr class="memdesc:a3a2cd2c5406b242b18802188b7027e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set average LSN and page flush speed across multiple iterations.  <a href="namespaceAdaptive__flush.html#a3a2cd2c5406b242b18802188b7027e02">More...</a><br /></td></tr>
<tr class="separator:a3a2cd2c5406b242b18802188b7027e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392dd5b6d8f27d0af07445809e25562e"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a392dd5b6d8f27d0af07445809e25562e">Adaptive_flush::get_pct_for_dirty</a> ()</td></tr>
<tr class="memdesc:a392dd5b6d8f27d0af07445809e25562e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates if flushing is required based on number of dirty pages in the buffer pool.  <a href="namespaceAdaptive__flush.html#a392dd5b6d8f27d0af07445809e25562e">More...</a><br /></td></tr>
<tr class="separator:a392dd5b6d8f27d0af07445809e25562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e946b68431afb4e12b6b5367e448a05"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a4e946b68431afb4e12b6b5367e448a05">Adaptive_flush::get_pct_for_lsn</a> (<a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> age)</td></tr>
<tr class="memdesc:a4e946b68431afb4e12b6b5367e448a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates if flushing is required based on redo generation rate.  <a href="namespaceAdaptive__flush.html#a4e946b68431afb4e12b6b5367e448a05">More...</a><br /></td></tr>
<tr class="separator:a4e946b68431afb4e12b6b5367e448a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d653300f1d3f125c7afbbbf864e1b2"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#ad6d653300f1d3f125c7afbbbf864e1b2">Adaptive_flush::set_flush_target_by_lsn</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync_flush)</td></tr>
<tr class="memdesc:ad6d653300f1d3f125c7afbbbf864e1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set page flush target based on LSN change and checkpoint age.  <a href="namespaceAdaptive__flush.html#ad6d653300f1d3f125c7afbbbf864e1b2">More...</a><br /></td></tr>
<tr class="separator:ad6d653300f1d3f125c7afbbbf864e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef6924c1242079b8852257943c7b598"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#acef6924c1242079b8852257943c7b598">Adaptive_flush::set_flush_target_by_page</a> (ulint n_pages_lsn)</td></tr>
<tr class="memdesc:acef6924c1242079b8852257943c7b598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set page flush target based on dirty pages in buffer pool.  <a href="namespaceAdaptive__flush.html#acef6924c1242079b8852257943c7b598">More...</a><br /></td></tr>
<tr class="separator:acef6924c1242079b8852257943c7b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c46b652fbb1a08a32eee084d62675d"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a73c46b652fbb1a08a32eee084d62675d">Adaptive_flush::page_recommendation</a> (ulint last_pages_in, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_sync_flush)</td></tr>
<tr class="memdesc:a73c46b652fbb1a08a32eee084d62675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called approximately once every second by the page_cleaner thread, unless it is sync flushing mode, in which case it is called every small round.  <a href="namespaceAdaptive__flush.html#a73c46b652fbb1a08a32eee084d62675d">More...</a><br /></td></tr>
<tr class="separator:a73c46b652fbb1a08a32eee084d62675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f3d897efd351c0e01df7c8fb9879b"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ac29f3d897efd351c0e01df7c8fb9879b">pc_sleep_if_needed</a> (<a class="el" href="ut0ut_8h.html#a3e075761a4687069aecd2e080344189b">ib_time_monotonic_ms_t</a> next_loop_time, int64_t sig_count)</td></tr>
<tr class="memdesc:ac29f3d897efd351c0e01df7c8fb9879b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the page_cleaner thread to sleep if it has finished work in less than a second.  <a href="#ac29f3d897efd351c0e01df7c8fb9879b">More...</a><br /></td></tr>
<tr class="separator:ac29f3d897efd351c0e01df7c8fb9879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32a17f0dc7a9895adec53754ae98cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#afc32a17f0dc7a9895adec53754ae98cd">buf_flush_page_cleaner_is_active</a> ()</td></tr>
<tr class="memdesc:afc32a17f0dc7a9895adec53754ae98cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if page cleaners are active.  <a href="#afc32a17f0dc7a9895adec53754ae98cd">More...</a><br /></td></tr>
<tr class="separator:afc32a17f0dc7a9895adec53754ae98cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ffa9bb53ae04af71f6b0831832e7a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a53ffa9bb53ae04af71f6b0831832e7a8">buf_flush_page_cleaner_init</a> (size_t n_page_cleaners)</td></tr>
<tr class="memdesc:a53ffa9bb53ae04af71f6b0831832e7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize page_cleaner.  <a href="#a53ffa9bb53ae04af71f6b0831832e7a8">More...</a><br /></td></tr>
<tr class="separator:a53ffa9bb53ae04af71f6b0831832e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad0a7d0ac76bfb86abf8fe3652ae02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a08ad0a7d0ac76bfb86abf8fe3652ae02">buf_flush_page_cleaner_close</a> (void)</td></tr>
<tr class="memdesc:a08ad0a7d0ac76bfb86abf8fe3652ae02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close page_cleaner.  <a href="#a08ad0a7d0ac76bfb86abf8fe3652ae02">More...</a><br /></td></tr>
<tr class="separator:a08ad0a7d0ac76bfb86abf8fe3652ae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52132cc188612607e92f65b8349b6ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ac52132cc188612607e92f65b8349b6ea">pc_request</a> (ulint min_n, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit)</td></tr>
<tr class="memdesc:ac52132cc188612607e92f65b8349b6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests for all slots to flush all buffer pool instances.  <a href="#ac52132cc188612607e92f65b8349b6ea">More...</a><br /></td></tr>
<tr class="separator:ac52132cc188612607e92f65b8349b6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022060b72c75a618ac9330f1da74ebc5"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a022060b72c75a618ac9330f1da74ebc5">pc_flush_slot</a> (void)</td></tr>
<tr class="memdesc:a022060b72c75a618ac9330f1da74ebc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do flush for one slot.  <a href="#a022060b72c75a618ac9330f1da74ebc5">More...</a><br /></td></tr>
<tr class="separator:a022060b72c75a618ac9330f1da74ebc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89b4a08042d59cc1331cbf32322f3b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#af89b4a08042d59cc1331cbf32322f3b0">pc_wait_finished</a> (ulint *n_flushed_lru, ulint *n_flushed_list)</td></tr>
<tr class="memdesc:af89b4a08042d59cc1331cbf32322f3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all flush requests are finished.  <a href="#af89b4a08042d59cc1331cbf32322f3b0">More...</a><br /></td></tr>
<tr class="separator:af89b4a08042d59cc1331cbf32322f3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64538b18df39c11043a219828395b45d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a64538b18df39c11043a219828395b45d">buf_flush_page_cleaner_disabled_loop</a> (void)</td></tr>
<tr class="memdesc:a64538b18df39c11043a219828395b45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop used to disable page cleaner threads.  <a href="#a64538b18df39c11043a219828395b45d">More...</a><br /></td></tr>
<tr class="separator:a64538b18df39c11043a219828395b45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2cb1355911c2d1581560fc3ea299f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a6a2cb1355911c2d1581560fc3ea299f5">buf_flush_page_cleaner_disabled_debug_update</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structSYS__VAR.html">SYS_VAR</a> *var, void *var_ptr, const void *save)</td></tr>
<tr class="memdesc:a6a2cb1355911c2d1581560fc3ea299f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables page cleaner threads (coordinator and workers).  <a href="#a6a2cb1355911c2d1581560fc3ea299f5">More...</a><br /></td></tr>
<tr class="separator:a6a2cb1355911c2d1581560fc3ea299f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b8fee83b5a7a0569c8e0e9eb6d596b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ae1b8fee83b5a7a0569c8e0e9eb6d596b">buf_flush_sync_all_buf_pools</a> (void)</td></tr>
<tr class="memdesc:ae1b8fee83b5a7a0569c8e0e9eb6d596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously flush dirty blocks from the end of the flush list of all buffer pool instances.  <a href="#ae1b8fee83b5a7a0569c8e0e9eb6d596b">More...</a><br /></td></tr>
<tr class="separator:ae1b8fee83b5a7a0569c8e0e9eb6d596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0553b7e69d539966d0ff4096b2bf4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a6b0553b7e69d539966d0ff4096b2bf4c">reset_buf_flush_sync_lsn</a> ()</td></tr>
<tr class="memdesc:a6b0553b7e69d539966d0ff4096b2bf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset sync LSN if beyond current log sys LSN.  <a href="#a6b0553b7e69d539966d0ff4096b2bf4c">More...</a><br /></td></tr>
<tr class="separator:a6b0553b7e69d539966d0ff4096b2bf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d0b53149ea04d5d4afb4150a6e8f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ae5d0b53149ea04d5d4afb4150a6e8f7f">buf_flush_request_force</a> (<a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit)</td></tr>
<tr class="memdesc:ae5d0b53149ea04d5d4afb4150a6e8f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request IO burst and wake page_cleaner up.  <a href="#ae5d0b53149ea04d5d4afb4150a6e8f7f">More...</a><br /></td></tr>
<tr class="separator:ae5d0b53149ea04d5d4afb4150a6e8f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49be0031c6d9844ec4fa2bfe8bb97861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a49be0031c6d9844ec4fa2bfe8bb97861">buf_flush_validate</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a49be0031c6d9844ec4fa2bfe8bb97861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the flush list.  <a href="#a49be0031c6d9844ec4fa2bfe8bb97861">More...</a><br /></td></tr>
<tr class="separator:a49be0031c6d9844ec4fa2bfe8bb97861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d1cae1738f050554b98aa0eede40fe"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab8d1cae1738f050554b98aa0eede40fe">buf_pool_get_dirty_pages_count</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="classFlushObserver.html">FlushObserver</a> *observer)</td></tr>
<tr class="memdesc:ab8d1cae1738f050554b98aa0eede40fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any dirty pages that belong to a space id in the flush list in a particular buffer pool.  <a href="#ab8d1cae1738f050554b98aa0eede40fe">More...</a><br /></td></tr>
<tr class="separator:ab8d1cae1738f050554b98aa0eede40fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d8dc2a045471a7e137bf09fae05c4"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a9f6d8dc2a045471a7e137bf09fae05c4">buf_flush_get_dirty_pages_count</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="classFlushObserver.html">FlushObserver</a> *observer)</td></tr>
<tr class="memdesc:a9f6d8dc2a045471a7e137bf09fae05c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any dirty pages that belong to a space id in the flush list.  <a href="#a9f6d8dc2a045471a7e137bf09fae05c4">More...</a><br /></td></tr>
<tr class="separator:a9f6d8dc2a045471a7e137bf09fae05c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3202981d62523b59648d39f0226eecea"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a3202981d62523b59648d39f0226eecea">buf_lru_flush_page_count</a> = 0</td></tr>
<tr class="memdesc:a3202981d62523b59648d39f0226eecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of pages flushed through non flush_list flushes.  <a href="#a3202981d62523b59648d39f0226eecea">More...</a><br /></td></tr>
<tr class="separator:a3202981d62523b59648d39f0226eecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3827d552d589ba9607739b2974e900"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aad3827d552d589ba9607739b2974e900">buf_flush_lsn_scan_factor</a> = 3</td></tr>
<tr class="memdesc:aad3827d552d589ba9607739b2974e900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor for scan length to determine n_pages for intended oldest LSN progress.  <a href="#aad3827d552d589ba9607739b2974e900">More...</a><br /></td></tr>
<tr class="separator:aad3827d552d589ba9607739b2974e900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da8daacb4c1e7b7d4b2a30ccd350b6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a5da8daacb4c1e7b7d4b2a30ccd350b6b">buf_flush_sync_lsn</a> = 0</td></tr>
<tr class="memdesc:a5da8daacb4c1e7b7d4b2a30ccd350b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target oldest LSN for the requested flush_sync.  <a href="#a5da8daacb4c1e7b7d4b2a30ccd350b6b">More...</a><br /></td></tr>
<tr class="separator:a5da8daacb4c1e7b7d4b2a30ccd350b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89813a5f0a56b1a2baf315553652fa42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a89813a5f0a56b1a2baf315553652fa42">buf_flush_event</a></td></tr>
<tr class="memdesc:a89813a5f0a56b1a2baf315553652fa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event to synchronise with the flushing.  <a href="#a89813a5f0a56b1a2baf315553652fa42">More...</a><br /></td></tr>
<tr class="separator:a89813a5f0a56b1a2baf315553652fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0f75b6932976e19431ee9f5f550faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a7e0f75b6932976e19431ee9f5f550faf">buf_flush_tick_event</a></td></tr>
<tr class="memdesc:a7e0f75b6932976e19431ee9f5f550faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event to wait for one flushing step.  <a href="#a7e0f75b6932976e19431ee9f5f550faf">More...</a><br /></td></tr>
<tr class="separator:a7e0f75b6932976e19431ee9f5f550faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dac036692a423995a10775b6983c74"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structpage__cleaner__t.html">page_cleaner_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#af3dac036692a423995a10775b6983c74">page_cleaner</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="separator:af3dac036692a423995a10775b6983c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ded563e72647ca835048b2f4f0c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ade5ded563e72647ca835048b2f4f0c5b">innodb_page_cleaner_disabled_debug</a></td></tr>
<tr class="memdesc:ade5ded563e72647ca835048b2f4f0c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of MySQL global variable used to disable page cleaner.  <a href="#ade5ded563e72647ca835048b2f4f0c5b">More...</a><br /></td></tr>
<tr class="separator:ade5ded563e72647ca835048b2f4f0c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee942b4357d81bd69e7ec9c97ec097af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ut0ut_8h.html#a3e075761a4687069aecd2e080344189b">ib_time_monotonic_ms_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#aee942b4357d81bd69e7ec9c97ec097af">Adaptive_flush::cur_iter_time</a></td></tr>
<tr class="memdesc:aee942b4357d81bd69e7ec9c97ec097af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stamp of current iteration.  <a href="namespaceAdaptive__flush.html#aee942b4357d81bd69e7ec9c97ec097af">More...</a><br /></td></tr>
<tr class="separator:aee942b4357d81bd69e7ec9c97ec097af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe64ac01defbce1e6562ff1e4f1e77e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#afe64ac01defbce1e6562ff1e4f1e77e8">Adaptive_flush::cur_iter_lsn</a> = 0</td></tr>
<tr class="memdesc:afe64ac01defbce1e6562ff1e4f1e77e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSN at current iteration.  <a href="namespaceAdaptive__flush.html#afe64ac01defbce1e6562ff1e4f1e77e8">More...</a><br /></td></tr>
<tr class="separator:afe64ac01defbce1e6562ff1e4f1e77e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f2404f0e04d12b8729186b5f6ac5e1"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a21f2404f0e04d12b8729186b5f6ac5e1">Adaptive_flush::cur_iter_pages_dirty</a> = 0</td></tr>
<tr class="memdesc:a21f2404f0e04d12b8729186b5f6ac5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of dirty pages in flush list in current iteration.  <a href="namespaceAdaptive__flush.html#a21f2404f0e04d12b8729186b5f6ac5e1">More...</a><br /></td></tr>
<tr class="separator:a21f2404f0e04d12b8729186b5f6ac5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad3d914841609fe07116ec3569ce5d8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#abad3d914841609fe07116ec3569ce5d8">Adaptive_flush::cur_iter_dirty_pct</a> = 0</td></tr>
<tr class="memdesc:abad3d914841609fe07116ec3569ce5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dirty page percentage in buffer pool.  <a href="namespaceAdaptive__flush.html#abad3d914841609fe07116ec3569ce5d8">More...</a><br /></td></tr>
<tr class="separator:abad3d914841609fe07116ec3569ce5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa76c9bba5600dee75e31f06a01700b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ut0ut_8h.html#a3e075761a4687069aecd2e080344189b">ib_time_monotonic_ms_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a2aa76c9bba5600dee75e31f06a01700b">Adaptive_flush::prev_iter_time</a></td></tr>
<tr class="memdesc:a2aa76c9bba5600dee75e31f06a01700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stamp of previous iteration.  <a href="namespaceAdaptive__flush.html#a2aa76c9bba5600dee75e31f06a01700b">More...</a><br /></td></tr>
<tr class="separator:a2aa76c9bba5600dee75e31f06a01700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86260323764c73ad86acd2e7158c7cf"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#aa86260323764c73ad86acd2e7158c7cf">Adaptive_flush::prev_iter_pages_dirty</a> = 0</td></tr>
<tr class="memdesc:aa86260323764c73ad86acd2e7158c7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of dirty pages in flush list at previous iteration.  <a href="namespaceAdaptive__flush.html#aa86260323764c73ad86acd2e7158c7cf">More...</a><br /></td></tr>
<tr class="separator:aa86260323764c73ad86acd2e7158c7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b96dca15d892057caa98874335ae1f8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a6b96dca15d892057caa98874335ae1f8">Adaptive_flush::prev_iter_pages_flushed</a> = 0</td></tr>
<tr class="memdesc:a6b96dca15d892057caa98874335ae1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual number of pages flushed by last iteration.  <a href="namespaceAdaptive__flush.html#a6b96dca15d892057caa98874335ae1f8">More...</a><br /></td></tr>
<tr class="separator:a6b96dca15d892057caa98874335ae1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e8d17b1f118394fde15aa429980839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#af4e8d17b1f118394fde15aa429980839">Adaptive_flush::lsn_avg_rate</a> = 0</td></tr>
<tr class="memdesc:af4e8d17b1f118394fde15aa429980839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average redo generation rate.  <a href="namespaceAdaptive__flush.html#af4e8d17b1f118394fde15aa429980839">More...</a><br /></td></tr>
<tr class="separator:af4e8d17b1f118394fde15aa429980839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841387ce3fd84ae9865805cfa2c42668"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a841387ce3fd84ae9865805cfa2c42668">Adaptive_flush::page_avg_rate</a> = 0</td></tr>
<tr class="memdesc:a841387ce3fd84ae9865805cfa2c42668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average page flush rate.  <a href="namespaceAdaptive__flush.html#a841387ce3fd84ae9865805cfa2c42668">More...</a><br /></td></tr>
<tr class="separator:a841387ce3fd84ae9865805cfa2c42668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a39e9771bd43131e05eb3f4255e51d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a8a39e9771bd43131e05eb3f4255e51d3">Adaptive_flush::prev_lsn</a> = 0</td></tr>
<tr class="memdesc:a8a39e9771bd43131e05eb3f4255e51d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSN when last average rates are computed.  <a href="namespaceAdaptive__flush.html#a8a39e9771bd43131e05eb3f4255e51d3">More...</a><br /></td></tr>
<tr class="separator:a8a39e9771bd43131e05eb3f4255e51d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0430de97f5c1ae8e33ebe6545385efa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ut0ut_8h.html#a3e075761a4687069aecd2e080344189b">ib_time_monotonic_ms_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a0430de97f5c1ae8e33ebe6545385efa9">Adaptive_flush::prev_time</a></td></tr>
<tr class="memdesc:a0430de97f5c1ae8e33ebe6545385efa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stamp when last average rates are computed.  <a href="namespaceAdaptive__flush.html#a0430de97f5c1ae8e33ebe6545385efa9">More...</a><br /></td></tr>
<tr class="separator:a0430de97f5c1ae8e33ebe6545385efa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf24eb2d85e7c9cfad30c79040d7d30f"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#adf24eb2d85e7c9cfad30c79040d7d30f">Adaptive_flush::n_iterations</a> = 0</td></tr>
<tr class="memdesc:adf24eb2d85e7c9cfad30c79040d7d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of iteration till average rates are computed.  <a href="namespaceAdaptive__flush.html#adf24eb2d85e7c9cfad30c79040d7d30f">More...</a><br /></td></tr>
<tr class="separator:adf24eb2d85e7c9cfad30c79040d7d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbde4e870a4609ee20c6af28e2f4878"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAdaptive__flush.html#a0dbde4e870a4609ee20c6af28e2f4878">Adaptive_flush::sum_pages</a> = 0</td></tr>
<tr class="memdesc:a0dbde4e870a4609ee20c6af28e2f4878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pages flushed till last average rates are computed.  <a href="namespaceAdaptive__flush.html#a0dbde4e870a4609ee20c6af28e2f4878">More...</a><br /></td></tr>
<tr class="separator:a0dbde4e870a4609ee20c6af28e2f4878"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer buf_pool flush algorithm. </p>
<p>Created 11/11/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1abe88c736f003292626dadb9b91520b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abe88c736f003292626dadb9b91520b">&#9670;&nbsp;</a></span>BUF_FLUSH_VALIDATE_SKIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_FLUSH_VALIDATE_SKIP&#160;&#160;&#160;23</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4ce9aa39c4345fc00d614f78fb37e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ce9aa39c4345fc00d614f78fb37e8d">&#9670;&nbsp;</a></span>BUF_LRU_MIN_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_MIN_LEN&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If LRU list of a buf_pool is less than this size then LRU eviction should not happen. </p>
<p>This is because when we do LRU flushing we also put the blocks on free list. If LRU list is very small then we can end up in thrashing. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8e017425a8d346943e46278e4c7c5092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e017425a8d346943e46278e4c7c5092">&#9670;&nbsp;</a></span>page_cleaner_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buf0flu_8cc.html#a8e017425a8d346943e46278e4c7c5092">page_cleaner_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State for page cleaner array slot. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8e017425a8d346943e46278e4c7c5092a85e9e6ff2614662f242d60cc0142887a"></a>PAGE_CLEANER_STATE_NONE&#160;</td><td class="fielddoc"><p>Not requested any yet. </p>
<p>Moved from FINISHED by the coordinator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8e017425a8d346943e46278e4c7c5092a58ea007d2d1530d0646c20247c161311"></a>PAGE_CLEANER_STATE_REQUESTED&#160;</td><td class="fielddoc"><p>Requested but not started flushing. </p>
<p>Moved from NONE by the coordinator. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8e017425a8d346943e46278e4c7c5092af50bf1c4793e161cc2fb75fbda1ccb29"></a>PAGE_CLEANER_STATE_FLUSHING&#160;</td><td class="fielddoc"><p>Flushing is on going. </p>
<p>Moved from REQUESTED by the worker. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8e017425a8d346943e46278e4c7c5092a8f2907c833129d797c2abecd9b927fd5"></a>PAGE_CLEANER_STATE_FINISHED&#160;</td><td class="fielddoc"><p>Flushing was finished. </p>
<p>Moved from FLUSHING by the worker. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae47d4eda20cf0af997a5689804836808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47d4eda20cf0af997a5689804836808">&#9670;&nbsp;</a></span>buf_are_flush_lists_empty_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_are_flush_lists_empty_validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all flush lists are empty. </p>
<p>It is supposed to be used in single thread, during startup or shutdown. Hence it does not acquire lock and it is caller's responsibility to guarantee that flush lists are not changed in background. </p><dl class="section return"><dt>Returns</dt><dd>true if all flush lists were empty. </dd></dl>

</div>
</div>
<a id="aeab380a24de97ba79d0e6db35c7e725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab380a24de97ba79d0e6db35c7e725b">&#9670;&nbsp;</a></span>buf_do_flush_list_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_do_flush_list_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility flushes dirty blocks from the end of the flush_list. </p>
<p>The calling thread is not allowed to own any latches on pages! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_n</td><td>wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks for which the write request was queued; ULINT_UNDEFINED if there was a flush of the same type already running </dd></dl>

</div>
</div>
<a id="aeb81af9d46be9ca6afe966c01a63c375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb81af9d46be9ca6afe966c01a63c375">&#9670;&nbsp;</a></span>buf_do_LRU_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_do_LRU_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush and move pages from LRU or unzip_LRU list to the free list. </p>
<p>Whether LRU or unzip_LRU is used depends on the state of the system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>desired number of blocks in the free_list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks for which either the write request was queued or in case of unzip_LRU the number of blocks actually moved to the free list </dd></dl>

</div>
</div>
<a id="acc5e7a3059daaf5c13a3892619494de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5e7a3059daaf5c13a3892619494de3">&#9670;&nbsp;</a></span>buf_flush_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility flushes dirty blocks from the end of the LRU list or flush_list. </p>
<p>NOTE 1: in the case of an LRU flush the calling thread may own latches to pages: to avoid deadlocks, this function must be written so that it cannot end up waiting for these latches! NOTE 2: in the case of a flush list flush, the calling thread is not allowed to own any latches on pages! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>BUF_FLUSH_LRU or BUF_FLUSH_LIST; if BUF_FLUSH_LIST, then the caller must not own any latches on pages </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_n</td><td>wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>in the case of BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks for which the write request was queued </dd></dl>

</div>
</div>
<a id="a0a3218423965865bfb20be90854fc67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3218423965865bfb20be90854fc67a">&#9670;&nbsp;</a></span>buf_flush_block_cmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int buf_flush_block_cmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two modified blocks in the buffer pool. </p>
<p>The key for comparison is: key = &lt;oldest_modification, space, offset&gt; This comparison is used to maintian ordering of blocks in the buf_pool-&gt;flush_rbt. Note that for the purpose of flush_rbt, we only need to order blocks on the oldest_modification. The other two fields are used to uniquely identify the blocks. </p><dl class="section return"><dt>Returns</dt><dd>&lt; 0 if b2 &lt; b1, 0 if b2 == b1, &gt; 0 if b2 &gt; b1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>in: block1 </td></tr>
    <tr><td class="paramname">p2</td><td>in: block2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9690c1c7fabb1d832db9269900805916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9690c1c7fabb1d832db9269900805916">&#9670;&nbsp;</a></span>buf_flush_borrow_lsn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_flush_borrow_lsn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Borrows LSN from the recent added dirty page to the flush list. </p>
<p>This should be the lsn which we may use to mark pages dirtied without underlying redo records, when we add them to the flush list.</p>
<p>The lsn should be chosen in a way which will guarantee that we will not destroy checkpoint calculations if we inserted a new dirty page with such lsn to the flush list. This is strictly related to the limitations we put on the relaxed order in flush lists, which have direct impact on computation of lsn available for next checkpoint.</p>
<p>Therefore when the flush list is empty, the lsn is chosen as the maximum lsn up to which we know, that all dirty pages with smaller oldest_modification were added to the flush list.</p>
<p>This guarantees that the limitations put on the relaxed order are hold and lsn available for next checkpoint is not miscalculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the borrowed newest_modification of the page or lsn up to which all dirty pages were added to the flush list if the flush list is empty </dd></dl>

</div>
</div>
<a id="a279873b4458c6992089a9cbfd7b93734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279873b4458c6992089a9cbfd7b93734">&#9670;&nbsp;</a></span>buf_flush_check_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_check_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the page is in buffer pool and can be flushed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the page can be flushed. </dd></dl>

</div>
</div>
<a id="af746dcfb3778cbdec70aef3e821bfb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746dcfb3778cbdec70aef3e821bfb52">&#9670;&nbsp;</a></span>buf_flush_delete_from_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_delete_from_flush_rbt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a bpage from the flush_rbt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: bpage to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42235e1e34a9f14524c48935848d2686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42235e1e34a9f14524c48935848d2686">&#9670;&nbsp;</a></span>buf_flush_do_batch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_do_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do flushing batch of a given type. </p>
<p>NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>flush type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_n</td><td>wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_processed</td><td>the number of pages which were processed is passed back to caller. Ignored if NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if a batch was queued successfully. </td></tr>
    <tr><td class="paramname">false</td><td>if another batch of same type was already running. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04f046fa30d716082b81862a574b8643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f046fa30d716082b81862a574b8643">&#9670;&nbsp;</a></span>buf_flush_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End a buffer flush batch for LRU or flush list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f7e668a2ff50fe0e70ec6514061315a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7e668a2ff50fe0e70ec6514061315a">&#9670;&nbsp;</a></span>buf_flush_free_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_free_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees up the red-black tree. </p>

</div>
</div>
<a id="a9f6d8dc2a045471a7e137bf09fae05c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6d8dc2a045471a7e137bf09fae05c4">&#9670;&nbsp;</a></span>buf_flush_get_dirty_pages_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_get_dirty_pages_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlushObserver.html">FlushObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if there are any dirty pages that belong to a space id in the flush list. </p>
<dl class="section return"><dt>Returns</dt><dd>number of dirty pages present in all the buffer pools </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id to check </td></tr>
    <tr><td class="paramname">observer</td><td>in: flush observer to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fee1529fdf99802a4d838f15e2e00f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fee1529fdf99802a4d838f15e2e00f4">&#9670;&nbsp;</a></span>buf_flush_init_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_init_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the red-black tree to speed up insertions into the flush_list during recovery process. </p>
<p>Should be called at the start of recovery process before any page has been read/written. </p>

</div>
</div>
<a id="afb0d8b9bbb44ab1ea73374bfba8d6417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0d8b9bbb44ab1ea73374bfba8d6417">&#9670;&nbsp;</a></span>buf_flush_init_for_writing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_init_for_writing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>page_zip_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>newest_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>skip_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>skip_lsn_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a page for writing to the tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block; NULL if bypassing the buffer pool </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page</td><td>page frame </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page_zip_</td><td>compressed page, or NULL if uncompressed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newest_lsn</td><td>newest modification LSN to the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_checksum</td><td>whether to disable the page checksum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_lsn_check</td><td>true to skip check for LSN (in DEBUG) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c445e7d4386b79b9e58e6a902f6e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c445e7d4386b79b9e58e6a902f6e1ad">&#9670;&nbsp;</a></span>buf_flush_insert_in_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_flush_insert_in_flush_rbt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a block in the flush_rbt and returns a pointer to its predecessor or NULL if no predecessor. </p>
<p>The ordering is maintained on the basis of the &lt;oldest_modification, space, offset&gt; key. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the predecessor or NULL if no predecessor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: bpage to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3ba2a4149ff800fbc5b17c270f17b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ba2a4149ff800fbc5b17c270f17b75">&#9670;&nbsp;</a></span>buf_flush_insert_into_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_insert_into_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a modified block into the flush list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in/out: block which is modified </td></tr>
    <tr><td class="paramname">lsn</td><td>in: oldest modification </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8081c6e4fff08f1e5a2e117bb845e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8081c6e4fff08f1e5a2e117bb845e43">&#9670;&nbsp;</a></span>buf_flush_insert_sorted_into_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_insert_sorted_into_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a modified block into the flush list in the right sorted position. </p>
<p>This function is used by recovery, because there the modifications do not necessarily come in the order of lsn's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in/out: block which is modified </td></tr>
    <tr><td class="paramname">lsn</td><td>in: oldest modification </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e531650b1d5374ecbaad42b4af62c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e531650b1d5374ecbaad42b4af62c78">&#9670;&nbsp;</a></span>buf_flush_list_order_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_list_order_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>earlier_added_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>new_added_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that order of two consecutive pages in flush list would be valid, according to their oldest_modification values. </p>
<dl class="section remark"><dt>Remarks</dt><dd>We have a relaxed order in flush list, but still we have guarantee, that the earliest added page has oldest_modification not greater than minimum oldest_midification of all dirty pages by more than number of slots in the log recent closed buffer.</dd></dl>
<p>This is used by assertions only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">earlier_added_lsn</td><td>oldest_modification of page which was added to flush list earlier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_added_lsn</td><td>oldest_modification of page which is being added to flush list </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the order is valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_reclaim_space">Reclaiming space in redo log</a> </dd>
<dd>
<a class="el" href="PAGE_INNODB_REDO_LOG_BUF.html#sect_redo_log_add_dirty_pages">Adding dirty pages to flush lists</a> </dd></dl>

</div>
</div>
<a id="a528025409ff3ed8503e172b8ae62a6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528025409ff3ed8503e172b8ae62a6be">&#9670;&nbsp;</a></span>buf_flush_lists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_lists </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility flushes dirty blocks from the end of the flush list of all buffer pool instances. </p>
<p>NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_n</td><td>wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_processed</td><td>the number of pages which were processed is passed back to caller. Ignored if NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a batch was queued successfully for each buffer pool instance. false if another batch of same type was already running in at least one of the buffer pool instance </dd></dl>

</div>
</div>
<a id="a88bea250231bab014cc313a472185e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bea250231bab014cc313a472185e46">&#9670;&nbsp;</a></span>buf_flush_LRU_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_LRU_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears up tail of the LRU list of a given buffer pool instance: Put replaceable pages at the tail of LRU to the free list Flush dirty pages at the tail of LRU to the disk The depth to which we scan each buffer pool is controlled by dynamic config parameter innodb_LRU_scan_depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total pages flushed </dd></dl>

</div>
</div>
<a id="ab9aad352583b7bf98ccf0005d736e4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aad352583b7bf98ccf0005d736e4ad">&#9670;&nbsp;</a></span>buf_flush_LRU_list_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_LRU_list_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility flushes dirty blocks from the end of the LRU list. </p>
<p>The calling thread is not allowed to own any latches on pages! It attempts to make 'max' blocks available in the free list. Note that it is a best effort attempt and it is not guaranteed that after a call to this function there will be 'max' blocks in the free list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>desired number for blocks in the free_list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks for which the write request was queued. </dd></dl>

</div>
</div>
<a id="aaa4f35ed7b257e277bb3c8bdba954bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f35ed7b257e277bb3c8bdba954bcc">&#9670;&nbsp;</a></span>buf_flush_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_flush_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a flushable page asynchronously from the buffer pool to a file. </p>
<p>NOTE: 1. in simulated aio we must call os_aio_simulated_wake_handler_threads after we have posted a batch of writes! 2. buf_page_get_mutex(bpage) must be held upon entering this function. The LRU list mutex must be held if flush_type == BUF_FLUSH_SINGLE_PAGE. Both mutexes will be released by this function if it returns true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>type of flush </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>true if sync IO request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if page was flushed </dd></dl>

</div>
</div>
<a id="aeb23162e99c847670f4e120ef86cb07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb23162e99c847670f4e120ef86cb07a">&#9670;&nbsp;</a></span>buf_flush_page_and_try_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_page_and_try_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_to_flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the block is modified and ready for flushing. </p>
<p>If ready to flush then flush the page and try o flush its neighbors. The caller must hold the buffer pool list mutex corresponding to the type of flush. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer control block, must be buf_page_in_file(bpage) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_to_flush</td><td>number of pages to flush </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">count</td><td>number of pages flushed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the list mutex was released during this function. This does not guarantee that some pages were written as well. </dd></dl>

</div>
</div>
<a id="a08ad0a7d0ac76bfb86abf8fe3652ae02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ad0a7d0ac76bfb86abf8fe3652ae02">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_page_cleaner_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close page_cleaner. </p>

</div>
</div>
<a id="a6a2cb1355911c2d1581560fc3ea299f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2cb1355911c2d1581560fc3ea299f5">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_disabled_debug_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_page_cleaner_disabled_debug_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSYS__VAR.html">SYS_VAR</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>var_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>save</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables page cleaner threads (coordinator and workers). </p>
<p>It's used by: SET GLOBAL innodb_page_cleaner_disabled_debug = 1 (0). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>pointer to system variable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">var_ptr</td><td>where the formal string goes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save</td><td>immediate result from check function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64538b18df39c11043a219828395b45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64538b18df39c11043a219828395b45d">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_disabled_loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_page_cleaner_disabled_loop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loop used to disable page cleaner threads. </p>

</div>
</div>
<a id="a53ffa9bb53ae04af71f6b0831832e7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ffa9bb53ae04af71f6b0831832e7a8">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_page_cleaner_init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_page_cleaners</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize page_cleaner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_page_cleaners</td><td>Number of page cleaner threads to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc32a17f0dc7a9895adec53754ae98cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc32a17f0dc7a9895adec53754ae98cd">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_page_cleaner_is_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if page cleaners are active. </p>
<p>Checks if the page_cleaner is in active state.</p>

</div>
</div>
<a id="aae2a3eca6d146ddd040858d5188813b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2a3eca6d146ddd040858d5188813b0">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_page_cleaner_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread of page_cleaner. </p>

</div>
</div>
<a id="a8c2e611a0c9e59a7cde86a364d149319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2e611a0c9e59a7cde86a364d149319">&#9670;&nbsp;</a></span>buf_flush_page_coordinator_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_page_coordinator_thread </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_page_cleaners</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread tasked with flushing dirty pages from the buffer pools. </p>
<p>As of now we'll have only one coordinator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_page_cleaners</td><td>Number of page cleaner threads to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82378da645bc734469c6c11e24a15399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82378da645bc734469c6c11e24a15399">&#9670;&nbsp;</a></span>buf_flush_page_try()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_page_try </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a flushable page asynchronously from the buffer pool to a file. </p>
<p>NOTE: block and LRU list mutexes must be held upon entering this function, and they will be released by this function after flushing. This is loosely based on buf_flush_batch() and buf_flush_page(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>buffer control block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the page was flushed and the mutex released </dd></dl>

</div>
</div>
<a id="aecec14617af55f34859e552f9df967d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecec14617af55f34859e552f9df967d9">&#9670;&nbsp;</a></span>buf_flush_ready_for_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_ready_for_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the block is modified and ready for flushing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer control block, must be buf_page_in_file() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>type of flush </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if can flush immediately </dd></dl>

</div>
</div>
<a id="ab62dc5b248898f799ccc3efdfa91a1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62dc5b248898f799ccc3efdfa91a1a5">&#9670;&nbsp;</a></span>buf_flush_ready_for_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_flush_ready_for_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the file page block is immediately suitable for replacement, i.e., the transition FILE_PAGE =&gt; NOT_USED allowed. </p>
<p>The caller must hold the LRU list and block mutexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer control block, must be buf_page_in_file() and in the LRU list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if can replace immediately </dd></dl>

</div>
</div>
<a id="ab3be9763cec3cba165c7b9f4897ac382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3be9763cec3cba165c7b9f4897ac382">&#9670;&nbsp;</a></span>buf_flush_relocate_on_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_relocate_on_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relocates a buffer control block on the flush_list. </p>
<p>Note that it is assumed that the contents of bpage have already been copied to dpage. IMPORTANT: When this function is called bpage and dpage are not exact copies of each other. For example, they both will have different "::state". Also the "::list" pointers in dpage may be stale. We need to use the current list node (bpage) to do the list manipulation because the list pointers could have changed between the time that we copied the contents of bpage to the dpage and the flush list manipulation below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block being moved </td></tr>
    <tr><td class="paramname">dpage</td><td>in/out: destination block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ecfb0cf0b18959486e8f155f60fcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ecfb0cf0b18959486e8f155f60fcaf">&#9670;&nbsp;</a></span>buf_flush_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a block from the flush list of modified blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d0b53149ea04d5d4afb4150a6e8f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d0b53149ea04d5d4afb4150a6e8f7f">&#9670;&nbsp;</a></span>buf_flush_request_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_request_force </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request IO burst and wake page_cleaner up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>upper limit of LSN to be flushed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we requested higher lsn than ever requested so far </dd></dl>

</div>
</div>
<a id="a43a7147265a4e12b3bb5b6cea221caf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a7147265a4e12b3bb5b6cea221caf4">&#9670;&nbsp;</a></span>buf_flush_single_page_from_LRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_single_page_from_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function picks up a single page from the tail of the LRU list, flushes it (if it is dirty), removes it from page_hash and LRU list and puts it on the free list. </p>
<p>It is called from user threads when they are unable to find a replaceable page at the tail of the LRU list i.e.: when the background LRU flushing in the page_cleaner thread is not fast enough to keep pace with the workload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success. </dd></dl>

</div>
</div>
<a id="a123e98bfe5f927a308226cb6d7fc1622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123e98bfe5f927a308226cb6d7fc1622">&#9670;&nbsp;</a></span>buf_flush_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_flush_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a buffer flush batch for LRU or flush list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d623d465c442fde1ffee9b4feb9e228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d623d465c442fde1ffee9b4feb9e228">&#9670;&nbsp;</a></span>buf_flush_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_stats </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_count_flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_count_LRU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather the aggregated stats for both flush list and LRU list flushing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_count_flush</td><td>number of pages flushed from the end of the flush_list </td></tr>
    <tr><td class="paramname">page_count_LRU</td><td>number of pages flushed from the end of the LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1b8fee83b5a7a0569c8e0e9eb6d596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b8fee83b5a7a0569c8e0e9eb6d596b">&#9670;&nbsp;</a></span>buf_flush_sync_all_buf_pools()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_sync_all_buf_pools </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously flush dirty blocks from the end of the flush list of all buffer pool instances. </p>
<p>NOTE: The calling thread is not allowed to own any latches on pages! </p>

</div>
</div>
<a id="ac4e6017eaf88ff9cb026accfe5a438a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6017eaf88ff9cb026accfe5a438a4">&#9670;&nbsp;</a></span>buf_flush_sync_datafiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_sync_datafiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush a batch of writes to the datafiles that have already been written to the dblwr buffer on disk. </p>

</div>
</div>
<a id="abe4e3e8acf4267d820ea1168e19de2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4e3e8acf4267d820ea1168e19de2fd">&#9670;&nbsp;</a></span>buf_flush_try_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_try_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_flushed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_to_flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes to disk all flushable pages within the flush area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_flushed</td><td>number of pages flushed so far in this batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_to_flush</td><td>maximum number of pages we are allowed to flush </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of pages flushed </dd></dl>

</div>
</div>
<a id="a1eec07edc8c41c7b8d17b0053f28ffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eec07edc8c41c7b8d17b0053f28ffee">&#9670;&nbsp;</a></span>buf_flush_update_zip_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_update_zip_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>skip_lsn_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the checksum of a page from compressed table and update the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page</td><td>page to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>compressed page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn</td><td>LSN to stamp on the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_lsn_check</td><td>true to skip check for lsn (in DEBUG) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49be0031c6d9844ec4fa2bfe8bb97861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49be0031c6d9844ec4fa2bfe8bb97861">&#9670;&nbsp;</a></span>buf_flush_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the flush list. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>

</div>
</div>
<a id="a351f33bda26385a52dc973fd78674843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351f33bda26385a52dc973fd78674843">&#9670;&nbsp;</a></span>buf_flush_validate_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_validate_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate a buffer pool instance flush list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>Instance to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a5b57786441733f7f82c504d163720fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57786441733f7f82c504d163720fd0">&#9670;&nbsp;</a></span>buf_flush_validate_skip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_flush_validate_skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the flush list some of the time. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok or the check was skipped </dd></dl>
<p>Try buf_flush_validate_low() every this many times </p><pre class="fragment">The buf_flush_validate_low() call skip counter.
</pre><p> Use a signed type because of the race condition below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: Buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25b6769e4f299f9c14aa375bb9eab878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b6769e4f299f9c14aa375bb9eab878">&#9670;&nbsp;</a></span>buf_flush_wait_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_wait_batch_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a flush batch of the given type ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>Buffer pool instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>Flush type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5a471a6e27bbe81f9ccb9f39943da47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a471a6e27bbe81f9ccb9f39943da47">&#9670;&nbsp;</a></span>buf_flush_wait_LRU_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_wait_LRU_batch_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for any possible LRU flushes that are in progress to end. </p>

</div>
</div>
<a id="aa1062d51b94e2b084c044e70f2ae88ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1062d51b94e2b084c044e70f2ae88ef">&#9670;&nbsp;</a></span>buf_flush_write_block_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_write_block_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an asynchronous write of a buffer page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer block to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>type of flush </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>true if sync IO request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e3dd9b538ed985dbb702a4963374a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e3dd9b538ed985dbb702a4963374a9">&#9670;&nbsp;</a></span>buf_flush_write_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_write_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the flush system data structures when a write is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad00eb217491a10ca7a1811570177bf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00eb217491a10ca7a1811570177bf30">&#9670;&nbsp;</a></span>buf_free_from_unzip_LRU_list_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_free_from_unzip_LRU_list_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility moves the uncompressed frames of pages to the free list. </p>
<p>Note that this function does not actually flush any data to disk. It just detaches the uncompressed frames from the compressed pages at the tail of the unzip_LRU and puts those freed frames in the free list. Note that it is a best effort attempt and it is not guaranteed that after a call to this function there will be 'max' blocks in the free list. The caller must hold the LRU list mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>desired number of blocks in the free_list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of blocks moved to the free list. </dd></dl>

</div>
</div>
<a id="ab8d1cae1738f050554b98aa0eede40fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d1cae1738f050554b98aa0eede40fe">&#9670;&nbsp;</a></span>buf_pool_get_dirty_pages_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_get_dirty_pages_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlushObserver.html">FlushObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are any dirty pages that belong to a space id in the flush list in a particular buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of dirty pages present in a single buffer pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
    <tr><td class="paramname">id</td><td>in: space id to check </td></tr>
    <tr><td class="paramname">observer</td><td>in: flush observer to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a761e7586969f3f27fd95463f47b08223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761e7586969f3f27fd95463f47b08223">&#9670;&nbsp;</a></span>incr_flush_list_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void incr_flush_list_size_in_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases flush_list size in bytes with the page size in inline function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: control block </td></tr>
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe33c34fe5f19231976b9b60753f3599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe33c34fe5f19231976b9b60753f3599">&#9670;&nbsp;</a></span>page_is_uncompressed_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> page_is_uncompressed_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if page type is uncompressed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>page frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if uncompressed page type. </dd></dl>

</div>
</div>
<a id="a022060b72c75a618ac9330f1da74ebc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022060b72c75a618ac9330f1da74ebc5">&#9670;&nbsp;</a></span>pc_flush_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint pc_flush_slot </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do flush for one slot. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of the slots which has not been treated yet. </dd></dl>

</div>
</div>
<a id="ac52132cc188612607e92f65b8349b6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52132cc188612607e92f65b8349b6ea">&#9670;&nbsp;</a></span>pc_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pc_request </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests for all slots to flush all buffer pool instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_n</td><td>wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big) </td></tr>
    <tr><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac29f3d897efd351c0e01df7c8fb9879b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29f3d897efd351c0e01df7c8fb9879b">&#9670;&nbsp;</a></span>pc_sleep_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint pc_sleep_if_needed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ut0ut_8h.html#a3e075761a4687069aecd2e080344189b">ib_time_monotonic_ms_t</a>&#160;</td>
          <td class="paramname"><em>next_loop_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>sig_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the page_cleaner thread to sleep if it has finished work in less than a second. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>wake up by event set, </td></tr>
    <tr><td class="paramname">OS_SYNC_TIME_EXCEEDED</td><td>if timeout was exceeded </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_loop_time</td><td>time when next loop iteration should start </td></tr>
    <tr><td class="paramname">sig_count</td><td>zero or the value returned by previous call of os_event_reset() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af89b4a08042d59cc1331cbf32322f3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89b4a08042d59cc1331cbf32322f3b0">&#9670;&nbsp;</a></span>pc_wait_finished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> pc_wait_finished </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_flushed_lru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_flushed_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until all flush requests are finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_flushed_lru</td><td>number of pages flushed from the end of the LRU list. </td></tr>
    <tr><td class="paramname">n_flushed_list</td><td>number of pages flushed from the end of the flush_list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all flush_list flushing batch were success. </dd></dl>

</div>
</div>
<a id="a6b0553b7e69d539966d0ff4096b2bf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0553b7e69d539966d0ff4096b2bf4c">&#9670;&nbsp;</a></span>reset_buf_flush_sync_lsn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_buf_flush_sync_lsn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset sync LSN if beyond current log sys LSN. </p>
<p>Currently used when redo logging is disabled. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a89813a5f0a56b1a2baf315553652fa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89813a5f0a56b1a2baf315553652fa42">&#9670;&nbsp;</a></span>buf_flush_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> buf_flush_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event to synchronise with the flushing. </p>

</div>
</div>
<a id="aad3827d552d589ba9607739b2974e900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3827d552d589ba9607739b2974e900">&#9670;&nbsp;</a></span>buf_flush_lsn_scan_factor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_flush_lsn_scan_factor = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factor for scan length to determine n_pages for intended oldest LSN progress. </p>

</div>
</div>
<a id="a5da8daacb4c1e7b7d4b2a30ccd350b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da8daacb4c1e7b7d4b2a30ccd350b6b">&#9670;&nbsp;</a></span>buf_flush_sync_lsn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_flush_sync_lsn = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target oldest LSN for the requested flush_sync. </p>

</div>
</div>
<a id="a7e0f75b6932976e19431ee9f5f550faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0f75b6932976e19431ee9f5f550faf">&#9670;&nbsp;</a></span>buf_flush_tick_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> buf_flush_tick_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event to wait for one flushing step. </p>

</div>
</div>
<a id="a3202981d62523b59648d39f0226eecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3202981d62523b59648d39f0226eecea">&#9670;&nbsp;</a></span>buf_lru_flush_page_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_lru_flush_page_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of pages flushed through non flush_list flushes. </p>

</div>
</div>
<a id="ade5ded563e72647ca835048b2f4f0c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5ded563e72647ca835048b2f4f0c5b">&#9670;&nbsp;</a></span>innodb_page_cleaner_disabled_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> innodb_page_cleaner_disabled_debug</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of MySQL global variable used to disable page cleaner. </p>

</div>
</div>
<a id="af3dac036692a423995a10775b6983c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dac036692a423995a10775b6983c74">&#9670;&nbsp;</a></span>page_cleaner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__cleaner__t.html">page_cleaner_t</a>* page_cleaner = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_19e7dc57837d445aa8a255d4d3e40a16.html">buf</a></li><li class="navelem"><a class="el" href="buf0flu_8cc.html">buf0flu.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
