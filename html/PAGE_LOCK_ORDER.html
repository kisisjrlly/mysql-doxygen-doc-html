<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Lock Order</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PAGE_LOCK_ORDER.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lock Order </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>MySQL LOCK ORDER</p>
<h1><a class="anchor" id="LO_MAIN_INTRO"></a>
Introduction</h1>
<p>LOCK ORDER is a debugging tool used to enforce that no deadlocks can happen in the server.</p>
<p>The general idea is as follows.</p>
<p>Every mutex is instrumented by the performance schema, and is assigned a name already.</p>
<p>There is a global, unique, oriented graph, that describes the lock sequences allowed during runtime.</p>
<p>Instrumented mutexes are nodes in the graph.</p>
<p>When some code locks mutex A then B, there is an explicit A -&gt; B edge in the graph.</p>
<p>During runtime execution, the LOCK ORDER tool checks whether the actual locks taken comply with the graph.</p>
<p>Should any test not comply,</p><ul>
<li>either the arc is considered valid, so the graph is incomplete, and it should be amended (provided there are no cycles), to describe more accurately actual dependencies,</li>
<li>or the lock sequence is deemed illegal, in which case the code should be changed to avoid it.</li>
</ul>
<p>Once a state is achieved where:</p><ul>
<li>the graph has no cycle,</li>
<li>the entire test suite executes within the graph constraints,</li>
</ul>
<p>then the server is guaranteed to have no dead locks.</p>
<p>The beauty of this approach is that there is no need to run tests concurrently to expose deadlocks.</p>
<p>When statements are executed, even alone in a single session, any statement that causes an execution path to be not compliant will be detected, and reported.</p>
<h1><a class="anchor" id="LO_BUILDING"></a>
Building the code</h1>
<p>LOCK ORDER is a debugging tool only. It should not be used in production.</p>
<p><code>CMAKE</code> contains a new build option <code>WITH_LOCK_ORDER</code>, to build with the tool.</p>
<h1><a class="anchor" id="LO_RUNNING"></a>
Running MySQL test with LOCK ORDER</h1>
<p>To run a test without LOCK ORDER, use any of the following:</p>
<pre class="fragment">  ./mtr --lock-order=0 main.parser</pre><pre class="fragment">  export MTR_LOCK_ORDER=0
  ./mtr main.parser</pre><p>To run a test with LOCK_ORDER, use any of the following:</p>
<pre class="fragment">  ./mtr --lock-order=1 main.parser</pre><pre class="fragment">  export MTR_LOCK_ORDER=1
  ./mtr main.parser</pre><p>By default, LOCK ORDER is disabled in mysql-test-run.</p>
<p>Executing a test with LOCK_ORDER enabled will have the following effects:</p>
<ul>
<li>the file <code>lock_order_dependencies.txt</code> is read by the tool, to load the graph to enforce.</li>
<li>the file <code>lock_order-</code>(timestamp)-(pid).log is written by the tool, and contains various messages.</li>
<li>optionally, the file <code>lock_order.txt</code> is written, and contains a textual representation of the graph, with some analysis.</li>
</ul>
<h1><a class="anchor" id="LO_FILE_FORMATS"></a>
Lock order file formats</h1>
<h2><a class="anchor" id="LO_DEPENDENCIES"></a>
lock_order_dependencies file</h2>
<p>The default dependencies file is <code></code>(root)/mysql-test/lock_order_dependencies.txt.</p>
<p>To use a different dependencies file, use the <code>lock_order_dependencies</code> system variable.</p>
<p>The file format is text, with one line per declaration.</p>
<h3><a class="anchor" id="LO_DEP_MUTEX"></a>
Mutex nodes</h3>
<p>Every node is named from the performance schema instrumentation, with a shorter prefix.</p>
<p>For example, the mutex <code>mysql_mutex_t</code> <code>LOCK_open</code> is named "wait/synch/mutex/sql/LOCK_open" in the performance schema, simplified as "mutex/sql/LOCK_open" in LOCK ORDER.</p>
<p>When the code locks A then B, this arc is declared in the graph as:</p>
<pre class="fragment">  ARC FROM "A" TO "B"</pre><p>For example:</p>
<pre class="fragment">  ARC FROM "mutex/sql/LOCK_open" TO "mutex/sql/TABLE_SHARE::LOCK_ha_data"</pre><p>Note that arcs are not transitive in the graph.</p>
<p>For example, if the graph has the following arcs:</p>
<pre class="fragment">  ARC FROM "A" TO "B"
  ARC FROM "B" TO "C"</pre><p>Then the following code will comply:</p>
<div class="fragment"><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(A);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(B);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(A);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(C);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(B);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(C);</div></div><!-- fragment --><p>But the following code will not comply:</p>
<div class="fragment"><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(A);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(B);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(C); <span class="comment">// &lt;- this will raise an error.</span></div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(A);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(B);</div><div class="line"><a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(C);</div></div><!-- fragment --><p>This happens because the "A" -&gt; "C" transition is not declared.</p>
<p>This is a desired feature: to understand contention in the server, the real dependencies (the paths actually taken) must be documented explicitly. The tool could, but does not, infer more arcs by transitivity.</p>
<p>Additional metadata can be associated with an ARC, by adding flags to the arc declaration.</p>
<p>The format is</p>
<pre class="fragment">  ARC FROM "A" TO "B" FLAGS &lt;flag1&gt; &lt;flag2&gt; ... &lt;flagN&gt;</pre><p>Individual flags are separated by spaces.</p>
<p>Supported arc flags are:</p><ul>
<li>TRACE</li>
<li>DEBUG</li>
<li>LOOP</li>
<li>IGNORED</li>
</ul>
<h3><a class="anchor" id="LO_DEP_RWLOCK"></a>
Rwlock nodes</h3>
<p>Read write locks are named from the performance schema, with a shorter prefix.</p>
<p>There are three kinds of read write locks instrumented:</p><ul>
<li>read write locks (<code>mysql_rwlock_t</code>)</li>
<li>priority read write lock (<code>mysql_prlock_t</code>)</li>
<li>shared exclusive locks (<code>rw_lock_t</code> in innodb)</li>
</ul>
<p>The lock <code>mysql_rwlock_t</code> <code>LOCK_system_variables_hash</code>, which is a read write lock, is named "wait/synch/rwlock/sql/LOCK_system_variables_hash" in the performance schema, simplified as "rwlock/sql/LOCK_system_variables_hash" in LOCK ORDER.</p>
<p>Read write locks are recursive, but only on read operations. Due to the scheduling behavior in the underlying implementation, a reader might block indirectly another reader, if a write request is present.</p>
<p>When a lock is held on a read write lock, it can be in two states:</p><ul>
<li>either READ,</li>
<li>or WRITE.</li>
</ul>
<p>These states are exclusive.</p>
<p>When a thread holds a read write lock on "L" and locks "B", arcs are noted as follows:</p>
<pre class="fragment">  ARC FROM "rwlock/sql/L" STATE "R" TO "B" ...
  ARC FROM "rwlock/sql/L" STATE "W" TO "B" ...</pre><p>Operations on read write locks are:</p><ul>
<li>READ</li>
<li>TRY READ</li>
<li>WRITE</li>
<li>TRY WRITE</li>
</ul>
<p>When a thread holds a lock on "A" and then locks a read write lock "L", arcs are noted as follows:</p>
<pre class="fragment">  ARC FROM "A" ... TO "rwlock/sql/L" OP "R"
  ARC FROM "A" ... TO "rwlock/sql/L" OP "TRY R"
  ARC FROM "A" ... TO "rwlock/sql/L" OP "W"
  ARC FROM "A" ... TO "rwlock/sql/L" OP "TRY W"</pre><p>Recursive locks are noted as follows:</p>
<pre class="fragment">  ARC FROM "rwlock/sql/L" STATE "..." TO "rwlock/sql/L" RECURSIVE OP "R"
  ARC FROM "rwlock/sql/L" STATE "..." TO "rwlock/sql/L" RECURSIVE OP "TRY R"</pre><p>The lock <code>mysql_prlock_t</code> <code>MDL_context::m_LOCK_waiting_for</code>, which is a priority read write lock, is named "wait/synch/prlock/sql/MDL_context::LOCK_waiting_for" in the performance schema, simplified as "prlock/sql/MDL_context::LOCK_waiting_for" in LOCK ORDER.</p>
<p>Priority locks are recursive. A reader will never block another reader, even if a write request is present.</p>
<p>When a lock is held on a priority lock, it can be in two states:</p><ul>
<li>either READ,</li>
<li>or WRITE.</li>
</ul>
<p>These states are exclusive.</p>
<p>When a thread holds a priority lock on "L" and locks "B", arcs are noted as follows:</p>
<pre class="fragment">  ARC FROM "prlock/sql/L" STATE "R" TO "B" ...
  ARC FROM "prlock/sql/L" STATE "W" TO "B" ...</pre><p>Operations on priority locks are:</p><ul>
<li>READ</li>
<li>WRITE</li>
</ul>
<p>Note that the READ state can be acquired recursively on the same priority lock.</p>
<p>When a thread holds a lock on "A" and then locks a priority lock "L", arcs are noted as follows:</p>
<pre class="fragment">  ARC FROM "A" ... TO "prlock/sql/L" OP "R"
  ARC FROM "A" ... TO "prlock/sql/L" OP "W"</pre><p>Recursive locks are noted as follows:</p>
<pre class="fragment">  ARC FROM "prlock/sql/L" STATE "..." TO "prlock/sql/L" RECURSIVE OP "R"</pre><p>The lock <code>rw_lock_t</code> <code>dict_operation_lock</code>, which is a shared exclusive lock, is named "wait/synch/sxlock/innodb/dict_operation_lock" in the performance schema, simplified as "sxlock/innodb/dict_operation_lock" in LOCK ORDER.</p>
<p>Shared exclusive locks are recursive. Shared exclusive locks are implemented as spin locks, with fallback on condition variables.</p>
<p>When a lock is held on a shared exclusive lock, it can be in three states:</p><ul>
<li>SHARED,</li>
<li>or SHARED EXCLUSIVE,</li>
<li>or EXCLUSIVE.</li>
</ul>
<p>Because the same lock can be acquired recursively, when multiple locks are taken by the same thread on the same object, the overall equivalent state is computed (for example, SX + X counts as X).</p>
<p>When a thread holds a shared exclusive lock on "L" and locks "B", arcs are noted as follows:</p>
<pre class="fragment">  ARC FROM "sxlock/innodb/L" STATE "S" TO "B" ...
  ARC FROM "sxlock/innodb/L" STATE "SX" TO "B" ...
  ARC FROM "sxlock/innodb/L" STATE "X" TO "B" ...</pre><p>Operations on shared exclusive locks are:</p><ul>
<li>SHARED</li>
<li>TRY SHARED</li>
<li>SHARED EXCLUSIVE</li>
<li>TRY SHARED EXCLUSIVE</li>
<li>EXCLUSIVE</li>
<li>TRY EXCLUSIVE</li>
</ul>
<p>Note that some states can be acquired recursively on the same shared exclusive lock.</p>
<p>When a thread holds a lock on "A" and then locks a shared exclusive lock "L", arcs are noted as follows:</p>
<pre class="fragment">  ARC FROM "A" ... TO "sxlock/innodb/L" OP "S"
  ARC FROM "A" ... TO "sxlock/innodb/L" OP "TRY S"
  ARC FROM "A" ... TO "sxlock/innodb/L" OP "SX"
  ARC FROM "A" ... TO "sxlock/innodb/L" OP "TRY SX"
  ARC FROM "A" ... TO "sxlock/innodb/L" OP "X"
  ARC FROM "A" ... TO "sxlock/innodb/L" OP "TRY X"</pre><p>Recursive locks are noted as follows:</p>
<pre class="fragment">  ARC FROM "sxlock/innodb/L" STATE "..." TO "sxlock/innodb/L" RECURSIVE OP "S"
  ARC FROM "sxlock/innodb/L" STATE "..." TO "sxlock/innodb/L" RECURSIVE OP "SX"
  ARC FROM "sxlock/innodb/L" STATE "..." TO "sxlock/innodb/L" RECURSIVE OP "X"</pre><h3><a class="anchor" id="LO_DEP_COND"></a>
Cond nodes</h3>
<p>Conditions are named from the performance schema, with a shorter prefix.</p>
<p>For example, the condition <code>mysql_cond_t</code> <code>COND_open</code> is named "wait/synch/cond/sql/COND_open" in the performance schema, simplified as "cond/sql/COND_open" in LOCK ORDER.</p>
<p>Explicit arcs are declared between mutexes and associated conditions, so that the tool also enforces that the same mutex is consistently used for the same condition, to comply with the posix APIs.</p>
<p>When a condition C is associated with a mutex M, this arc is declared in the graph as:</p>
<pre class="fragment">  BIND "C" TO "M"</pre><p>For example:</p>
<pre class="fragment">  BIND "cond/sql/COND_open" TO "mutex/sql/LOCK_open"</pre><p>In the following sequence of code:</p>
<pre class="fragment">  mysql_mutex_lock(M);
  mysql_cond_signal(C);
  mysql_mutex_unlock(M);</pre><p>The tool will verify, when calling mysql_cond_signal, that condition C is bound with M, and that M is locked.</p>
<p>Note that holding a mutex when using signal or broadcast is recommended, but not mandatory.</p>
<p>To allow the following code:</p>
<pre class="fragment">  mysql_cond_signal(C); // mutex M not locked</pre><p>The condition must be flagged explicitly as using 'UNFAIR' scheduling, as in:</p>
<pre class="fragment">  BIND "C" TO "M" FLAGS UNFAIR</pre><p>For example:</p>
<pre class="fragment">  BIND "cond/sql/Master_info::start_cond" TO "mutex/sql/Master_info::run_lock" FLAGS UNFAIR</pre><h3><a class="anchor" id="LO_DEP_FILE"></a>
File nodes</h3>
<p>Files are named from the performance schema, with a shorter prefix.</p>
<p>For example, the relay log file is named "wait/io/file/sql/relaylog" in the performance schema, simplified as "file/sql/relaylog" in LOCK ORDER.</p>
<p>File io operations (read, write, etc) on the file are not documented. When any file io is performed while holding a lock, the dependency is documented, for example:</p>
<pre class="fragment">  ARC FROM "rwlock/sql/channel_lock" STATE "W" TO "file/sql/relaylog"
  ARC FROM "sxlock/innodb/dict_operation_lock" STATE "X" TO "file/innodb/innodb_data_file"</pre><h2><a class="anchor" id="LO_LOG"></a>
lock_order.log file</h2>
<p>During execution, the server writes to a log file located under the build directory, in a sub directory named lock-order, and named <code>lock_order-</code>(timestamp)-(pid).log where (pid) is the process id for mysqld.</p>
<p>The log file contains various messages printed by LOCK ORDER.</p>
<h2><a class="anchor" id="LO_GRAPH_TEXT"></a>
lock_order.txt file</h2>
<p>This file is an optional output.</p>
<p>To print the lock_order.txt file, two actions are required:</p><ul>
<li>enable the lock_order_print_txt system variable,</li>
<li>send a COM_DEBUG command to the server, using mysqladmin.</li>
</ul>
<p>The COM_DEBUG causes the file to be printed. It is desirable to load dynamic plugins and components before dumping this report, so that lock names instrumented inside the loaded code are checked against the dependencies graph.</p>
<p>A helper test, lock_order.cycle, performs all the steps required to dump the lock_order.txt report.</p>
<p>This command:</p>
<pre class="fragment">  export MTR_LOCK_ORDER=1
  ./mtr lock_order.cycle</pre><p>will generate the graph dump as a side effect.</p>
<p>The generated file contains the following sections:</p><ul>
<li>DEPENDENCY GRAPH</li>
<li>SCC ANALYSIS (full graph)</li>
<li>IGNORED NODES</li>
<li>LOOP ARC</li>
<li>SCC ANALYSIS (revised graph)</li>
<li>UNRESOLVED ARCS</li>
</ul>
<p>The section "DEPENDENCY GRAPH" is a textual representation of the graph, to facilitate investigations.</p>
<p>Each node is dumped with incoming and outgoing arcs, for example:</p>
<pre class="fragment">NODE: mutex/sql/LOCK_open
  16 incoming arcs:
    FROM: mutex/sql/tz_LOCK
    FROM: mutex/p_dyn_loader/key_component_id_by_urn_mutex
    FROM: mutex/sql/LOCK_plugin_install
    FROM: mutex/sql/LOCK_table_cache
    FROM: mutex/sql/key_mts_temp_table_LOCK
    FROM: mutex/sql/LOCK_event_queue
    FROM: mutex/sql/LOCK_global_system_variables
    FROM: mutex/sql/LOCK_reset_gtid_table
    FROM: mutex/sql/Master_info::data_lock
    FROM: mutex/sql/Master_info::run_lock
    FROM: mutex/sql/MYSQL_BIN_LOG::LOCK_index
    FROM: mutex/sql/MYSQL_BIN_LOG::LOCK_log
    FROM: mutex/sql/MYSQL_RELAY_LOG::LOCK_log
    FROM: mutex/sql/Relay_log_info::data_lock
    FROM: mutex/sql/Relay_log_info::run_lock
    FROM: mutex/sql/TABLE_SHARE::LOCK_ha_data -- LOOP FLAG
  22 outgoing arcs:
    TO: mutex/blackhole/blackhole
    TO: mutex/archive/Archive_share::mutex
    TO: mutex/myisam/MYISAM_SHARE::intern_lock
    TO: mutex/innodb/sync_array_mutex
    TO: mutex/innodb/rtr_active_mutex
    TO: mutex/innodb/srv_sys_mutex
    TO: mutex/innodb/rw_lock_list_mutex
    TO: mutex/innodb/rw_lock_debug_mutex
    TO: mutex/innodb/dict_table_mutex
    TO: mutex/innodb/dict_sys_mutex
    TO: mutex/innodb/innobase_share_mutex
    TO: mutex/csv/tina
    TO: mutex/sql/LOCK_plugin
    TO: cond/sql/COND_open
    TO: mutex/mysys/KEY_CACHE::cache_lock
    TO: mutex/mysys/THR_LOCK_heap
    TO: mutex/mysys/THR_LOCK_myisam
    TO: mutex/mysys/THR_LOCK_open
    TO: mutex/sql/DEBUG_SYNC::mutex
    TO: mutex/sql/MDL_wait::LOCK_wait_status
    TO: mutex/sql/TABLE_SHARE::LOCK_ha_data
    TO: mutex/sql/THD::LOCK_current_cond -- LOOP FLAG</pre><p>The section "SCC ANALYSIS (full graph)" is a "Strongly Connected Component" (SCC) analysis of the entire graph.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">https://en.wikipedia.org/wiki/Strongly_connected_component</a></p>
<p>For each SCC, the report prints the nodes part of the SCCs:</p>
<pre class="fragment">Found SCC number 1 of size 26:
mutex/innodb/dict_sys_mutex
...
mutex/sql/LOCK_offline_mode

Found SCC number 2 of size 2:
mutex/sql/Relay_log_info::run_lock
mutex/sql/Master_info::run_lock

Number of SCC found: 2</pre><p>Then the arcs internal to each SCC are printed.</p>
<pre class="fragment">Dumping arcs for SCC 1:
SCC ARC FROM "mutex/myisam/MYISAM_SHARE::intern_lock" TO "mutex/sql/LOCK_plugin"
SCC ARC FROM "mutex/innodb/parser_mutex" TO "mutex/innodb/dict_sys_mutex"
SCC ARC FROM "mutex/innodb/dict_sys_mutex" TO "mutex/sql/LOCK_plugin"
SCC ARC FROM "mutex/sql/LOCK_plugin" TO "mutex/sql/LOCK_global_system_variables"
SCC ARC FROM "mutex/sql/LOCK_plugin" TO "mutex/sql/THD::LOCK_current_cond"
SCC ARC FROM "mutex/sql/LOCK_table_cache" TO "mutex/myisam/MYISAM_SHARE::intern_lock"
SCC ARC FROM "mutex/sql/LOCK_table_cache" TO "mutex/innodb/dict_sys_mutex"
SCC ARC FROM "mutex/sql/LOCK_table_cache" TO "mutex/sql/LOCK_plugin"
...
SCC ARC FROM "mutex/sql/MYSQL_BIN_LOG::LOCK_commit" TO "mutex/sql/LOCK_plugin"
SCC ARC FROM "mutex/sql/MYSQL_BIN_LOG::LOCK_commit" TO "mutex/sql/THD::LOCK_current_cond"

Dumping arcs for SCC 2:
SCC ARC FROM "mutex/sql/Relay_log_info::run_lock" TO "mutex/sql/Master_info::run_lock"
SCC ARC FROM "mutex/sql/Master_info::run_lock" TO "mutex/sql/Relay_log_info::run_lock"</pre><p>The section "IGNORED NODES" prints the nodes flagged as IGNORED in the dependencies file:</p>
<pre class="fragment">IGNORED NODE: mutex/sql/LOCK_thd_list
IGNORED NODE: mutex/sql/LOCK_event_queue
IGNORED NODE: mutex/sql/LOCK_offline_mode
IGNORED NODE: mutex/sql/LOCK_global_system_variables</pre><p>The section "LOOP ARC" prints the arcs flagged as LOOP in the dependencies file:</p>
<pre class="fragment">LOOP ARC FROM mutex/myisam/MYISAM_SHARE::intern_lock TO mutex/sql/LOCK_plugin
LOOP ARC FROM mutex/innodb/dict_sys_mutex TO mutex/sql/LOCK_plugin
LOOP ARC FROM mutex/mysys/THR_LOCK_myisam TO mutex/sql/LOCK_plugin
LOOP ARC FROM mutex/sql/LOCK_plugin TO mutex/sql/LOCK_global_system_variables
LOOP ARC FROM mutex/sql/LOCK_plugin TO mutex/sql/THD::LOCK_current_cond
LOOP ARC FROM mutex/sql/TABLE_SHARE::LOCK_ha_data TO mutex/sql/LOCK_table_cache
LOOP ARC FROM mutex/sql/LOCK_open TO mutex/sql/THD::LOCK_current_cond
LOOP ARC FROM mutex/sql/TABLE_SHARE::LOCK_ha_data TO mutex/sql/LOCK_open
LOOP ARC FROM mutex/sql/LOCK_global_system_variables TO mutex/sql/LOCK_thd_list
LOOP ARC FROM mutex/sql/TABLE_SHARE::LOCK_ha_data TO mutex/sql/THD::LOCK_thd_data</pre><p>The section "SCC ANALYSIS (revised graph)" prints the strongly connected components of a sub graph, obtained by:</p><ul>
<li>ignoring nodes tagged IGNORED,</li>
<li>ignoring arcs tagged LOOP.</li>
</ul>
<pre class="fragment">Found SCC number 1 of size 14:
mutex/sql/THD::LOCK_current_cond
mutex/sql/MYSQL_RELAY_LOG::LOCK_log_end_pos
mutex/sql/Relay_log_info::log_space_lock
mutex/sql/MYSQL_RELAY_LOG::LOCK_index
mutex/sql/THD::LOCK_thd_data
mutex/sql/MYSQL_BIN_LOG::LOCK_log
mutex/sql/LOCK_reset_gtid_table
mutex/sql/MYSQL_BIN_LOG::LOCK_sync
mutex/sql/MYSQL_BIN_LOG::LOCK_commit
mutex/sql/MYSQL_BIN_LOG::LOCK_index
mutex/sql/MYSQL_RELAY_LOG::LOCK_log
mutex/sql/Relay_log_info::data_lock
mutex/sql/key_mts_temp_table_LOCK
mutex/sql/Master_info::data_lock

Found SCC number 2 of size 2:
mutex/sql/Relay_log_info::run_lock
mutex/sql/Master_info::run_lock

Number of SCC found: 2

Dumping arcs for SCC 1:
...

Dumping arcs for SCC 2:
...</pre><p>Finally, the section "UNRESOLVED ARCS" lists arcs found in the dependency graph that could not be matched with actual nodes from the code.</p>
<pre class="fragment">UNRESOLVED ARC FROM "mutex/sql/MYSQL_BIN_LOG::LOCK_log" TO "mutex/semisync/LOCK_binlog_"
UNRESOLVED ARC FROM "mutex/sql/MYSQL_BIN_LOG::LOCK_commit" TO "mutex/semisync/LOCK_binlog_"
UNRESOLVED ARC FROM "mutex/sql/LOCK_plugin" TO "mutex/semisync/LOCK_binlog_"
UNRESOLVED ARC FROM "mutex/sql/LOCK_plugin_install" TO "mutex/semisync/LOCK_binlog_"
UNRESOLVED ARC FROM "mutex/sql/LOCK_plugin_install" TO "mutex/semisync/Ack_receiver::m_mutex"
UNRESOLVED ARC FROM "mutex/semisync/LOCK_binlog_" TO "cond/semisync/COND_binlog_send_"
UNRESOLVED ARC FROM "mutex/semisync/Ack_receiver::m_mutex" TO "cond/semisync/Ack_receiver::m_cond"</pre><p>Arcs can be unresolved for two reasons:</p><ul>
<li>The code changed, and a node was either removed or renamed. The fix is to correct the dependency file accordingly.</li>
<li>A node is defined in a plugin (in this example, semisync), but the plugin is not loaded in the lock_order.cycle test script. The fix is to add the missing plugin.</li>
</ul>
<h1><a class="anchor" id="LO_METHODOLOGY"></a>
Methodology</h1>
<p>First, the graph defining valid lock sequences should be unique for the server. Any attempt to use different graphs for different tests is fundamentally flawed.</p>
<p>Secondly, documenting the dependencies graph helps to document the design, as the order of locks does not happen by accident in the code but as a result of design decisions by development.</p>
<p>In an ideal world, the dependency graph should be documented up front when writing the code, and testing should only verify that the code complies with the graph.</p>
<p>In practice, such a graph is &ndash; not &ndash; documented, only fragments of it are "common knowledge".</p>
<p>As a result, the complete graph must be discovered from the code, by performing reverse engineering, to be documented.</p>
<p>The LOCK_ORDER tool support both:</p><ul>
<li>discovery, to rebuild a graph from runtime execution</li>
<li>enforcement, to ensure runtime execution complies with constraints</li>
</ul>
<h2><a class="anchor" id="LO_PROCESS_COLLECT"></a>
Collect missing arcs</h2>
<p>Start with an empty lock_order_dependencies.txt file, and run a test.</p>
<p>For example, </p><pre class="fragment">  ./mtr main.parser</pre><p>The resulting <code>lock-order-</code>(timestamp)-(pid).log file will contain numerous messages, like:</p>
<pre class="fragment">MISSING: ARC FROM "mutex/sql/LOCK_table_cache" TO "mutex/sql/LOCK_open"
Trace: using missing arc mutex/sql/LOCK_table_cache (/home/malff/GIT_LOCK_ORDER/sql/table_cache.h:140)
 -&gt; mutex/sql/LOCK_open (/home/malff/GIT_LOCK_ORDER/sql/table_cache.h:319)
</pre><p>Here, the tool detected a lock sequence (<code>LOCK_table_cache</code> then <code>LOCK_open</code>) that is not declared in the graph. The "MISSING:" line prints the arc definition that should be added in the lock_order_dependencies.txt file, for easier copy and paste. The "Trace:" message gives details about where each lock was taken in the source code.</p>
<p>An efficient way to add at once all the missing arcs found while running tests is as follows:</p>
<pre class="fragment">  cat lock_order*.log | grep MISSING | sort -u</pre><p>Run this script, remove the MISSING: prefix, and add the result to the dependency graph. Then run tests again, with the new graph, and repeat until no more missing arcs are found.</p>
<h2><a class="anchor" id="LO_PROCESS_ANALYSIS"></a>
Perform graph analysis</h2>
<p>The tool processes the dependency graph to detect "Strongly Connected Components". See <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">https://en.wikipedia.org/wiki/Strongly_connected_component</a></p>
<p>Strictly speaking, a Strongly Connected Component can be a single node. In the context of LOCK_ORDER, "SCC" refers to Strongly Connected Components of size greater or equal to 2, that is, an actual cluster of <em>several</em> nodes.</p>
<p>This computation is done when dumping the lock_order.txt file.</p>
<p>A dedicated mtr test is written as a helper:</p>
<pre class="fragment">  ./mtr lock_order.cycle</pre><p>Then read the section named "SCC ANALYSIS (full graph)" in file lock_order.txt</p>
<p>At time of writing, it reads as:</p>
<pre class="fragment">SCC ANALYSIS (full graph):
==========================

Found SCC number 1 of size 26:
mutex/innodb/dict_sys_mutex
mutex/sql/LOCK_plugin
mutex/sql/LOCK_global_system_variables
mutex/innodb/parser_mutex
mutex/sql/LOCK_table_cache
mutex/myisam/MYISAM_SHARE::intern_lock
mutex/mysys/THR_LOCK_myisam
mutex/sql/LOCK_open
mutex/sql/TABLE_SHARE::LOCK_ha_data
mutex/sql/THD::LOCK_thd_data
mutex/sql/LOCK_event_queue
mutex/sql/MYSQL_BIN_LOG::LOCK_commit
mutex/sql/THD::LOCK_current_cond
mutex/sql/MYSQL_RELAY_LOG::LOCK_log_end_pos
mutex/sql/Relay_log_info::log_space_lock
mutex/sql/LOCK_thd_list
mutex/sql/MYSQL_RELAY_LOG::LOCK_index
mutex/sql/MYSQL_RELAY_LOG::LOCK_log
mutex/sql/Relay_log_info::data_lock
mutex/sql/key_mts_temp_table_LOCK
mutex/sql/Master_info::data_lock
mutex/sql/MYSQL_BIN_LOG::LOCK_log
mutex/sql/LOCK_reset_gtid_table
mutex/sql/MYSQL_BIN_LOG::LOCK_sync
mutex/sql/MYSQL_BIN_LOG::LOCK_index
mutex/sql/LOCK_offline_mode

Found SCC number 2 of size 2:
mutex/sql/Relay_log_info::run_lock
mutex/sql/Master_info::run_lock

Number of SCC found: 2</pre><p>The tool found two Strongly Connected Components (SCC).</p>
<p>The details about each arcs are printed:</p>
<pre class="fragment">Dumping arcs for SCC 1:
SCC ARC FROM "mutex/myisam/MYISAM_SHARE::intern_lock" TO "mutex/sql/LOCK_plugin"
SCC ARC FROM "mutex/innodb/parser_mutex" TO "mutex/innodb/dict_sys_mutex"
SCC ARC FROM "mutex/innodb/dict_sys_mutex" TO "mutex/sql/LOCK_plugin"
SCC ARC FROM "mutex/sql/LOCK_plugin" TO "mutex/sql/LOCK_global_system_variables"
SCC ARC FROM "mutex/sql/LOCK_plugin" TO "mutex/sql/THD::LOCK_current_cond"
SCC ARC FROM "mutex/sql/LOCK_table_cache" TO "mutex/myisam/MYISAM_SHARE::intern_lock"
SCC ARC FROM "mutex/sql/LOCK_table_cache" TO "mutex/innodb/dict_sys_mutex"
SCC ARC FROM "mutex/sql/LOCK_table_cache" TO "mutex/sql/LOCK_plugin"
...
SCC ARC FROM "mutex/sql/MYSQL_BIN_LOG::LOCK_commit" TO "mutex/sql/LOCK_plugin"
SCC ARC FROM "mutex/sql/MYSQL_BIN_LOG::LOCK_commit" TO "mutex/sql/THD::LOCK_current_cond"

Dumping arcs for SCC 2:
SCC ARC FROM "mutex/sql/Relay_log_info::run_lock" TO "mutex/sql/Master_info::run_lock"
SCC ARC FROM "mutex/sql/Master_info::run_lock" TO "mutex/sql/Relay_log_info::run_lock"</pre><p>Note that only arcs within the same SCC are printed here, as they are the ones that need closer investigation. Arcs coming in or out of this SCC are omitted, to reduce noise.</p>
<h2><a class="anchor" id="LO_PROCESS_BREAK"></a>
Break Strongly Connected Components</h2>
<p>By its very own definition, a SCC of size greater than one is a cluster of nodes where any node is reachable, using locks, from any other node. Hence, SCC should not exist, and the code must be re-factored to avoid them.</p>
<p>In the list of SCC arcs printed, some (human) analysis is required to decide:</p><ul>
<li>which arc is valid, and compliant with the MySQL server design</li>
<li>which arc is invalid, which points to a flaw in the code.</li>
</ul>
<p>A bug fix is required to change the server code affected, to avoid locks, or take locks in the proper order.</p>
<p>Now, this is a sensitive task, for the following reasons:</p><ul>
<li>deciding which arc to remove is by itself difficult</li>
<li>changing the server code and / or design to change lock order can be even more difficult</li>
<li>removing an arc alone might not even fix anything, if there is another path in the graph that closes the same loop.</li>
</ul>
<p>For this reason, the tool supports ways to simulate "what-if" scenarios, and see in practice what the overall graph would look like if such and such arc were to be removed.</p>
<p>First, some nodes can (temporarily) be ignored entirely, to simplify the graph analysis, and identify smaller sub graphs in a big SCC.</p>
<p>By ignoring some nodes, a big SCC can be broken down into smaller, independent, sub graphs, which helps to investigate, identify, and resolve several dead lock root causes in isolation.</p>
<p>To ignore a node "A", use the following syntax in the dependency graph:</p>
<pre class="fragment">NODE "A" IGNORED</pre><p>For example, using</p>
<pre class="fragment">NODE "mutex/sql/LOCK_event_queue" IGNORED
NODE "mutex/sql/LOCK_global_system_variables" IGNORED
NODE "mutex/sql/LOCK_offline_mode" IGNORED
NODE "mutex/sql/LOCK_thd_list" IGNORED</pre><p>will produce a graph without these nodes, also ignoring arcs from and to these nodes.</p>
<p>Secondly, arcs that are considered loops to fix in the code can be marked explicitly, like this:</p>
<pre class="fragment">ARC FROM "mutex/sql/TABLE_SHARE::LOCK_ha_data" TO "mutex/sql/LOCK_open" FLAGS LOOP
ARC FROM "mutex/sql/TABLE_SHARE::LOCK_ha_data" TO "mutex/sql/LOCK_table_cache" FLAGS LOOP
ARC FROM "mutex/sql/TABLE_SHARE::LOCK_ha_data" TO "mutex/sql/THD::LOCK_thd_data" FLAGS LOOP</pre><p>After tagging some IGNORED nodes or LOOP arcs, generate the lock_order.txt report again, to perform some analysis again.</p>
<p>The section "SCC ANALYSIS (full graph)" will be identical, as the real graph did not change.</p>
<p>The section "SCC ANALYSIS (revised graph)" will show what the graph would look like, with the loops fixed.</p>
<p>The goal is to iteratively tweak the LOOP flags in the graph, and perform analysis on the revised graph, until:</p><ul>
<li>the list of LOOP arcs can be reasonably fixed in the code, without causing too much re-engineering effort.</li>
<li>the resulting revised graph has less complicated SCC (ideally, there should be none left), showing progress towards the resolution of dead locks.</li>
</ul>
<p>Once a viable set of LOOP arcs to remove is identified, file a bug report to address the issue found.</p>
<h2><a class="anchor" id="LO_PROCESS_FIX"></a>
Get reported bugs fixed</h2>
<p>Each time a dependency is flagged as a LOOP, a matching bug report should be filed, and that bug should be eventually resolved.</p>
<p>Marking nodes are IGNORED or arcs as LOOP is equivalent to using suppressions in valgrind to avoid error messages.</p>
<p>This can be convenient to investigate further other areas, but it is by no means a satisfactory resolution in itself.</p>
<p>To achieve a state where the server can be declared as deadlock free with reasonable confidence, all the following conditions are required:</p><ul>
<li>the GCOV code coverage is satisfactory, and in particular covers all lines of code taking locks.</li>
<li>all mutexes in the code are instrumented with the performance schema</li>
<li>the dependency graph contains no SCC</li>
<li>the dependency graph contains no LOOP arcs</li>
<li>the dependency graph contains no IGNORED nodes</li>
<li>the test suite passes under LOCK_ORDER without any complaints from the tool.</li>
</ul>
<h1><a class="anchor" id="LO_TOOLS"></a>
Advanced tooling</h1>
<p>To facilitate investigations and debugging, the following features are available:</p><ul>
<li>Tracing</li>
<li>Debugging</li>
<li>Simulating loop arcs</li>
<li>Simulating ignored nodes</li>
</ul>
<h2><a class="anchor" id="LO_TOOL_TRACE"></a>
Tracing dependencies</h2>
<p>When an arc from A to B exists in the graph, it might be sometime necessary to understand where in the source code the A -&gt; B dependency is actually taken.</p>
<p>By declaring the arc with the TRACE flag, as in</p>
<pre class="fragment">  ARC FROM "mutex/sql/LOCK_open" TO "mutex/sql/TABLE_SHARE::LOCK_ha_data" FLAGS TRACE</pre><p>the tool will:</p><ul>
<li>capture the current statement text,</li>
<li>capture the source code location, and the call stack, when the first lock is taken,</li>
<li>capture the source code location, and the call stack, when the second lock is taken, and print all the details in the log file when this arc is found during runtime execution.</li>
</ul>
<p>An example of trace:</p>
<pre class="fragment">Trace: using arc mutex/sql/LOCK_open (/home/malff/GIT_LOCK_ORDER/sql/sql_base.cc:1704) -&gt; mutex/sql/TABLE_SHARE::LOCK_ha_data (/home/malff/GIT_LOCK_ORDER/sql/handler.cc:7764)
statement when first lock was acquired:
ALTER TABLE t1 ADD PARTITION
stack when the first lock was acquired:
[0] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN14LO_stack_traceC2Ev+0x28) [0x2e9f654]
[1] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN7LO_lock18record_stack_traceEv+0x24) [0x2e9fe52]
[2] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN9LO_thread14add_mutex_lockEP8LO_mutexPKci+0x18c) [0x2e9aeb4]
[3] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN15LO_mutex_locker3endEv+0x3e) [0x2ea02dc]
[4] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2e9d834]
[5] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b30112]
[6] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b33f39]
[7] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z18close_thread_tableP3THDPP5TABLE+0x20e) [0x2b34196]
[8] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b336db]
[9] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z19close_thread_tablesP3THD+0x3fd) [0x2b33e83]
[10] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z21mysql_execute_commandP3THDb+0x5dca) [0x2be875c]
[11] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z11mysql_parseP3THDP12Parser_stateb+0x672) [0x2bea1bb]
[12] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z16dispatch_commandP3THDPK8COM_DATA19enum_server_command+0x1496) [0x2be0291]
[13] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z10do_commandP3THD+0x448) [0x2bde867]
[14] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2d799ba]
[15] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(lo_spawn_thread+0xda) [0x2e9cb5c]
[16] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x466465e]
[17] /lib64/libpthread.so.0(+0x80a4) [0x7f094120a0a4]
[18] /lib64/libc.so.6(clone+0x6d) [0x7f093f75102d]
stack when the second lock was acquired:
[0] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN14LO_stack_traceC2Ev+0x28) [0x2e9f654]
[1] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN8LO_graph5checkEPK7LO_lockS2_+0x447) [0x2e99d25]
[2] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN9LO_thread11check_locksEPK7LO_lock+0xf1) [0x2e9aa99]
[3] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN9LO_thread14add_mutex_lockEP8LO_mutexPKci+0x1c9) [0x2e9aef1]
[4] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN15LO_mutex_locker3endEv+0x3e) [0x2ea02dc]
[5] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2e9d834]
[6] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2f04334]
[7] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN7handler19lock_shared_ha_dataEv+0x6c) [0x2f18e10]
[8] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN11ha_innopart5closeEv+0xec) [0x4125be8]
[9] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_ZN7handler8ha_closeEv+0x173) [0x2f0aa1d]
[10] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z8closefrmP5TABLEb+0x8c) [0x2d1e118]
[11] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z18intern_close_tableP5TABLE+0xe5) [0x2b32d42]
[12] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b33f45]
[13] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z18close_thread_tableP3THDPP5TABLE+0x20e) [0x2b34196]
[14] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b336db]
[15] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z19close_thread_tablesP3THD+0x3fd) [0x2b33e83]
[16] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z21mysql_execute_commandP3THDb+0x5dca) [0x2be875c]
[17] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z11mysql_parseP3THDP12Parser_stateb+0x672) [0x2bea1bb]
[18] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z16dispatch_commandP3THDPK8COM_DATA19enum_server_command+0x1496) [0x2be0291]
[19] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(_Z10do_commandP3THD+0x448) [0x2bde867]
[20] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2d799ba]
[21] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(lo_spawn_thread+0xda) [0x2e9cb5c]
[22] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x466465e]
[23] /lib64/libpthread.so.0(+0x80a4) [0x7f094120a0a4]
[24] /lib64/libc.so.6(clone+0x6d) [0x7f093f75102d]</pre><p>Note that C++ symbol names are mangled. Using <code>c++filt</code> on the log produces the following output:</p>
<pre class="fragment">Trace: using arc mutex/sql/LOCK_open (/home/malff/GIT_LOCK_ORDER/sql/sql_base.cc:1704) -&gt; mutex/sql/TABLE_SHARE::LOCK_ha_data (/home/malff/GIT_LOCK_ORDER/sql/handler.cc:7764)
statement when first lock was acquired:
ALTER TABLE t1 ADD PARTITION
stack when the first lock was acquired:
[0] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_stack_trace::LO_stack_trace()+0x28) [0x2e9f654]
[1] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_lock::record_stack_trace()+0x24) [0x2e9fe52]
[2] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_thread::add_mutex_lock(LO_mutex*, char const*, int)+0x18c) [0x2e9aeb4]
[3] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_mutex_locker::end()+0x3e) [0x2ea02dc]
[4] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2e9d834]
[5] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b30112]
[6] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b33f39]
[7] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(close_thread_table(THD*, TABLE**)+0x20e) [0x2b34196]
[8] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b336db]
[9] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(close_thread_tables(THD*)+0x3fd) [0x2b33e83]
[10] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(mysql_execute_command(THD*, bool)+0x5dca) [0x2be875c]
[11] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(mysql_parse(THD*, Parser_state*, bool)+0x672) [0x2bea1bb]
[12] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(dispatch_command(THD*, COM_DATA const*, enum_server_command)+0x1496) [0x2be0291]
[13] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(do_command(THD*)+0x448) [0x2bde867]
[14] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2d799ba]
[15] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(lo_spawn_thread+0xda) [0x2e9cb5c]
[16] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x466465e]
[17] /lib64/libpthread.so.0(+0x80a4) [0x7f094120a0a4]
[18] /lib64/libc.so.6(clone+0x6d) [0x7f093f75102d]
stack when the second lock was acquired:
[0] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_stack_trace::LO_stack_trace()+0x28) [0x2e9f654]
[1] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_graph::check(LO_lock const*, LO_lock const*)+0x447) [0x2e99d25]
[2] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_thread::check_locks(LO_lock const*)+0xf1) [0x2e9aa99]
[3] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_thread::add_mutex_lock(LO_mutex*, char const*, int)+0x1c9) [0x2e9aef1]
[4] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(LO_mutex_locker::end()+0x3e) [0x2ea02dc]
[5] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2e9d834]
[6] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2f04334]
[7] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(handler::lock_shared_ha_data()+0x6c) [0x2f18e10]
[8] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(ha_innopart::close()+0xec) [0x4125be8]
[9] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(handler::ha_close()+0x173) [0x2f0aa1d]
[10] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(closefrm(TABLE*, bool)+0x8c) [0x2d1e118]
[11] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(intern_close_table(TABLE*)+0xe5) [0x2b32d42]
[12] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b33f45]
[13] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(close_thread_table(THD*, TABLE**)+0x20e) [0x2b34196]
[14] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2b336db]
[15] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(close_thread_tables(THD*)+0x3fd) [0x2b33e83]
[16] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(mysql_execute_command(THD*, bool)+0x5dca) [0x2be875c]
[17] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(mysql_parse(THD*, Parser_state*, bool)+0x672) [0x2bea1bb]
[18] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(dispatch_command(THD*, COM_DATA const*, enum_server_command)+0x1496) [0x2be0291]
[19] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(do_command(THD*)+0x448) [0x2bde867]
[20] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x2d799ba]
[21] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld(lo_spawn_thread+0xda) [0x2e9cb5c]
[22] /home/malff/GIT_LOCK_ORDER/build/runtime_output_directory/mysqld() [0x466465e]
[23] /lib64/libpthread.so.0(+0x80a4) [0x7f094120a0a4]
[24] /lib64/libc.so.6(clone+0x6d) [0x7f093f75102d]</pre><h2><a class="anchor" id="LO_TOOL_DEBUG"></a>
Debugging dependencies</h2>
<p>When tracing is not enough, the next step is to break the server execution in a debugger to understand the context, to investigate.</p>
<p>The tool allows to put breakpoints on dependencies (not just functions), using the DEBUG flag on an arc, as in:</p>
<pre class="fragment">  ARC FROM "mutex/sql/LOCK_open" TO "mutex/sql/TABLE_SHARE::LOCK_ha_data" FLAGS DEBUG</pre><p>When this arc is found at runtime, a <code>DBUG_ASSERT</code> will fail, that can be caught.</p>
<p>To help diagnostics, the tool will construct a string that details the reason for the failed assert.</p>
<p>In a debugger, a good place to put breakpoints to debug specific arcs is the function <code>debug_lock_order_break_here()</code>.</p>
<h2><a class="anchor" id="LO_TOOL_LOOP"></a>
Simulating loops</h2>
<p>Loops can be declared explicitly in the dependency graph, using the LOOP flag:</p>
<pre class="fragment">  ARC FROM "mutex/sql/TABLE_SHARE::LOCK_ha_data" TO "mutex/sql/LOCK_open" FLAGS LOOP</pre><h2><a class="anchor" id="LO_TOOL_IGNORED"></a>
Simulating ignored nodes</h2>
<p>To facilitate investigation, nodes can be ignored to produce a smaller graph:</p>
<pre class="fragment">  NODE "mutex/sql/LOCK_thd_list" IGNORED</pre><h1><a class="anchor" id="LO_NOTATION"></a>
Understanding the notation</h1>
<p>This is a mini tutorial with examples, to better understand the notations used in file lock_order.txt.</p>
<h2><a class="anchor" id="LO_TUT_1"></a>
Basic mutex loop</h2>
<h3><a class="anchor" id="LO_TUT_1_CODE"></a>
Sample code</h3>
<p>Assume some server code as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="structmysql__mutex__t.html">mysql_mutex_t</a> mutex_A;</div><div class="line"><a class="code" href="structmysql__mutex__t.html">mysql_mutex_t</a> mutex_B;</div><div class="line"><a class="code" href="structmysql__mutex__t.html">mysql_mutex_t</a> mutex_C;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_red() {</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_A);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_B);</div><div class="line">  do_something_red();</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_B);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_A);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_green() {</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_B);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_C);</div><div class="line">  do_something_green();</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_C);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_B);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_blue() {</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_C);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_A);</div><div class="line">  do_something_blue();</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_A);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_C);</div><div class="line">}</div></div><!-- fragment --><p>Then, assume three different threads (red, green and blue) execute the corresponding functions in the server.</p>
<h3><a class="anchor" id="LO_TUT_1_GRAPH"></a>
Dependency graph</h3>
<p>When running tests, the lock_order tool will find the following dependencies, to add in the lock_order_dependencies.txt file:</p>
<pre class="fragment">  ARC FROM "mutex/sql/A" TO "mutex/sql/B"
  ARC FROM "mutex/sql/B" TO "mutex/sql/C"
  ARC FROM "mutex/sql/C" TO "mutex/sql/A"</pre><h3><a class="anchor" id="LO_TUT_1_REPORT"></a>
Lock order report</h3>
<p>Executing the lock_order.cycle test, to get the lock_order.txt report, will show the following SCC:</p>
<pre class="fragment">  Dumping classes for SCC 1:
  SCC Class mutex/sql/A
  SCC Class mutex/sql/B
  SCC Class mutex/sql/C

  Dumping nodes for SCC 1:
  SCC Node mutex/sql/A Girth 3
  SCC Node mutex/sql/B Girth 3
  SCC Node mutex/sql/C Girth 3

  Dumping arcs for SCC 1:
  SCC ARC FROM "mutex/sql/A" TO "mutex/sql/B"
  SCC ARC FROM "mutex/sql/B" TO "mutex/sql/C"
  SCC ARC FROM "mutex/sql/C" TO "mutex/sql/A"

  SCC 1/1 summary:
   - Class Size 3
   - Node Size 3
   - Arc Count 3
   - Girth 3
   - Circumference 3</pre><p>In other words, the tool found a cycle in the code, illustrated below.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
<map name="dot_inline_dotgraph_1.map" id="dot_inline_dotgraph_1.map"></map>
</div>
<p>This cycle involves three nodes, so the cycle girth is 3.</p>
<p>A possible fix is to change the implementation of func_blue() to take locks on A then C, in that order.</p>
<p>Fixing the code is not enought, as the lock_order_dependencies.txt file now contains an arc (C -&gt; A) that is never taken in the code.</p>
<p>Once both:</p><ul>
<li>the code is fixed</li>
<li>the C -&gt; A arc is replaced by an A -&gt; C arc in lock_order_dependencies.txt</li>
</ul>
<p>the tool will then detect no more deadlocks involving these nodes.</p>
<h2><a class="anchor" id="LO_TUT_2"></a>
With read write lock</h2>
<p>Building on the previous example, let's now change B and C to read write locks.</p>
<h3><a class="anchor" id="LO_TUT_2_CODE"></a>
Sample code</h3>
<div class="fragment"><div class="line"><a class="code" href="structmysql__mutex__t.html">mysql_mutex_t</a> mutex_A;</div><div class="line"><a class="code" href="structmysql__rwlock__t.html">mysql_rwlock_t</a> rwlock_B;</div><div class="line"><a class="code" href="structmysql__rwlock__t.html">mysql_rwlock_t</a> rwlock_C;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_red() {</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_A);</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#a1c25890bfe1411b77970c11b3d40ee04">mysql_rwlock_rdlock</a>(&amp;rwlock_B);</div><div class="line">  do_something_red();</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#a4cf02935345f57ead26969b33eebe8b6">mysql_rwlock_unlock</a>(&amp;rwlock_B);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_A);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_green() {</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#a1c25890bfe1411b77970c11b3d40ee04">mysql_rwlock_rdlock</a>(&amp;rwlock_B);</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#affa04754b0b37aeb8ae6740c917e7562">mysql_rwlock_wrlock</a>(&amp;rwlock_C);</div><div class="line">  do_something_green();</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#a4cf02935345f57ead26969b33eebe8b6">mysql_rwlock_unlock</a>(&amp;rwlock_C);</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#a4cf02935345f57ead26969b33eebe8b6">mysql_rwlock_unlock</a>(&amp;rwlock_B);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_blue() {</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#a1c25890bfe1411b77970c11b3d40ee04">mysql_rwlock_rdlock</a>(&amp;rwlock_C);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_A);</div><div class="line">  do_something_blue();</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_A);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_C);</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="LO_TUT_2_GRAPH"></a>
Dependency graph</h3>
<p>The dependencies found, to add in the lock_order_dependencies.txt file, are:</p>
<pre class="fragment">  ARC FROM "mutex/sql/A" TO "rwlock/sql/B" OP "R"
  ARC FROM "rwlock/sql/B" STATE "R" TO "rwlock/sql/C" OP "W"
  ARC FROM "rwlock/sql/C" STATE "R" TO "mutex/sql/A"</pre><h3><a class="anchor" id="LO_TUT_2_REPORT"></a>
Lock order report</h3>
<p>File lock_order.txt indicates a SCC, so there is a cycle.</p>
<pre class="fragment">  Dumping classes for SCC 1:
  SCC Class mutex/sql/A
  SCC Class rwlock/sql/B
  SCC Class rwlock/sql/C

  Dumping nodes for SCC 1:
  SCC Node mutex/sql/A
  SCC Node rwlock/sql/B:-R
  SCC Node rwlock/sql/B:+R
  SCC Node rwlock/sql/C:-R
  SCC Node rwlock/sql/C:+W

  -- Note that these nodes exist, but are not part of the SCC: --
  Node rwlock/sql/B:+W
  Node rwlock/sql/B:-W
  Node rwlock/sql/C:+R
  Node rwlock/sql/C:-W

  Dumping arcs for SCC 1:
  SCC ARC FROM "mutex/sql/A" TO "rwlock/sql/B:+R"
  SCC ARC FROM "rwlock/sql/B:+R" TO "rwlok/sql/B:-R" -- MICRO ARC
  SCC ARC FROM "rwlock/sql/B:-R" TO "rwlock/sql/C:+W"
  SCC ARC FROM "rwlock/sql/C:+W" TO "rwlock/sql/C:-R" -- MICRO ARC
  SCC ARC FROM "rwlock/sql/C:-R" TO "rwlock/sql/A"

  SCC 1/1 summary:
   - Class Size 3
   - Node Size 5
   - Arc Count 5
   - Girth 5
   - Circumference 5</pre><p>First, notice how the read write lock class "rwlock/sql/B" is represented by four nodes, named:</p><ul>
<li>"rwlock/sql/B:+R", incomming read lock</li>
<li>"rwlock/sql/B:-R", outgoing read lock</li>
<li>"rwlock/sql/B:+W", incomming write lock</li>
<li>"rwlock/sql/B:-W", outgoing write lock</li>
</ul>
<p>A practical way to represent this graphically is to draw a box for the lock, that contains four ports. Internal connections between ports represent the logic table for the lock: an arc from "+R" to "-W" means that an incomming request for a read lock ("+R") is blocked by a write lock request already given ("-W").</p>
<p>Micro arcs represent the wired logic of the lock itself, these can not be changed.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_2.png" alt="dot_inline_dotgraph_2.png" border="0" usemap="#dot_inline_dotgraph_2.map"/>
<map name="dot_inline_dotgraph_2.map" id="dot_inline_dotgraph_2.map"></map>
</div>
<p>The complete SCC report can be represented graphically as follows:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_3.png" alt="dot_inline_dotgraph_3.png" border="0" usemap="#dot_inline_dotgraph_3.map"/>
<map name="dot_inline_dotgraph_3.map" id="dot_inline_dotgraph_3.map"></map>
</div>
<p>Indeed in this graph, there is a cycle of girth 5 involving the following 3 objects:</p><ul>
<li>mutex_A</li>
<li>rwlock_B</li>
<li>rwlock_C</li>
</ul>
<p>The lock order tool indicates that this is a dead lock ... let's verify this with a test scenario:</p><ul>
<li>t1: thread red executes function func_red</li>
<li>t2: thread red locks mutex_A</li>
<li>t3: thread red is interrupted, and sleeps for a while</li>
<li>t4: thread blue executes function func_blue</li>
<li>t5: thread blue locks rwlock_C in read mode</li>
<li>t6: thread blue attempts to lock mutex_A and is blocked.</li>
<li>t7: thread green executes function func_green</li>
<li>t8: thread green locks rwlock_B in read mode</li>
<li>t9: thread green attempts to lock rwlock_C in write mode and is blocked.</li>
<li>t20: thread red awakes</li>
<li>t21: thread red attempts to lock rwlock_B in read mode ...</li>
</ul>
<p>Now, at t21, rwlock_B is locked in read mode by thread green, so a request for a read lock should be granted, right ?</p>
<p>Lock order claims there is a dead lock, because a read can block indirectly a read:</p>
<p>Consider the folowing code:</p>
<div class="fragment"><div class="line">func_grey() {</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#affa04754b0b37aeb8ae6740c917e7562">mysql_rwlock_wrlock</a>(&amp;rwlock_B);</div><div class="line">  <a class="code" href="components_2services_2mysql__rwlock_8h.html#a4cf02935345f57ead26969b33eebe8b6">mysql_rwlock_unlock</a>(&amp;rwlock_B);</div><div class="line">}</div></div><!-- fragment --><p>Executing func_grey() in thread grey any time after t8 will cause thread grey to block, with a write lock request in the queue in rwlock_B.</p>
<p>Such a request will in turn block thread red at t21.</p>
<p>The system is in deadlock:</p><ul>
<li>thread red holds mutex_A, waits for rwlock_B:+R</li>
<li>thread blue holds rwlock_C:-R, waits for mutex_A</li>
<li>thread gren holds rwlock_B:-R, waits for rwlock_C:+W</li>
<li>thread grey holds nothing, waits for rwlock_B:+W</li>
</ul>
<p>A possible fix is to replace rwlock_B by a priority lock, prlock_B. Priority locks differ from read write locks precisely on this scheduling policy, as a read lock will never block another read lock, even when write lock requests are present.</p>
<p>The internal representation of a priority lock is as follows, note how the "+R" -&gt; "-R" arc is missing, allowing parallel processing for reads.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_4.png" alt="dot_inline_dotgraph_4.png" border="0" usemap="#dot_inline_dotgraph_4.map"/>
<map name="dot_inline_dotgraph_4.map" id="dot_inline_dotgraph_4.map"></map>
</div>
<h2><a class="anchor" id="LO_TUT_3"></a>
With shared exclusive locks</h2>
<p>Let's now look at innodb <code>rw_lock_t</code>, which is a shared exclusive read write lock.</p>
<h3><a class="anchor" id="LO_TUT_3_CODE"></a>
Sample code</h3>
<p>Consider the following code:</p>
<div class="fragment"><div class="line"><a class="code" href="structmysql__mutex__t.html">mysql_mutex_t</a> mutex_A;</div><div class="line">-- these are innodb locks, see storage/innobase/include/sync0rw.h --</div><div class="line"><a class="code" href="structrw__lock__t.html">rw_lock_t</a> latch_B;</div><div class="line"><a class="code" href="structrw__lock__t.html">rw_lock_t</a> latch_C;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_red() {</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_A);</div><div class="line">  <a class="code" href="sync0rw_8h.html#a75ab160551c85fc478837cda173ef4d0">rw_lock_s_lock</a>(&amp;latch_B);</div><div class="line">  do_something_red();</div><div class="line">  <a class="code" href="sync0rw_8h.html#a41172c45229ea4cbe60f4669b3b68994">rw_lock_s_unlock</a>(&amp;latch_B);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_A);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_green() {</div><div class="line">  <a class="code" href="sync0rw_8h.html#a61900eabf2cba712bbf286034d4428e9">rw_lock_sx_lock</a>(&amp;latch_B); -- Holds a SX lock.</div><div class="line">  <a class="code" href="sync0rw_8h.html#ad3004dd4636535a3aab2cecfdb7dae54">rw_lock_x_lock</a>(&amp;latch_B); -- Recursive, now holds a <a class="code" href="xcom__base_8cc.html#a5c618775a4e4914274a27c7e15d5fbee">X</a> lock.</div><div class="line"></div><div class="line">  <a class="code" href="sync0rw_8h.html#ad3004dd4636535a3aab2cecfdb7dae54">rw_lock_x_lock</a>(&amp;latch_C);</div><div class="line"></div><div class="line">  do_something_green();</div><div class="line"></div><div class="line">  <a class="code" href="sync0rw_8h.html#ae10266de83fba11c12e595ca4ab1f17c">rw_lock_x_unlock</a>(&amp;latch_C);</div><div class="line"></div><div class="line">  <a class="code" href="sync0rw_8h.html#ae10266de83fba11c12e595ca4ab1f17c">rw_lock_x_unlock</a>(&amp;latch_B);</div><div class="line">  <a class="code" href="sync0rw_8h.html#af5f7c8e02817d70766332c9593004876">rw_lock_sx_unlock</a>(&amp;latch_B);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> func_blue() {</div><div class="line">  <a class="code" href="sync0rw_8h.html#a61900eabf2cba712bbf286034d4428e9">rw_lock_sx_lock</a>(&amp;latch_C);</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a340bf8f49d0cbaa994eaf5fb1fc7a22f">mysql_mutex_lock</a>(&amp;mutex_A);</div><div class="line">  do_something_blue();</div><div class="line">  <a class="code" href="components_2services_2mysql__mutex_8h.html#a5c748d3c7862702885acb90576754a2c">mysql_mutex_unlock</a>(&amp;mutex_A);</div><div class="line">  <a class="code" href="sync0rw_8h.html#af5f7c8e02817d70766332c9593004876">rw_lock_sx_unlock</a>(&amp;latch_C);</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="LO_TUT_3_GRAPH"></a>
Dependency graph</h3>
<p>When executing func_red(), the tool detects the following dependencies:</p>
<pre class="fragment">  ARC FROM "mutex/tutorial/mutex_A" TO "sxlock/tutorial/latch_B" OP "S"</pre><p>Likewise for func_green(), the dependencies found are:</p>
<pre class="fragment">  ARC FROM "sxlock/tutorial/latch_B" STATE "SX" TO "sxlock/tutorial/latch_B" RECURSIVE OP "X"
  ARC FROM "sxlock/tutorial/latch_B" STATE "X" TO "sxlock/tutorial/latch_C" OP "X"</pre><p>Notice how the tool:</p><ul>
<li>detects that some locks are recursive</li>
<li>infere the overall STATE of a lock based on all lock calls made.</li>
</ul>
<p>And finally for func_blue(), the tool detects:</p>
<pre class="fragment">  ARC FROM "sxlock/tutorial/latch_C" STATE "SX" TO "mutex/tutorial/mutex_A"</pre><h3><a class="anchor" id="LO_TUT_3_REPORT"></a>
Lock order report</h3>
<pre class="fragment">  Dumping classes for SCC 1:
  SCC Class sxlock/tutorial/latch_C
  SCC Class sxlock/tutorial/latch_B
  SCC Class mutex/tutorial/mutex_A

  Dumping nodes for SCC 1:
  SCC Node sxlock/tutorial/latch_C:+X Girth 5
  SCC Node sxlock/tutorial/latch_C:-SX Girth 5
  SCC Node sxlock/tutorial/latch_B:-X Girth 5
  SCC Node sxlock/tutorial/latch_B:+S Girth 5
  SCC Node mutex/tutorial/mutex_A Girth 5

  -- Note that these nodes exist, but are not part of the SCC: --
  Node sxlock/tutorial/latch_C:-X
  Node sxlock/tutorial/latch_C:+SX
  Node sxlock/tutorial/latch_C:+S
  Node sxlock/tutorial/latch_C:-S
  Node sxlock/tutorial/latch_B:+X
  Node sxlock/tutorial/latch_B:+SX
  Node sxlock/tutorial/latch_B:-SX
  Node sxlock/tutorial/latch_B:-S

  Dumping arcs for SCC 1:
  SCC ARC FROM "sxlock/tutorial/latch_C:+X" TO "sxlock/tutorial/latch_C:-SX" -- MICRO ARC
  SCC ARC FROM "sxlock/tutorial/latch_C:-SX" TO "mutex/tutorial/mutex_A"
  SCC ARC FROM "sxlock/tutorial/latch_B:-X" TO "sxlock/tutorial/latch_C:+X"
  SCC ARC FROM "sxlock/tutorial/latch_B:+S" TO "sxlock/tutorial/latch_B:-X" -- MICRO ARC
  SCC ARC FROM "mutex/tutorial/mutex_A" TO "sxlock/tutorial/latch_B:+S"

  -- Note that these arcs exist, but are not part of the SCC: --
  ARC FROM "sxlock/tutorial/latch_B:-SX" TO "sxlock/tutorial/latch_B:-X"

  SCC 1/1 summary:
   - Class Size 3
   - Node Size 5
   - Arc Count 3
   - Girth 5
   - Circumference 5</pre><p>The graphical representation of a shared exclusive lock is as follows:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_5.png" alt="dot_inline_dotgraph_5.png" border="0" usemap="#dot_inline_dotgraph_5.map"/>
<map name="dot_inline_dotgraph_5.map" id="dot_inline_dotgraph_5.map"></map>
</div>
<p>Using this graphical representation, the SCC reported can be represented as:</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_6.png" alt="dot_inline_dotgraph_6.png" border="0" usemap="#dot_inline_dotgraph_6.map"/>
<map name="dot_inline_dotgraph_6.map" id="dot_inline_dotgraph_6.map"></map>
</div>
<p>There is a cycle of girth five involving the three nodes:</p><ul>
<li>mutex_A</li>
<li>latch_B</li>
<li>latch_C</li>
</ul>
<p>By code review, this is correct:</p><ul>
<li>func_red() will hold mutex_A, blocking func_blue()</li>
<li>func_blue() will hold a SX lock on latch_C, blocking func_green()</li>
<li>func_green() will hold a X lock on latch_B, blocking func_red()</li>
</ul>
<p>As can be found by reading the diagram, there are several options to break the deadlock:</p><ul>
<li>the order of locks between mutex_A and latch_C can be reversed, breaking the loop,</li>
<li>func_green() could avoid taking a X lock on latch_B, and use a SX lock only. This breaks the cycle because a S lock (from func_red()) and a SX lock (from modified func_green()) are not blocking each others, making the graph loop free.</li>
</ul>
<p>As a site note about the notation used, see how the recursive lock taken by func_green() in latch_B is represented: An "-SX" -&gt; "-X" arc means that the already given SX lock ("-SX") is promoted to a given X lock ("-X"). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_DEV_TOOLS.html">Development Tools</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
