<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/lock0lock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lock0lock_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lock0lock.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The transaction lock system.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0types_8h_source.html">lock0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0types_8h_source.html">mtr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0types_8h_source.html">rem0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0vec_8h_source.html">ut0vec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="gis0rtree_8h_source.html">gis0rtree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0latches_8h_source.html">lock0latches.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0prdt_8h_source.html">lock0prdt.h</a>&quot;</code><br />
<code>#include &quot;lock0lock.ic&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0guards_8h_source.html">lock0guards.h</a>&quot;</code><br />
</div>
<p><a href="lock0lock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__op__t.html">lock_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock operation struct.  <a href="structlock__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__sys__t.html">lock_sys_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock system struct.  <a href="structlock__sys__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelocksys"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html">locksys</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aaf586f74bea52a9f41cb48d219e03cda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aaf586f74bea52a9f41cb48d219e03cda">lock_wait_mutex_own</a>()&#160;&#160;&#160;(<a class="el" href="lock0lock_8cc.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;wait_mutex.is_owned())</td></tr>
<tr class="memdesc:aaf586f74bea52a9f41cb48d219e03cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if lock_sys-&gt;wait_mutex is owned.  <a href="#aaf586f74bea52a9f41cb48d219e03cda">More...</a><br /></td></tr>
<tr class="separator:aaf586f74bea52a9f41cb48d219e03cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af316b7272e81c47c1548d22025f542e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af316b7272e81c47c1548d22025f542e3">lock_wait_mutex_enter</a>()</td></tr>
<tr class="memdesc:af316b7272e81c47c1548d22025f542e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock_sys-&gt;wait_mutex.  <a href="#af316b7272e81c47c1548d22025f542e3">More...</a><br /></td></tr>
<tr class="separator:af316b7272e81c47c1548d22025f542e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac7466a6379499864e831e92c950956"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acac7466a6379499864e831e92c950956">lock_wait_mutex_exit</a>()</td></tr>
<tr class="memdesc:acac7466a6379499864e831e92c950956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the lock_sys-&gt;wait_mutex.  <a href="#acac7466a6379499864e831e92c950956">More...</a><br /></td></tr>
<tr class="separator:acac7466a6379499864e831e92c950956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aea25ac33bd6692ef77c95c6a7da765a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aea25ac33bd6692ef77c95c6a7da765a8">LOCK_MODE_MASK</a>&#160;&#160;&#160;0xFUL</td></tr>
<tr class="memdesc:aea25ac33bd6692ef77c95c6a7da765a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock modes and types.  <a href="#aea25ac33bd6692ef77c95c6a7da765a8">More...</a><br /></td></tr>
<tr class="separator:aea25ac33bd6692ef77c95c6a7da765a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5d26fd94580daba78f376b8ca887dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3f5d26fd94580daba78f376b8ca887dd">LOCK_TABLE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a3f5d26fd94580daba78f376b8ca887dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock types.  <a href="#a3f5d26fd94580daba78f376b8ca887dd">More...</a><br /></td></tr>
<tr class="separator:a3f5d26fd94580daba78f376b8ca887dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145ae646d1def688ee264b9d98c2e981"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a145ae646d1def688ee264b9d98c2e981">LOCK_REC</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:a145ae646d1def688ee264b9d98c2e981"><td class="mdescLeft">&#160;</td><td class="mdescRight">record lock  <a href="#a145ae646d1def688ee264b9d98c2e981">More...</a><br /></td></tr>
<tr class="separator:a145ae646d1def688ee264b9d98c2e981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51876da8368dde6b362ce3c465dcc9eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a51876da8368dde6b362ce3c465dcc9eb">LOCK_TYPE_MASK</a>&#160;&#160;&#160;0xF0UL</td></tr>
<tr class="memdesc:a51876da8368dde6b362ce3c465dcc9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask used to extract lock type from the \ type_mode field in a lock  <a href="#a51876da8368dde6b362ce3c465dcc9eb">More...</a><br /></td></tr>
<tr class="separator:a51876da8368dde6b362ce3c465dcc9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad796dd0adc2da08468a220376fe76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a92ad796dd0adc2da08468a220376fe76">LOCK_WAIT</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a92ad796dd0adc2da08468a220376fe76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waiting lock flag; when set, it \ means that the lock has not yet been \ granted, it is just waiting for its \ turn in the wait queue.  <a href="#a92ad796dd0adc2da08468a220376fe76">More...</a><br /></td></tr>
<tr class="separator:a92ad796dd0adc2da08468a220376fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f8dd3d016d01aaa314160f0db74e75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a95f8dd3d016d01aaa314160f0db74e75">LOCK_ORDINARY</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a95f8dd3d016d01aaa314160f0db74e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">this flag denotes an ordinary \ next-key lock in contrast to LOCK_GAP \ or LOCK_REC_NOT_GAP  <a href="#a95f8dd3d016d01aaa314160f0db74e75">More...</a><br /></td></tr>
<tr class="separator:a95f8dd3d016d01aaa314160f0db74e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8631af3f85d4c19484f6de819b2b2a37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a8631af3f85d4c19484f6de819b2b2a37">LOCK_GAP</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:a8631af3f85d4c19484f6de819b2b2a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">when this bit is set, it means that the \ lock holds only on the gap before the record; \ for instance, an x-lock on the gap does not \ give permission to modify the record on which \ the bit is set; locks of this type are created \ when records are removed from the index chain \ of records  <a href="#a8631af3f85d4c19484f6de819b2b2a37">More...</a><br /></td></tr>
<tr class="separator:a8631af3f85d4c19484f6de819b2b2a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec9b0cce21ee17de083d3bb96b1bec6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5ec9b0cce21ee17de083d3bb96b1bec6">LOCK_REC_NOT_GAP</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:a5ec9b0cce21ee17de083d3bb96b1bec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">this bit means that the lock is only on \ the index record and does NOT block inserts \ to the gap before the index record; this is \ used in the case when we retrieve a record \ with a unique key, and is also used in \ locking plain SELECTs (not part of UPDATE \ or DELETE) when the user has set the READ \ COMMITTED isolation level  <a href="#a5ec9b0cce21ee17de083d3bb96b1bec6">More...</a><br /></td></tr>
<tr class="separator:a5ec9b0cce21ee17de083d3bb96b1bec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a448126f7465de2aa940d1751dd8b7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7a448126f7465de2aa940d1751dd8b7e">LOCK_INSERT_INTENTION</a>&#160;&#160;&#160;2048</td></tr>
<tr class="memdesc:a7a448126f7465de2aa940d1751dd8b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">this bit is set when we place a waiting \ gap type record lock request in order to let \ an insert of an index record to wait until \ there are no conflicting locks by other \ transactions on the gap; note that this flag \ remains set when the waiting lock is granted, \ or if the lock is inherited to a neighboring \ record  <a href="#a7a448126f7465de2aa940d1751dd8b7e">More...</a><br /></td></tr>
<tr class="separator:a7a448126f7465de2aa940d1751dd8b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e59e399364d823b33bc010e93e9c278"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7e59e399364d823b33bc010e93e9c278">LOCK_PREDICATE</a>&#160;&#160;&#160;8192</td></tr>
<tr class="memdesc:a7e59e399364d823b33bc010e93e9c278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate lock.  <a href="#a7e59e399364d823b33bc010e93e9c278">More...</a><br /></td></tr>
<tr class="separator:a7e59e399364d823b33bc010e93e9c278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe3f32b4e6bb44b08818eea5638e94b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7fe3f32b4e6bb44b08818eea5638e94b">LOCK_PRDT_PAGE</a>&#160;&#160;&#160;16384</td></tr>
<tr class="memdesc:a7fe3f32b4e6bb44b08818eea5638e94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page lock.  <a href="#a7fe3f32b4e6bb44b08818eea5638e94b">More...</a><br /></td></tr>
<tr class="separator:a7fe3f32b4e6bb44b08818eea5638e94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaa4032e81bf70e9e852814f9ed299741"><td class="memItemLeft" align="right" valign="top">typedef ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aaa4032e81bf70e9e852814f9ed299741">Lock_mutex</a></td></tr>
<tr class="separator:aaa4032e81bf70e9e852814f9ed299741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adfd720ce09a7e9babfd890d6a3c3d0a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a> { <a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3a820ead78f0fa32544c7ba38fe7ff53d9">lock_duration_t::REGULAR</a> = 0, 
<a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3a04f081bd5710a2e39455c0ddda6b23b4">lock_duration_t::AT_LEAST_STATEMENT</a> = 1
 }<tr class="memdesc:adfd720ce09a7e9babfd890d6a3c3d0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify the intended duration of a record lock.  <a href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adfd720ce09a7e9babfd890d6a3c3d0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a478c022c5f5da29524207004cfc5325d"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a478c022c5f5da29524207004cfc5325d">lock_get_size</a> (void)</td></tr>
<tr class="memdesc:a478c022c5f5da29524207004cfc5325d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of a lock struct.  <a href="#a478c022c5f5da29524207004cfc5325d">More...</a><br /></td></tr>
<tr class="separator:a478c022c5f5da29524207004cfc5325d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b61b8949e0116857ff488de16509d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a6b61b8949e0116857ff488de16509d4d">lock_sys_create</a> (ulint n_cells)</td></tr>
<tr class="memdesc:a6b61b8949e0116857ff488de16509d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the lock system at database start.  <a href="#a6b61b8949e0116857ff488de16509d4d">More...</a><br /></td></tr>
<tr class="separator:a6b61b8949e0116857ff488de16509d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6032b9d467a2fa36b3a6b1532df30a33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a6032b9d467a2fa36b3a6b1532df30a33">lock_sys_resize</a> (ulint n_cells)</td></tr>
<tr class="memdesc:a6032b9d467a2fa36b3a6b1532df30a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the lock hash tables.  <a href="#a6032b9d467a2fa36b3a6b1532df30a33">More...</a><br /></td></tr>
<tr class="separator:a6032b9d467a2fa36b3a6b1532df30a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127c8053fd0338b4d796d0c0de0272dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a127c8053fd0338b4d796d0c0de0272dd">lock_sys_close</a> (void)</td></tr>
<tr class="memdesc:a127c8053fd0338b4d796d0c0de0272dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the lock system at database shutdown.  <a href="#a127c8053fd0338b4d796d0c0de0272dd">More...</a><br /></td></tr>
<tr class="separator:a127c8053fd0338b4d796d0c0de0272dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d299943e5932310b8db82f441b885f5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9d299943e5932310b8db82f441b885f5">lock_get_min_heap_no</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a9d299943e5932310b8db82f441b885f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the heap_no of the smallest user record on a page.  <a href="#a9d299943e5932310b8db82f441b885f5">More...</a><br /></td></tr>
<tr class="separator:a9d299943e5932310b8db82f441b885f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb133e68ef2953ee54049f280eff17af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acb133e68ef2953ee54049f280eff17af">lock_move_reorganize_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *oblock)</td></tr>
<tr class="memdesc:acb133e68ef2953ee54049f280eff17af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when we have reorganized a page.  <a href="#acb133e68ef2953ee54049f280eff17af">More...</a><br /></td></tr>
<tr class="separator:acb133e68ef2953ee54049f280eff17af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4bca65fd7f08390fbe370ab09fe24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a72a4bca65fd7f08390fbe370ab09fe24">lock_move_rec_list_end</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a72a4bca65fd7f08390fbe370ab09fe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the explicit locks on user records to another page if a record list end is moved to another page.  <a href="#a72a4bca65fd7f08390fbe370ab09fe24">More...</a><br /></td></tr>
<tr class="separator:a72a4bca65fd7f08390fbe370ab09fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b4f10d6691a2c3446378525c1a9f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a856b4f10d6691a2c3446378525c1a9f2">lock_move_rec_list_start</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *old_end)</td></tr>
<tr class="memdesc:a856b4f10d6691a2c3446378525c1a9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the explicit locks on user records to another page if a record list start is moved to another page.  <a href="#a856b4f10d6691a2c3446378525c1a9f2">More...</a><br /></td></tr>
<tr class="separator:a856b4f10d6691a2c3446378525c1a9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af01b85f0aa5d1e2d0e026044673110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9af01b85f0aa5d1e2d0e026044673110">lock_update_split_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memdesc:a9af01b85f0aa5d1e2d0e026044673110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is split to the right.  <a href="#a9af01b85f0aa5d1e2d0e026044673110">More...</a><br /></td></tr>
<tr class="separator:a9af01b85f0aa5d1e2d0e026044673110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d987baa574ae26300c02c38d3297aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a98d987baa574ae26300c02c38d3297aa">lock_update_merge_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *orig_succ, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memdesc:a98d987baa574ae26300c02c38d3297aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is merged to the right.  <a href="#a98d987baa574ae26300c02c38d3297aa">More...</a><br /></td></tr>
<tr class="separator:a98d987baa574ae26300c02c38d3297aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60bc5af0ffa9cbef92444c2f36cbca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa60bc5af0ffa9cbef92444c2f36cbca0">lock_update_root_raise</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *root)</td></tr>
<tr class="memdesc:aa60bc5af0ffa9cbef92444c2f36cbca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when the root page is copied to another in btr_root_raise_and_insert.  <a href="#aa60bc5af0ffa9cbef92444c2f36cbca0">More...</a><br /></td></tr>
<tr class="separator:aa60bc5af0ffa9cbef92444c2f36cbca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d530560f93577d1c8b2865251a3a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a72d530560f93577d1c8b2865251a3a47">lock_update_copy_and_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a72d530560f93577d1c8b2865251a3a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root!  <a href="#a72d530560f93577d1c8b2865251a3a47">More...</a><br /></td></tr>
<tr class="separator:a72d530560f93577d1c8b2865251a3a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c056f069cb338691dafe4665b8a4435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a0c056f069cb338691dafe4665b8a4435">lock_update_split_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memdesc:a0c056f069cb338691dafe4665b8a4435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is split to the left.  <a href="#a0c056f069cb338691dafe4665b8a4435">More...</a><br /></td></tr>
<tr class="separator:a0c056f069cb338691dafe4665b8a4435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa151b0e44c3fd7542ef9441ac2125988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa151b0e44c3fd7542ef9441ac2125988">lock_update_merge_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *orig_pred, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block)</td></tr>
<tr class="memdesc:aa151b0e44c3fd7542ef9441ac2125988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is merged to the left.  <a href="#aa151b0e44c3fd7542ef9441ac2125988">More...</a><br /></td></tr>
<tr class="separator:aa151b0e44c3fd7542ef9441ac2125988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a13c16488466902242a906b82422a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad5a13c16488466902242a906b82422a7">lock_rec_reset_and_inherit_gap_locks</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="memdesc:ad5a13c16488466902242a906b82422a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the original locks on heir and replaces them with gap type locks inherited from rec.  <a href="#ad5a13c16488466902242a906b82422a7">More...</a><br /></td></tr>
<tr class="separator:ad5a13c16488466902242a906b82422a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c59f431194af5e5f6a6842bfe50344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a11c59f431194af5e5f6a6842bfe50344">lock_update_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, ulint heir_heap_no, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a11c59f431194af5e5f6a6842bfe50344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is discarded.  <a href="#a11c59f431194af5e5f6a6842bfe50344">More...</a><br /></td></tr>
<tr class="separator:a11c59f431194af5e5f6a6842bfe50344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de1c790f6a289f4b803acab127b3755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3de1c790f6a289f4b803acab127b3755">lock_update_insert</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a3de1c790f6a289f4b803acab127b3755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a new user record is inserted.  <a href="#a3de1c790f6a289f4b803acab127b3755">More...</a><br /></td></tr>
<tr class="separator:a3de1c790f6a289f4b803acab127b3755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d9fef0df1b551f23c7da52fd68accd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa2d9fef0df1b551f23c7da52fd68accd">lock_update_delete</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:aa2d9fef0df1b551f23c7da52fd68accd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a record is removed.  <a href="#aa2d9fef0df1b551f23c7da52fd68accd">More...</a><br /></td></tr>
<tr class="separator:aa2d9fef0df1b551f23c7da52fd68accd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e2620fd1f715019989f11107c2de47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a63e2620fd1f715019989f11107c2de47">lock_rec_store_on_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a63e2620fd1f715019989f11107c2de47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores on the page infimum record the explicit locks of another record.  <a href="#a63e2620fd1f715019989f11107c2de47">More...</a><br /></td></tr>
<tr class="separator:a63e2620fd1f715019989f11107c2de47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70020e803cb615546ffde6384bb8505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae70020e803cb615546ffde6384bb8505">lock_rec_restore_from_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator)</td></tr>
<tr class="memdesc:ae70020e803cb615546ffde6384bb8505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page.  <a href="#ae70020e803cb615546ffde6384bb8505">More...</a><br /></td></tr>
<tr class="separator:ae70020e803cb615546ffde6384bb8505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105a61c935f6765bbc78ddbf40203a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a105a61c935f6765bbc78ddbf40203a4f">lock_rec_expl_exist_on_page</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a105a61c935f6765bbc78ddbf40203a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if there are explicit record locks on a page.  <a href="#a105a61c935f6765bbc78ddbf40203a4f">More...</a><br /></td></tr>
<tr class="separator:a105a61c935f6765bbc78ddbf40203a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d6fd7d2966684cc39668db595f5c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af3d6fd7d2966684cc39668db595f5c3a">lock_rec_insert_check_and_lock</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, ibool *inherit)</td></tr>
<tr class="memdesc:af3d6fd7d2966684cc39668db595f5c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate insert of a record.  <a href="#af3d6fd7d2966684cc39668db595f5c3a">More...</a><br /></td></tr>
<tr class="separator:af3d6fd7d2966684cc39668db595f5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf66df1ce4412d6d621cdc8b77859e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aaf66df1ce4412d6d621cdc8b77859e81">lock_clust_rec_modify_check_and_lock</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:aaf66df1ce4412d6d621cdc8b77859e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate modify (update, delete mark, or delete unmark) of a clustered index record.  <a href="#aaf66df1ce4412d6d621cdc8b77859e81">More...</a><br /></td></tr>
<tr class="separator:aaf66df1ce4412d6d621cdc8b77859e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00980a4b5a19525a76a41633a5acfb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae00980a4b5a19525a76a41633a5acfb2">lock_sec_rec_modify_check_and_lock</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae00980a4b5a19525a76a41633a5acfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate modify (delete mark or delete unmark) of a secondary index record.  <a href="#ae00980a4b5a19525a76a41633a5acfb2">More...</a><br /></td></tr>
<tr class="separator:ae00980a4b5a19525a76a41633a5acfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9025c7188f98ef88d223591eb7fe0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aca9025c7188f98ef88d223591eb7fe0d">lock_on_statement_end</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aca9025c7188f98ef88d223591eb7fe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to inform lock-sys that a statement processing for a trx has just finished.  <a href="#aca9025c7188f98ef88d223591eb7fe0d">More...</a><br /></td></tr>
<tr class="separator:aca9025c7188f98ef88d223591eb7fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d0cc4eeb09cc8c0c1b56e777c08fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a759d0cc4eeb09cc8c0c1b56e777c08fb">lock_sec_rec_read_check_and_lock</a> (<a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a> duration, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a759d0cc4eeb09cc8c0c1b56e777c08fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lock_clust_rec_read_check_and_lock(), but reads a secondary index record.  <a href="#a759d0cc4eeb09cc8c0c1b56e777c08fb">More...</a><br /></td></tr>
<tr class="separator:a759d0cc4eeb09cc8c0c1b56e777c08fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64258dd611022cc3e5ddd008b1d8e853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a64258dd611022cc3e5ddd008b1d8e853">lock_clust_rec_read_check_and_lock</a> (<a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a> duration, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a64258dd611022cc3e5ddd008b1d8e853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record.  <a href="#a64258dd611022cc3e5ddd008b1d8e853">More...</a><br /></td></tr>
<tr class="separator:a64258dd611022cc3e5ddd008b1d8e853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57805d4a0fcad73101c822963168dca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a57805d4a0fcad73101c822963168dca0">lock_clust_rec_read_check_and_lock_alt</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a57805d4a0fcad73101c822963168dca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record.  <a href="#a57805d4a0fcad73101c822963168dca0">More...</a><br /></td></tr>
<tr class="separator:a57805d4a0fcad73101c822963168dca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c0eec427989825525fd4b4b9cffc1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a02c0eec427989825525fd4b4b9cffc1b">lock_clust_rec_cons_read_sees</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="classReadView.html">ReadView</a> *view)</td></tr>
<tr class="memdesc:a02c0eec427989825525fd4b4b9cffc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a record is seen in a consistent read.  <a href="#a02c0eec427989825525fd4b4b9cffc1b">More...</a><br /></td></tr>
<tr class="separator:a02c0eec427989825525fd4b4b9cffc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a7181a1b37cd5b082c7b41f816e7be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a53a7181a1b37cd5b082c7b41f816e7be">lock_sec_rec_cons_read_sees</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="classReadView.html">ReadView</a> *view)</td></tr>
<tr class="memdesc:a53a7181a1b37cd5b082c7b41f816e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a non-clustered index record is seen in a consistent read.  <a href="#a53a7181a1b37cd5b082c7b41f816e7be">More...</a><br /></td></tr>
<tr class="separator:a53a7181a1b37cd5b082c7b41f816e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a3a3e111f874ce25075882ef35dfd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae1a3a3e111f874ce25075882ef35dfd9">lock_table</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ae1a3a3e111f874ce25075882ef35dfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the specified database table in the mode given.  <a href="#ae1a3a3e111f874ce25075882ef35dfd9">More...</a><br /></td></tr>
<tr class="separator:ae1a3a3e111f874ce25075882ef35dfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1d4aaa7d211a0b5fa98edcf3b7c09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a8b1d4aaa7d211a0b5fa98edcf3b7c09b">lock_table_ix_resurrect</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a8b1d4aaa7d211a0b5fa98edcf3b7c09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table IX lock object for a resurrected transaction.  <a href="#a8b1d4aaa7d211a0b5fa98edcf3b7c09b">More...</a><br /></td></tr>
<tr class="separator:a8b1d4aaa7d211a0b5fa98edcf3b7c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8b30188b58505e53584a7c428a95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a94f8b30188b58505e53584a7c428a95d">lock_table_for_trx</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structtrx__t.html">trx_t</a> *trx, enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode)</td></tr>
<tr class="memdesc:a94f8b30188b58505e53584a7c428a95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lock on a table based on the given mode.  <a href="#a94f8b30188b58505e53584a7c428a95d">More...</a><br /></td></tr>
<tr class="separator:a94f8b30188b58505e53584a7c428a95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385872f00cebe85ef57ac1ee1d1a9ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a385872f00cebe85ef57ac1ee1d1a9ec5">lock_rec_unlock</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>)</td></tr>
<tr class="memdesc:a385872f00cebe85ef57ac1ee1d1a9ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock.  <a href="#a385872f00cebe85ef57ac1ee1d1a9ec5">More...</a><br /></td></tr>
<tr class="separator:a385872f00cebe85ef57ac1ee1d1a9ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb256f6d14ba050d686b9ba1d007b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a0fbb256f6d14ba050d686b9ba1d007b0">lock_trx_release_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a0fbb256f6d14ba050d686b9ba1d007b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a transaction's locks, and releases possible other transactions waiting because of these locks.  <a href="#a0fbb256f6d14ba050d686b9ba1d007b0">More...</a><br /></td></tr>
<tr class="separator:a0fbb256f6d14ba050d686b9ba1d007b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837664214700c0a21ff9c6ab1085fa76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a837664214700c0a21ff9c6ab1085fa76">lock_trx_release_read_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> only_gap)</td></tr>
<tr class="memdesc:a837664214700c0a21ff9c6ab1085fa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release read locks of a transaction.  <a href="#a837664214700c0a21ff9c6ab1085fa76">More...</a><br /></td></tr>
<tr class="separator:a837664214700c0a21ff9c6ab1085fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b05d56ac7614e7dccf30e00730ef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a324b05d56ac7614e7dccf30e00730ef3">lock_make_trx_hit_list</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="trx0types_8h.html#a13121c5e3c7e683afe964f2903433257">hit_list_t</a> &amp;hit_list)</td></tr>
<tr class="memdesc:a324b05d56ac7614e7dccf30e00730ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the granted locks which conflict with trx-&gt;lock.wait_lock and prepare the hit list for ASYNC Rollback.  <a href="#a324b05d56ac7614e7dccf30e00730ef3">More...</a><br /></td></tr>
<tr class="separator:a324b05d56ac7614e7dccf30e00730ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef596f4d04a32dc7eeea3e7a8481341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a2ef596f4d04a32dc7eeea3e7a8481341">lock_remove_all_on_table</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ibool remove_also_table_sx_locks)</td></tr>
<tr class="memdesc:a2ef596f4d04a32dc7eeea3e7a8481341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes locks on a table to be dropped.  <a href="#a2ef596f4d04a32dc7eeea3e7a8481341">More...</a><br /></td></tr>
<tr class="separator:a2ef596f4d04a32dc7eeea3e7a8481341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1206e21ae1b1abe21e29acec6af79a8c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a1206e21ae1b1abe21e29acec6af79a8c">lock_rec_fold</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> page_id)</td></tr>
<tr class="memdesc:a1206e21ae1b1abe21e29acec6af79a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fold value of a page file address: used in inserting or searching for a lock in the hash table.  <a href="#a1206e21ae1b1abe21e29acec6af79a8c">More...</a><br /></td></tr>
<tr class="separator:a1206e21ae1b1abe21e29acec6af79a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa323d3d3a9437fb8589b1856ce3afdee"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa323d3d3a9437fb8589b1856ce3afdee">lock_rec_hash</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:aa323d3d3a9437fb8589b1856ce3afdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hash value of a page file address: used in inserting or searching for a lock in the hash table.  <a href="#aa323d3d3a9437fb8589b1856ce3afdee">More...</a><br /></td></tr>
<tr class="separator:aa323d3d3a9437fb8589b1856ce3afdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fec2aa31cc581d490329f5be3e11088"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7fec2aa31cc581d490329f5be3e11088">lock_hash_get</a> (ulint mode)</td></tr>
<tr class="memdesc:a7fec2aa31cc581d490329f5be3e11088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lock hash table.  <a href="#a7fec2aa31cc581d490329f5be3e11088">More...</a><br /></td></tr>
<tr class="separator:a7fec2aa31cc581d490329f5be3e11088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ccba69e261b79e8c7ab7d83cb41319"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad7ccba69e261b79e8c7ab7d83cb41319">lock_rec_find_set_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ad7ccba69e261b79e8c7ab7d83cb41319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for a set bit in a record lock bitmap.  <a href="#ad7ccba69e261b79e8c7ab7d83cb41319">More...</a><br /></td></tr>
<tr class="separator:ad7ccba69e261b79e8c7ab7d83cb41319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c73150ff49ff33364b8dfe57796bac2"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a6c73150ff49ff33364b8dfe57796bac2">lock_rec_find_next_set_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="memdesc:a6c73150ff49ff33364b8dfe57796bac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for the next set bit in the record lock bitmap.  <a href="#a6c73150ff49ff33364b8dfe57796bac2">More...</a><br /></td></tr>
<tr class="separator:a6c73150ff49ff33364b8dfe57796bac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cec654a8d71e13f4113aa36dd0d78f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae9cec654a8d71e13f4113aa36dd0d78f">lock_has_to_wait</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock1, const <a class="el" href="structlock__t.html">lock_t</a> *lock2)</td></tr>
<tr class="memdesc:ae9cec654a8d71e13f4113aa36dd0d78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a lock request lock1 has to wait for request lock2.  <a href="#ae9cec654a8d71e13f4113aa36dd0d78f">More...</a><br /></td></tr>
<tr class="separator:ae9cec654a8d71e13f4113aa36dd0d78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac881161276c0dfc1994b2af6d22f3ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac881161276c0dfc1994b2af6d22f3ea5">lock_report_trx_id_insanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> max_trx_id)</td></tr>
<tr class="memdesc:ac881161276c0dfc1994b2af6d22f3ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports that a transaction id is insensible, i.e., in the future.  <a href="#ac881161276c0dfc1994b2af6d22f3ea5">More...</a><br /></td></tr>
<tr class="separator:ac881161276c0dfc1994b2af6d22f3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396c1bdffc5e098c024ad929ba594dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a396c1bdffc5e098c024ad929ba594dd8">lock_print_info_summary</a> (FILE *file)</td></tr>
<tr class="memdesc:a396c1bdffc5e098c024ad929ba594dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of locks for all transactions.  <a href="#a396c1bdffc5e098c024ad929ba594dd8">More...</a><br /></td></tr>
<tr class="separator:a396c1bdffc5e098c024ad929ba594dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b2ef62b3cd2784b7d3d3c442d9a320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa4b2ef62b3cd2784b7d3d3c442d9a320">lock_trx_print_wait_and_mvcc_state</a> (FILE *file, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aa4b2ef62b3cd2784b7d3d3c442d9a320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints transaction lock wait and MVCC state.  <a href="#aa4b2ef62b3cd2784b7d3d3c442d9a320">More...</a><br /></td></tr>
<tr class="separator:aa4b2ef62b3cd2784b7d3d3c442d9a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc5c7b8bef35ee70ba968607a22fb24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#abdc5c7b8bef35ee70ba968607a22fb24">lock_print_info_all_transactions</a> (FILE *file)</td></tr>
<tr class="memdesc:abdc5c7b8bef35ee70ba968607a22fb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of locks for each transaction.  <a href="#abdc5c7b8bef35ee70ba968607a22fb24">More...</a><br /></td></tr>
<tr class="separator:abdc5c7b8bef35ee70ba968607a22fb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ab5b5a29bf12d5dfd022fc0ee5d815"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af0ab5b5a29bf12d5dfd022fc0ee5d815">lock_number_of_rows_locked</a> (const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *trx_lock)</td></tr>
<tr class="memdesc:af0ab5b5a29bf12d5dfd022fc0ee5d815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return approximate number or record locks (bits set in the bitmap) for this transaction.  <a href="#af0ab5b5a29bf12d5dfd022fc0ee5d815">More...</a><br /></td></tr>
<tr class="separator:af0ab5b5a29bf12d5dfd022fc0ee5d815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9f940afda7bc372f6b78a23ed1aa37"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a8a9f940afda7bc372f6b78a23ed1aa37">lock_number_of_tables_locked</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a8a9f940afda7bc372f6b78a23ed1aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of table locks for a transaction.  <a href="#a8a9f940afda7bc372f6b78a23ed1aa37">More...</a><br /></td></tr>
<tr class="separator:a8a9f940afda7bc372f6b78a23ed1aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374b98595a50acd2ec82df4e1952d51e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a374b98595a50acd2ec82df4e1952d51e">lock_get_type</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a374b98595a50acd2ec82df4e1952d51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of a lock.  <a href="#a374b98595a50acd2ec82df4e1952d51e">More...</a><br /></td></tr>
<tr class="separator:a374b98595a50acd2ec82df4e1952d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecbf8e0ed8c9de8a425e360a40ac779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#abecbf8e0ed8c9de8a425e360a40ac779">lock_get_trx_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:abecbf8e0ed8c9de8a425e360a40ac779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the id of the transaction owning a lock.  <a href="#abecbf8e0ed8c9de8a425e360a40ac779">More...</a><br /></td></tr>
<tr class="separator:abecbf8e0ed8c9de8a425e360a40ac779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0570cd0fb05c95af79ac66dcea8c636b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a0570cd0fb05c95af79ac66dcea8c636b">lock_get_trx_immutable_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a0570cd0fb05c95af79ac66dcea8c636b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the immutable id of the transaction owning a lock.  <a href="#a0570cd0fb05c95af79ac66dcea8c636b">More...</a><br /></td></tr>
<tr class="separator:a0570cd0fb05c95af79ac66dcea8c636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1dd693350e9ebc88a5f07f4a9236d4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a0a1dd693350e9ebc88a5f07f4a9236d4">lock_get_immutable_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a0a1dd693350e9ebc88a5f07f4a9236d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the immutable id of this lock.  <a href="#a0a1dd693350e9ebc88a5f07f4a9236d4">More...</a><br /></td></tr>
<tr class="separator:a0a1dd693350e9ebc88a5f07f4a9236d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecc4ffef7bce145529de20c3ee12d36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acecc4ffef7bce145529de20c3ee12d36">lock_get_psi_event</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *<a class="el" href="my__thr__init_8cc.html#a670cae2ed1025603c1d5b6712d264645">thread_id</a>, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *event_id)</td></tr>
<tr class="memdesc:acecc4ffef7bce145529de20c3ee12d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the performance schema event (thread_id, event_id) that created the lock.  <a href="#acecc4ffef7bce145529de20c3ee12d36">More...</a><br /></td></tr>
<tr class="separator:acecc4ffef7bce145529de20c3ee12d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d39383d7ac9dd4ca34a24f271a1baf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac7d39383d7ac9dd4ca34a24f271a1baf">lock_get_first_trx_locks</a> (const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *trx_lock)</td></tr>
<tr class="memdesc:ac7d39383d7ac9dd4ca34a24f271a1baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first lock of a trx lock list.  <a href="#ac7d39383d7ac9dd4ca34a24f271a1baf">More...</a><br /></td></tr>
<tr class="separator:ac7d39383d7ac9dd4ca34a24f271a1baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b99bda2e15de31f306979231d1f5436"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5b99bda2e15de31f306979231d1f5436">lock_get_next_trx_locks</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a5b99bda2e15de31f306979231d1f5436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next lock of a trx lock list.  <a href="#a5b99bda2e15de31f306979231d1f5436">More...</a><br /></td></tr>
<tr class="separator:a5b99bda2e15de31f306979231d1f5436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb165a7de4839caf9783cade418f7703"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aeb165a7de4839caf9783cade418f7703">lock_get_mode_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aeb165a7de4839caf9783cade418f7703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mode of a lock in a human readable string.  <a href="#aeb165a7de4839caf9783cade418f7703">More...</a><br /></td></tr>
<tr class="separator:aeb165a7de4839caf9783cade418f7703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae17fad2ea0c4abe3252d4089e6a6a5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a2ae17fad2ea0c4abe3252d4089e6a6a5">lock_get_type_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a2ae17fad2ea0c4abe3252d4089e6a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of a lock in a human readable string.  <a href="#a2ae17fad2ea0c4abe3252d4089e6a6a5">More...</a><br /></td></tr>
<tr class="separator:a2ae17fad2ea0c4abe3252d4089e6a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f014df68b9ac74600c80de96092b91c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7f014df68b9ac74600c80de96092b91c">lock_get_table_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a7f014df68b9ac74600c80de96092b91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the id of the table on which the lock is.  <a href="#a7f014df68b9ac74600c80de96092b91c">More...</a><br /></td></tr>
<tr class="separator:a7f014df68b9ac74600c80de96092b91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd305f10c527e77d4f78fbb758b89b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtable__name__t.html">table_name_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acfd305f10c527e77d4f78fbb758b89b6">lock_get_table_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:acfd305f10c527e77d4f78fbb758b89b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which table a lock is associated with.  <a href="#acfd305f10c527e77d4f78fbb758b89b6">More...</a><br /></td></tr>
<tr class="separator:acfd305f10c527e77d4f78fbb758b89b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489f292f2abfd59464a820e4ef3efdf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a489f292f2abfd59464a820e4ef3efdf6">lock_rec_get_index</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a489f292f2abfd59464a820e4ef3efdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a record lock, gets the index on which the lock is.  <a href="#a489f292f2abfd59464a820e4ef3efdf6">More...</a><br /></td></tr>
<tr class="separator:a489f292f2abfd59464a820e4ef3efdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cae5f235e5f095fb70d92c8d2e0bc6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a07cae5f235e5f095fb70d92c8d2e0bc6">lock_rec_get_index_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a07cae5f235e5f095fb70d92c8d2e0bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a record lock, gets the name of the index on which the lock is.  <a href="#a07cae5f235e5f095fb70d92c8d2e0bc6">More...</a><br /></td></tr>
<tr class="separator:a07cae5f235e5f095fb70d92c8d2e0bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa95ea09f1777797a5e22cb63720d483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpage__id__t.html">page_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aaa95ea09f1777797a5e22cb63720d483">lock_rec_get_page_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aaa95ea09f1777797a5e22cb63720d483"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a record lock, gets the tablespace number and page number on which the lock is.  <a href="#aaa95ea09f1777797a5e22cb63720d483">More...</a><br /></td></tr>
<tr class="separator:aaa95ea09f1777797a5e22cb63720d483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7271bf61ea0010a2552e9343dad624c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7271bf61ea0010a2552e9343dad624c3">lock_table_has_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a7271bf61ea0010a2552e9343dad624c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any locks (table or rec) against table.  <a href="#a7271bf61ea0010a2552e9343dad624c3">More...</a><br /></td></tr>
<tr class="separator:a7271bf61ea0010a2552e9343dad624c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b7ab612695ece320a4731a8f69e8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a82b7ab612695ece320a4731a8f69e8cb">lock_wait_timeout_thread</a> ()</td></tr>
<tr class="memdesc:a82b7ab612695ece320a4731a8f69e8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread which wakes up threads whose lock wait may have lasted too long.  <a href="#a82b7ab612695ece320a4731a8f69e8cb">More...</a><br /></td></tr>
<tr class="separator:a82b7ab612695ece320a4731a8f69e8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791dd54f6bbed78c9fc0f94c454f18da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a791dd54f6bbed78c9fc0f94c454f18da">lock_wait_request_check_for_cycles</a> ()</td></tr>
<tr class="memdesc:a791dd54f6bbed78c9fc0f94c454f18da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the thread which analyzes wait-for-graph that there was at least one new edge added or modified ( trx-&gt;blocking_trx has changed ), so that the thread will know it has to analyze it.  <a href="#a791dd54f6bbed78c9fc0f94c454f18da">More...</a><br /></td></tr>
<tr class="separator:a791dd54f6bbed78c9fc0f94c454f18da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef9abc31e16983f141559c65f7582d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae4ef9abc31e16983f141559c65f7582d">lock_wait_suspend_thread</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ae4ef9abc31e16983f141559c65f7582d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a user OS thread to wait for a lock to be released.  <a href="#ae4ef9abc31e16983f141559c65f7582d">More...</a><br /></td></tr>
<tr class="separator:ae4ef9abc31e16983f141559c65f7582d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af6183a5555e7a95a366be8aaa7f280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5af6183a5555e7a95a366be8aaa7f280">lock_unlock_table_autoinc</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a5af6183a5555e7a95a366be8aaa7f280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks AUTO_INC type locks that were possibly reserved by a trx.  <a href="#a5af6183a5555e7a95a366be8aaa7f280">More...</a><br /></td></tr>
<tr class="separator:a5af6183a5555e7a95a366be8aaa7f280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefbced8febccb3e8ab67e20ee33b0b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aeefbced8febccb3e8ab67e20ee33b0b4">lock_trx_handle_wait</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aeefbced8febccb3e8ab67e20ee33b0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the transaction has already been rolled back because it was selected as a deadlock victim, or if it has to wait then cancel the wait lock.  <a href="#aeefbced8febccb3e8ab67e20ee33b0b4">More...</a><br /></td></tr>
<tr class="separator:aeefbced8febccb3e8ab67e20ee33b0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5f27eeb669c559bcf49469cbe3d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a82f5f27eeb669c559bcf49469cbe3d16">lock_trx_lock_list_init</a> (trx_lock_list_t *lock_list)</td></tr>
<tr class="memdesc:a82f5f27eeb669c559bcf49469cbe3d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the trx lock list.  <a href="#a82f5f27eeb669c559bcf49469cbe3d16">More...</a><br /></td></tr>
<tr class="separator:a82f5f27eeb669c559bcf49469cbe3d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba28814c32fc40e4c71c8a32f6fdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af0ba28814c32fc40e4c71c8a32f6fdba">lock_set_timeout_event</a> ()</td></tr>
<tr class="memdesc:af0ba28814c32fc40e4c71c8a32f6fdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the lock system timeout event.  <a href="#af0ba28814c32fc40e4c71c8a32f6fdba">More...</a><br /></td></tr>
<tr class="separator:af0ba28814c32fc40e4c71c8a32f6fdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ca4cfe4edd613e4bf2f2880d5e6a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab0ca4cfe4edd613e4bf2f2880d5e6a7e">lock_check_trx_id_sanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:ab0ca4cfe4edd613e4bf2f2880d5e6a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a transaction id is sensible, i.e., not in the future.  <a href="#ab0ca4cfe4edd613e4bf2f2880d5e6a7e">More...</a><br /></td></tr>
<tr class="separator:ab0ca4cfe4edd613e4bf2f2880d5e6a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99887080ffdb266d6f94b5938ab423d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a99887080ffdb266d6f94b5938ab423d2">lock_trx_has_rec_x_lock</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no)</td></tr>
<tr class="memdesc:a99887080ffdb266d6f94b5938ab423d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the transaction holds an exclusive lock on a record.  <a href="#a99887080ffdb266d6f94b5938ab423d2">More...</a><br /></td></tr>
<tr class="separator:a99887080ffdb266d6f94b5938ab423d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba7196cfa609a25581a9c37537b697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a4aba7196cfa609a25581a9c37537b697">lock_validate</a> ()</td></tr>
<tr class="memdesc:a4aba7196cfa609a25581a9c37537b697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the lock system.  <a href="#a4aba7196cfa609a25581a9c37537b697">More...</a><br /></td></tr>
<tr class="separator:a4aba7196cfa609a25581a9c37537b697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd23066177e056191e90bae4f14215e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#afd23066177e056191e90bae4f14215e0">lock_trx_alloc_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:afd23066177e056191e90bae4f14215e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate cached locks for the transaction.  <a href="#afd23066177e056191e90bae4f14215e0">More...</a><br /></td></tr>
<tr class="separator:afd23066177e056191e90bae4f14215e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98fb0ca09acc1516e030769b0ba8358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac98fb0ca09acc1516e030769b0ba8358">lock_rec_convert_active_impl_to_expl</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint heap_no)</td></tr>
<tr class="memdesc:ac98fb0ca09acc1516e030769b0ba8358"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is kind of wrapper to lock_rec_convert_impl_to_expl_for_trx() function with functionailty added to facilitate lock conversion from implicit to explicit for partial rollback cases.  <a href="#ac98fb0ca09acc1516e030769b0ba8358">More...</a><br /></td></tr>
<tr class="separator:ac98fb0ca09acc1516e030769b0ba8358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb40b46c0751e5e8f8d6d9b841251a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aeb40b46c0751e5e8f8d6d9b841251a64">lock_rec_discard</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="memdesc:aeb40b46c0751e5e8f8d6d9b841251a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a record lock request, waiting or granted, from the queue.  <a href="#aeb40b46c0751e5e8f8d6d9b841251a64">More...</a><br /></td></tr>
<tr class="separator:aeb40b46c0751e5e8f8d6d9b841251a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fefbca8fe9d4d308d925eff524b4f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a47fefbca8fe9d4d308d925eff524b4f8">lock_rtr_move_rec_list</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="gis0type_8h.html#a2d71af64b5717827d5581da7a7b4a180">rtr_rec_move_t</a> *rec_move, ulint num_move)</td></tr>
<tr class="memdesc:a47fefbca8fe9d4d308d925eff524b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the explicit locks on user records to another page if a record list start is moved to another page.  <a href="#a47fefbca8fe9d4d308d925eff524b4f8">More...</a><br /></td></tr>
<tr class="separator:a47fefbca8fe9d4d308d925eff524b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c55d69db3ad92b4af176625eac460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5f9c55d69db3ad92b4af176625eac460">lock_rec_free_all_from_discard_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a5f9c55d69db3ad92b4af176625eac460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes record lock objects set on an index page which is discarded.  <a href="#a5f9c55d69db3ad92b4af176625eac460">More...</a><br /></td></tr>
<tr class="separator:a5f9c55d69db3ad92b4af176625eac460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc396ea6e4e953a9400b711b2d57230f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#adc396ea6e4e953a9400b711b2d57230f">lock_rec_trx_wait</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, ulint i, ulint type)</td></tr>
<tr class="memdesc:adc396ea6e4e953a9400b711b2d57230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the nth bit of a record lock.  <a href="#adc396ea6e4e953a9400b711b2d57230f">More...</a><br /></td></tr>
<tr class="separator:adc396ea6e4e953a9400b711b2d57230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c13b29c0950883c716f2195fcaca15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#aa1c13b29c0950883c716f2195fcaca15">locksys::owns_exclusive_global_latch</a> ()</td></tr>
<tr class="memdesc:aa1c13b29c0950883c716f2195fcaca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if lock_sys latch is exclusively owned by the current thread.  <a href="namespacelocksys.html#aa1c13b29c0950883c716f2195fcaca15">More...</a><br /></td></tr>
<tr class="separator:aa1c13b29c0950883c716f2195fcaca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b658001706cfd23bc39aa8b5854adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a75b658001706cfd23bc39aa8b5854adb">locksys::owns_shared_global_latch</a> ()</td></tr>
<tr class="memdesc:a75b658001706cfd23bc39aa8b5854adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if lock_sys latch is owned in shared mode by the current thread.  <a href="namespacelocksys.html#a75b658001706cfd23bc39aa8b5854adb">More...</a><br /></td></tr>
<tr class="separator:a75b658001706cfd23bc39aa8b5854adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6f08b62f3525ce41e225523a004f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a2f6f08b62f3525ce41e225523a004f5b">locksys::owns_page_shard</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a2f6f08b62f3525ce41e225523a004f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if given page shard can be safely accessed by the current thread.  <a href="namespacelocksys.html#a2f6f08b62f3525ce41e225523a004f5b">More...</a><br /></td></tr>
<tr class="separator:a2f6f08b62f3525ce41e225523a004f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb712cc63a48c9031f3c9af257bcf29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a6bb712cc63a48c9031f3c9af257bcf29">locksys::owns_table_shard</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> &amp;table)</td></tr>
<tr class="memdesc:a6bb712cc63a48c9031f3c9af257bcf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if given table shard can be safely accessed by the current thread.  <a href="namespacelocksys.html#a6bb712cc63a48c9031f3c9af257bcf29">More...</a><br /></td></tr>
<tr class="separator:a6bb712cc63a48c9031f3c9af257bcf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9dc7c8edd2e37a5c20ae2672c28f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a9e9dc7c8edd2e37a5c20ae2672c28f27">locksys::owns_lock_shard</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a9e9dc7c8edd2e37a5c20ae2672c28f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if shard which contains lock is latched (or that an exclusive latch on whole lock_sys is held) by current thread.  <a href="namespacelocksys.html#a9e9dc7c8edd2e37a5c20ae2672c28f27">More...</a><br /></td></tr>
<tr class="separator:a9e9dc7c8edd2e37a5c20ae2672c28f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a81d550ee42c724c84fb023128ce80147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a81d550ee42c724c84fb023128ce80147">innobase_deadlock_detect</a></td></tr>
<tr class="separator:a81d550ee42c724c84fb023128ce80147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5399aad1a992cb27e897fc806570ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__sys__t.html">lock_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></td></tr>
<tr class="memdesc:ac5399aad1a992cb27e897fc806570ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock system.  <a href="#ac5399aad1a992cb27e897fc806570ba0">More...</a><br /></td></tr>
<tr class="separator:ac5399aad1a992cb27e897fc806570ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The transaction lock system. </p>
<p>Created 5/7/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8631af3f85d4c19484f6de819b2b2a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8631af3f85d4c19484f6de819b2b2a37">&#9670;&nbsp;</a></span>LOCK_GAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_GAP&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>when this bit is set, it means that the \ lock holds only on the gap before the record; \ for instance, an x-lock on the gap does not \ give permission to modify the record on which \ the bit is set; locks of this type are created \ when records are removed from the index chain \ of records </p>

</div>
</div>
<a id="a7a448126f7465de2aa940d1751dd8b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a448126f7465de2aa940d1751dd8b7e">&#9670;&nbsp;</a></span>LOCK_INSERT_INTENTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_INSERT_INTENTION&#160;&#160;&#160;2048</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this bit is set when we place a waiting \ gap type record lock request in order to let \ an insert of an index record to wait until \ there are no conflicting locks by other \ transactions on the gap; note that this flag \ remains set when the waiting lock is granted, \ or if the lock is inherited to a neighboring \ record </p>

</div>
</div>
<a id="aea25ac33bd6692ef77c95c6a7da765a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea25ac33bd6692ef77c95c6a7da765a8">&#9670;&nbsp;</a></span>LOCK_MODE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_MODE_MASK&#160;&#160;&#160;0xFUL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock modes and types. </p>
<p>mask used to extract mode from the \ type_mode field in a lock </p>

</div>
</div>
<a id="a95f8dd3d016d01aaa314160f0db74e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f8dd3d016d01aaa314160f0db74e75">&#9670;&nbsp;</a></span>LOCK_ORDINARY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_ORDINARY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this flag denotes an ordinary \ next-key lock in contrast to LOCK_GAP \ or LOCK_REC_NOT_GAP </p>

</div>
</div>
<a id="a7fe3f32b4e6bb44b08818eea5638e94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe3f32b4e6bb44b08818eea5638e94b">&#9670;&nbsp;</a></span>LOCK_PRDT_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_PRDT_PAGE&#160;&#160;&#160;16384</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Page lock. </p>

</div>
</div>
<a id="a7e59e399364d823b33bc010e93e9c278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e59e399364d823b33bc010e93e9c278">&#9670;&nbsp;</a></span>LOCK_PREDICATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_PREDICATE&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate lock. </p>

</div>
</div>
<a id="a145ae646d1def688ee264b9d98c2e981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145ae646d1def688ee264b9d98c2e981">&#9670;&nbsp;</a></span>LOCK_REC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_REC&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>record lock </p>

</div>
</div>
<a id="a5ec9b0cce21ee17de083d3bb96b1bec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec9b0cce21ee17de083d3bb96b1bec6">&#9670;&nbsp;</a></span>LOCK_REC_NOT_GAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_REC_NOT_GAP&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this bit means that the lock is only on \ the index record and does NOT block inserts \ to the gap before the index record; this is \ used in the case when we retrieve a record \ with a unique key, and is also used in \ locking plain SELECTs (not part of UPDATE \ or DELETE) when the user has set the READ \ COMMITTED isolation level </p>

</div>
</div>
<a id="a3f5d26fd94580daba78f376b8ca887dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5d26fd94580daba78f376b8ca887dd">&#9670;&nbsp;</a></span>LOCK_TABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_TABLE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock types. </p>
<p>table lock </p>

</div>
</div>
<a id="a51876da8368dde6b362ce3c465dcc9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51876da8368dde6b362ce3c465dcc9eb">&#9670;&nbsp;</a></span>LOCK_TYPE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_TYPE_MASK&#160;&#160;&#160;0xF0UL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mask used to extract lock type from the \ type_mode field in a lock </p>

</div>
</div>
<a id="a92ad796dd0adc2da08468a220376fe76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad796dd0adc2da08468a220376fe76">&#9670;&nbsp;</a></span>LOCK_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_WAIT&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waiting lock flag; when set, it \ means that the lock has not yet been \ granted, it is just waiting for its \ turn in the wait queue. </p>

</div>
</div>
<a id="af316b7272e81c47c1548d22025f542e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af316b7272e81c47c1548d22025f542e3">&#9670;&nbsp;</a></span>lock_wait_mutex_enter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_enter</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                  \</div><div class="line">    mutex_enter(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#ac820ef11c4d82095fe9bd839b272cc78">wait_mutex</a>); \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="structlock__sys__t_html_ac820ef11c4d82095fe9bd839b272cc78"><div class="ttname"><a href="structlock__sys__t.html#ac820ef11c4d82095fe9bd839b272cc78">lock_sys_t::wait_mutex</a></div><div class="ttdeci">Lock_mutex wait_mutex</div><div class="ttdoc">The mutex protecting the next two fields. </div><div class="ttdef"><b>Definition:</b> lock0lock.h:987</div></div>
<div class="ttc" id="lock0lock_8h_html_ac5399aad1a992cb27e897fc806570ba0"><div class="ttname"><a href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></div><div class="ttdeci">lock_sys_t * lock_sys</div><div class="ttdoc">The lock system. </div><div class="ttdef"><b>Definition:</b> lock0lock.cc:191</div></div>
</div><!-- fragment -->
<p>Acquire the lock_sys-&gt;wait_mutex. </p>

</div>
</div>
<a id="acac7466a6379499864e831e92c950956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac7466a6379499864e831e92c950956">&#9670;&nbsp;</a></span>lock_wait_mutex_exit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_exit</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                           \</div><div class="line">    lock_sys-&gt;wait_mutex.exit(); \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
<p>Release the lock_sys-&gt;wait_mutex. </p>

</div>
</div>
<a id="aaf586f74bea52a9f41cb48d219e03cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf586f74bea52a9f41cb48d219e03cda">&#9670;&nbsp;</a></span>lock_wait_mutex_own</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_own</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="lock0lock_8cc.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;wait_mutex.is_owned())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if lock_sys-&gt;wait_mutex is owned. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aaa4032e81bf70e9e852814f9ed299741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4032e81bf70e9e852814f9ed299741">&#9670;&nbsp;</a></span>Lock_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ib_mutex_t <a class="el" href="lock0lock_8h.html#aaa4032e81bf70e9e852814f9ed299741">Lock_mutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adfd720ce09a7e9babfd890d6a3c3d0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd720ce09a7e9babfd890d6a3c3d0a3">&#9670;&nbsp;</a></span>lock_duration_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to specify the intended duration of a record lock. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adfd720ce09a7e9babfd890d6a3c3d0a3a820ead78f0fa32544c7ba38fe7ff53d9"></a>REGULAR&#160;</td><td class="fielddoc"><p>Keep the lock according to the rules of particular isolation level, in particular in case of READ COMMITTED or less restricive modes, do not inherit the lock if the record is purged. </p>
</td></tr>
<tr><td class="fieldname"><a id="adfd720ce09a7e9babfd890d6a3c3d0a3a04f081bd5710a2e39455c0ddda6b23b4"></a>AT_LEAST_STATEMENT&#160;</td><td class="fielddoc"><p>Keep the lock around for at least the duration of the current statement, in particular make sure it is inherited as gap lock if the record is purged. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab0ca4cfe4edd613e4bf2f2880d5e6a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ca4cfe4edd613e4bf2f2880d5e6a7e">&#9670;&nbsp;</a></span>lock_check_trx_id_sanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_check_trx_id_sanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a transaction id is sensible, i.e., not in the future. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_id</td><td>in: trx id </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c0eec427989825525fd4b4b9cffc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c0eec427989825525fd4b4b9cffc1b">&#9670;&nbsp;</a></span>lock_clust_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_clust_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classReadView.html">ReadView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a record is seen in a consistent read. </p>
<dl class="section return"><dt>Returns</dt><dd>true if sees, or false if an earlier version of the record should be retrieved in: consistent read view</dd>
<dd>
true if sees, or false if an earlier version of the record should be retrieved </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf66df1ce4412d6d621cdc8b77859e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf66df1ce4412d6d621cdc8b77859e81">&#9670;&nbsp;</a></span>lock_clust_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate modify (update, delete mark, or delete unmark) of a clustered index record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64258dd611022cc3e5ddd008b1d8e853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64258dd611022cc3e5ddd008b1d8e853">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a>&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>If equal to AT_LEAST_STATEMENT, then makes sure that the lock will be kept around and inherited for at least the duration of current statement. If equal to REGULAR the life-cycle of the lock will depend on isolation level rules. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap_mode</td><td>LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, DB_SKIP_LOCKED, or DB_LOCK_NOWAIT </dd></dl>

</div>
</div>
<a id="a57805d4a0fcad73101c822963168dca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57805d4a0fcad73101c822963168dca0">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock_alt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock_alt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. This is an alternative version of lock_clust_rec_read_check_and_lock() that does not require the parameter "offsets". </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d39383d7ac9dd4ca34a24f271a1baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d39383d7ac9dd4ca34a24f271a1baf">&#9670;&nbsp;</a></span>lock_get_first_trx_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structlock__t.html">lock_t</a>* lock_get_first_trx_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *&#160;</td>
          <td class="paramname"><em>trx_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first lock of a trx lock list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_lock</td><td>the trx lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first lock </dd></dl>

</div>
</div>
<a id="a0a1dd693350e9ebc88a5f07f4a9236d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1dd693350e9ebc88a5f07f4a9236d4">&#9670;&nbsp;</a></span>lock_get_immutable_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lock_get_immutable_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the immutable id of this lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lock's immutable id </dd></dl>

</div>
</div>
<a id="a9d299943e5932310b8db82f441b885f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d299943e5932310b8db82f441b885f5">&#9670;&nbsp;</a></span>lock_get_min_heap_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_get_min_heap_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the heap_no of the smallest user record on a page. </p>
<dl class="section return"><dt>Returns</dt><dd>heap_no of smallest user record, or PAGE_HEAP_NO_SUPREMUM in: buffer block </dd></dl>

</div>
</div>
<a id="aeb165a7de4839caf9783cade418f7703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb165a7de4839caf9783cade418f7703">&#9670;&nbsp;</a></span>lock_get_mode_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lock_get_mode_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mode of a lock in a human readable string. </p>
<p>The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock mode in: lock</dd></dl>
<p>The string should not be free()'d or modified. This functions is a bit complex for following reasons:</p><ul>
<li>the way it is used in performance schema requires that the memory pointed by the return value is accessible for a long time</li>
<li>the caller never frees the memory</li>
<li>so, we need to maintain a pool of these strings or use string literals</li>
<li>there are many possible combinations of flags and thus it is impractical to maintain the list of all possible literals and if/else logic</li>
<li>moreover, sometimes performance_schema.data_locks is used precisely to investigate some unexpected situation, thus limiting output of this function only to expected combinations of flags might be misleading <dl class="section return"><dt>Returns</dt><dd>lock mode </dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b99bda2e15de31f306979231d1f5436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b99bda2e15de31f306979231d1f5436">&#9670;&nbsp;</a></span>lock_get_next_trx_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structlock__t.html">lock_t</a>* lock_get_next_trx_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next lock of a trx lock list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>the current lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next lock </dd></dl>

</div>
</div>
<a id="acecc4ffef7bce145529de20c3ee12d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecc4ffef7bce145529de20c3ee12d36">&#9670;&nbsp;</a></span>lock_get_psi_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_get_psi_event </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>event_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the performance schema event (thread_id, event_id) that created the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>Lock </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">thread_id</td><td>Thread ID that created the lock </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">event_id</td><td>Event ID that created the lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a478c022c5f5da29524207004cfc5325d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478c022c5f5da29524207004cfc5325d">&#9670;&nbsp;</a></span>lock_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of a lock struct. </p>
<dl class="section return"><dt>Returns</dt><dd>size in bytes </dd></dl>

</div>
</div>
<a id="a7f014df68b9ac74600c80de96092b91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f014df68b9ac74600c80de96092b91c">&#9670;&nbsp;</a></span>lock_get_table_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a> lock_get_table_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the id of the table on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>id of the table in: lock</dd>
<dd>
id of the table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfd305f10c527e77d4f78fbb758b89b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd305f10c527e77d4f78fbb758b89b6">&#9670;&nbsp;</a></span>lock_get_table_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtable__name__t.html">table_name_t</a>&amp; lock_get_table_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which table a lock is associated with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the table </dd></dl>

</div>
</div>
<a id="abecbf8e0ed8c9de8a425e360a40ac779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecbf8e0ed8c9de8a425e360a40ac779">&#9670;&nbsp;</a></span>lock_get_trx_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_get_trx_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the id of the transaction owning a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>A lock of the transaction we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transaction's id </dd></dl>

</div>
</div>
<a id="a0570cd0fb05c95af79ac66dcea8c636b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0570cd0fb05c95af79ac66dcea8c636b">&#9670;&nbsp;</a></span>lock_get_trx_immutable_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lock_get_trx_immutable_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the immutable id of the transaction owning a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>A lock of the transaction we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transaction's immutable id </dd></dl>

</div>
</div>
<a id="a374b98595a50acd2ec82df4e1952d51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374b98595a50acd2ec82df4e1952d51e">&#9670;&nbsp;</a></span>lock_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lock_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of a lock. </p>
<p>Non-inline version for using outside of the lock module. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC in: lock</dd></dl>
<p>Non-inline version for using outside of the lock module. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ae17fad2ea0c4abe3252d4089e6a6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae17fad2ea0c4abe3252d4089e6a6a5">&#9670;&nbsp;</a></span>lock_get_type_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lock_get_type_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of a lock in a human readable string. </p>
<p>The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock type in: lock</dd></dl>
<p>The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9cec654a8d71e13f4113aa36dd0d78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cec654a8d71e13f4113aa36dd0d78f">&#9670;&nbsp;</a></span>lock_has_to_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_has_to_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a lock request lock1 has to wait for request lock2. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if lock1 has to wait for lock2 to be removed in: another lock; NOTE that it is assumed that this has a lock bit set on the same record as in lock1 if the locks are record locks</dd>
<dd>
true if lock1 has to wait for lock2 to be removed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock1</td><td>in: waiting lock </td></tr>
    <tr><td class="paramname">lock2</td><td>in: another lock; NOTE that it is assumed that this has a lock bit set on the same record as in lock1 if the locks are record locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fec2aa31cc581d490329f5be3e11088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fec2aa31cc581d490329f5be3e11088">&#9670;&nbsp;</a></span>lock_hash_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structhash__table__t.html">hash_table_t</a>* lock_hash_get </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lock hash table. </p>
<p>in: lock mode </p>

</div>
</div>
<a id="a324b05d56ac7614e7dccf30e00730ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324b05d56ac7614e7dccf30e00730ef3">&#9670;&nbsp;</a></span>lock_make_trx_hit_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_make_trx_hit_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a13121c5e3c7e683afe964f2903433257">hit_list_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hit_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the granted locks which conflict with trx-&gt;lock.wait_lock and prepare the hit list for ASYNC Rollback. </p>
<p>If the transaction is waiting for some other lock then wake up with deadlock error. Currently we don't mark following transactions for ASYNC Rollback.</p>
<ol type="1">
<li>Read only transactions</li>
<li>Background transactions</li>
<li>Other High priority transactions <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>High Priority transaction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hit_list</td><td>List of transactions which need to be rolled back </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="a72a4bca65fd7f08390fbe370ab09fe24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a4bca65fd7f08390fbe370ab09fe24">&#9670;&nbsp;</a></span>lock_move_rec_list_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_move_rec_list_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the explicit locks on user records to another page if a record list end is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to move to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record on page: this is the first record moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a856b4f10d6691a2c3446378525c1a9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856b4f10d6691a2c3446378525c1a9f2">&#9670;&nbsp;</a></span>lock_move_rec_list_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_move_rec_list_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>old_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to move to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record on page: this is the first record not copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_end</td><td>Old previous-to-last record on new_page before the records were copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb133e68ef2953ee54049f280eff17af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb133e68ef2953ee54049f280eff17af">&#9670;&nbsp;</a></span>lock_move_reorganize_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_move_reorganize_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>oblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when we have reorganized a page. </p>
<p>NOTE: we copy also the locks set on the infimum of the page; the infimum may carry locks if an update of a record is occurring on the page, and its locks were temporarily stored on the infimum. in: copy of the old, not reorganized page</p>
<p>NOTE: we copy also the locks set on the infimum of the page; the infimum may carry locks if an update of a record is occurring on the page, and its locks were temporarily stored on the infimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: old index page, now reorganized </td></tr>
    <tr><td class="paramname">oblock</td><td>in: copy of the old, not reorganized page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0ab5b5a29bf12d5dfd022fc0ee5d815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ab5b5a29bf12d5dfd022fc0ee5d815">&#9670;&nbsp;</a></span>lock_number_of_rows_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_number_of_rows_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *&#160;</td>
          <td class="paramname"><em>trx_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return approximate number or record locks (bits set in the bitmap) for this transaction. </p>
<p>Since delete-marked records may be removed, the record count will not be precise. The caller must be holding exclusive global lock_sys latch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_lock</td><td>transaction locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a9f940afda7bc372f6b78a23ed1aa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9f940afda7bc372f6b78a23ed1aa37">&#9670;&nbsp;</a></span>lock_number_of_tables_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_number_of_tables_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of table locks for a transaction. </p>
<p>The caller must be holding trx-&gt;mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the transaction for which we want the number of table locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9025c7188f98ef88d223591eb7fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9025c7188f98ef88d223591eb7fe0d">&#9670;&nbsp;</a></span>lock_on_statement_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_on_statement_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called to inform lock-sys that a statement processing for a trx has just finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction which has finished processing a statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc5c7b8bef35ee70ba968607a22fb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc5c7b8bef35ee70ba968607a22fb24">&#9670;&nbsp;</a></span>lock_print_info_all_transactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_print_info_all_transactions </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of locks for each transaction. </p>
<p>This function assumes that the caller holds the exclusive global latch and more importantly it may release and reacquire it on behalf of the caller. (This should be fixed in the future). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>the file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a396c1bdffc5e098c024ad929ba594dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396c1bdffc5e098c024ad929ba594dd8">&#9670;&nbsp;</a></span>lock_print_info_summary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_print_info_summary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of locks for all transactions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac98fb0ca09acc1516e030769b0ba8358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98fb0ca09acc1516e030769b0ba8358">&#9670;&nbsp;</a></span>lock_rec_convert_active_impl_to_expl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_convert_active_impl_to_expl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is kind of wrapper to lock_rec_convert_impl_to_expl_for_trx() function with functionailty added to facilitate lock conversion from implicit to explicit for partial rollback cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record on page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>active transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>rec heap number to lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb40b46c0751e5e8f8d6d9b841251a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb40b46c0751e5e8f8d6d9b841251a64">&#9670;&nbsp;</a></span>lock_rec_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a record lock request, waiting or granted, from the queue. </p>
<p>in: record lock object: all record locks which are contained in this lock object are removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_lock</td><td>record lock object: all record locks which are contained in this lock object are removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a105a61c935f6765bbc78ddbf40203a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105a61c935f6765bbc78ddbf40203a4f">&#9670;&nbsp;</a></span>lock_rec_expl_exist_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_rec_expl_exist_on_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if there are explicit record locks on a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>space id and page number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff an explicit record lock on the page exists </dd></dl>

</div>
</div>
<a id="a6c73150ff49ff33364b8dfe57796bac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c73150ff49ff33364b8dfe57796bac2">&#9670;&nbsp;</a></span>lock_rec_find_next_set_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_rec_find_next_set_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for the next set bit in the record lock bitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>record lock with at least one bit set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>current set bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next bit index == heap number following heap_no, or ULINT_UNDEFINED if none found </dd></dl>

</div>
</div>
<a id="ad7ccba69e261b79e8c7ab7d83cb41319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ccba69e261b79e8c7ab7d83cb41319">&#9670;&nbsp;</a></span>lock_rec_find_set_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_rec_find_set_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for a set bit in a record lock bitmap. </p>
<p>Returns ULINT_UNDEFINED, if none found. </p><dl class="section return"><dt>Returns</dt><dd>bit index == heap number of the record, or ULINT_UNDEFINED if none found in: record lock with at least one bit set</dd></dl>
<p>Returns ULINT_UNDEFINED, if none found. </p><dl class="section return"><dt>Returns</dt><dd>bit index == heap number of the record, or ULINT_UNDEFINED if none found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock with at least one bit set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1206e21ae1b1abe21e29acec6af79a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1206e21ae1b1abe21e29acec6af79a8c">&#9670;&nbsp;</a></span>lock_rec_fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fold value of a page file address: used in inserting or searching for a lock in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>specifies the page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>folded value </dd></dl>

</div>
</div>
<a id="a5f9c55d69db3ad92b4af176625eac460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9c55d69db3ad92b4af176625eac460">&#9670;&nbsp;</a></span>lock_rec_free_all_from_discard_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_free_all_from_discard_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes record lock objects set on an index page which is discarded. </p>
<p>This function does not move locks, or check for waiting locks, therefore the lock bitmaps must already be reset when this function is called. in: page to be discarded</p>
<p>This function does not move locks, or check for waiting locks, therefore the lock bitmaps must already be reset when this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: page to be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a489f292f2abfd59464a820e4ef3efdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489f292f2abfd59464a820e4ef3efdf6">&#9670;&nbsp;</a></span>lock_rec_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdict__index__t.html">dict_index_t</a>* lock_rec_get_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a record lock, gets the index on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>index in: lock</dd>
<dd>
index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07cae5f235e5f095fb70d92c8d2e0bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cae5f235e5f095fb70d92c8d2e0bc6">&#9670;&nbsp;</a></span>lock_rec_get_index_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lock_rec_get_index_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a record lock, gets the name of the index on which the lock is. </p>
<p>The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the index in: lock</dd></dl>
<p>The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa95ea09f1777797a5e22cb63720d483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa95ea09f1777797a5e22cb63720d483">&#9670;&nbsp;</a></span>lock_rec_get_page_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpage__id__t.html">page_id_t</a> lock_rec_get_page_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a record lock, gets the tablespace number and page number on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>tablespace number in: lock </dd></dl>

</div>
</div>
<a id="aa323d3d3a9437fb8589b1856ce3afdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa323d3d3a9437fb8589b1856ce3afdee">&#9670;&nbsp;</a></span>lock_rec_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the hash value of a page file address: used in inserting or searching for a lock in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>specifies the page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hashed value </dd></dl>

</div>
</div>
<a id="af3d6fd7d2966684cc39668db595f5c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d6fd7d2966684cc39668db595f5c3a">&#9670;&nbsp;</a></span>lock_rec_insert_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_insert_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate insert of a record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a gap x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">rec</td><td>in: record after which to insert </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">inherit</td><td>out: set to true if the new inserted record maybe should inherit LOCK_GAP type locks from the successor record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5a13c16488466902242a906b82422a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a13c16488466902242a906b82422a7">&#9670;&nbsp;</a></span>lock_rec_reset_and_inherit_gap_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_reset_and_inherit_gap_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the original locks on heir and replaces them with gap type locks inherited from rec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_block</td><td>Block containing the record which inherits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Block containing the record from which inherited; does not reset the locks on this record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_heap_no</td><td>Heap_no of the inheriting record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>Heap_no of the donating record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae70020e803cb615546ffde6384bb8505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70020e803cb615546ffde6384bb8505">&#9670;&nbsp;</a></span>lock_rec_restore_from_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_restore_from_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Buffer block containing rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Record whose lock state is restored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">donator</td><td>Page (rec is not necessarily on this page) whose infimum stored the lock state; lock bits are reset on the infimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63e2620fd1f715019989f11107c2de47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e2620fd1f715019989f11107c2de47">&#9670;&nbsp;</a></span>lock_rec_store_on_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_store_on_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores on the page infimum record the explicit locks of another record. </p>
<p>This function is used to store the lock state of a record when it is updated and the size of the record changes in the update. The record is in such an update moved, perhaps to another page. The infimum record acts as a dummy carrier record, taking care of lock releases while the actual record is being moved. in: record whose lock state is stored on the infimum record of the same page; lock bits are reset on the record</p>
<p>This function is used to store the lock state of a record when it is updated and the size of the record changes in the update. The record is moved in such an update, perhaps to another page. The infimum record acts as a dummy carrier record, taking care of lock releases while the actual record is being moved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record whose lock state is stored on the infimum record of the same page; lock bits are reset on the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc396ea6e4e953a9400b711b2d57230f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc396ea6e4e953a9400b711b2d57230f">&#9670;&nbsp;</a></span>lock_rec_trx_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_trx_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the nth bit of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>record lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of the bit that will be reset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>whether the lock is in wait mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a385872f00cebe85ef57ac1ee1d1a9ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385872f00cebe85ef57ac1ee1d1a9ec5">&#9670;&nbsp;</a></span>lock_rec_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>lock_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock. </p>
<p>in: LOCK_S or LOCK_X</p>
<p>This function is meant to be used only by row_unlock_for_mysql, and it assumes that the lock we are looking for has LOCK_REC_NOT_GAP flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction that has set a record lock </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">lock_mode</td><td>in: LOCK_S or LOCK_X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ef596f4d04a32dc7eeea3e7a8481341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef596f4d04a32dc7eeea3e7a8481341">&#9670;&nbsp;</a></span>lock_remove_all_on_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_remove_all_on_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>remove_also_table_sx_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes locks on a table to be dropped. </p>
<p>If remove_also_table_sx_locks is TRUE then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock, that is going to be removed, is allowed to be a wait lock. in: also removes table S and X locks</p>
<p>If remove_also_table_sx_locks is true then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock, that is going to be removed, is allowed to be a wait lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to be dropped or discarded </td></tr>
    <tr><td class="paramname">remove_also_table_sx_locks</td><td>in: also removes table S and X locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac881161276c0dfc1994b2af6d22f3ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac881161276c0dfc1994b2af6d22f3ea5">&#9670;&nbsp;</a></span>lock_report_trx_id_insanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_report_trx_id_insanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>max_trx_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports that a transaction id is insensible, i.e., in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Trx id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>User record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_trx_id</td><td>Trx_sys_get_max_trx_id() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47fefbca8fe9d4d308d925eff524b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fefbca8fe9d4d308d925eff524b4f8">&#9670;&nbsp;</a></span>lock_rtr_move_rec_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rtr_move_rec_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gis0type_8h.html#a2d71af64b5717827d5581da7a7b4a180">rtr_rec_move_t</a> *&#160;</td>
          <td class="paramname"><em>rec_move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>num_move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to move to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_move</td><td>Recording records moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_move</td><td>Num of rec to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53a7181a1b37cd5b082c7b41f816e7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a7181a1b37cd5b082c7b41f816e7be">&#9670;&nbsp;</a></span>lock_sec_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_sec_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classReadView.html">ReadView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a non-clustered index record is seen in a consistent read. </p>
<p>NOTE that a non-clustered index page contains so little information on its modifications that also in the case false, the present version of rec may be the right, but we must check this from the clustered index record.</p>
<dl class="section return"><dt>Returns</dt><dd>true if certainly sees, or false if an earlier version of the clustered index record might be needed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae00980a4b5a19525a76a41633a5acfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00980a4b5a19525a76a41633a5acfb2">&#9670;&nbsp;</a></span>lock_sec_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate modify (delete mark or delete unmark) of a secondary index record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified; NOTE: as this is a secondary index, we always have to modify the clustered index record first: see the comment below </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread (can be NULL if BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a759d0cc4eeb09cc8c0c1b56e777c08fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759d0cc4eeb09cc8c0c1b56e777c08fb">&#9670;&nbsp;</a></span>lock_sec_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a>&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like lock_clust_rec_read_check_and_lock(), but reads a secondary index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>If equal to AT_LEAST_STATEMENT, then makes sure that the lock will be kept around and inherited for at least the duration of current statement. If equal to REGULAR the life-cycle of the lock will depend on isolation level rules. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap_mode</td><td>LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, DB_SKIP_LOCKED, or DB_LOCK_NOWAIT </dd></dl>

</div>
</div>
<a id="af0ba28814c32fc40e4c71c8a32f6fdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba28814c32fc40e4c71c8a32f6fdba">&#9670;&nbsp;</a></span>lock_set_timeout_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_set_timeout_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the lock system timeout event. </p>

</div>
</div>
<a id="a127c8053fd0338b4d796d0c0de0272dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127c8053fd0338b4d796d0c0de0272dd">&#9670;&nbsp;</a></span>lock_sys_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_sys_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the lock system at database shutdown. </p>

</div>
</div>
<a id="a6b61b8949e0116857ff488de16509d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b61b8949e0116857ff488de16509d4d">&#9670;&nbsp;</a></span>lock_sys_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_sys_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the lock system at database start. </p>
<p>in: number of slots in lock hash table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_cells</td><td>in: number of slots in lock hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6032b9d467a2fa36b3a6b1532df30a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6032b9d467a2fa36b3a6b1532df30a33">&#9670;&nbsp;</a></span>lock_sys_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_sys_resize </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the lock hash tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_cells</td><td>number of slots in lock hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1a3a3e111f874ce25075882ef35dfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a3a3e111f874ce25075882ef35dfd9">&#9670;&nbsp;</a></span>lock_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the specified database table in the mode given. </p>
<p>If the lock cannot be granted immediately, the query thread is put to wait. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">table</td><td>in/out: database table in dictionary cache </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94f8b30188b58505e53584a7c428a95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f8b30188b58505e53584a7c428a95d">&#9670;&nbsp;</a></span>lock_table_for_trx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table_for_trx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a lock on a table based on the given mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to lock </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>LOCK_X or LOCK_S </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS. </dd></dl>

</div>
</div>
<a id="a7271bf61ea0010a2552e9343dad624c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7271bf61ea0010a2552e9343dad624c3">&#9670;&nbsp;</a></span>lock_table_has_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_table_has_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are any locks (table or rec) against table. </p>
<p>Returned value might be obsolete. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there were any locks held on records in this table or on the table itself at some point in time during the call </dd></dl>
<p>The n_rec_locks field might be modified by operation on any page shard, so we need to latch everything. Note, that the results of this function will be obsolete, as soon as we release the latch. It is called in contexts where we believe that the number of locks should either be zero or decreasing. For such scenario of usage, we might perhaps read the n_rec_locks without latch and restrict latch just to a table shard. But that would complicate the debug version of the code for no significant gain as this is not a hot path. </p>

</div>
</div>
<a id="a8b1d4aaa7d211a0b5fa98edcf3b7c09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1d4aaa7d211a0b5fa98edcf3b7c09b">&#9670;&nbsp;</a></span>lock_table_ix_resurrect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_table_ix_resurrect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table IX lock object for a resurrected transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>Transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd23066177e056191e90bae4f14215e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd23066177e056191e90bae4f14215e0">&#9670;&nbsp;</a></span>lock_trx_alloc_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_alloc_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate cached locks for the transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>allocate cached record locks for this transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeefbced8febccb3e8ab67e20ee33b0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefbced8febccb3e8ab67e20ee33b0b4">&#9670;&nbsp;</a></span>lock_trx_handle_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_trx_handle_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the transaction has already been rolled back because it was selected as a deadlock victim, or if it has to wait then cancel the wait lock. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_DEADLOCK, DB_LOCK_WAIT or DB_SUCCESS in/out: trx lock state</dd>
<dd>
DB_DEADLOCK, DB_LOCK_WAIT or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: trx lock state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99887080ffdb266d6f94b5938ab423d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99887080ffdb266d6f94b5938ab423d2">&#9670;&nbsp;</a></span>lock_trx_has_rec_x_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_trx_has_rec_x_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the transaction holds an exclusive lock on a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread of the transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>record heap number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the locks are held </dd></dl>

</div>
</div>
<a id="a82f5f27eeb669c559bcf49469cbe3d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5f27eeb669c559bcf49469cbe3d16">&#9670;&nbsp;</a></span>lock_trx_lock_list_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_lock_list_init </td>
          <td>(</td>
          <td class="paramtype">trx_lock_list_t *&#160;</td>
          <td class="paramname"><em>lock_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the trx lock list. </p>
<p>List to initialise</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_list</td><td>List to initialise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4b2ef62b3cd2784b7d3d3c442d9a320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b2ef62b3cd2784b7d3d3c442d9a320">&#9670;&nbsp;</a></span>lock_trx_print_wait_and_mvcc_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_print_wait_and_mvcc_state </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints transaction lock wait and MVCC state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>file where to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fbb256f6d14ba050d686b9ba1d007b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbb256f6d14ba050d686b9ba1d007b0">&#9670;&nbsp;</a></span>lock_trx_release_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_release_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a transaction's locks, and releases possible other transactions waiting because of these locks. </p>
<p>Change the state of the transaction to TRX_STATE_COMMITTED_IN_MEMORY. in/out: transaction</p>
<p>Change the state of the transaction to TRX_STATE_COMMITTED_IN_MEMORY. </p>
<p>Doing an implicit to explicit conversion should not be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a837664214700c0a21ff9c6ab1085fa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837664214700c0a21ff9c6ab1085fa76">&#9670;&nbsp;</a></span>lock_trx_release_read_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_release_read_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>only_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release read locks of a transaction. </p>
<p>It is called during XA prepare to release locks early. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">only_gap</td><td>release only GAP locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af6183a5555e7a95a366be8aaa7f280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af6183a5555e7a95a366be8aaa7f280">&#9670;&nbsp;</a></span>lock_unlock_table_autoinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_unlock_table_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks AUTO_INC type locks that were possibly reserved by a trx. </p>
<p>This function should be called at the the end of an SQL statement, by the connection thread that owns the transaction (trx-&gt;mysql_thd). in/out: transaction</p>
<p>This function should be called at the the end of an SQL statement, by the connection thread that owns the transaction (trx-&gt;mysql_thd). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72d530560f93577d1c8b2865251a3a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d530560f93577d1c8b2865251a3a47">&#9670;&nbsp;</a></span>lock_update_copy_and_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_copy_and_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to which copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page; not the root! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2d9fef0df1b551f23c7da52fd68accd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d9fef0df1b551f23c7da52fd68accd">&#9670;&nbsp;</a></span>lock_update_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a record is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Buffer block containing rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>The record to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c59f431194af5e5f6a6842bfe50344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c59f431194af5e5f6a6842bfe50344">&#9670;&nbsp;</a></span>lock_update_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is discarded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_block</td><td>Index page which will inherit the locks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_heap_no</td><td>Heap_no of the record which will inherit the locks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de1c790f6a289f4b803acab127b3755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de1c790f6a289f4b803acab127b3755">&#9670;&nbsp;</a></span>lock_update_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a new user record is inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Buffer block containing rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>The inserted record</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: the inserted record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa151b0e44c3fd7542ef9441ac2125988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa151b0e44c3fd7542ef9441ac2125988">&#9670;&nbsp;</a></span>lock_update_merge_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_merge_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>orig_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is merged to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Left page to which merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orig_pred</td><td>Original predecessor of supremum on the left page before merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d987baa574ae26300c02c38d3297aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d987baa574ae26300c02c38d3297aa">&#9670;&nbsp;</a></span>lock_update_merge_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_merge_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>orig_succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is merged to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Right page to which merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orig_succ</td><td>Original successor of infimum on the right page before merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa60bc5af0ffa9cbef92444c2f36cbca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60bc5af0ffa9cbef92444c2f36cbca0">&#9670;&nbsp;</a></span>lock_update_root_raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_root_raise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when the root page is copied to another in btr_root_raise_and_insert. </p>
<p>Note that we leave lock structs on the root page, even though they do not make sense on other than leaf pages: the reason is that in a pessimistic update the infimum record of the root page will act as a dummy carrier of the locks of the record to be updated. in: root page</p>
<p>Note that we leave lock structs on the root page, even though they do not make sense on other than leaf pages: the reason is that in a pessimistic update the infimum record of the root page will act as a dummy carrier of the locks of the record to be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page to which copied </td></tr>
    <tr><td class="paramname">root</td><td>in: root page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c056f069cb338691dafe4665b8a4435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c056f069cb338691dafe4665b8a4435">&#9670;&nbsp;</a></span>lock_update_split_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_split_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is split to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Right page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af01b85f0aa5d1e2d0e026044673110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af01b85f0aa5d1e2d0e026044673110">&#9670;&nbsp;</a></span>lock_update_split_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_split_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is split to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Right page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4aba7196cfa609a25581a9c37537b697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aba7196cfa609a25581a9c37537b697">&#9670;&nbsp;</a></span>lock_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the lock system. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>

</div>
</div>
<a id="a791dd54f6bbed78c9fc0f94c454f18da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791dd54f6bbed78c9fc0f94c454f18da">&#9670;&nbsp;</a></span>lock_wait_request_check_for_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_wait_request_check_for_cycles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies the thread which analyzes wait-for-graph that there was at least one new edge added or modified ( trx-&gt;blocking_trx has changed ), so that the thread will know it has to analyze it. </p>

</div>
</div>
<a id="ae4ef9abc31e16983f141559c65f7582d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef9abc31e16983f141559c65f7582d">&#9670;&nbsp;</a></span>lock_wait_suspend_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_wait_suspend_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a user OS thread to wait for a lock to be released. </p>
<p>If an error occurs during the wait trx-&gt;error_state associated with thr is != DB_SUCCESS when we return. DB_LOCK_WAIT_TIMEOUT and DB_DEADLOCK are possible errors. DB_DEADLOCK is returned if selective deadlock resolution chose this transaction as a victim. in: query thread associated with the user OS thread</p>
<p>If an error occurs during the wait trx-&gt;error_state associated with thr is != DB_SUCCESS when we return. DB_LOCK_WAIT_TIMEOUT and DB_DEADLOCK are possible errors. DB_DEADLOCK is returned if selective deadlock resolution chose this transaction as a victim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread associated with the user OS thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82b7ab612695ece320a4731a8f69e8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b7ab612695ece320a4731a8f69e8cb">&#9670;&nbsp;</a></span>lock_wait_timeout_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_wait_timeout_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A thread which wakes up threads whose lock wait may have lasted too long. </p>
<p>A thread which wakes up threads whose lock wait may have lasted too long. </p>
<p>The last time we've checked for timeouts. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a81d550ee42c724c84fb023128ce80147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d550ee42c724c84fb023128ce80147">&#9670;&nbsp;</a></span>innobase_deadlock_detect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> innobase_deadlock_detect</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5399aad1a992cb27e897fc806570ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5399aad1a992cb27e897fc806570ba0">&#9670;&nbsp;</a></span>lock_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__sys__t.html">lock_sys_t</a>* lock_sys</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The lock system. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="lock0lock_8h.html">lock0lock.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
