<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/btr0btr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('btr0btr_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0btr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The B-tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="data0data_8h_source.html">data0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="gis0type_8h_source.html">gis0type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0mtr_8h_source.html">mtr0mtr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0cur_8h_source.html">page0cur.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;btr0btr.ic&quot;</code><br />
</div>
<p><a href="btr0btr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a478a4bd54ccaf1b7bcff648f788e16fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a478a4bd54ccaf1b7bcff648f788e16fd">BTR_PAGE_MAX_REC_SIZE</a>&#160;&#160;&#160;(UNIV_PAGE_SIZE / 2 - 200)</td></tr>
<tr class="memdesc:a478a4bd54ccaf1b7bcff648f788e16fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum record size which can be stored on a page, without using the special big record storage structure.  <a href="#a478a4bd54ccaf1b7bcff648f788e16fd">More...</a><br /></td></tr>
<tr class="separator:a478a4bd54ccaf1b7bcff648f788e16fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673d044d0cec2c50072b3c14df981105"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a673d044d0cec2c50072b3c14df981105">BTR_MAX_LEVELS</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:a673d044d0cec2c50072b3c14df981105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum depth of a B-tree in InnoDB.  <a href="#a673d044d0cec2c50072b3c14df981105">More...</a><br /></td></tr>
<tr class="separator:a673d044d0cec2c50072b3c14df981105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60b568a3b8345949e70acea4130d767"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aa60b568a3b8345949e70acea4130d767">BTR_LATCH_MODE_WITHOUT_FLAGS</a>(latch_mode)</td></tr>
<tr class="separator:aa60b568a3b8345949e70acea4130d767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1162a49c36e8c4c9f7db739ffe91d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a4d1162a49c36e8c4c9f7db739ffe91d6">BTR_LATCH_MODE_WITHOUT_INTENTION</a>(latch_mode)</td></tr>
<tr class="separator:a4d1162a49c36e8c4c9f7db739ffe91d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7b9b7db7f01f12accffb27b543d03d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a2e7b9b7db7f01f12accffb27b543d03d">btr_assert_not_corrupted</a>(block,  <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a2e7b9b7db7f01f12accffb27b543d03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that a B-tree page is not corrupted.  <a href="#a2e7b9b7db7f01f12accffb27b543d03d">More...</a><br /></td></tr>
<tr class="separator:a2e7b9b7db7f01f12accffb27b543d03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe7f5a0b3a66c74e33f28437d67939a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a6fe7f5a0b3a66c74e33f28437d67939a">btr_block_get</a>(page_id,  page_size,  mode,  <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>,  mtr)&#160;&#160;&#160;<a class="el" href="btr0btr_8h.html#a9090f73ca3c7684e70759fcefe4a3e2c">btr_block_get_func</a>(page_id, page_size, mode, __FILE__, __LINE__, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, mtr)</td></tr>
<tr class="memdesc:a6fe7f5a0b3a66c74e33f28437d67939a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a buffer page and declares its latching order level.  <a href="#a6fe7f5a0b3a66c74e33f28437d67939a">More...</a><br /></td></tr>
<tr class="separator:a6fe7f5a0b3a66c74e33f28437d67939a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b582fbcaa5d8c7d6e9fcea1c050f17"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a94b582fbcaa5d8c7d6e9fcea1c050f17">btr_page_get</a>(page_id,  page_size,  mode,  <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>,  mtr)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a95db363e6bf7655c69a903397199b780">buf_block_get_frame</a>(<a class="el" href="btr0btr_8h.html#a6fe7f5a0b3a66c74e33f28437d67939a">btr_block_get</a>(page_id, page_size, mode, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, mtr))</td></tr>
<tr class="memdesc:a94b582fbcaa5d8c7d6e9fcea1c050f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a buffer page and declares its latching order level.  <a href="#a94b582fbcaa5d8c7d6e9fcea1c050f17">More...</a><br /></td></tr>
<tr class="separator:a94b582fbcaa5d8c7d6e9fcea1c050f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f69a3a51aa6d003885a7b14562cd4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad8f69a3a51aa6d003885a7b14562cd4f">btr_page_get_level</a>(<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>,  mtr)&#160;&#160;&#160;<a class="el" href="btr0btr_8h.html#a573f7dd66509be89eaeeaad8201f729b">btr_page_get_level_low</a>(<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="separator:ad8f69a3a51aa6d003885a7b14562cd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ab04c61d04bd8e4904157405624b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a558ab04c61d04bd8e4904157405624b4">btr_insert_on_non_leaf_level</a>(f,  i,  l,  t,  m)&#160;&#160;&#160;<a class="el" href="btr0btr_8h.html#a18a13ed2995588a23441f93237aa2843">btr_insert_on_non_leaf_level_func</a>(f, i, l, t, __FILE__, __LINE__, m)</td></tr>
<tr class="separator:a558ab04c61d04bd8e4904157405624b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae693faeca995271eb27f60e74fda3395"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ae693faeca995271eb27f60e74fda3395">BTR_N_LEAF_PAGES</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ae693faeca995271eb27f60e74fda3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa5fd7bb5a6aaa5720e74b8933d6914"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aeaa5fd7bb5a6aaa5720e74b8933d6914">BTR_TOTAL_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aeaa5fd7bb5a6aaa5720e74b8933d6914"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2e8da6642741a4294e1de2a0ff5f2dc8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8">btr_latch_mode</a> : size_t { <br />
&#160;&#160;<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a851af4ea6177309bedbe8f143726ccd8">BTR_SEARCH_LEAF</a> = RW_S_LATCH, 
<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a47d0ffb5f1bd7b913c3f98df60b9d793">BTR_MODIFY_LEAF</a> = RW_X_LATCH, 
<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a79778e0de38ce6f6fd5f52fa8f17e108">BTR_NO_LATCHES</a> = RW_NO_LATCH, 
<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a16200f39165164daf6003bd8c081e61f">BTR_MODIFY_TREE</a> = 33, 
<br />
&#160;&#160;<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a0c6b78ce4b3f3ff9e86bbe769841aa6b">BTR_CONT_MODIFY_TREE</a> = 34, 
<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8a62dd636a279e6e83c7c1361e0fc3faf4">BTR_SEARCH_PREV</a> = 35, 
<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8aae7c44e6a014139ef9fb614f17f2d967">BTR_MODIFY_PREV</a> = 36, 
<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8aeaa22ebc92bb2fe8bfc8e6c35c453f7b">BTR_SEARCH_TREE</a> = 37, 
<br />
&#160;&#160;<a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8ac226de21f5121a5fe7bc94ed50229ff2">BTR_CONT_SEARCH_TREE</a> = 38
<br />
 }<tr class="memdesc:a2e8da6642741a4294e1de2a0ff5f2dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latching modes for btr_cur_search_to_nth_level().  <a href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2e8da6642741a4294e1de2a0ff5f2dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad8a3be58d71578953b59c6f875a71a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad8a3be58d71578953b59c6f875a71a4a">btr_corruption_report</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>) UNIV_COLD</td></tr>
<tr class="memdesc:ad8a3be58d71578953b59c6f875a71a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report that an index page is corrupted.  <a href="#ad8a3be58d71578953b59c6f875a71a4a">More...</a><br /></td></tr>
<tr class="separator:ad8a3be58d71578953b59c6f875a71a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ea96c431b04a3bc2944e7e22eadb35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aa0ea96c431b04a3bc2944e7e22eadb35">btr_root_get</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa0ea96c431b04a3bc2944e7e22eadb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root node of a tree and sx-latches it for segment access.  <a href="#aa0ea96c431b04a3bc2944e7e22eadb35">More...</a><br /></td></tr>
<tr class="separator:aa0ea96c431b04a3bc2944e7e22eadb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147370fa0331bbfa2534ff64b077830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a4147370fa0331bbfa2534ff64b077830">btr_root_adjust_on_import</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a4147370fa0331bbfa2534ff64b077830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and adjusts the root node of a tree during IMPORT TABLESPACE.  <a href="#a4147370fa0331bbfa2534ff64b077830">More...</a><br /></td></tr>
<tr class="separator:a4147370fa0331bbfa2534ff64b077830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3b94ce40c2202dd2678f5fda28e4e"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#af6f3b94ce40c2202dd2678f5fda28e4e">btr_height_get</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af6f3b94ce40c2202dd2678f5fda28e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the B-tree (the level of the root, when the leaf level is assumed to be 0).  <a href="#af6f3b94ce40c2202dd2678f5fda28e4e">More...</a><br /></td></tr>
<tr class="separator:af6f3b94ce40c2202dd2678f5fda28e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9090f73ca3c7684e70759fcefe4a3e2c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a9090f73ca3c7684e70759fcefe4a3e2c">btr_block_get_func</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint mode, const char *file, ulint line, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a9090f73ca3c7684e70759fcefe4a3e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a buffer page and declares its latching order level.  <a href="#a9090f73ca3c7684e70759fcefe4a3e2c">More...</a><br /></td></tr>
<tr class="separator:a9090f73ca3c7684e70759fcefe4a3e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa04ce1675becd32994c630c3762b798"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aaa04ce1675becd32994c630c3762b798">btr_page_get_index_id</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="memdesc:aaa04ce1675becd32994c630c3762b798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index id field of a page.  <a href="#aaa04ce1675becd32994c630c3762b798">More...</a><br /></td></tr>
<tr class="separator:aaa04ce1675becd32994c630c3762b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573f7dd66509be89eaeeaad8201f729b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a573f7dd66509be89eaeeaad8201f729b">btr_page_get_level_low</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="memdesc:a573f7dd66509be89eaeeaad8201f729b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the node level field in an index page.  <a href="#a573f7dd66509be89eaeeaad8201f729b">More...</a><br /></td></tr>
<tr class="separator:a573f7dd66509be89eaeeaad8201f729b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1a85ee930f8419ed9941f38a9262a6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a9f1a85ee930f8419ed9941f38a9262a6">btr_page_get_next</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a9f1a85ee930f8419ed9941f38a9262a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next index page number.  <a href="#a9f1a85ee930f8419ed9941f38a9262a6">More...</a><br /></td></tr>
<tr class="separator:a9f1a85ee930f8419ed9941f38a9262a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cf75688b15a7687e9c79e14f861366"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ae8cf75688b15a7687e9c79e14f861366">btr_page_get_prev</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae8cf75688b15a7687e9c79e14f861366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previous index page number.  <a href="#ae8cf75688b15a7687e9c79e14f861366">More...</a><br /></td></tr>
<tr class="separator:ae8cf75688b15a7687e9c79e14f861366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785f57bc94bbf370cb3d6de8e6353c13"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a785f57bc94bbf370cb3d6de8e6353c13">btr_leaf_page_release</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint latch_mode, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a785f57bc94bbf370cb3d6de8e6353c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the latch on a leaf page and bufferunfixes it.  <a href="#a785f57bc94bbf370cb3d6de8e6353c13">More...</a><br /></td></tr>
<tr class="separator:a785f57bc94bbf370cb3d6de8e6353c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0469f8de72c9bbb6875785d53532e88a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a0469f8de72c9bbb6875785d53532e88a">btr_node_ptr_get_child_page_no</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets)</td></tr>
<tr class="memdesc:a0469f8de72c9bbb6875785d53532e88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the child node file address in a node pointer.  <a href="#a0469f8de72c9bbb6875785d53532e88a">More...</a><br /></td></tr>
<tr class="separator:a0469f8de72c9bbb6875785d53532e88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dda6a915f6afbd8c1cf21840875e33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a77dda6a915f6afbd8c1cf21840875e33">btr_node_ptr_get_child</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *node_ptr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a> type=<a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574a0a61b228e5530d2c67679946b4bca4f2">RW_SX_LATCH</a>)</td></tr>
<tr class="memdesc:a77dda6a915f6afbd8c1cf21840875e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the child page of a node pointer and sx-latches it.  <a href="#a77dda6a915f6afbd8c1cf21840875e33">More...</a><br /></td></tr>
<tr class="separator:a77dda6a915f6afbd8c1cf21840875e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c675c012fdbf24ab0f4d81dd16d1ac"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a08c675c012fdbf24ab0f4d81dd16d1ac">btr_create</a> (ulint type, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a> index_id, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a08c675c012fdbf24ab0f4d81dd16d1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the root node for a new index tree.  <a href="#a08c675c012fdbf24ab0f4d81dd16d1ac">More...</a><br /></td></tr>
<tr class="separator:a08c675c012fdbf24ab0f4d81dd16d1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0d34be2b0c8e2b14490bd1a3e507c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a1b0d34be2b0c8e2b14490bd1a3e507c1">btr_free_if_exists</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a> index_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a1b0d34be2b0c8e2b14490bd1a3e507c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a persistent index tree if it exists.  <a href="#a1b0d34be2b0c8e2b14490bd1a3e507c1">More...</a><br /></td></tr>
<tr class="separator:a1b0d34be2b0c8e2b14490bd1a3e507c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193fcd2b57ae443bdeb7d72fa98cd40e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a193fcd2b57ae443bdeb7d72fa98cd40e">btr_free</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size)</td></tr>
<tr class="memdesc:a193fcd2b57ae443bdeb7d72fa98cd40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an index tree in a temporary tablespace.  <a href="#a193fcd2b57ae443bdeb7d72fa98cd40e">More...</a><br /></td></tr>
<tr class="separator:a193fcd2b57ae443bdeb7d72fa98cd40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d21d2a6fa315b6aef46ee926f98ceae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a0d21d2a6fa315b6aef46ee926f98ceae">btr_truncate</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a0d21d2a6fa315b6aef46ee926f98ceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate an index tree.  <a href="#a0d21d2a6fa315b6aef46ee926f98ceae">More...</a><br /></td></tr>
<tr class="separator:a0d21d2a6fa315b6aef46ee926f98ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adbc37056b85a4b15d771e526602792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a5adbc37056b85a4b15d771e526602792">btr_truncate_recover</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a5adbc37056b85a4b15d771e526602792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovery function for btr_truncate.  <a href="#a5adbc37056b85a4b15d771e526602792">More...</a><br /></td></tr>
<tr class="separator:a5adbc37056b85a4b15d771e526602792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dbcd9ec49055114b55b9b4e50c43a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad4dbcd9ec49055114b55b9b4e50c43a1">btr_root_raise_and_insert</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ad4dbcd9ec49055114b55b9b4e50c43a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes tree one level higher by splitting the root, and inserts the tuple.  <a href="#ad4dbcd9ec49055114b55b9b4e50c43a1">More...</a><br /></td></tr>
<tr class="separator:ad4dbcd9ec49055114b55b9b4e50c43a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41fefade013636c0ff53fef29c29e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aa41fefade013636c0ff53fef29c29e3c">btr_page_reorganize_low</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> recovery, ulint z_level, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa41fefade013636c0ff53fef29c29e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganizes an index page.  <a href="#aa41fefade013636c0ff53fef29c29e3c">More...</a><br /></td></tr>
<tr class="separator:aa41fefade013636c0ff53fef29c29e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21abcd4da4bc353f9a2b855a79450490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a21abcd4da4bc353f9a2b855a79450490">btr_page_reorganize</a> (<a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a21abcd4da4bc353f9a2b855a79450490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorganizes an index page.  <a href="#a21abcd4da4bc353f9a2b855a79450490">More...</a><br /></td></tr>
<tr class="separator:a21abcd4da4bc353f9a2b855a79450490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9814eaf18cf608e29cb25cc24b1aa766"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a9814eaf18cf608e29cb25cc24b1aa766">btr_page_get_split_rec_to_left</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **split_rec)</td></tr>
<tr class="memdesc:a9814eaf18cf608e29cb25cc24b1aa766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides if the page should be split at the convergence point of inserts converging to left.  <a href="#a9814eaf18cf608e29cb25cc24b1aa766">More...</a><br /></td></tr>
<tr class="separator:a9814eaf18cf608e29cb25cc24b1aa766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dc7dce0944faaeaa433b5d611b8d11"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a28dc7dce0944faaeaa433b5d611b8d11">btr_page_get_split_rec_to_right</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **split_rec)</td></tr>
<tr class="memdesc:a28dc7dce0944faaeaa433b5d611b8d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides if the page should be split at the convergence point of inserts converging to right.  <a href="#a28dc7dce0944faaeaa433b5d611b8d11">More...</a><br /></td></tr>
<tr class="separator:a28dc7dce0944faaeaa433b5d611b8d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41424f75ebce380f498a411829d22c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a41424f75ebce380f498a411829d22c48">btr_page_split_and_insert</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a41424f75ebce380f498a411829d22c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits an index page to halves and inserts the tuple.  <a href="#a41424f75ebce380f498a411829d22c48">More...</a><br /></td></tr>
<tr class="separator:a41424f75ebce380f498a411829d22c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a13ed2995588a23441f93237aa2843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a18a13ed2995588a23441f93237aa2843">btr_insert_on_non_leaf_level_func</a> (uint32_t <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a18a13ed2995588a23441f93237aa2843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a data tuple to a tree on a non-leaf level.  <a href="#a18a13ed2995588a23441f93237aa2843">More...</a><br /></td></tr>
<tr class="separator:a18a13ed2995588a23441f93237aa2843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4330cef72fbfbb638446103baddd5c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ac4330cef72fbfbb638446103baddd5c0">btr_set_min_rec_mark</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac4330cef72fbfbb638446103baddd5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a record as the predefined minimum record.  <a href="#ac4330cef72fbfbb638446103baddd5c0">More...</a><br /></td></tr>
<tr class="separator:ac4330cef72fbfbb638446103baddd5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900f501e4015c67b08fc4f58e5f704df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a900f501e4015c67b08fc4f58e5f704df">btr_node_ptr_delete</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a900f501e4015c67b08fc4f58e5f704df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes on the upper level the node pointer to a page.  <a href="#a900f501e4015c67b08fc4f58e5f704df">More...</a><br /></td></tr>
<tr class="separator:a900f501e4015c67b08fc4f58e5f704df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98340cedd4876607365ac140c3c9549"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#af98340cedd4876607365ac140c3c9549">btr_check_node_ptr</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af98340cedd4876607365ac140c3c9549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the node pointer to a page is appropriate.  <a href="#af98340cedd4876607365ac140c3c9549">More...</a><br /></td></tr>
<tr class="separator:af98340cedd4876607365ac140c3c9549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a4adfc9b6b2aac22fef42be5d75235"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aa8a4adfc9b6b2aac22fef42be5d75235">btr_compress</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ibool adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa8a4adfc9b6b2aac22fef42be5d75235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to merge the page first to the left immediate brother if such a brother exists, and the node pointers to the current page and to the brother reside on the same page.  <a href="#aa8a4adfc9b6b2aac22fef42be5d75235">More...</a><br /></td></tr>
<tr class="separator:aa8a4adfc9b6b2aac22fef42be5d75235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22a428cb7087e01af9c80a814e4fcfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad22a428cb7087e01af9c80a814e4fcfb">btr_discard_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ad22a428cb7087e01af9c80a814e4fcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards a page from a B-tree.  <a href="#ad22a428cb7087e01af9c80a814e4fcfb">More...</a><br /></td></tr>
<tr class="separator:ad22a428cb7087e01af9c80a814e4fcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b38ae3a4b9a9d41758c1d7a989d426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a76b38ae3a4b9a9d41758c1d7a989d426">btr_parse_set_min_rec_mark</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, ulint comp, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a76b38ae3a4b9a9d41758c1d7a989d426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the redo log record for setting an index record as the predefined minimum record.  <a href="#a76b38ae3a4b9a9d41758c1d7a989d426">More...</a><br /></td></tr>
<tr class="separator:a76b38ae3a4b9a9d41758c1d7a989d426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6387b234b3e7ebc7c8bc1a8d023e587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#af6387b234b3e7ebc7c8bc1a8d023e587">btr_parse_page_reorganize</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> compressed, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af6387b234b3e7ebc7c8bc1a8d023e587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a redo log record of reorganizing a page.  <a href="#af6387b234b3e7ebc7c8bc1a8d023e587">More...</a><br /></td></tr>
<tr class="separator:af6387b234b3e7ebc7c8bc1a8d023e587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e65306550a56feffb3904a9c619778"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a79e65306550a56feffb3904a9c619778">btr_get_size</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a79e65306550a56feffb3904a9c619778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pages in a B-tree.  <a href="#a79e65306550a56feffb3904a9c619778">More...</a><br /></td></tr>
<tr class="separator:a79e65306550a56feffb3904a9c619778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b6e143b4d70a1656c1f9110ebc62a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a56b6e143b4d70a1656c1f9110ebc62a1">btr_page_alloc</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> hint_page_no, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> file_direction, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structmtr__t.html">mtr_t</a> *init_mtr)</td></tr>
<tr class="memdesc:a56b6e143b4d70a1656c1f9110ebc62a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new file page to be used in an index tree.  <a href="#a56b6e143b4d70a1656c1f9110ebc62a1">More...</a><br /></td></tr>
<tr class="separator:a56b6e143b4d70a1656c1f9110ebc62a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b6c9643b6c0950f74c5926291e66fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#af3b6c9643b6c0950f74c5926291e66fd">btr_page_free</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:af3b6c9643b6c0950f74c5926291e66fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a file page used in an index tree.  <a href="#af3b6c9643b6c0950f74c5926291e66fd">More...</a><br /></td></tr>
<tr class="separator:af3b6c9643b6c0950f74c5926291e66fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0eab34f77f8475935b6683d95c22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ab8b0eab34f77f8475935b6683d95c22e">btr_page_create</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab8b0eab34f77f8475935b6683d95c22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new index page (not the root, and also not used in page reorganization).  <a href="#ab8b0eab34f77f8475935b6683d95c22e">More...</a><br /></td></tr>
<tr class="separator:ab8b0eab34f77f8475935b6683d95c22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444dc4bd2155c2ea85dea09bf5c78931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a444dc4bd2155c2ea85dea09bf5c78931">btr_page_free_low</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a444dc4bd2155c2ea85dea09bf5c78931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a file page used in an index tree.  <a href="#a444dc4bd2155c2ea85dea09bf5c78931">More...</a><br /></td></tr>
<tr class="separator:a444dc4bd2155c2ea85dea09bf5c78931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd1295c03b53daf3008ad4859e2cab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aedd1295c03b53daf3008ad4859e2cab8">btr_root_block_get</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint mode, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aedd1295c03b53daf3008ad4859e2cab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root node of a tree and x- or s-latches it.  <a href="#aedd1295c03b53daf3008ad4859e2cab8">More...</a><br /></td></tr>
<tr class="separator:aedd1295c03b53daf3008ad4859e2cab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e281cd01a4261bf7f681c49cc6ef2"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a031e281cd01a4261bf7f681c49cc6ef2">btr_index_rec_validate</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ibool dump_on_error)</td></tr>
<tr class="memdesc:a031e281cd01a4261bf7f681c49cc6ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the size and number of fields in a record based on the definition of the index.  <a href="#a031e281cd01a4261bf7f681c49cc6ef2">More...</a><br /></td></tr>
<tr class="separator:a031e281cd01a4261bf7f681c49cc6ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85fb82a7c6060cfa8f1ced5a610615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a2a85fb82a7c6060cfa8f1ced5a610615">btr_validate_index</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lockout)</td></tr>
<tr class="memdesc:a2a85fb82a7c6060cfa8f1ced5a610615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the consistency of an index tree.  <a href="#a2a85fb82a7c6060cfa8f1ced5a610615">More...</a><br /></td></tr>
<tr class="separator:a2a85fb82a7c6060cfa8f1ced5a610615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98f3838f331835474a95ffe18d0aae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ab98f3838f331835474a95ffe18d0aae8">btr_sdi_create_index</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_locked)</td></tr>
<tr class="memdesc:ab98f3838f331835474a95ffe18d0aae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates SDI index and stores the root page numbers in page 1 &amp; 2.  <a href="#ab98f3838f331835474a95ffe18d0aae8">More...</a><br /></td></tr>
<tr class="separator:ab98f3838f331835474a95ffe18d0aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a83f00d659563b666880b97ce3dab0054"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a83f00d659563b666880b97ce3dab0054">BTR_INSERT</a> = 512</td></tr>
<tr class="memdesc:a83f00d659563b666880b97ce3dab0054"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this is ORed to btr_latch_mode, it means that the search tuple will be inserted to the index, at the searched position.  <a href="#a83f00d659563b666880b97ce3dab0054">More...</a><br /></td></tr>
<tr class="separator:a83f00d659563b666880b97ce3dab0054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b16ec14e5e38c2782670eb35a4bf631"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a8b16ec14e5e38c2782670eb35a4bf631">BTR_ESTIMATE</a> = 1024</td></tr>
<tr class="memdesc:a8b16ec14e5e38c2782670eb35a4bf631"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag ORed to btr_latch_mode says that we do the search in query optimization.  <a href="#a8b16ec14e5e38c2782670eb35a4bf631">More...</a><br /></td></tr>
<tr class="separator:a8b16ec14e5e38c2782670eb35a4bf631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8088268d461f227478149b5ec4ddbd"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a3f8088268d461f227478149b5ec4ddbd">BTR_IGNORE_SEC_UNIQUE</a> = 2048</td></tr>
<tr class="memdesc:a3f8088268d461f227478149b5ec4ddbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag ORed to BTR_INSERT says that we can ignore possible UNIQUE definition on secondary indexes when we decide if we can use the insert buffer to speed up inserts.  <a href="#a3f8088268d461f227478149b5ec4ddbd">More...</a><br /></td></tr>
<tr class="separator:a3f8088268d461f227478149b5ec4ddbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4926a122ebc3b25db0c7948ae54dec"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a7e4926a122ebc3b25db0c7948ae54dec">BTR_DELETE_MARK</a> = 4096</td></tr>
<tr class="memdesc:a7e4926a122ebc3b25db0c7948ae54dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to delete mark the record at the searched position using the insert/delete buffer when the record is not in the buffer pool.  <a href="#a7e4926a122ebc3b25db0c7948ae54dec">More...</a><br /></td></tr>
<tr class="separator:a7e4926a122ebc3b25db0c7948ae54dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f077089c41ed9a35e90b21050e6854"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a74f077089c41ed9a35e90b21050e6854">BTR_DELETE</a> = 8192</td></tr>
<tr class="memdesc:a74f077089c41ed9a35e90b21050e6854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to purge the record at the searched position using the insert/delete buffer when the record is not in the buffer pool.  <a href="#a74f077089c41ed9a35e90b21050e6854">More...</a><br /></td></tr>
<tr class="separator:a74f077089c41ed9a35e90b21050e6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8639c3003d316a0ad77ebd3f1f98ecf3"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a8639c3003d316a0ad77ebd3f1f98ecf3">BTR_ALREADY_S_LATCHED</a> = 16384</td></tr>
<tr class="memdesc:a8639c3003d316a0ad77ebd3f1f98ecf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of BTR_SEARCH_LEAF or BTR_MODIFY_LEAF, the caller is already holding an S latch on the index tree.  <a href="#a8639c3003d316a0ad77ebd3f1f98ecf3">More...</a><br /></td></tr>
<tr class="separator:a8639c3003d316a0ad77ebd3f1f98ecf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9727c1ccdc9aeaf21cc4ee410fb9f38"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad9727c1ccdc9aeaf21cc4ee410fb9f38">BTR_LATCH_FOR_INSERT</a> = 32768</td></tr>
<tr class="memdesc:ad9727c1ccdc9aeaf21cc4ee410fb9f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of BTR_MODIFY_TREE, the caller specifies the intention to insert record only.  <a href="#ad9727c1ccdc9aeaf21cc4ee410fb9f38">More...</a><br /></td></tr>
<tr class="separator:ad9727c1ccdc9aeaf21cc4ee410fb9f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777679e5f839af055e8175ee81dc8858"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a777679e5f839af055e8175ee81dc8858">BTR_LATCH_FOR_DELETE</a> = 65536</td></tr>
<tr class="memdesc:a777679e5f839af055e8175ee81dc8858"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of BTR_MODIFY_TREE, the caller specifies the intention to delete record only.  <a href="#a777679e5f839af055e8175ee81dc8858">More...</a><br /></td></tr>
<tr class="separator:a777679e5f839af055e8175ee81dc8858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61036c5bfb8d2aec415010d46c55ca2"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aa61036c5bfb8d2aec415010d46c55ca2">BTR_RTREE_UNDO_INS</a> = 131072</td></tr>
<tr class="memdesc:aa61036c5bfb8d2aec415010d46c55ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag is for undo insert of rtree.  <a href="#aa61036c5bfb8d2aec415010d46c55ca2">More...</a><br /></td></tr>
<tr class="separator:aa61036c5bfb8d2aec415010d46c55ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12dc330add9b6a745cd32d118e49af4"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ac12dc330add9b6a745cd32d118e49af4">BTR_MODIFY_EXTERNAL</a> = 262144</td></tr>
<tr class="memdesc:ac12dc330add9b6a745cd32d118e49af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of BTR_MODIFY_LEAF, the caller intends to allocate or free the pages of externally stored fields.  <a href="#ac12dc330add9b6a745cd32d118e49af4">More...</a><br /></td></tr>
<tr class="separator:ac12dc330add9b6a745cd32d118e49af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d088998260c0210aae480b8d3a186fc"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a6d088998260c0210aae480b8d3a186fc">BTR_RTREE_DELETE_MARK</a> = 524288</td></tr>
<tr class="memdesc:a6d088998260c0210aae480b8d3a186fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to delete mark the record at the searched position when the record is in spatial index.  <a href="#a6d088998260c0210aae480b8d3a186fc">More...</a><br /></td></tr>
<tr class="separator:a6d088998260c0210aae480b8d3a186fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The B-tree. </p>
<p>Created 6/2/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2e7b9b7db7f01f12accffb27b543d03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7b9b7db7f01f12accffb27b543d03d">&#9670;&nbsp;</a></span>btr_assert_not_corrupted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_assert_not_corrupted</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((ibool) !!<a class="code" href="page0page_8h.html#a84498b8178988dbaccd7a9020ba1f590">page_is_comp</a>(<a class="code" href="buf0buf_8h.html#a95db363e6bf7655c69a903397199b780">buf_block_get_frame</a>(block)) != \</div><div class="line">      <a class="code" href="dict0dict_8h.html#afeb24172dd54a082038c4f7c6aff7ce6">dict_table_is_comp</a>((<a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)-&gt;table)) {                 \</div><div class="line">    btr_corruption_report(block, <a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>);                    \</div><div class="line">    ut_error;                                               \</div><div class="line">  }</div><div class="ttc" id="page0page_8h_html_a84498b8178988dbaccd7a9020ba1f590"><div class="ttname"><a href="page0page_8h.html#a84498b8178988dbaccd7a9020ba1f590">page_is_comp</a></div><div class="ttdeci">UNIV_INLINE ulint page_is_comp(const page_t *page)</div><div class="ttdoc">Determine whether the page is in new-style compact format. </div></div>
<div class="ttc" id="dict0dict_8h_html_afeb24172dd54a082038c4f7c6aff7ce6"><div class="ttname"><a href="dict0dict_8h.html#afeb24172dd54a082038c4f7c6aff7ce6">dict_table_is_comp</a></div><div class="ttdeci">UNIV_INLINE ibool dict_table_is_comp(const dict_table_t *table)</div><div class="ttdoc">Check whether the table uses the compact page format. </div></div>
<div class="ttc" id="mysql_8cc_html_adfa69ae672499b1037123a1f17c5552b"><div class="ttname"><a href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></div><div class="ttdeci">char * index(const char *, int c)</div><div class="ttdef"><b>Definition:</b> mysql.cc:2928</div></div>
<div class="ttc" id="buf0buf_8h_html_a95db363e6bf7655c69a903397199b780"><div class="ttname"><a href="buf0buf_8h.html#a95db363e6bf7655c69a903397199b780">buf_block_get_frame</a></div><div class="ttdeci">UNIV_INLINE buf_frame_t * buf_block_get_frame(const buf_block_t *block)</div><div class="ttdoc">Gets a pointer to the memory frame of a block. </div></div>
</div><!-- fragment -->
<p>Assert that a B-tree page is not corrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>buffer block containing a B-tree page </td></tr>
    <tr><td class="paramname">index</td><td>the B-tree index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fe7f5a0b3a66c74e33f28437d67939a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe7f5a0b3a66c74e33f28437d67939a">&#9670;&nbsp;</a></span>btr_block_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_block_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="btr0btr_8h.html#a9090f73ca3c7684e70759fcefe4a3e2c">btr_block_get_func</a>(page_id, page_size, mode, __FILE__, __LINE__, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, mtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a buffer page and declares its latching order level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>Tablespace/page identifier </td></tr>
    <tr><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramname">mode</td><td>Latch mode </td></tr>
    <tr><td class="paramname">index</td><td>Index tree, may be NULL if not the insert buffer tree </td></tr>
    <tr><td class="paramname">mtr</td><td>Mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the block descriptor </dd></dl>

</div>
</div>
<a id="a558ab04c61d04bd8e4904157405624b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ab04c61d04bd8e4904157405624b4">&#9670;&nbsp;</a></span>btr_insert_on_non_leaf_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_insert_on_non_leaf_level</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="btr0btr_8h.html#a18a13ed2995588a23441f93237aa2843">btr_insert_on_non_leaf_level_func</a>(f, i, l, t, __FILE__, __LINE__, m)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa60b568a3b8345949e70acea4130d767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60b568a3b8345949e70acea4130d767">&#9670;&nbsp;</a></span>BTR_LATCH_MODE_WITHOUT_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_LATCH_MODE_WITHOUT_FLAGS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">latch_mode</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((latch_mode) &amp;                                                           \</div><div class="line">   ~(<a class="code" href="btr0btr_8h.html#a83f00d659563b666880b97ce3dab0054">BTR_INSERT</a> | <a class="code" href="btr0btr_8h.html#a7e4926a122ebc3b25db0c7948ae54dec">BTR_DELETE_MARK</a> | <a class="code" href="btr0btr_8h.html#aa61036c5bfb8d2aec415010d46c55ca2">BTR_RTREE_UNDO_INS</a> |                    \</div><div class="line">     <a class="code" href="btr0btr_8h.html#a6d088998260c0210aae480b8d3a186fc">BTR_RTREE_DELETE_MARK</a> | <a class="code" href="btr0btr_8h.html#a74f077089c41ed9a35e90b21050e6854">BTR_DELETE</a> | <a class="code" href="btr0btr_8h.html#a8b16ec14e5e38c2782670eb35a4bf631">BTR_ESTIMATE</a> |                    \</div><div class="line">     <a class="code" href="btr0btr_8h.html#a3f8088268d461f227478149b5ec4ddbd">BTR_IGNORE_SEC_UNIQUE</a> | <a class="code" href="btr0btr_8h.html#a8639c3003d316a0ad77ebd3f1f98ecf3">BTR_ALREADY_S_LATCHED</a> | <a class="code" href="btr0btr_8h.html#ad9727c1ccdc9aeaf21cc4ee410fb9f38">BTR_LATCH_FOR_INSERT</a> | \</div><div class="line">     <a class="code" href="btr0btr_8h.html#a777679e5f839af055e8175ee81dc8858">BTR_LATCH_FOR_DELETE</a> | <a class="code" href="btr0btr_8h.html#ac12dc330add9b6a745cd32d118e49af4">BTR_MODIFY_EXTERNAL</a>))</div><div class="ttc" id="btr0btr_8h_html_a777679e5f839af055e8175ee81dc8858"><div class="ttname"><a href="btr0btr_8h.html#a777679e5f839af055e8175ee81dc8858">BTR_LATCH_FOR_DELETE</a></div><div class="ttdeci">constexpr size_t BTR_LATCH_FOR_DELETE</div><div class="ttdoc">In the case of BTR_MODIFY_TREE, the caller specifies the intention to delete record only...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:116</div></div>
<div class="ttc" id="btr0btr_8h_html_a8639c3003d316a0ad77ebd3f1f98ecf3"><div class="ttname"><a href="btr0btr_8h.html#a8639c3003d316a0ad77ebd3f1f98ecf3">BTR_ALREADY_S_LATCHED</a></div><div class="ttdeci">constexpr size_t BTR_ALREADY_S_LATCHED</div><div class="ttdoc">In the case of BTR_SEARCH_LEAF or BTR_MODIFY_LEAF, the caller is already holding an S latch on the in...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:108</div></div>
<div class="ttc" id="btr0btr_8h_html_a3f8088268d461f227478149b5ec4ddbd"><div class="ttname"><a href="btr0btr_8h.html#a3f8088268d461f227478149b5ec4ddbd">BTR_IGNORE_SEC_UNIQUE</a></div><div class="ttdeci">constexpr size_t BTR_IGNORE_SEC_UNIQUE</div><div class="ttdoc">This flag ORed to BTR_INSERT says that we can ignore possible UNIQUE definition on secondary indexes ...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:96</div></div>
<div class="ttc" id="btr0btr_8h_html_ac12dc330add9b6a745cd32d118e49af4"><div class="ttname"><a href="btr0btr_8h.html#ac12dc330add9b6a745cd32d118e49af4">BTR_MODIFY_EXTERNAL</a></div><div class="ttdeci">constexpr size_t BTR_MODIFY_EXTERNAL</div><div class="ttdoc">In the case of BTR_MODIFY_LEAF, the caller intends to allocate or free the pages of externally stored...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:124</div></div>
<div class="ttc" id="btr0btr_8h_html_aa61036c5bfb8d2aec415010d46c55ca2"><div class="ttname"><a href="btr0btr_8h.html#aa61036c5bfb8d2aec415010d46c55ca2">BTR_RTREE_UNDO_INS</a></div><div class="ttdeci">constexpr size_t BTR_RTREE_UNDO_INS</div><div class="ttdoc">This flag is for undo insert of rtree. </div><div class="ttdef"><b>Definition:</b> btr0btr.h:120</div></div>
<div class="ttc" id="btr0btr_8h_html_a74f077089c41ed9a35e90b21050e6854"><div class="ttname"><a href="btr0btr_8h.html#a74f077089c41ed9a35e90b21050e6854">BTR_DELETE</a></div><div class="ttdeci">constexpr size_t BTR_DELETE</div><div class="ttdoc">Try to purge the record at the searched position using the insert/delete buffer when the record is no...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:104</div></div>
<div class="ttc" id="btr0btr_8h_html_ad9727c1ccdc9aeaf21cc4ee410fb9f38"><div class="ttname"><a href="btr0btr_8h.html#ad9727c1ccdc9aeaf21cc4ee410fb9f38">BTR_LATCH_FOR_INSERT</a></div><div class="ttdeci">constexpr size_t BTR_LATCH_FOR_INSERT</div><div class="ttdoc">In the case of BTR_MODIFY_TREE, the caller specifies the intention to insert record only...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:112</div></div>
<div class="ttc" id="btr0btr_8h_html_a7e4926a122ebc3b25db0c7948ae54dec"><div class="ttname"><a href="btr0btr_8h.html#a7e4926a122ebc3b25db0c7948ae54dec">BTR_DELETE_MARK</a></div><div class="ttdeci">constexpr size_t BTR_DELETE_MARK</div><div class="ttdoc">Try to delete mark the record at the searched position using the insert/delete buffer when the record...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:100</div></div>
<div class="ttc" id="btr0btr_8h_html_a83f00d659563b666880b97ce3dab0054"><div class="ttname"><a href="btr0btr_8h.html#a83f00d659563b666880b97ce3dab0054">BTR_INSERT</a></div><div class="ttdeci">constexpr size_t BTR_INSERT</div><div class="ttdoc">If this is ORed to btr_latch_mode, it means that the search tuple will be inserted to the index...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:87</div></div>
<div class="ttc" id="btr0btr_8h_html_a8b16ec14e5e38c2782670eb35a4bf631"><div class="ttname"><a href="btr0btr_8h.html#a8b16ec14e5e38c2782670eb35a4bf631">BTR_ESTIMATE</a></div><div class="ttdeci">constexpr size_t BTR_ESTIMATE</div><div class="ttdoc">This flag ORed to btr_latch_mode says that we do the search in query optimization. </div><div class="ttdef"><b>Definition:</b> btr0btr.h:91</div></div>
<div class="ttc" id="btr0btr_8h_html_a6d088998260c0210aae480b8d3a186fc"><div class="ttname"><a href="btr0btr_8h.html#a6d088998260c0210aae480b8d3a186fc">BTR_RTREE_DELETE_MARK</a></div><div class="ttdeci">constexpr size_t BTR_RTREE_DELETE_MARK</div><div class="ttdoc">Try to delete mark the record at the searched position when the record is in spatial index...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:128</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d1162a49c36e8c4c9f7db739ffe91d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1162a49c36e8c4c9f7db739ffe91d6">&#9670;&nbsp;</a></span>BTR_LATCH_MODE_WITHOUT_INTENTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_LATCH_MODE_WITHOUT_INTENTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">latch_mode</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((latch_mode) &amp;                                    \</div><div class="line">   ~(<a class="code" href="btr0btr_8h.html#ad9727c1ccdc9aeaf21cc4ee410fb9f38">BTR_LATCH_FOR_INSERT</a> | <a class="code" href="btr0btr_8h.html#a777679e5f839af055e8175ee81dc8858">BTR_LATCH_FOR_DELETE</a> | <a class="code" href="btr0btr_8h.html#ac12dc330add9b6a745cd32d118e49af4">BTR_MODIFY_EXTERNAL</a>))</div><div class="ttc" id="btr0btr_8h_html_a777679e5f839af055e8175ee81dc8858"><div class="ttname"><a href="btr0btr_8h.html#a777679e5f839af055e8175ee81dc8858">BTR_LATCH_FOR_DELETE</a></div><div class="ttdeci">constexpr size_t BTR_LATCH_FOR_DELETE</div><div class="ttdoc">In the case of BTR_MODIFY_TREE, the caller specifies the intention to delete record only...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:116</div></div>
<div class="ttc" id="btr0btr_8h_html_ac12dc330add9b6a745cd32d118e49af4"><div class="ttname"><a href="btr0btr_8h.html#ac12dc330add9b6a745cd32d118e49af4">BTR_MODIFY_EXTERNAL</a></div><div class="ttdeci">constexpr size_t BTR_MODIFY_EXTERNAL</div><div class="ttdoc">In the case of BTR_MODIFY_LEAF, the caller intends to allocate or free the pages of externally stored...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:124</div></div>
<div class="ttc" id="btr0btr_8h_html_ad9727c1ccdc9aeaf21cc4ee410fb9f38"><div class="ttname"><a href="btr0btr_8h.html#ad9727c1ccdc9aeaf21cc4ee410fb9f38">BTR_LATCH_FOR_INSERT</a></div><div class="ttdeci">constexpr size_t BTR_LATCH_FOR_INSERT</div><div class="ttdoc">In the case of BTR_MODIFY_TREE, the caller specifies the intention to insert record only...</div><div class="ttdef"><b>Definition:</b> btr0btr.h:112</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a673d044d0cec2c50072b3c14df981105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673d044d0cec2c50072b3c14df981105">&#9670;&nbsp;</a></span>BTR_MAX_LEVELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_MAX_LEVELS&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum depth of a B-tree in InnoDB. </p>
<p>Note that this isn't a maximum as such; none of the tree operations avoid producing trees bigger than this. It is instead a "max depth
that other code must work with", useful for e.g. fixed-size arrays that must store some information about each level in a tree. In other words: if a B-tree with bigger depth than this is encountered, it is not acceptable for it to lead to mysterious memory corruption, but it is acceptable for the program to die with a clear assert failure. </p>

</div>
</div>
<a id="ae693faeca995271eb27f60e74fda3395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae693faeca995271eb27f60e74fda3395">&#9670;&nbsp;</a></span>BTR_N_LEAF_PAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_N_LEAF_PAGES&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94b582fbcaa5d8c7d6e9fcea1c050f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b582fbcaa5d8c7d6e9fcea1c050f17">&#9670;&nbsp;</a></span>btr_page_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_page_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a95db363e6bf7655c69a903397199b780">buf_block_get_frame</a>(<a class="el" href="btr0btr_8h.html#a6fe7f5a0b3a66c74e33f28437d67939a">btr_block_get</a>(page_id, page_size, mode, <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, mtr))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a buffer page and declares its latching order level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>Tablespace/page identifier </td></tr>
    <tr><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramname">mode</td><td>Latch mode </td></tr>
    <tr><td class="paramname">index</td><td>Index tree, may be NULL if not the insert buffer tree </td></tr>
    <tr><td class="paramname">mtr</td><td>Mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uncompressed page frame </dd></dl>

</div>
</div>
<a id="ad8f69a3a51aa6d003885a7b14562cd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f69a3a51aa6d003885a7b14562cd4f">&#9670;&nbsp;</a></span>btr_page_get_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_page_get_level</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="btr0btr_8h.html#a573f7dd66509be89eaeeaad8201f729b">btr_page_get_level_low</a>(<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a478a4bd54ccaf1b7bcff648f788e16fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478a4bd54ccaf1b7bcff648f788e16fd">&#9670;&nbsp;</a></span>BTR_PAGE_MAX_REC_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_PAGE_MAX_REC_SIZE&#160;&#160;&#160;(UNIV_PAGE_SIZE / 2 - 200)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum record size which can be stored on a page, without using the special big record storage structure. </p>

</div>
</div>
<a id="aeaa5fd7bb5a6aaa5720e74b8933d6914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa5fd7bb5a6aaa5720e74b8933d6914">&#9670;&nbsp;</a></span>BTR_TOTAL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_TOTAL_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2e8da6642741a4294e1de2a0ff5f2dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8da6642741a4294e1de2a0ff5f2dc8">&#9670;&nbsp;</a></span>btr_latch_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0btr_8h.html#a2e8da6642741a4294e1de2a0ff5f2dc8">btr_latch_mode</a> : size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Latching modes for btr_cur_search_to_nth_level(). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8a851af4ea6177309bedbe8f143726ccd8"></a>BTR_SEARCH_LEAF&#160;</td><td class="fielddoc"><p>Search a record on a leaf page and S-latch it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8a47d0ffb5f1bd7b913c3f98df60b9d793"></a>BTR_MODIFY_LEAF&#160;</td><td class="fielddoc"><p>(Prepare to) modify a record on a leaf page and X-latch it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8a79778e0de38ce6f6fd5f52fa8f17e108"></a>BTR_NO_LATCHES&#160;</td><td class="fielddoc"><p>Obtain no latches. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8a16200f39165164daf6003bd8c081e61f"></a>BTR_MODIFY_TREE&#160;</td><td class="fielddoc"><p>Start modifying the entire B-tree. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8a0c6b78ce4b3f3ff9e86bbe769841aa6b"></a>BTR_CONT_MODIFY_TREE&#160;</td><td class="fielddoc"><p>Continue modifying the entire B-tree. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8a62dd636a279e6e83c7c1361e0fc3faf4"></a>BTR_SEARCH_PREV&#160;</td><td class="fielddoc"><p>Search the previous record. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8aae7c44e6a014139ef9fb614f17f2d967"></a>BTR_MODIFY_PREV&#160;</td><td class="fielddoc"><p>Modify the previous record. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8aeaa22ebc92bb2fe8bfc8e6c35c453f7b"></a>BTR_SEARCH_TREE&#160;</td><td class="fielddoc"><p>Start searching the entire B-tree. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2e8da6642741a4294e1de2a0ff5f2dc8ac226de21f5121a5fe7bc94ed50229ff2"></a>BTR_CONT_SEARCH_TREE&#160;</td><td class="fielddoc"><p>Continue searching the entire B-tree. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9090f73ca3c7684e70759fcefe4a3e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9090f73ca3c7684e70759fcefe4a3e2c">&#9670;&nbsp;</a></span>btr_block_get_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_block_get_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a buffer page and declares its latching order level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Latch mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree, may be NULL if it is not an insert buffer tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>block </dd></dl>

</div>
</div>
<a id="af98340cedd4876607365ac140c3c9549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98340cedd4876607365ac140c3c9549">&#9670;&nbsp;</a></span>btr_check_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_check_node_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the node pointer to a page is appropriate. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a4adfc9b6b2aac22fef42be5d75235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a4adfc9b6b2aac22fef42be5d75235">&#9670;&nbsp;</a></span>btr_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to merge the page first to the left immediate brother if such a brother exists, and the node pointers to the current page and to the brother reside on the same page. </p>
<p>If the left brother does not satisfy these conditions, looks at the right brother. If the page is the only one on that level lifts the records of the page to the father page, thus reducing the tree height. It is assumed that mtr holds an x-latch on the tree and on the page. If cursor is on the leaf level, mtr must also hold x-latches to the brothers, if they exist. </p><dl class="section return"><dt>Returns</dt><dd>true on success in/out: mini-transaction</dd></dl>
<p>If the left brother does not satisfy these conditions, looks at the right brother. If the page is the only one on that level lifts the records of the page to the father page, thus reducing the tree height. It is assumed that mtr holds an x-latch on the tree and on the page. If cursor is on the leaf level, mtr must also hold x-latches to the brothers, if they exist. </p><dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to merge or lift; the page must not be empty: when deleting records, use btr_discard_page() if the page would become empty </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8a3be58d71578953b59c6f875a71a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a3be58d71578953b59c6f875a71a4a">&#9670;&nbsp;</a></span>btr_corruption_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_corruption_report </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report that an index page is corrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: corrupted block </td></tr>
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08c675c012fdbf24ab0f4d81dd16d1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c675c012fdbf24ab0f4d81dd16d1ac">&#9670;&nbsp;</a></span>btr_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a>&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the root node for a new index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of the index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>Space where created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_id</td><td>Index id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>page number of the created root </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FIL_NULL</td><td>if did not succeed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad22a428cb7087e01af9c80a814e4fcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22a428cb7087e01af9c80a814e4fcfb">&#9670;&nbsp;</a></span>btr_discard_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_discard_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards a page from a B-tree. </p>
<p>This is used to remove the last record from a B-tree page: the whole page must be removed at the same time. This cannot be used for the root page, which is allowed to be empty. in: mtr</p>
<p>This is used to remove the last record from a B-tree page: the whole page must be removed at the same time. This cannot be used for the root page, which is allowed to be empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the page to discard: not on the root page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a193fcd2b57ae443bdeb7d72fa98cd40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193fcd2b57ae443bdeb7d72fa98cd40e">&#9670;&nbsp;</a></span>btr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_free </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an index tree in a temporary tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>root page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b0d34be2b0c8e2b14490bd1a3e507c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0d34be2b0c8e2b14490bd1a3e507c1">&#9670;&nbsp;</a></span>btr_free_if_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_free_if_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a>&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a persistent index tree if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Root page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_id</td><td>PAGE_INDEX_ID contents </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79e65306550a56feffb3904a9c619778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e65306550a56feffb3904a9c619778">&#9670;&nbsp;</a></span>btr_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of pages in a B-tree. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pages, or ULINT_UNDEFINED if the index is unavailable </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">flag</td><td>in: BTR_N_LEAF_PAGES or BTR_TOTAL_SIZE </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction where index is s-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6f3b94ce40c2202dd2678f5fda28e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f3b94ce40c2202dd2678f5fda28e4e">&#9670;&nbsp;</a></span>btr_height_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_height_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the height of the B-tree (the level of the root, when the leaf level is assumed to be 0). </p>
<p>The caller must hold an S or X latch on the index. </p><dl class="section return"><dt>Returns</dt><dd>tree height (level of the root) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a031e281cd01a4261bf7f681c49cc6ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e281cd01a4261bf7f681c49cc6ef2">&#9670;&nbsp;</a></span>btr_index_rec_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_index_rec_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dump_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the size and number of fields in a record based on the definition of the index. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">dump_on_error</td><td>in: TRUE if the function should print hex dump of record and page on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18a13ed2995588a23441f93237aa2843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a13ed2995588a23441f93237aa2843">&#9670;&nbsp;</a></span>btr_insert_on_non_leaf_level_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_insert_on_non_leaf_level_func </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a data tuple to a tree on a non-leaf level. </p>
<p>It is assumed that mtr holds an x-latch on the tree. in: mtr</p>
<p>It is assumed that mtr holds an x-latch on the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: level, must be &gt; 0 </td></tr>
    <tr><td class="paramname">tuple</td><td>in: the record to be inserted </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a785f57bc94bbf370cb3d6de8e6353c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785f57bc94bbf370cb3d6de8e6353c13">&#9670;&nbsp;</a></span>btr_leaf_page_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_leaf_page_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the latch on a leaf page and bufferunfixes it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">latch_mode</td><td>BTR_SEARCH_LEAF or BTR_MODIFY_LEAF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a900f501e4015c67b08fc4f58e5f704df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900f501e4015c67b08fc4f58e5f704df">&#9670;&nbsp;</a></span>btr_node_ptr_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_node_ptr_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes on the upper level the node pointer to a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Page whose node pointer is deleted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77dda6a915f6afbd8c1cf21840875e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dda6a915f6afbd8c1cf21840875e33">&#9670;&nbsp;</a></span>btr_node_ptr_get_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_node_ptr_get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574">rw_lock_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="sync0rw_8h.html#ac63f6bb2316c64592a2494595132e574a0a61b228e5530d2c67679946b4bca4f2">RW_SX_LATCH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the child page of a node pointer and sx-latches it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_ptr</td><td>node pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>latch type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>child page, latched as per the type </dd></dl>

</div>
</div>
<a id="a0469f8de72c9bbb6875785d53532e88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0469f8de72c9bbb6875785d53532e88a">&#9670;&nbsp;</a></span>btr_node_ptr_get_child_page_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> btr_node_ptr_get_child_page_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the child node file address in a node pointer. </p>
<p>NOTE: the offsets array must contain all offsets for the record since we read the last field according to offsets and assume that it contains the child page number. In other words offsets must have been retrieved with rec_get_offsets(n_fields=ULINT_UNDEFINED). </p><dl class="section return"><dt>Returns</dt><dd>child node address </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: node pointer record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b6e143b4d70a1656c1f9110ebc62a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b6e143b4d70a1656c1f9110ebc62a1">&#9670;&nbsp;</a></span>btr_page_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_page_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>hint_page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>file_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new file page to be used in an index tree. </p>
<p>NOTE: we assume that the caller has made the reservation for free extents! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint_page_no</td><td>Hint of a good page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_direction</td><td>Direction where a possible page split is made </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level where the page is placed in the tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction for the allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">init_mtr</td><td>Mini-transaction for x-latching and initializing the page </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr), returned block is not allocated nor initialized otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8b0eab34f77f8475935b6683d95c22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b0eab34f77f8475935b6683d95c22e">&#9670;&nbsp;</a></span>btr_page_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_page_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new index page (not the root, and also not used in page reorganization). </p>
<dl class="section see"><dt>See also</dt><dd>btr_page_empty(). in: mtr</dd>
<dd>
btr_page_empty(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: page to be created </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: the B-tree level of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3b6c9643b6c0950f74c5926291e66fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b6c9643b6c0950f74c5926291e66fd">&#9670;&nbsp;</a></span>btr_page_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_page_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a file page used in an index tree. </p>
<p>NOTE: cannot free field external storage pages because the page must contain info on its level. in: mtr</p>
<p>NOTE: cannot free field external storage pages because the page must contain info on its level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a444dc4bd2155c2ea85dea09bf5c78931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444dc4bd2155c2ea85dea09bf5c78931">&#9670;&nbsp;</a></span>btr_page_free_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_page_free_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a file page used in an index tree. </p>
<p>Can be used also to BLOB external storage pages. in: mtr</p>
<p>Can be used also to (BLOB) external storage pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">level</td><td>in: page level (ULINT_UNDEFINED=BLOB) </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa04ce1675becd32994c630c3762b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa04ce1675becd32994c630c3762b798">&#9670;&nbsp;</a></span>btr_page_get_index_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="dict0types_8h.html#a00c394837dddc950522d91155514e7de">space_index_t</a> btr_page_get_index_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the index id field of a page. </p>
<dl class="section return"><dt>Returns</dt><dd>index id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a573f7dd66509be89eaeeaad8201f729b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573f7dd66509be89eaeeaad8201f729b">&#9670;&nbsp;</a></span>btr_page_get_level_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint btr_page_get_level_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the node level field in an index page. </p>
<dl class="section return"><dt>Returns</dt><dd>level, leaf level == 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f1a85ee930f8419ed9941f38a9262a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1a85ee930f8419ed9941f38a9262a6">&#9670;&nbsp;</a></span>btr_page_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> btr_page_get_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next index page number. </p>
<dl class="section return"><dt>Returns</dt><dd>next page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8cf75688b15a7687e9c79e14f861366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cf75688b15a7687e9c79e14f861366">&#9670;&nbsp;</a></span>btr_page_get_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> btr_page_get_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the previous index page number. </p>
<dl class="section return"><dt>Returns</dt><dd>prev page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9814eaf18cf608e29cb25cc24b1aa766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9814eaf18cf608e29cb25cc24b1aa766">&#9670;&nbsp;</a></span>btr_page_get_split_rec_to_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_page_get_split_rec_to_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides if the page should be split at the convergence point of inserts converging to left. </p>
<dl class="section return"><dt>Returns</dt><dd>true if split recommended</dd></dl>
<p>Decides if the page should be split at the convergence point of inserts converging to left.</p>
<dl class="section return"><dt>Returns</dt><dd>true if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple to be inserted should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28dc7dce0944faaeaa433b5d611b8d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dc7dce0944faaeaa433b5d611b8d11">&#9670;&nbsp;</a></span>btr_page_get_split_rec_to_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool btr_page_get_split_rec_to_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides if the page should be split at the convergence point of inserts converging to right. </p>
<dl class="section return"><dt>Returns</dt><dd>true if split recommended</dd></dl>
<p>Decides if the page should be split at the convergence point of inserts converging to right.</p>
<dl class="section return"><dt>Returns</dt><dd>true if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple to be inserted should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21abcd4da4bc353f9a2b855a79450490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21abcd4da4bc353f9a2b855a79450490">&#9670;&nbsp;</a></span>btr_page_reorganize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_page_reorganize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorganizes an index page. </p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking ibuf_reset_free_bits() before mtr_commit(). On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>Page cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index tree of the page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa41fefade013636c0ff53fef29c29e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41fefade013636c0ff53fef29c29e3c">&#9670;&nbsp;</a></span>btr_page_reorganize_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_page_reorganize_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>z_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorganizes an index page. </p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking ibuf_reset_free_bits() before mtr_commit(). On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recovery</td><td>in: true if called in recovery: locks should not be updated, i.e., there cannot exist locks on the page, and a hash index should not be dropped: it cannot exist </td></tr>
    <tr><td class="paramname">z_level</td><td>in: compression level to be used if dealing with compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41424f75ebce380f498a411829d22c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41424f75ebce380f498a411829d22c48">&#9670;&nbsp;</a></span>btr_page_split_and_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* btr_page_split_and_insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits an index page to halves and inserts the tuple. </p>
<p>It is assumed that mtr holds an x-latch to the index tree. NOTE: the tree x-latch is released within this function! NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space (2 pages) must be guaranteed to be available before this function is called.</p>
<dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6387b234b3e7ebc7c8bc1a8d023e587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6387b234b3e7ebc7c8bc1a8d023e587">&#9670;&nbsp;</a></span>btr_parse_page_reorganize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* btr_parse_page_reorganize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a redo log record of reorganizing a page. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">compressed</td><td>in: true if compressed page </td></tr>
    <tr><td class="paramname">block</td><td>in: page to be reorganized, or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76b38ae3a4b9a9d41758c1d7a989d426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b38ae3a4b9a9d41758c1d7a989d426">&#9670;&nbsp;</a></span>btr_parse_set_min_rec_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* btr_parse_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the redo log record for setting an index record as the predefined minimum record. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">comp</td><td>in: nonzero=compact page format </td></tr>
    <tr><td class="paramname">page</td><td>in: page or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4147370fa0331bbfa2534ff64b077830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147370fa0331bbfa2534ff64b077830">&#9670;&nbsp;</a></span>btr_root_adjust_on_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_root_adjust_on_import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and adjusts the root node of a tree during IMPORT TABLESPACE. </p>
<dl class="section return"><dt>Returns</dt><dd>error code, or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedd1295c03b53daf3008ad4859e2cab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd1295c03b53daf3008ad4859e2cab8">&#9670;&nbsp;</a></span>btr_root_block_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_root_block_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the root node of a tree and x- or s-latches it. </p>
<dl class="section return"><dt>Returns</dt><dd>root page, x- or s-latched in: mtr</dd>
<dd>
root page, x- or s-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mode</td><td>in: either RW_S_LATCH or RW_X_LATCH </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0ea96c431b04a3bc2944e7e22eadb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ea96c431b04a3bc2944e7e22eadb35">&#9670;&nbsp;</a></span>btr_root_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* btr_root_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the root node of a tree and sx-latches it for segment access. </p>
<dl class="section return"><dt>Returns</dt><dd>root page, sx-latched in: mtr</dd>
<dd>
root page, sx-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4dbcd9ec49055114b55b9b4e50c43a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dbcd9ec49055114b55b9b4e50c43a1">&#9670;&nbsp;</a></span>btr_root_raise_and_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* btr_root_raise_and_insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes tree one level higher by splitting the root, and inserts the tuple. </p>
<p>It is assumed that mtr contains an x-latch on the tree. NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space must be guaranteed to be available before this function is called. </p><dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert: must be on the root page; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab98f3838f331835474a95ffe18d0aae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98f3838f331835474a95ffe18d0aae8">&#9670;&nbsp;</a></span>btr_sdi_create_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_sdi_create_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>dict_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates SDI index and stores the root page numbers in page 1 &amp; 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">space_id</td><td>tablespace id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dict_locked</td><td>true if dict_sys mutex is acquired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS on success, else DB_ERROR on failure </dd></dl>

</div>
</div>
<a id="ac4330cef72fbfbb638446103baddd5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4330cef72fbfbb638446103baddd5c0">&#9670;&nbsp;</a></span>btr_set_min_rec_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a record as the predefined minimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d21d2a6fa315b6aef46ee926f98ceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d21d2a6fa315b6aef46ee926f98ceae">&#9670;&nbsp;</a></span>btr_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_truncate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate an index tree. </p>
<p>We just free all except the root. Currently, this function is only specific for clustered indexes and the only caller is DDTableBuffer which manages a table with only a clustered index. It is up to the caller to ensure atomicity and to ensure correct recovery by calling btr_truncate_recover(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5adbc37056b85a4b15d771e526602792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adbc37056b85a4b15d771e526602792">&#9670;&nbsp;</a></span>btr_truncate_recover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btr_truncate_recover </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recovery function for btr_truncate. </p>
<p>We will check if there is a crash during btr_truncate, if so, do recover it, if not, do nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a85fb82a7c6060cfa8f1ced5a610615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85fb82a7c6060cfa8f1ced5a610615">&#9670;&nbsp;</a></span>btr_validate_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> btr_validate_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>lockout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the consistency of an index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction or NULL </td></tr>
    <tr><td class="paramname">lockout</td><td>in: true if X-latch index is intended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8639c3003d316a0ad77ebd3f1f98ecf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8639c3003d316a0ad77ebd3f1f98ecf3">&#9670;&nbsp;</a></span>BTR_ALREADY_S_LATCHED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_ALREADY_S_LATCHED = 16384</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the case of BTR_SEARCH_LEAF or BTR_MODIFY_LEAF, the caller is already holding an S latch on the index tree. </p>

</div>
</div>
<a id="a74f077089c41ed9a35e90b21050e6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f077089c41ed9a35e90b21050e6854">&#9670;&nbsp;</a></span>BTR_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_DELETE = 8192</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to purge the record at the searched position using the insert/delete buffer when the record is not in the buffer pool. </p>

</div>
</div>
<a id="a7e4926a122ebc3b25db0c7948ae54dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4926a122ebc3b25db0c7948ae54dec">&#9670;&nbsp;</a></span>BTR_DELETE_MARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_DELETE_MARK = 4096</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to delete mark the record at the searched position using the insert/delete buffer when the record is not in the buffer pool. </p>

</div>
</div>
<a id="a8b16ec14e5e38c2782670eb35a4bf631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b16ec14e5e38c2782670eb35a4bf631">&#9670;&nbsp;</a></span>BTR_ESTIMATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_ESTIMATE = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This flag ORed to btr_latch_mode says that we do the search in query optimization. </p>

</div>
</div>
<a id="a3f8088268d461f227478149b5ec4ddbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8088268d461f227478149b5ec4ddbd">&#9670;&nbsp;</a></span>BTR_IGNORE_SEC_UNIQUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_IGNORE_SEC_UNIQUE = 2048</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This flag ORed to BTR_INSERT says that we can ignore possible UNIQUE definition on secondary indexes when we decide if we can use the insert buffer to speed up inserts. </p>

</div>
</div>
<a id="a83f00d659563b666880b97ce3dab0054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f00d659563b666880b97ce3dab0054">&#9670;&nbsp;</a></span>BTR_INSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_INSERT = 512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this is ORed to btr_latch_mode, it means that the search tuple will be inserted to the index, at the searched position. </p>
<p>When the record is not in the buffer pool, try to use the insert buffer. </p>

</div>
</div>
<a id="a777679e5f839af055e8175ee81dc8858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777679e5f839af055e8175ee81dc8858">&#9670;&nbsp;</a></span>BTR_LATCH_FOR_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_LATCH_FOR_DELETE = 65536</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the case of BTR_MODIFY_TREE, the caller specifies the intention to delete record only. </p>
<p>It is used to optimize block-&gt;lock range. </p>

</div>
</div>
<a id="ad9727c1ccdc9aeaf21cc4ee410fb9f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9727c1ccdc9aeaf21cc4ee410fb9f38">&#9670;&nbsp;</a></span>BTR_LATCH_FOR_INSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_LATCH_FOR_INSERT = 32768</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the case of BTR_MODIFY_TREE, the caller specifies the intention to insert record only. </p>
<p>It is used to optimize block-&gt;lock range. </p>

</div>
</div>
<a id="ac12dc330add9b6a745cd32d118e49af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12dc330add9b6a745cd32d118e49af4">&#9670;&nbsp;</a></span>BTR_MODIFY_EXTERNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_MODIFY_EXTERNAL = 262144</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the case of BTR_MODIFY_LEAF, the caller intends to allocate or free the pages of externally stored fields. </p>

</div>
</div>
<a id="a6d088998260c0210aae480b8d3a186fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d088998260c0210aae480b8d3a186fc">&#9670;&nbsp;</a></span>BTR_RTREE_DELETE_MARK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_RTREE_DELETE_MARK = 524288</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to delete mark the record at the searched position when the record is in spatial index. </p>

</div>
</div>
<a id="aa61036c5bfb8d2aec415010d46c55ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61036c5bfb8d2aec415010d46c55ca2">&#9670;&nbsp;</a></span>BTR_RTREE_UNDO_INS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t BTR_RTREE_UNDO_INS = 131072</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This flag is for undo insert of rtree. </p>
<p>For rtree, we need this flag to find proper rec to undo insert. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="btr0btr_8h.html">btr0btr.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
