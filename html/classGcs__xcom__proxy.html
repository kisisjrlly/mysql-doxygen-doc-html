<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Gcs_xcom_proxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classGcs__xcom__proxy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGcs__xcom__proxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gcs_xcom_proxy Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="gcs__xcom__proxy_8h_source.html">gcs_xcom_proxy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gcs_xcom_proxy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classGcs__xcom__proxy.png" usemap="#Gcs_5Fxcom_5Fproxy_map" alt=""/>
  <map id="Gcs_5Fxcom_5Fproxy_map" name="Gcs_5Fxcom_5Fproxy_map">
<area href="classGcs__xcom__proxy__base.html" alt="Gcs_xcom_proxy_base" shape="rect" coords="0,56,143,80"/>
<area href="classGcs__xcom__proxy__impl.html" alt="Gcs_xcom_proxy_impl" shape="rect" coords="0,112,143,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGcs__xcom__proxy_1_1ssl__parameters.html">ssl_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGcs__xcom__proxy_1_1tls__parameters.html">tls_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad11e5683a8bda04920db63fc2924bc37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ad11e5683a8bda04920db63fc2924bc37">Gcs_xcom_proxy</a> ()</td></tr>
<tr class="separator:ad11e5683a8bda04920db63fc2924bc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6d6337be3df9ef4e15ba8565521c76"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aad6d6337be3df9ef4e15ba8565521c76">~Gcs_xcom_proxy</a> ()</td></tr>
<tr class="memdesc:aad6d6337be3df9ef4e15ba8565521c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="#aad6d6337be3df9ef4e15ba8565521c76">More...</a><br /></td></tr>
<tr class="separator:aad6d6337be3df9ef4e15ba8565521c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df54bc007f77fdbd415474a954c7cd7"><td class="memItemLeft" align="right" valign="top">virtual node_address *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a9df54bc007f77fdbd415474a954c7cd7">new_node_address_uuid</a> (unsigned int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, char *names[], blob uuids[])=0</td></tr>
<tr class="memdesc:a9df54bc007f77fdbd415474a954c7cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an utility member function that is used to call into XCom for creating list with node's addresses and their associated UUIDs.  <a href="#a9df54bc007f77fdbd415474a954c7cd7">More...</a><br /></td></tr>
<tr class="separator:a9df54bc007f77fdbd415474a954c7cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae902596752c184cd1f6aac6985a46c4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ae902596752c184cd1f6aac6985a46c4d">delete_node_address</a> (unsigned int <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, node_address *na)=0</td></tr>
<tr class="memdesc:ae902596752c184cd1f6aac6985a46c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is responsible to delete the list of nodes that had been previously created by <code>new_node_address</code>.  <a href="#ae902596752c184cd1f6aac6985a46c4d">More...</a><br /></td></tr>
<tr class="separator:ae902596752c184cd1f6aac6985a46c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2631e62f729479da7265e916454591"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a0f2631e62f729479da7265e916454591">xcom_client_add_node</a> (<a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *fd, node_list *nl, uint32_t group_id)=0</td></tr>
<tr class="memdesc:a0f2631e62f729479da7265e916454591"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible to call into XCom consensus and add a node to the group.  <a href="#a0f2631e62f729479da7265e916454591">More...</a><br /></td></tr>
<tr class="separator:a0f2631e62f729479da7265e916454591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d75f59fbeea6e8dc939c8c79a2f272"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#af4d75f59fbeea6e8dc939c8c79a2f272">xcom_client_remove_node</a> (node_list *nl, uint32_t group_id)=0</td></tr>
<tr class="memdesc:af4d75f59fbeea6e8dc939c8c79a2f272"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible for triggering the removal of a node from the XCom configuration.  <a href="#af4d75f59fbeea6e8dc939c8c79a2f272">More...</a><br /></td></tr>
<tr class="separator:af4d75f59fbeea6e8dc939c8c79a2f272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d703c136c82f9b66e7995337a422b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a69d703c136c82f9b66e7995337a422b2">xcom_client_remove_node</a> (<a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *fd, node_list *nl, uint32_t group_id)=0</td></tr>
<tr class="memdesc:a69d703c136c82f9b66e7995337a422b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible for triggering the removal of a node from the XCom configuration.  <a href="#a69d703c136c82f9b66e7995337a422b2">More...</a><br /></td></tr>
<tr class="separator:a69d703c136c82f9b66e7995337a422b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed0f3295a39f17c6450c0fa9f999059"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a3ed0f3295a39f17c6450c0fa9f999059">xcom_client_get_event_horizon</a> (uint32_t group_id, xcom_event_horizon &amp;event_horizon)=0</td></tr>
<tr class="memdesc:a3ed0f3295a39f17c6450c0fa9f999059"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible for retrieving the event horizon of the XCom configuration.  <a href="#a3ed0f3295a39f17c6450c0fa9f999059">More...</a><br /></td></tr>
<tr class="separator:a3ed0f3295a39f17c6450c0fa9f999059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93a0098f558e4af5817e2a71d3161b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aa93a0098f558e4af5817e2a71d3161b8">xcom_client_set_event_horizon</a> (uint32_t group_id, xcom_event_horizon event_horizon)=0</td></tr>
<tr class="memdesc:aa93a0098f558e4af5817e2a71d3161b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible for triggering the reconfiguration of the event horizon of the XCom configuration.  <a href="#aa93a0098f558e4af5817e2a71d3161b8">More...</a><br /></td></tr>
<tr class="separator:aa93a0098f558e4af5817e2a71d3161b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3564c81ccf2ce35e32e1bc78c9a0aefa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a3564c81ccf2ce35e32e1bc78c9a0aefa">xcom_client_get_synode_app_data</a> (<a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *fd, uint32_t group_id, synode_no_array &amp;synodes, synode_app_data_array &amp;reply)=0</td></tr>
<tr class="memdesc:a3564c81ccf2ce35e32e1bc78c9a0aefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible for retrieving the application payloads decided in the synodes in <code>synodes</code>, from the XCom instance connected to via <code>fd</code>.  <a href="#a3564c81ccf2ce35e32e1bc78c9a0aefa">More...</a><br /></td></tr>
<tr class="separator:a3564c81ccf2ce35e32e1bc78c9a0aefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba61bebd67dd7bb2a0fd730da4b5ee69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aba61bebd67dd7bb2a0fd730da4b5ee69">xcom_client_set_cache_size</a> (uint64_t size)=0</td></tr>
<tr class="memdesc:aba61bebd67dd7bb2a0fd730da4b5ee69"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible for setting a new value for the maximum size of the XCom cache.  <a href="#aba61bebd67dd7bb2a0fd730da4b5ee69">More...</a><br /></td></tr>
<tr class="separator:aba61bebd67dd7bb2a0fd730da4b5ee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7407911bccaa906d14c29e21c4825e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#af7407911bccaa906d14c29e21c4825e2">xcom_client_send_data</a> (unsigned long long size, char *data)=0</td></tr>
<tr class="memdesc:af7407911bccaa906d14c29e21c4825e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is responsible for pushing data into consensus on XCom.  <a href="#af7407911bccaa906d14c29e21c4825e2">More...</a><br /></td></tr>
<tr class="separator:af7407911bccaa906d14c29e21c4825e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af668b01a850ef0b9b92e0d0dfa2d32e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#af668b01a850ef0b9b92e0d0dfa2d32e4">xcom_init</a> (<a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a> listen_port)=0</td></tr>
<tr class="memdesc:af668b01a850ef0b9b92e0d0dfa2d32e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function initializes XCom.  <a href="#af668b01a850ef0b9b92e0d0dfa2d32e4">More...</a><br /></td></tr>
<tr class="separator:af668b01a850ef0b9b92e0d0dfa2d32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55193c7c502976be3f5d17942a588c08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a55193c7c502976be3f5d17942a588c08">xcom_exit</a> ()=0</td></tr>
<tr class="memdesc:a55193c7c502976be3f5d17942a588c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function finishes the XCom thread.  <a href="#a55193c7c502976be3f5d17942a588c08">More...</a><br /></td></tr>
<tr class="separator:a55193c7c502976be3f5d17942a588c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d4551e045f9f3d3b16bdedb6dbf16a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a47d4551e045f9f3d3b16bdedb6dbf16a">xcom_get_ssl_mode</a> (const char *mode)=0</td></tr>
<tr class="separator:a47d4551e045f9f3d3b16bdedb6dbf16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff3ff1adcda3c32ba8bb0af5a11a2ee"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a3ff3ff1adcda3c32ba8bb0af5a11a2ee">xcom_set_ssl_mode</a> (int mode)=0</td></tr>
<tr class="separator:a3ff3ff1adcda3c32ba8bb0af5a11a2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86a293dddb5c3560a3e60cef28ca8c5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ac86a293dddb5c3560a3e60cef28ca8c5">xcom_get_ssl_fips_mode</a> (const char *mode)=0</td></tr>
<tr class="separator:ac86a293dddb5c3560a3e60cef28ca8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf99c0e2d0645a58ad6a425166e97bb6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aaf99c0e2d0645a58ad6a425166e97bb6">xcom_set_ssl_fips_mode</a> (int mode)=0</td></tr>
<tr class="separator:aaf99c0e2d0645a58ad6a425166e97bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8760439210d57cda3ef4385f2cb49f37"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a8760439210d57cda3ef4385f2cb49f37">xcom_init_ssl</a> ()=0</td></tr>
<tr class="memdesc:a8760439210d57cda3ef4385f2cb49f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the SSL.  <a href="#a8760439210d57cda3ef4385f2cb49f37">More...</a><br /></td></tr>
<tr class="separator:a8760439210d57cda3ef4385f2cb49f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524d9774f758c9eef3aeba9d8fe22a10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a524d9774f758c9eef3aeba9d8fe22a10">xcom_destroy_ssl</a> ()=0</td></tr>
<tr class="separator:a524d9774f758c9eef3aeba9d8fe22a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af867420fa5e3f73964946a74d4d56488"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#af867420fa5e3f73964946a74d4d56488">xcom_use_ssl</a> ()=0</td></tr>
<tr class="memdesc:af867420fa5e3f73964946a74d4d56488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the SSL will be used to encrypt data or not.  <a href="#af867420fa5e3f73964946a74d4d56488">More...</a><br /></td></tr>
<tr class="separator:af867420fa5e3f73964946a74d4d56488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac723bf262dafe0e3540176abf512d4af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ac723bf262dafe0e3540176abf512d4af">xcom_set_ssl_parameters</a> (<a class="el" href="structGcs__xcom__proxy_1_1ssl__parameters.html">ssl_parameters</a> ssl, <a class="el" href="structGcs__xcom__proxy_1_1tls__parameters.html">tls_parameters</a> tls)=0</td></tr>
<tr class="separator:ac723bf262dafe0e3540176abf512d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affad7aec77baf4c21362d3f51562ab5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsite__def.html">site_def</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#affad7aec77baf4c21362d3f51562ab5b">find_site_def</a> (synode_no synode)=0</td></tr>
<tr class="separator:affad7aec77baf4c21362d3f51562ab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7374347b84dda1c31952c111653c664"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#af7374347b84dda1c31952c111653c664">xcom_client_boot</a> (node_list *nl, uint32_t group_id)=0</td></tr>
<tr class="memdesc:af7374347b84dda1c31952c111653c664"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function boots XCom.  <a href="#af7374347b84dda1c31952c111653c664">More...</a><br /></td></tr>
<tr class="separator:af7374347b84dda1c31952c111653c664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c8ef7a21cc79e54f10ba68d67210b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a33c8ef7a21cc79e54f10ba68d67210b2">xcom_client_open_connection</a> (std::string addr, <a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a> <a class="el" href="testapp_8c.html#a466f7b109ba414c07158f07424a82f6f">port</a>)=0</td></tr>
<tr class="memdesc:a33c8ef7a21cc79e54f10ba68d67210b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function opens a connection to an XCom instance.  <a href="#a33c8ef7a21cc79e54f10ba68d67210b2">More...</a><br /></td></tr>
<tr class="separator:a33c8ef7a21cc79e54f10ba68d67210b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647f2418553aa0384809c3b812404da5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a647f2418553aa0384809c3b812404da5">xcom_client_close_connection</a> (<a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *fd)=0</td></tr>
<tr class="memdesc:a647f2418553aa0384809c3b812404da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function closes the connection to an XCom instance.  <a href="#a647f2418553aa0384809c3b812404da5">More...</a><br /></td></tr>
<tr class="separator:a647f2418553aa0384809c3b812404da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f04678f3d75d728539ee46531a7a15"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aa0f04678f3d75d728539ee46531a7a15">xcom_wait_ready</a> ()=0</td></tr>
<tr class="memdesc:aa0f04678f3d75d728539ee46531a7a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member waits for XCom to be initialized.  <a href="#aa0f04678f3d75d728539ee46531a7a15">More...</a><br /></td></tr>
<tr class="separator:aa0f04678f3d75d728539ee46531a7a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1af550cd06d384925f0848f443c298"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aeb1af550cd06d384925f0848f443c298">xcom_is_ready</a> ()=0</td></tr>
<tr class="separator:aeb1af550cd06d384925f0848f443c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1114bb201f5ef0dbb8e596d96e079918"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a1114bb201f5ef0dbb8e596d96e079918">xcom_set_ready</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)=0</td></tr>
<tr class="separator:a1114bb201f5ef0dbb8e596d96e079918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e481bb1e383c624c0cff1ccb5b16e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a88e481bb1e383c624c0cff1ccb5b16e8">xcom_signal_ready</a> ()=0</td></tr>
<tr class="separator:a88e481bb1e383c624c0cff1ccb5b16e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e26410f42506cc1ebcb7c78ccfd8aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a34e26410f42506cc1ebcb7c78ccfd8aa">xcom_wait_for_xcom_comms_status_change</a> (int &amp;<a class="el" href="mysql_8cc.html#a1025e6cbbd3179d2d91b9b4afb8f8efc">status</a>)=0</td></tr>
<tr class="memdesc:a34e26410f42506cc1ebcb7c78ccfd8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to wait for XCom communications to be initialized.  <a href="#a34e26410f42506cc1ebcb7c78ccfd8aa">More...</a><br /></td></tr>
<tr class="separator:a34e26410f42506cc1ebcb7c78ccfd8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c933c4069b93eb1f7f6d9d09feb7fb6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a2c933c4069b93eb1f7f6d9d09feb7fb6">xcom_has_comms_status_changed</a> ()=0</td></tr>
<tr class="separator:a2c933c4069b93eb1f7f6d9d09feb7fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1cde763e909867f5deb34e8c348886"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aaa1cde763e909867f5deb34e8c348886">xcom_set_comms_status</a> (int <a class="el" href="mysql_8cc.html#a1025e6cbbd3179d2d91b9b4afb8f8efc">status</a>)=0</td></tr>
<tr class="separator:aaa1cde763e909867f5deb34e8c348886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eef6e8aedc0e809aa71b3a6498c2db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ac6eef6e8aedc0e809aa71b3a6498c2db">xcom_signal_comms_status_changed</a> (int <a class="el" href="mysql_8cc.html#a1025e6cbbd3179d2d91b9b4afb8f8efc">status</a>)=0</td></tr>
<tr class="separator:ac6eef6e8aedc0e809aa71b3a6498c2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c453329a4627c9f3b75aa46d1395786"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a0c453329a4627c9f3b75aa46d1395786">xcom_wait_exit</a> ()=0</td></tr>
<tr class="memdesc:a0c453329a4627c9f3b75aa46d1395786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to wait for XCom to exit.  <a href="#a0c453329a4627c9f3b75aa46d1395786">More...</a><br /></td></tr>
<tr class="separator:a0c453329a4627c9f3b75aa46d1395786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cd8aeff7307945f913be18d6545c6c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a39cd8aeff7307945f913be18d6545c6c">xcom_is_exit</a> ()=0</td></tr>
<tr class="memdesc:a39cd8aeff7307945f913be18d6545c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This verifies if XCom has finished or not.  <a href="#a39cd8aeff7307945f913be18d6545c6c">More...</a><br /></td></tr>
<tr class="separator:a39cd8aeff7307945f913be18d6545c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59dfe2d2b47ee4d6aba634fd5a9e869"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#af59dfe2d2b47ee4d6aba634fd5a9e869">xcom_set_exit</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)=0</td></tr>
<tr class="memdesc:af59dfe2d2b47ee4d6aba634fd5a9e869"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets whether XCom has finished or not.  <a href="#af59dfe2d2b47ee4d6aba634fd5a9e869">More...</a><br /></td></tr>
<tr class="separator:af59dfe2d2b47ee4d6aba634fd5a9e869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105425d68a5408c04be008828fee6ab5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a105425d68a5408c04be008828fee6ab5">xcom_set_cleanup</a> ()=0</td></tr>
<tr class="memdesc:a105425d68a5408c04be008828fee6ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up variables used to notify states in the XCOM's state machine.  <a href="#a105425d68a5408c04be008828fee6ab5">More...</a><br /></td></tr>
<tr class="separator:a105425d68a5408c04be008828fee6ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a669d9b3d753dffea56373f43dde6b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a2a669d9b3d753dffea56373f43dde6b9">xcom_signal_exit</a> ()=0</td></tr>
<tr class="memdesc:a2a669d9b3d753dffea56373f43dde6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This modifies the internal cached status and signals all threads that might be waiting on xcom_wait_exit.  <a href="#a2a669d9b3d753dffea56373f43dde6b9">More...</a><br /></td></tr>
<tr class="separator:a2a669d9b3d753dffea56373f43dde6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888991e1fd62947cd2a4c0786a275166"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a888991e1fd62947cd2a4c0786a275166">xcom_client_force_config</a> (node_list *nl, uint32_t group_id)=0</td></tr>
<tr class="memdesc:a888991e1fd62947cd2a4c0786a275166"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces XCom to inject a new configuration in the group, even if it does not contain a majority of members.  <a href="#a888991e1fd62947cd2a4c0786a275166">More...</a><br /></td></tr>
<tr class="separator:a888991e1fd62947cd2a4c0786a275166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416e08cf1663dd155ca8b2fea10ce24d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a416e08cf1663dd155ca8b2fea10ce24d">xcom_boot_node</a> (<a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> &amp;node, uint32_t group_id_hash)=0</td></tr>
<tr class="memdesc:a416e08cf1663dd155ca8b2fea10ce24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to boot a node in XCOM.  <a href="#a416e08cf1663dd155ca8b2fea10ce24d">More...</a><br /></td></tr>
<tr class="separator:a416e08cf1663dd155ca8b2fea10ce24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f11b91277b6450b834a3bf5eed34a4a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a6f11b91277b6450b834a3bf5eed34a4a">xcom_remove_nodes</a> (<a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;nodes, uint32_t group_id_hash)=0</td></tr>
<tr class="memdesc:a6f11b91277b6450b834a3bf5eed34a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to remove a set of nodes from XCOM.  <a href="#a6f11b91277b6450b834a3bf5eed34a4a">More...</a><br /></td></tr>
<tr class="separator:a6f11b91277b6450b834a3bf5eed34a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872caa3bb83828c66a2965d745a460de"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a872caa3bb83828c66a2965d745a460de">xcom_remove_nodes</a> (<a class="el" href="structconnection__descriptor.html">connection_descriptor</a> &amp;con, <a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;nodes, uint32_t group_id_hash)=0</td></tr>
<tr class="memdesc:a872caa3bb83828c66a2965d745a460de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to remove a set of nodes from XCOM.  <a href="#a872caa3bb83828c66a2965d745a460de">More...</a><br /></td></tr>
<tr class="separator:a872caa3bb83828c66a2965d745a460de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3771e66b38b9b1e0c9e54beec260dec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ad3771e66b38b9b1e0c9e54beec260dec">xcom_remove_node</a> (const <a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> &amp;node, uint32_t group_id_hash)=0</td></tr>
<tr class="memdesc:ad3771e66b38b9b1e0c9e54beec260dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to remove a node from XCOM.  <a href="#ad3771e66b38b9b1e0c9e54beec260dec">More...</a><br /></td></tr>
<tr class="separator:ad3771e66b38b9b1e0c9e54beec260dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196db7b34c612e6576c3af9c8ed1c1b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a196db7b34c612e6576c3af9c8ed1c1b7">xcom_add_nodes</a> (<a class="el" href="structconnection__descriptor.html">connection_descriptor</a> &amp;con, <a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;nodes, uint32_t group_id_hash)=0</td></tr>
<tr class="memdesc:a196db7b34c612e6576c3af9c8ed1c1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a set of nodes to XCOM.  <a href="#a196db7b34c612e6576c3af9c8ed1c1b7">More...</a><br /></td></tr>
<tr class="separator:a196db7b34c612e6576c3af9c8ed1c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f81224f2a5a29633b58bdbf9db7238b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a1f81224f2a5a29633b58bdbf9db7238b">xcom_add_node</a> (<a class="el" href="structconnection__descriptor.html">connection_descriptor</a> &amp;con, const <a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> &amp;node, uint32_t group_id_hash)=0</td></tr>
<tr class="memdesc:a1f81224f2a5a29633b58bdbf9db7238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a node to XCOM.  <a href="#a1f81224f2a5a29633b58bdbf9db7238b">More...</a><br /></td></tr>
<tr class="separator:a1f81224f2a5a29633b58bdbf9db7238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58772ad4110f172e1338fd5658d26015"><td class="memItemLeft" align="right" valign="top">virtual xcom_event_horizon&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a58772ad4110f172e1338fd5658d26015">xcom_get_minimum_event_horizon</a> ()=0</td></tr>
<tr class="memdesc:a58772ad4110f172e1338fd5658d26015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve XCOM's minimum supported event horizon value.  <a href="#a58772ad4110f172e1338fd5658d26015">More...</a><br /></td></tr>
<tr class="separator:a58772ad4110f172e1338fd5658d26015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b6f82fabf723b96a48ccc64554eaf2"><td class="memItemLeft" align="right" valign="top">virtual xcom_event_horizon&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a24b6f82fabf723b96a48ccc64554eaf2">xcom_get_maximum_event_horizon</a> ()=0</td></tr>
<tr class="memdesc:a24b6f82fabf723b96a48ccc64554eaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve XCOM's maximum supported event horizon value.  <a href="#a24b6f82fabf723b96a48ccc64554eaf2">More...</a><br /></td></tr>
<tr class="separator:a24b6f82fabf723b96a48ccc64554eaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4702f5bf3c190a3aa4e3e53ccd79c986"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a4702f5bf3c190a3aa4e3e53ccd79c986">xcom_get_event_horizon</a> (uint32_t group_id_hash, xcom_event_horizon &amp;event_horizon)=0</td></tr>
<tr class="memdesc:a4702f5bf3c190a3aa4e3e53ccd79c986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve XCOM's event horizon.  <a href="#a4702f5bf3c190a3aa4e3e53ccd79c986">More...</a><br /></td></tr>
<tr class="separator:a4702f5bf3c190a3aa4e3e53ccd79c986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a190a6551a82d236bf49e4ad5343a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a60a190a6551a82d236bf49e4ad5343a4">xcom_get_synode_app_data</a> (<a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> const &amp;xcom_instance, uint32_t group_id_hash, const std::unordered_set&lt; <a class="el" href="classGcs__xcom__synode.html">Gcs_xcom_synode</a> &gt; &amp;synode_set, synode_app_data_array &amp;reply)=0</td></tr>
<tr class="memdesc:a60a190a6551a82d236bf49e4ad5343a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve the application payloads decided on a set of synodes.  <a href="#a60a190a6551a82d236bf49e4ad5343a4">More...</a><br /></td></tr>
<tr class="separator:a60a190a6551a82d236bf49e4ad5343a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d3c582f6d893f4d63b956fde947a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a576d3c582f6d893f4d63b956fde947a1">xcom_set_event_horizon</a> (uint32_t group_id_hash, xcom_event_horizon event_horizon)=0</td></tr>
<tr class="memdesc:a576d3c582f6d893f4d63b956fde947a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to reconfigure XCOM's event horizon.  <a href="#a576d3c582f6d893f4d63b956fde947a1">More...</a><br /></td></tr>
<tr class="separator:a576d3c582f6d893f4d63b956fde947a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25bc70479dc69c59b66023f33ee2595"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ad25bc70479dc69c59b66023f33ee2595">xcom_set_cache_size</a> (uint64_t size)=0</td></tr>
<tr class="memdesc:ad25bc70479dc69c59b66023f33ee2595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to reconfigure the maximum size of the XCom cache.  <a href="#ad25bc70479dc69c59b66023f33ee2595">More...</a><br /></td></tr>
<tr class="separator:ad25bc70479dc69c59b66023f33ee2595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9548f11fb9c03382179aa454e292d5db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a9548f11fb9c03382179aa454e292d5db">xcom_force_nodes</a> (<a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;nodes, unsigned int group_id_hash)=0</td></tr>
<tr class="memdesc:a9548f11fb9c03382179aa454e292d5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to force the set of nodes in XCOM's configuration.  <a href="#a9548f11fb9c03382179aa454e292d5db">More...</a><br /></td></tr>
<tr class="separator:a9548f11fb9c03382179aa454e292d5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b2edeeffa41e244b4456b9816dc6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ac72b2edeeffa41e244b4456b9816dc6f">get_should_exit</a> ()=0</td></tr>
<tr class="memdesc:ac72b2edeeffa41e244b4456b9816dc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that retrieves the value that signals that XCom must be forcefully stopped.  <a href="#ac72b2edeeffa41e244b4456b9816dc6f">More...</a><br /></td></tr>
<tr class="separator:ac72b2edeeffa41e244b4456b9816dc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2cdc46dbcdcced54631c4a281c8a4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a5b2cdc46dbcdcced54631c4a281c8a4e">set_should_exit</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> should_exit)=0</td></tr>
<tr class="memdesc:a5b2cdc46dbcdcced54631c4a281c8a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that sets the value that signals that XCom must be forcefully stopped.  <a href="#a5b2cdc46dbcdcced54631c4a281c8a4e">More...</a><br /></td></tr>
<tr class="separator:a5b2cdc46dbcdcced54631c4a281c8a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd5bc9dfc70b149ce5d90113e8f3200"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#adcd5bc9dfc70b149ce5d90113e8f3200">xcom_input_connect</a> (std::string const &amp;address, <a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a> <a class="el" href="testapp_8c.html#a466f7b109ba414c07158f07424a82f6f">port</a>)=0</td></tr>
<tr class="memdesc:adcd5bc9dfc70b149ce5d90113e8f3200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the input channel to XCom.  <a href="#adcd5bc9dfc70b149ce5d90113e8f3200">More...</a><br /></td></tr>
<tr class="separator:adcd5bc9dfc70b149ce5d90113e8f3200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d972910d7cd8e8f6902933cbed901b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a8d972910d7cd8e8f6902933cbed901b7">xcom_input_disconnect</a> ()=0</td></tr>
<tr class="memdesc:a8d972910d7cd8e8f6902933cbed901b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the input channel to XCom.  <a href="#a8d972910d7cd8e8f6902933cbed901b7">More...</a><br /></td></tr>
<tr class="separator:a8d972910d7cd8e8f6902933cbed901b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cf07a54b1cd2f9858aa6a3ceb1f0f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ac0cf07a54b1cd2f9858aa6a3ceb1f0f1">xcom_input_try_push</a> (app_data_ptr data)=0</td></tr>
<tr class="memdesc:ac0cf07a54b1cd2f9858aa6a3ceb1f0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to send the command <code>data</code> to XCom.  <a href="#ac0cf07a54b1cd2f9858aa6a3ceb1f0f1">More...</a><br /></td></tr>
<tr class="separator:ac0cf07a54b1cd2f9858aa6a3ceb1f0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff04e7ad5a57169208f3a3c20fde37b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGcs__xcom__input__queue__impl.html#a6a103c354b68ac4196cfca768c68b109">Gcs_xcom_input_queue::future_reply</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#aff04e7ad5a57169208f3a3c20fde37b7">xcom_input_try_push_and_get_reply</a> (app_data_ptr data)=0</td></tr>
<tr class="memdesc:aff04e7ad5a57169208f3a3c20fde37b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to send the command <code>data</code> to XCom, and returns a future to XCom's reply.  <a href="#aff04e7ad5a57169208f3a3c20fde37b7">More...</a><br /></td></tr>
<tr class="separator:aff04e7ad5a57169208f3a3c20fde37b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93d9f194f32ad2beaf97aca027a3287"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="xcom__input__request_8h.html#ac5e9421e9b0e4c7d26f36ce4aa225415">xcom_input_request_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#ad93d9f194f32ad2beaf97aca027a3287">xcom_input_try_pop</a> ()=0</td></tr>
<tr class="memdesc:ad93d9f194f32ad2beaf97aca027a3287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to retrieve incoming commands.  <a href="#ad93d9f194f32ad2beaf97aca027a3287">More...</a><br /></td></tr>
<tr class="separator:ad93d9f194f32ad2beaf97aca027a3287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f018161d6e79e19736197fcbdeb0f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__proxy.html#a41f018161d6e79e19736197fcbdeb0f0">test_xcom_tcp_connection</a> (std::string &amp;<a class="el" href="persisted__variable_8cc.html#ac27d1f298862a7b4c7d6b7bcc59c9ffd">host</a>, <a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a> <a class="el" href="testapp_8c.html#a466f7b109ba414c07158f07424a82f6f">port</a>)=0</td></tr>
<tr class="memdesc:a41f018161d6e79e19736197fcbdeb0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a test connection to the given XCom instance via TCP.  <a href="#a41f018161d6e79e19736197fcbdeb0f0">More...</a><br /></td></tr>
<tr class="separator:a41f018161d6e79e19736197fcbdeb0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad11e5683a8bda04920db63fc2924bc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11e5683a8bda04920db63fc2924bc37">&#9670;&nbsp;</a></span>Gcs_xcom_proxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gcs_xcom_proxy::Gcs_xcom_proxy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad6d6337be3df9ef4e15ba8565521c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6d6337be3df9ef4e15ba8565521c76">&#9670;&nbsp;</a></span>~Gcs_xcom_proxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gcs_xcom_proxy::~Gcs_xcom_proxy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae902596752c184cd1f6aac6985a46c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae902596752c184cd1f6aac6985a46c4d">&#9670;&nbsp;</a></span>delete_node_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::delete_node_address </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_address *&#160;</td>
          <td class="paramname"><em>na</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is responsible to delete the list of nodes that had been previously created by <code>new_node_address</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the length of the list </td></tr>
    <tr><td class="paramname">na</td><td>the list to delete </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ac58970a73071fb4a467c7d2d5ab72dcc">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="affad7aec77baf4c21362d3f51562ab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affad7aec77baf4c21362d3f51562ab5b">&#9670;&nbsp;</a></span>find_site_def()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsite__def.html">site_def</a> const* Gcs_xcom_proxy::find_site_def </td>
          <td>(</td>
          <td class="paramtype">synode_no&#160;</td>
          <td class="paramname"><em>synode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a60f65a30ecd57e80a9e0efa22340d376">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="ac72b2edeeffa41e244b4456b9816dc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72b2edeeffa41e244b4456b9816dc6f">&#9670;&nbsp;</a></span>get_should_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::get_should_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that retrieves the value that signals that XCom must be forcefully stopped. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if XCom needs to forcefully exit. 0 otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a079ccfdb1194c7fa1f0d109959d408f4">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a9df54bc007f77fdbd415474a954c7cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df54bc007f77fdbd415474a954c7cd7">&#9670;&nbsp;</a></span>new_node_address_uuid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual node_address* Gcs_xcom_proxy::new_node_address_uuid </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>names</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blob&#160;</td>
          <td class="paramname"><em>uuids</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an utility member function that is used to call into XCom for creating list with node's addresses and their associated UUIDs. </p>
<p>Note that callers must provide the UUID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of elements in the list </td></tr>
    <tr><td class="paramname">names</td><td>The names to be put on the list </td></tr>
    <tr><td class="paramname">uuids</td><td>The UUIDs to be put on the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the list containing all the elements needed. The caller is responsible to reclaim memory once he is done with this data <code>delete_node_address</code> </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ac7cf7662e854fdf542eb5f8ffaf52b70">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a5b2cdc46dbcdcced54631c4a281c8a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2cdc46dbcdcced54631c4a281c8a4e">&#9670;&nbsp;</a></span>set_should_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::set_should_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>should_exit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that sets the value that signals that XCom must be forcefully stopped. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a41bfe21ee0eb7c7c8d30bfc6c54f983c">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a41f018161d6e79e19736197fcbdeb0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f018161d6e79e19736197fcbdeb0f0">&#9670;&nbsp;</a></span>test_xcom_tcp_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::test_xcom_tcp_connection </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a>&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a test connection to the given XCom instance via TCP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>the XCom instance's host </td></tr>
    <tr><td class="paramname">port</td><td>the XCom instance's port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we were able to successfully connect, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a4dd766924c0c9662ef83b004c3862d01">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a1f81224f2a5a29633b58bdbf9db7238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f81224f2a5a29633b58bdbf9db7238b">&#9670;&nbsp;</a></span>xcom_add_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__descriptor.html">connection_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to add a node to XCOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>Connection to a node that will carry on the request. </td></tr>
    <tr><td class="paramname">node</td><td>Node information. </td></tr>
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of adding a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the node was added to the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a30f23d1dac36df25252fefaff6105042">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a196db7b34c612e6576c3af9c8ed1c1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196db7b34c612e6576c3af9c8ed1c1b7">&#9670;&nbsp;</a></span>xcom_add_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_add_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__descriptor.html">connection_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to add a set of nodes to XCOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>Connection to a node that will carry on the request. </td></tr>
    <tr><td class="paramname">nodes</td><td>Set of nodes. </td></tr>
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of adding a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the nodes were added to the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a607e75376c57b7050df5c6cf20969fab">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a416e08cf1663dd155ca8b2fea10ce24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416e08cf1663dd155ca8b2fea10ce24d">&#9670;&nbsp;</a></span>xcom_boot_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_boot_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to boot a node in XCOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node information. </td></tr>
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of booting. Since this is basically an asynchronous function, one needs to wait for XCom to signal it is ready to validate whether it booted. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a851cf47c4a9c5a9f526fbd57d2544b1b">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a0f2631e62f729479da7265e916454591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2631e62f729479da7265e916454591">&#9670;&nbsp;</a></span>xcom_client_add_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_list *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible to call into XCom consensus and add a node to the group. </p>
<p>The caller is responsible for ensuring that the session has been opened before <code>open_session</code> and also that the node is not yet in the configuration.</p>
<p>The callee must have opened an XCom connection before calling this function. <code>xcom_client_open_connection</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor to the XCom connection established earlier </td></tr>
    <tr><td class="paramname">nl</td><td>The node list containing the list of peers to add </td></tr>
    <tr><td class="paramname">group_id</td><td>the identifier of the group to which the nodes should be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of adding a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the node was added to the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a6a11dd66a4c59ebcbb2d44a212defe06">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="af7374347b84dda1c31952c111653c664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7374347b84dda1c31952c111653c664">&#9670;&nbsp;</a></span>xcom_client_boot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_boot </td>
          <td>(</td>
          <td class="paramtype">node_list *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function boots XCom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>List with a single member - the one that boots the group </td></tr>
    <tr><td class="paramname">group_id</td><td>the Group identifier to which the member belongs to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of booting. Since this is basically an asynchronous function, one needs to wait for XCom to signal it is ready to validate whether it booted. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a4c13ac154b3d47a39ae547b1fb5fccc8">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a647f2418553aa0384809c3b812404da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647f2418553aa0384809c3b812404da5">&#9670;&nbsp;</a></span>xcom_client_close_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_close_connection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function closes the connection to an XCom instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The connection file descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure) </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a4b8093e33c3103c9336e74628d7eea0a">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a888991e1fd62947cd2a4c0786a275166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888991e1fd62947cd2a4c0786a275166">&#9670;&nbsp;</a></span>xcom_client_force_config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_force_config </td>
          <td>(</td>
          <td class="paramtype">node_list *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method forces XCom to inject a new configuration in the group, even if it does not contain a majority of members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>The list of nodes that will belong to this new configuration </td></tr>
    <tr><td class="paramname">group_id</td><td>The identifier of the group from which the nodes will belong </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of forcing the configuration. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the configuration was forced. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a4db079917b39c6585ed3f066d61a396c">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a3ed0f3295a39f17c6450c0fa9f999059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed0f3295a39f17c6450c0fa9f999059">&#9670;&nbsp;</a></span>xcom_client_get_event_horizon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_get_event_horizon </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xcom_event_horizon &amp;&#160;</td>
          <td class="paramname"><em>event_horizon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible for retrieving the event horizon of the XCom configuration. </p>
<p>This function REQUIRES a prior call to <code>xcom_open_handlers</code> to establish a connection to XCom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>The identifier of the group from which the event horizon will be retrieved </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">event_horizon</td><td>A reference to where the group's event horizon value will be written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if successful and <code>event_horizon</code> was written to </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ae30c6d97beecc15d34172f473cef3efa">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a3564c81ccf2ce35e32e1bc78c9a0aefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3564c81ccf2ce35e32e1bc78c9a0aefa">&#9670;&nbsp;</a></span>xcom_client_get_synode_app_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_get_synode_app_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">synode_no_array &amp;&#160;</td>
          <td class="paramname"><em>synodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">synode_app_data_array &amp;&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible for retrieving the application payloads decided in the synodes in <code>synodes</code>, from the XCom instance connected to via <code>fd</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The file descriptor to the XCom connection established earlier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id</td><td>The identifier of the group from which the payloads will be retrieved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synodes</td><td>The desired synodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reply</td><td>Where the requested payloads will be written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom had the requested payloads, which were written to <code>reply</code>. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#afe56b5a26297e15fd90afdac5fb1adc3">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a33c8ef7a21cc79e54f10ba68d67210b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c8ef7a21cc79e54f10ba68d67210b2">&#9670;&nbsp;</a></span>xcom_client_open_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structconnection__descriptor.html">connection_descriptor</a>* Gcs_xcom_proxy::xcom_client_open_connection </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a>&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function opens a connection to an XCom instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The XCom instance address </td></tr>
    <tr><td class="paramname">port</td><td>The XCom instance port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid file descriptor on success, -1 otherwise </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a62b411359fce8bffbb45e17a3dc60334">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="af4d75f59fbeea6e8dc939c8c79a2f272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d75f59fbeea6e8dc939c8c79a2f272">&#9670;&nbsp;</a></span>xcom_client_remove_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_remove_node </td>
          <td>(</td>
          <td class="paramtype">node_list *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible for triggering the removal of a node from the XCom configuration. </p>
<p>This function is asynchronous, so you need to wait for the view change to actually validate that the removal was successful.</p>
<p>The caller is responsible for making sure that the server to be removed is in the group.</p>
<p>This function MUST be called after opening the local XCom session <code>xcom_input_connect</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nl</td><td>The list of nodes to remove from the group </td></tr>
    <tr><td class="paramname">group_id</td><td>The identifier of the group from which the nodes will be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of removing a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the nodes were removed from the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#aa2ba57f5679d850dfd512790b0141a10">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a69d703c136c82f9b66e7995337a422b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d703c136c82f9b66e7995337a422b2">&#9670;&nbsp;</a></span>xcom_client_remove_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__descriptor.html">connection_descriptor</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_list *&#160;</td>
          <td class="paramname"><em>nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible for triggering the removal of a node from the XCom configuration. </p>
<p>This function is asynchronous, so you need to wait for the view change to actually validate that the removal was successful.</p>
<p>The caller is responsible for making sure that the server to be removed is in the group.</p>
<p>The callee must have opened an XCom connection before calling this function. <code>xcom_client_open_connection</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor to the XCom connection established earlier </td></tr>
    <tr><td class="paramname">nl</td><td>The list of nodes to remove from the group </td></tr>
    <tr><td class="paramname">group_id</td><td>The identifier of the group from which the nodes will be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of removing a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the nodes were removed from the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a42f8ccd0e441795d66243a5736b33d4c">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="af7407911bccaa906d14c29e21c4825e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7407911bccaa906d14c29e21c4825e2">&#9670;&nbsp;</a></span>xcom_client_send_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_send_data </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible for pushing data into consensus on XCom. </p>
<p>The caller is responsible to making sure that there is an open XCom session <code>xcom_input_connect</code> and also that the server is part of the XCom configuration before sending data to it.</p>
<p><code>data</code> must have been allocated by one of the functions of the malloc family, because <code>data</code> will be passed on to XCom. XCom is implemented in C and will use <code>free</code> to dispose of <code>data</code> when it is finished with <code>data</code>.</p>
<p>This function takes ownership of <code>data</code>. This means that this function becomes responsible for the lifetime of <code>data</code>. Since this function takes ownership of <code>data</code>, the caller must not interact with <code>data</code> after passing it to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of the payload </td></tr>
    <tr><td class="paramname">data</td><td>the payload </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ad2df3bfafcd73409a8b39352d9b3a5e4">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="aba61bebd67dd7bb2a0fd730da4b5ee69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba61bebd67dd7bb2a0fd730da4b5ee69">&#9670;&nbsp;</a></span>xcom_client_set_cache_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_set_cache_size </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible for setting a new value for the maximum size of the XCom cache. </p>
<p>This function is asynchronous, so the return value indicates only whether the request to change the value was successfully pushed to XCom or not. However, since the cache size is set only for the local node, and makes no further verifications on the value, if XCom processes the request, it will accept the new value. The callers of this function must validate that the value set is within the limits set to the maximum size of the XCom cache.</p>
<p>This function REQUIRES a prior call to <code>xcom_open_handlers</code> to establish a connection to XCom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new value for the maximum size of the XCom cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#aaf4cc501d3cefc396a9762b05085cb33">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="aa93a0098f558e4af5817e2a71d3161b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93a0098f558e4af5817e2a71d3161b8">&#9670;&nbsp;</a></span>xcom_client_set_event_horizon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_client_set_event_horizon </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xcom_event_horizon&#160;</td>
          <td class="paramname"><em>event_horizon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is responsible for triggering the reconfiguration of the event horizon of the XCom configuration. </p>
<p>This function is asynchronous, so you need to poll <code>xcom_get_event_horizon</code> to actually validate that the reconfiguration was successful.</p>
<p>This function REQUIRES a prior call to <code>xcom_open_handlers</code> to establish a connection to XCom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_horizon</td><td>The desired event horizon value </td></tr>
    <tr><td class="paramname">group_id</td><td>The identifier of the group from which the nodes will be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of setting the event horizon. Since this is basically an asynchronous function, one needs to busy-wait on <code>xcom_client_get_event_horizon</code> to validate that the event horizon was modified. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#af899caf5a75cf9fb56df0506495ae642">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a524d9774f758c9eef3aeba9d8fe22a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524d9774f758c9eef3aeba9d8fe22a10">&#9670;&nbsp;</a></span>xcom_destroy_ssl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_destroy_ssl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a1de6b3682c77fde431b524767783e85e">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a55193c7c502976be3f5d17942a588c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55193c7c502976be3f5d17942a588c08">&#9670;&nbsp;</a></span>xcom_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function finishes the XCom thread. </p>
<p>This function must be called when the XCOM thread was started but the node has not joined a group.</p>
<p>There could be errors later in the process of exiting XCom. Since this is basically an asynchronous function, one needs to wait for the XCom thread to to ensure that XCom terminated. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a0f23eba67d943ce010e013d347d3e0eb">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a9548f11fb9c03382179aa454e292d5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9548f11fb9c03382179aa454e292d5db">&#9670;&nbsp;</a></span>xcom_force_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_force_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>group_id_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to force the set of nodes in XCOM's configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>Set of nodes. </td></tr>
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of forcing the configuration. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the configuration was forced. </dd></dl>

</div>
</div>
<a id="a4702f5bf3c190a3aa4e3e53ccd79c986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4702f5bf3c190a3aa4e3e53ccd79c986">&#9670;&nbsp;</a></span>xcom_get_event_horizon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_get_event_horizon </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xcom_event_horizon &amp;&#160;</td>
          <td class="paramname"><em>event_horizon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to retrieve XCOM's event horizon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">event_horizon</td><td>A reference to where the group's event horizon value will be written to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#ab74789ee038822d1e26175faaa1ef4a8">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a24b6f82fabf723b96a48ccc64554eaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b6f82fabf723b96a48ccc64554eaf2">&#9670;&nbsp;</a></span>xcom_get_maximum_event_horizon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual xcom_event_horizon Gcs_xcom_proxy::xcom_get_maximum_event_horizon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to retrieve XCOM's maximum supported event horizon value. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a4734b22b85c30c0ce34d3ba6f701969d">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a58772ad4110f172e1338fd5658d26015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58772ad4110f172e1338fd5658d26015">&#9670;&nbsp;</a></span>xcom_get_minimum_event_horizon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual xcom_event_horizon Gcs_xcom_proxy::xcom_get_minimum_event_horizon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to retrieve XCOM's minimum supported event horizon value. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a2fbc6e2873e290e5403153162ef8935a">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="ac86a293dddb5c3560a3e60cef28ca8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86a293dddb5c3560a3e60cef28ca8c5">&#9670;&nbsp;</a></span>xcom_get_ssl_fips_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Gcs_xcom_proxy::xcom_get_ssl_fips_mode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a33af054741ab5a2e6a933251ec10c949">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a47d4551e045f9f3d3b16bdedb6dbf16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d4551e045f9f3d3b16bdedb6dbf16a">&#9670;&nbsp;</a></span>xcom_get_ssl_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Gcs_xcom_proxy::xcom_get_ssl_mode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a74ef0209df4d529d2fb7a1f47a66b8cf">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a60a190a6551a82d236bf49e4ad5343a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a190a6551a82d236bf49e4ad5343a4">&#9670;&nbsp;</a></span>xcom_get_synode_app_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_get_synode_app_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> const &amp;&#160;</td>
          <td class="paramname"><em>xcom_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classGcs__xcom__synode.html">Gcs_xcom_synode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>synode_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">synode_app_data_array &amp;&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to retrieve the application payloads decided on a set of synodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xcom_instance</td><td>The XCom instance to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synode_set</td><td>The desired synodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reply</td><td>Where the requested payloads will be written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom had the requested payloads, which were written to <code>reply</code>. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a35e590256db80df2eeac68b638c4e9a5">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a2c933c4069b93eb1f7f6d9d09feb7fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c933c4069b93eb1f7f6d9d09feb7fb6">&#9670;&nbsp;</a></span>xcom_has_comms_status_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_has_comms_status_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#af3359fdfbbcd1750a27e5b3a52576e2a">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="af668b01a850ef0b9b92e0d0dfa2d32e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af668b01a850ef0b9b92e0d0dfa2d32e4">&#9670;&nbsp;</a></span>xcom_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a>&#160;</td>
          <td class="paramname"><em>listen_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function initializes XCom. </p>
<p>This function must be called before anything else and from within the XCom thread. It will eventually call the main loop inside XCom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listen_port</td><td>the port that the local XCom is to be listening on. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ab5a2633df042d824b0fbb071b1d20bdc">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a8760439210d57cda3ef4385f2cb49f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8760439210d57cda3ef4385f2cb49f37">&#9670;&nbsp;</a></span>xcom_init_ssl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_init_ssl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the SSL. </p>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure) </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a8241df9b4d192574b24553ffe47b99f6">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="adcd5bc9dfc70b149ce5d90113e8f3200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd5bc9dfc70b149ce5d90113e8f3200">&#9670;&nbsp;</a></span>xcom_input_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_input_connect </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xcom__common_8h.html#a5eeb96a2f7ff513eaf7833042e08a28c">xcom_port</a>&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens the input channel to XCom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>port to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if successful </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a4aad9c13a3139bd8f9f7ff73fbf0bf77">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a8d972910d7cd8e8f6902933cbed901b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d972910d7cd8e8f6902933cbed901b7">&#9670;&nbsp;</a></span>xcom_input_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_input_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the input channel to XCom. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a774a80f3c9a0795bd13ff392503ba3fc">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="ad93d9f194f32ad2beaf97aca027a3287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93d9f194f32ad2beaf97aca027a3287">&#9670;&nbsp;</a></span>xcom_input_try_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="xcom__input__request_8h.html#ac5e9421e9b0e4c7d26f36ce4aa225415">xcom_input_request_ptr</a> Gcs_xcom_proxy::xcom_input_try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to retrieve incoming commands. </p>
<p>(Called by XCom.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input channel to XCom is open, i.e. <code>xcom_input_connect</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">app_data_ptr</td><td>linked list of the queued comamnds if the queue is not empty </td></tr>
    <tr><td class="paramname">nullptr</td><td>if the queue is empty </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a7a1de1b4f07f37ab7e08cf979ed2bd0c">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="ac0cf07a54b1cd2f9858aa6a3ceb1f0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cf07a54b1cd2f9858aa6a3ceb1f0f1">&#9670;&nbsp;</a></span>xcom_input_try_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_input_try_push </td>
          <td>(</td>
          <td class="paramtype">app_data_ptr&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to send the command <code>data</code> to XCom. </p>
<p>(Called by GCS.)</p>
<p>The function takes ownership of <code>data</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input channel to XCom is open, i.e. <code>xcom_input_connect</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the command to send to XCom </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the command was sent to XCom </td></tr>
    <tr><td class="paramname">false</td><td>if the command was not sent to XCom </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a665eff270c5ec350b5166a9a08053b77">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="aff04e7ad5a57169208f3a3c20fde37b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff04e7ad5a57169208f3a3c20fde37b7">&#9670;&nbsp;</a></span>xcom_input_try_push_and_get_reply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGcs__xcom__input__queue__impl.html#a6a103c354b68ac4196cfca768c68b109">Gcs_xcom_input_queue::future_reply</a> Gcs_xcom_proxy::xcom_input_try_push_and_get_reply </td>
          <td>(</td>
          <td class="paramtype">app_data_ptr&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to send the command <code>data</code> to XCom, and returns a future to XCom's reply. </p>
<p>(Called by GCS.)</p>
<p>The function takes ownership of <code>data</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input channel to XCom is open, i.e. <code>xcom_input_connect</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the command to send to XCom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future pointer to a Reply object if successful, a future pointer to nullptr otherwise </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a8b96e6a6a2ad04efa0f8dc5fe1ddf402">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a39cd8aeff7307945f913be18d6545c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cd8aeff7307945f913be18d6545c6c">&#9670;&nbsp;</a></span>xcom_is_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_is_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This verifies if XCom has finished or not. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a3d01ec8e2161b8376bbe15497c1d1b2c">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="aeb1af550cd06d384925f0848f443c298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1af550cd06d384925f0848f443c298">&#9670;&nbsp;</a></span>xcom_is_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_is_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ac5e7e706be683d4c820a23c3fe8f2956">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="ad3771e66b38b9b1e0c9e54beec260dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3771e66b38b9b1e0c9e54beec260dec">&#9670;&nbsp;</a></span>xcom_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGcs__xcom__node__information.html">Gcs_xcom_node_information</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to remove a node from XCOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node information. </td></tr>
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of removing a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the node was removed from the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a99627709653bef5af2d42e6a907b8f47">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a6f11b91277b6450b834a3bf5eed34a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f11b91277b6450b834a3bf5eed34a4a">&#9670;&nbsp;</a></span>xcom_remove_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_remove_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to remove a set of nodes from XCOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>Set of nodes. </td></tr>
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of removing a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the nodes were removed from the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a801734de80592f48b6749184cfba19d1">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a872caa3bb83828c66a2965d745a460de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872caa3bb83828c66a2965d745a460de">&#9670;&nbsp;</a></span>xcom_remove_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_remove_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structconnection__descriptor.html">connection_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to remove a set of nodes from XCOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>Connection to a node that will carry on the request. </td></tr>
    <tr><td class="paramname">nodes</td><td>Set of nodes to remove. </td></tr>
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (false) on success (failure). Success means that XCom will process our request, failure means it wont. There could be errors later in the process of removing a node. Since this is basically an asynchronous function, one needs to wait for the actual view change to validate that the nodes were removed from the configuration. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a1f7535fd8f76480ae49d895b785748ac">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="ad25bc70479dc69c59b66023f33ee2595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25bc70479dc69c59b66023f33ee2595">&#9670;&nbsp;</a></span>xcom_set_cache_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_set_cache_size </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to reconfigure the maximum size of the XCom cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Cache size limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operation is successfully pushed to XCom's queue, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a92a37da3a9f4a555d0af3b356816e1d0">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="a105425d68a5408c04be008828fee6ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105425d68a5408c04be008828fee6ab5">&#9670;&nbsp;</a></span>xcom_set_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_set_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up variables used to notify states in the XCOM's state machine. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a498d2318985ec6987c39a2a7aa9c6b11">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="aaa1cde763e909867f5deb34e8c348886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1cde763e909867f5deb34e8c348886">&#9670;&nbsp;</a></span>xcom_set_comms_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_set_comms_status </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a2942cc7753ae38ed4618ee5509517b6a">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a576d3c582f6d893f4d63b956fde947a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576d3c582f6d893f4d63b956fde947a1">&#9670;&nbsp;</a></span>xcom_set_event_horizon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_set_event_horizon </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_id_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xcom_event_horizon&#160;</td>
          <td class="paramname"><em>event_horizon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to reconfigure XCOM's event horizon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_id_hash</td><td>Hash of group identifier. </td></tr>
    <tr><td class="paramname">event_horizon</td><td>Desired event horizon value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__base.html#a89fe23cbce5b1b3c853189dacd484b30">Gcs_xcom_proxy_base</a>.</p>

</div>
</div>
<a id="af59dfe2d2b47ee4d6aba634fd5a9e869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59dfe2d2b47ee4d6aba634fd5a9e869">&#9670;&nbsp;</a></span>xcom_set_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_set_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sets whether XCom has finished or not. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a71d5e53a5151a4285802eda519ccfdc6">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a1114bb201f5ef0dbb8e596d96e079918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1114bb201f5ef0dbb8e596d96e079918">&#9670;&nbsp;</a></span>xcom_set_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_set_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a70e6c53a258ba6e97a5fbee8f9739829">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="aaf99c0e2d0645a58ad6a425166e97bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf99c0e2d0645a58ad6a425166e97bb6">&#9670;&nbsp;</a></span>xcom_set_ssl_fips_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Gcs_xcom_proxy::xcom_set_ssl_fips_mode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#af6eb7d358011ac017e4b0da539bce4d9">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a3ff3ff1adcda3c32ba8bb0af5a11a2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff3ff1adcda3c32ba8bb0af5a11a2ee">&#9670;&nbsp;</a></span>xcom_set_ssl_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Gcs_xcom_proxy::xcom_set_ssl_mode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ab0504dd7c2f7db40e78fce60812c3424">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="ac723bf262dafe0e3540176abf512d4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac723bf262dafe0e3540176abf512d4af">&#9670;&nbsp;</a></span>xcom_set_ssl_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_set_ssl_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGcs__xcom__proxy_1_1ssl__parameters.html">ssl_parameters</a>&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGcs__xcom__proxy_1_1tls__parameters.html">tls_parameters</a>&#160;</td>
          <td class="paramname"><em>tls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a6cdfc2c9dbb75809ceda32ee87685904">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="ac6eef6e8aedc0e809aa71b3a6498c2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eef6e8aedc0e809aa71b3a6498c2db">&#9670;&nbsp;</a></span>xcom_signal_comms_status_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_signal_comms_status_changed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#ac03bd9b6dcfdf25092eb030a9c330a66">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a2a669d9b3d753dffea56373f43dde6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a669d9b3d753dffea56373f43dde6b9">&#9670;&nbsp;</a></span>xcom_signal_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_signal_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This modifies the internal cached status and signals all threads that might be waiting on xcom_wait_exit. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a0408b9e74feb84f49d35a36b734697be">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a88e481bb1e383c624c0cff1ccb5b16e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e481bb1e383c624c0cff1ccb5b16e8">&#9670;&nbsp;</a></span>xcom_signal_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_signal_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a9b2e2de984f61849f66047d585553cdb">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="af867420fa5e3f73964946a74d4d56488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af867420fa5e3f73964946a74d4d56488">&#9670;&nbsp;</a></span>xcom_use_ssl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_proxy::xcom_use_ssl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the SSL will be used to encrypt data or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true (false) if XCom will (not) use SSL </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a7305d53287af26f23281c6871aabe939">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a0c453329a4627c9f3b75aa46d1395786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c453329a4627c9f3b75aa46d1395786">&#9670;&nbsp;</a></span>xcom_wait_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a> Gcs_xcom_proxy::xcom_wait_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method to wait for XCom to exit. </p>
<p>Call this method to wait for XCom to exit. It will block until XCom has exit or an error occurs.</p>
<dl class="section return"><dt>Returns</dt><dd>GCS_OK if success, otherwise GCS_NOK. </dd></dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a476e2313285f35f25ef17e9d80e7d94c">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="a34e26410f42506cc1ebcb7c78ccfd8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e26410f42506cc1ebcb7c78ccfd8aa">&#9670;&nbsp;</a></span>xcom_wait_for_xcom_comms_status_change()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gcs_xcom_proxy::xcom_wait_for_xcom_comms_status_change </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method to wait for XCom communications to be initialized. </p>
<p>Call this method to wait for XCom communications to be initialized. It will block until XCom communications are either OK or error out. The value of the status (XCOM_COMMS_OK or XCOM_COMMS_ERROR) is written into the status out parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>value of the XCom communication layer status. It can be either XCOM_COMMS_OK or XCOM_COMMS_ERROR </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a5a4852ff474d21e168d3b4a7b54ba0bf">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<a id="aa0f04678f3d75d728539ee46531a7a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f04678f3d75d728539ee46531a7a15">&#9670;&nbsp;</a></span>xcom_wait_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="gcs__types_8h.html#a64e52fec9923a278cc027dd12cb53121">enum_gcs_error</a> Gcs_xcom_proxy::xcom_wait_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member waits for XCom to be initialized. </p>

<p>Implemented in <a class="el" href="classGcs__xcom__proxy__impl.html#a24e4e9d726decb4e4320c421bfecf6eb">Gcs_xcom_proxy_impl</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>plugin/group_replication/libmysqlgcs/src/bindings/xcom/<a class="el" href="gcs__xcom__proxy_8h_source.html">gcs_xcom_proxy.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classGcs__xcom__proxy.html">Gcs_xcom_proxy</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
