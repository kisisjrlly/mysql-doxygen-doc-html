<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/lock/lock0wait.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lock0wait_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lock0wait.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The transaction lock system.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="service__thd__wait_8h_source.html">mysql/service_thd_wait.h</a>&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0priv_8h_source.html">lock0priv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0thread-create_8h_source.html">os0thread-create.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A snapshot of information about a single slot which was in use at the moment of taking the snapshot.  <a href="structwaiting__trx__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a390c44e3d017379682adbfa150f2c631"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a390c44e3d017379682adbfa150f2c631">LOCK_MODULE_IMPLEMENTATION</a></td></tr>
<tr class="separator:a390c44e3d017379682adbfa150f2c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84fab6fdaf6aa9752239617c53eb0868"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a84fab6fdaf6aa9752239617c53eb0868">lock_wait_table_print</a> (void)</td></tr>
<tr class="memdesc:a84fab6fdaf6aa9752239617c53eb0868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the lock_sys_t::waiting_threads array.  <a href="#a84fab6fdaf6aa9752239617c53eb0868">More...</a><br /></td></tr>
<tr class="separator:a84fab6fdaf6aa9752239617c53eb0868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27dbbe515cb4e94068d9ccddc46faa7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#af27dbbe515cb4e94068d9ccddc46faa7">lock_wait_table_release_slot</a> (<a class="el" href="structsrv__slot__t.html">srv_slot_t</a> *slot)</td></tr>
<tr class="memdesc:af27dbbe515cb4e94068d9ccddc46faa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a slot in the lock_sys_t::waiting_threads.  <a href="#af27dbbe515cb4e94068d9ccddc46faa7">More...</a><br /></td></tr>
<tr class="separator:af27dbbe515cb4e94068d9ccddc46faa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae13697fd14a07ff1d7a546aa94601d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structsrv__slot__t.html">srv_slot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a4ae13697fd14a07ff1d7a546aa94601d">lock_wait_table_reserve_slot</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> wait_timeout)</td></tr>
<tr class="memdesc:a4ae13697fd14a07ff1d7a546aa94601d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves a slot in the thread table for the current user OS thread.  <a href="#a4ae13697fd14a07ff1d7a546aa94601d">More...</a><br /></td></tr>
<tr class="separator:a4ae13697fd14a07ff1d7a546aa94601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791dd54f6bbed78c9fc0f94c454f18da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a791dd54f6bbed78c9fc0f94c454f18da">lock_wait_request_check_for_cycles</a> ()</td></tr>
<tr class="memdesc:a791dd54f6bbed78c9fc0f94c454f18da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the thread which analyzes wait-for-graph that there was at least one new edge added or modified ( trx-&gt;blocking_trx has changed ), so that the thread will know it has to analyze it.  <a href="#a791dd54f6bbed78c9fc0f94c454f18da">More...</a><br /></td></tr>
<tr class="separator:a791dd54f6bbed78c9fc0f94c454f18da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef9abc31e16983f141559c65f7582d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#ae4ef9abc31e16983f141559c65f7582d">lock_wait_suspend_thread</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ae4ef9abc31e16983f141559c65f7582d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a user OS thread to wait for a lock to be released.  <a href="#ae4ef9abc31e16983f141559c65f7582d">More...</a><br /></td></tr>
<tr class="separator:ae4ef9abc31e16983f141559c65f7582d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baeed3d2175d88f21d37128c1b57e32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a3baeed3d2175d88f21d37128c1b57e32">lock_wait_release_thread_if_suspended</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a3baeed3d2175d88f21d37128c1b57e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a user OS thread waiting for a lock to be released, if the thread is already suspended.  <a href="#a3baeed3d2175d88f21d37128c1b57e32">More...</a><br /></td></tr>
<tr class="separator:a3baeed3d2175d88f21d37128c1b57e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ad945a2410b29af7752e94ffa30ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a28ad945a2410b29af7752e94ffa30ae6">lock_reset_wait_and_release_thread_if_suspended</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a28ad945a2410b29af7752e94ffa30ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a wrapper around several functions which need to be called in particular order to wake up a transaction waiting for a lock.  <a href="#a28ad945a2410b29af7752e94ffa30ae6">More...</a><br /></td></tr>
<tr class="separator:a28ad945a2410b29af7752e94ffa30ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b54ea9aaa53f5f623bd5979437cb8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#aea8b54ea9aaa53f5f623bd5979437cb8">lock_wait_check_and_cancel</a> (const <a class="el" href="structsrv__slot__t.html">srv_slot_t</a> *slot)</td></tr>
<tr class="memdesc:aea8b54ea9aaa53f5f623bd5979437cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the thread lock wait has timed out.  <a href="#aea8b54ea9aaa53f5f623bd5979437cb8">More...</a><br /></td></tr>
<tr class="separator:aea8b54ea9aaa53f5f623bd5979437cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dadd7cdbddf344153403cd53d923258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a4dadd7cdbddf344153403cd53d923258">operator&lt;</a> (const <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &amp;a, const <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &amp;b)</td></tr>
<tr class="memdesc:a4dadd7cdbddf344153403cd53d923258"><td class="mdescLeft">&#160;</td><td class="mdescRight">As we want to quickly find a given trx_t within the snapshot, we use a sorting criterion which is based on trx only.  <a href="#a4dadd7cdbddf344153403cd53d923258">More...</a><br /></td></tr>
<tr class="separator:a4dadd7cdbddf344153403cd53d923258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12287cdbcac42eca4b992e9d6cbdc98"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#af12287cdbcac42eca4b992e9d6cbdc98">lock_wait_check_slots_for_timeouts</a> ()</td></tr>
<tr class="memdesc:af12287cdbcac42eca4b992e9d6cbdc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check all slots for user threads that are waiting on locks, and if they have exceeded the time limit.  <a href="#af12287cdbcac42eca4b992e9d6cbdc98">More...</a><br /></td></tr>
<tr class="separator:af12287cdbcac42eca4b992e9d6cbdc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19ce13e638057751b819dbc59cd661b"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#ad19ce13e638057751b819dbc59cd661b">lock_wait_snapshot_waiting_threads</a> (<a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:ad19ce13e638057751b819dbc59cd661b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a snapshot of the content of slots which are in use.  <a href="#ad19ce13e638057751b819dbc59cd661b">More...</a><br /></td></tr>
<tr class="separator:ad19ce13e638057751b819dbc59cd661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c4a13e74c824050239ca11d3792232"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a42c4a13e74c824050239ca11d3792232">lock_wait_compute_initial_weights</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, const uint64_t table_reservations, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights)</td></tr>
<tr class="memdesc:a42c4a13e74c824050239ca11d3792232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to initialize schedule weights of nodes in wait-for-graph for the computation.  <a href="#a42c4a13e74c824050239ca11d3792232">More...</a><br /></td></tr>
<tr class="separator:a42c4a13e74c824050239ca11d3792232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a295a2b859542daa04e06422ac4993"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a17a295a2b859542daa04e06422ac4993">lock_wait_build_wait_for_graph</a> (<a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;outgoing)</td></tr>
<tr class="memdesc:a17a295a2b859542daa04e06422ac4993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes content of the snapshot with information about slots in use, and builds a (subset of) list of edges from waiting transactions to blocking transactions, such that for each waiter we have one outgoing edge.  <a href="#a17a295a2b859542daa04e06422ac4993">More...</a><br /></td></tr>
<tr class="separator:a17a295a2b859542daa04e06422ac4993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b57d21d502607a49400532cb5e61fe7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a2b57d21d502607a49400532cb5e61fe7">lock_wait_rollback_deadlock_victim</a> (<a class="el" href="structtrx__t.html">trx_t</a> *chosen_victim)</td></tr>
<tr class="memdesc:a2b57d21d502607a49400532cb5e61fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the chosen_victim that it should roll back.  <a href="#a2b57d21d502607a49400532cb5e61fe7">More...</a><br /></td></tr>
<tr class="separator:a2b57d21d502607a49400532cb5e61fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b6354f337961fa65338098a9fa4a05"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#ac0b6354f337961fa65338098a9fa4a05">lock_wait_find_latest_pos_on_cycle</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:ac0b6354f337961fa65338098a9fa4a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code>infos</code> about transactions and indexes in <code>infos</code> which form a deadlock cycle, identifies the transaction with the largest <code>reservation_no</code>, that is the one which was the latest to join the cycle.  <a href="#ac0b6354f337961fa65338098a9fa4a05">More...</a><br /></td></tr>
<tr class="separator:ac0b6354f337961fa65338098a9fa4a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338719dbcfbd12968b1f999b83b8eb0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a338719dbcfbd12968b1f999b83b8eb0b">lock_wait_rotate_so_pos_is_first</a> (size_t first_pos, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids)</td></tr>
<tr class="memdesc:a338719dbcfbd12968b1f999b83b8eb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the deadlock cycle so that it starts from desired item.  <a href="#a338719dbcfbd12968b1f999b83b8eb0b">More...</a><br /></td></tr>
<tr class="separator:a338719dbcfbd12968b1f999b83b8eb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7031c19a856c3ab0ea4bbeccde725659"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7031c19a856c3ab0ea4bbeccde725659"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a7031c19a856c3ab0ea4bbeccde725659">lock_wait_map_ids_to_trxs</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:a7031c19a856c3ab0ea4bbeccde725659"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper, which extracts transactions with given indexes from the <code>infos</code> array.  <a href="#a7031c19a856c3ab0ea4bbeccde725659">More...</a><br /></td></tr>
<tr class="separator:a7031c19a856c3ab0ea4bbeccde725659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0850191c063448a7798002971b7d04"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structtrx__t.html">trx_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#aed0850191c063448a7798002971b7d04">lock_wait_order_for_choosing_victim</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:aed0850191c063448a7798002971b7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders the transactions from deadlock cycle in such a backward-compatible way, from the point of view of algorithm with picks the victim.  <a href="#aed0850191c063448a7798002971b7d04">More...</a><br /></td></tr>
<tr class="separator:aed0850191c063448a7798002971b7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ca81a261c58b377696419cf0744d6d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a90ca81a261c58b377696419cf0744d6d">lock_wait_add_subtree_weight</a> (<a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights, const size_t parent_id, const size_t child_id)</td></tr>
<tr class="memdesc:a90ca81a261c58b377696419cf0744d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs new_weights[parent_id] += new_weights[child_id] with sanity checks.  <a href="#a90ca81a261c58b377696419cf0744d6d">More...</a><br /></td></tr>
<tr class="separator:a90ca81a261c58b377696419cf0744d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edc071eb81b158ac2f73820668473fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a9edc071eb81b158ac2f73820668473fc">lock_wait_accumulate_weights</a> (<a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;incoming_count, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;outgoing)</td></tr>
<tr class="memdesc:a9edc071eb81b158ac2f73820668473fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a graph with at most one outgoing edge per node, and initial weight for each node, this function will compute for each node a partial sum of initial weights of the node and all nodes that can reach it in the graph.  <a href="#a9edc071eb81b158ac2f73820668473fc">More...</a><br /></td></tr>
<tr class="separator:a9edc071eb81b158ac2f73820668473fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457409fcb892f8229fcc59f4a8cd47d9"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structsrv__slot__t.html">srv_slot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a457409fcb892f8229fcc59f4a8cd47d9">lock_wait_get_slot_if_still_reserved</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, const size_t <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>)</td></tr>
<tr class="memdesc:a457409fcb892f8229fcc59f4a8cd47d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if info[id].slot is still in use and has not been freed and reserved again since we took the info snapshot ("ABA" type of race condition).  <a href="#a457409fcb892f8229fcc59f4a8cd47d9">More...</a><br /></td></tr>
<tr class="separator:a457409fcb892f8229fcc59f4a8cd47d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b88c45a56387d6603310f17a45354af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a8b88c45a56387d6603310f17a45354af">lock_wait_publish_new_weights</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;is_on_cycle, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights)</td></tr>
<tr class="memdesc:a8b88c45a56387d6603310f17a45354af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the newly computed schedule weights to the transactions fields.  <a href="#a8b88c45a56387d6603310f17a45354af">More...</a><br /></td></tr>
<tr class="separator:a8b88c45a56387d6603310f17a45354af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232bff112733db6018120480a04251f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a232bff112733db6018120480a04251f0">lock_wait_choose_victim</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:a232bff112733db6018120480a04251f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, picks the transaction to rollback.  <a href="#a232bff112733db6018120480a04251f0">More...</a><br /></td></tr>
<tr class="separator:a232bff112733db6018120480a04251f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa2d5ebd83a77df656600aea2bfdaa2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#aafa2d5ebd83a77df656600aea2bfdaa2">lock_wait_trxs_are_still_in_slots</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:aafa2d5ebd83a77df656600aea2bfdaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, checks if the transactions allegedly forming the deadlock have actually stayed in slots since we've last checked, as opposed to say, not leaving a slot, and/or re-entering the slot ("ABA" situation).  <a href="#aafa2d5ebd83a77df656600aea2bfdaa2">More...</a><br /></td></tr>
<tr class="separator:aafa2d5ebd83a77df656600aea2bfdaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ed4d74f30b04a3b725afadbfb2c34a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a57ed4d74f30b04a3b725afadbfb2c34a">lock_wait_trxs_are_still_waiting</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:a57ed4d74f30b04a3b725afadbfb2c34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, checks if the transactions allegedly forming the deadlock have actually still wait for a lock, as opposed to being already notified about lock being granted or timeout, but still being present in the slot.  <a href="#a57ed4d74f30b04a3b725afadbfb2c34a">More...</a><br /></td></tr>
<tr class="separator:a57ed4d74f30b04a3b725afadbfb2c34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5dbb2f4532bfe27275d612574ffb4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a0c5dbb2f4532bfe27275d612574ffb4e">lock_wait_rotate_cycle_ids_for_notification</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="separator:a0c5dbb2f4532bfe27275d612574ffb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7249118f406050e30c72a62b8be1bc33"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a7249118f406050e30c72a62b8be1bc33">lock_wait_rotate_cycle_ids_to_so_trx_is_first</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:a7249118f406050e30c72a62b8be1bc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function which rotates the deadlock cycle, so that the specified trx is the first one on the cycle.  <a href="#a7249118f406050e30c72a62b8be1bc33">More...</a><br /></td></tr>
<tr class="separator:a7249118f406050e30c72a62b8be1bc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77cb096185f824eeb4be5c4af5a0d07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#ae77cb096185f824eeb4be5c4af5a0d07">lock_wait_update_weights_on_cycle</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *chosen_victim, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights)</td></tr>
<tr class="memdesc:ae77cb096185f824eeb4be5c4af5a0d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the computation of new schedule weights, by providing missing information about transactions located on a deadlock cycle.  <a href="#ae77cb096185f824eeb4be5c4af5a0d07">More...</a><br /></td></tr>
<tr class="separator:ae77cb096185f824eeb4be5c4af5a0d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3adffc8b48e7521cf526fa97e67ce53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; const <a class="el" href="structtrx__t.html">trx_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#aa3adffc8b48e7521cf526fa97e67ce53">lock_wait_trxs_rotated_for_notification</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos)</td></tr>
<tr class="memdesc:aa3adffc8b48e7521cf526fa97e67ce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function which rotates the deadlock cycle, so that the order of transactions in it is suitable for notification.  <a href="#aa3adffc8b48e7521cf526fa97e67ce53">More...</a><br /></td></tr>
<tr class="separator:aa3adffc8b48e7521cf526fa97e67ce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da41865c8d9c5ac68a9aa1e98a3155e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a2da41865c8d9c5ac68a9aa1e98a3155e">lock_wait_handle_deadlock</a> (<a class="el" href="structtrx__t.html">trx_t</a> *chosen_victim, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights)</td></tr>
<tr class="memdesc:a2da41865c8d9c5ac68a9aa1e98a3155e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a deadlock found, by notifying about it, rolling back the chosen victim and updating schedule weights of transactions on the deadlock cycle.  <a href="#a2da41865c8d9c5ac68a9aa1e98a3155e">More...</a><br /></td></tr>
<tr class="separator:a2da41865c8d9c5ac68a9aa1e98a3155e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e0981f86842eeb9174ad70dcc10857"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a78e0981f86842eeb9174ad70dcc10857">lock_wait_check_candidate_cycle</a> (<a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights)</td></tr>
<tr class="memdesc:a78e0981f86842eeb9174ad70dcc10857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, checks if the transactions allegedly forming the deadlock cycle, indeed are still waiting, and if so, chooses a victim and handles the deadlock.  <a href="#a78e0981f86842eeb9174ad70dcc10857">More...</a><br /></td></tr>
<tr class="separator:a78e0981f86842eeb9174ad70dcc10857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f404da347a74d7a62a6573eef88d30a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a8f404da347a74d7a62a6573eef88d30a">lock_wait_extract_cycle_ids</a> (<a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;cycle_ids, const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;outgoing)</td></tr>
<tr class="memdesc:a8f404da347a74d7a62a6573eef88d30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list of <code>cycle_ids</code> by following <code>outgoing</code> edges from the <code>start</code>.  <a href="#a8f404da347a74d7a62a6573eef88d30a">More...</a><br /></td></tr>
<tr class="separator:a8f404da347a74d7a62a6573eef88d30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b4812f489c2c15845b401927ac79a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#ab1b4812f489c2c15845b401927ac79a7">lock_wait_find_and_handle_deadlocks</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;outgoing, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights)</td></tr>
<tr class="memdesc:ab1b4812f489c2c15845b401927ac79a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that <code>infos</code> contains information about all waiting transactions, and <code>outgoing[i]</code> is the endpoint of wait-for edge going out of infos[i].trx, or -1 if the transaction is not waiting, it identifies and handles all cycles in the wait-for graph.  <a href="#ab1b4812f489c2c15845b401927ac79a7">More...</a><br /></td></tr>
<tr class="separator:ab1b4812f489c2c15845b401927ac79a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee77ab45d8befa5cf02432d7392e8b07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#aee77ab45d8befa5cf02432d7392e8b07">lock_wait_compute_incoming_count</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;outgoing, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;incoming_count)</td></tr>
<tr class="memdesc:aee77ab45d8befa5cf02432d7392e8b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of incoming edges for each node of a given graph, in which each node has zero or one outgoing edge.  <a href="#aee77ab45d8befa5cf02432d7392e8b07">More...</a><br /></td></tr>
<tr class="separator:aee77ab45d8befa5cf02432d7392e8b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454e860fe8e3f9502c148f5da810da66"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a454e860fe8e3f9502c148f5da810da66">lock_wait_compute_and_publish_weights_except_cycles</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;infos, const uint64_t table_reservations, const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;outgoing, <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;new_weights)</td></tr>
<tr class="memdesc:a454e860fe8e3f9502c148f5da810da66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code>infos</code> snapshot about transactions, the value of lock_wait_table_reservations before taking the snapshot and the edges of the wait-for-graph relation between the transactions in the snapshot, computes the schedule weight for each transaction, which is the sum of initial weight of the transaction and all transactions that are blocked by it.  <a href="#a454e860fe8e3f9502c148f5da810da66">More...</a><br /></td></tr>
<tr class="separator:a454e860fe8e3f9502c148f5da810da66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31b56de0481a893677edddfdc690a67"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#ac31b56de0481a893677edddfdc690a67">lock_wait_update_schedule_and_check_for_deadlocks</a> ()</td></tr>
<tr class="memdesc:ac31b56de0481a893677edddfdc690a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a snapshot of transactions in waiting currently in slots, updates their schedule weights, searches for deadlocks among them and resolves them.  <a href="#ac31b56de0481a893677edddfdc690a67">More...</a><br /></td></tr>
<tr class="separator:ac31b56de0481a893677edddfdc690a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b7ab612695ece320a4731a8f69e8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a82b7ab612695ece320a4731a8f69e8cb">lock_wait_timeout_thread</a> ()</td></tr>
<tr class="memdesc:a82b7ab612695ece320a4731a8f69e8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread which wakes up threads whose lock wait may have lasted too long, analyzes wait-for-graph changes, checks for deadlocks and resolves them, and updates schedule weights.  <a href="#a82b7ab612695ece320a4731a8f69e8cb">More...</a><br /></td></tr>
<tr class="separator:a82b7ab612695ece320a4731a8f69e8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8c1aae5a72412d8f54c1231d63d8acd0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0wait_8cc.html#a8c1aae5a72412d8f54c1231d63d8acd0">lock_wait_table_reservations</a> = 0</td></tr>
<tr class="memdesc:a8c1aae5a72412d8f54c1231d63d8acd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of calls to lock_wait_table_reserve_slot.  <a href="#a8c1aae5a72412d8f54c1231d63d8acd0">More...</a><br /></td></tr>
<tr class="separator:a8c1aae5a72412d8f54c1231d63d8acd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The transaction lock system. </p>
<p>Created 25/5/2010 Sunny Bains </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a390c44e3d017379682adbfa150f2c631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390c44e3d017379682adbfa150f2c631">&#9670;&nbsp;</a></span>LOCK_MODULE_IMPLEMENTATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_MODULE_IMPLEMENTATION</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a28ad945a2410b29af7752e94ffa30ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ad945a2410b29af7752e94ffa30ae6">&#9670;&nbsp;</a></span>lock_reset_wait_and_release_thread_if_suspended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_reset_wait_and_release_thread_if_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a wrapper around several functions which need to be called in particular order to wake up a transaction waiting for a lock. </p>
<p>You should not call lock_wait_release_thread_if_suspended(thr) directly, but rather use this wrapper, as this makes it much easier to reason about all possible states in which lock, trx, and thr can be. It makes sure that trx is woken up exactly once, and only if it already went to sleep. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>The lock for which lock-&gt;trx is waiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9edc071eb81b158ac2f73820668473fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edc071eb81b158ac2f73820668473fc">&#9670;&nbsp;</a></span>lock_wait_accumulate_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_accumulate_weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>incoming_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a graph with at most one outgoing edge per node, and initial weight for each node, this function will compute for each node a partial sum of initial weights of the node and all nodes that can reach it in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">incoming_count</td><td>The value of incoming_count[id] should match the number of edges incoming to the node id. In other words |x : outgoing[x] == id|. This function will modify entries in this array, so that after the call, nodes on cycles will have value 1, and others will have 0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_weights</td><td>Should contain initial weight for each node. This function will modify entries for nodes which are not on cycles, so that new_weights[id] will be the sum of initial weights of the node <code>id</code> and all nodes that can reach it by one or more outgoing[] edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outgoing</td><td>The ids of edge endpoints. If outgoing[id] == -1, then there is no edge going out of id, otherwise there is an edge from id to outgoing[id]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ca81a261c58b377696419cf0744d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ca81a261c58b377696419cf0744d6d">&#9670;&nbsp;</a></span>lock_wait_add_subtree_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_add_subtree_weight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>child_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs new_weights[parent_id] += new_weights[child_id] with sanity checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_weights</td><td>schedule weights of transactions initialized and perhaps partially accumulated already. This function will modify new_weights[parent_id] by adding new_weights[child_id] to it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_id</td><td>index of the node to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child_id</td><td>index of the node which weight should be added to the parent's weight. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17a295a2b859542daa04e06422ac4993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a295a2b859542daa04e06422ac4993">&#9670;&nbsp;</a></span>lock_wait_build_wait_for_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_build_wait_for_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyzes content of the snapshot with information about slots in use, and builds a (subset of) list of edges from waiting transactions to blocking transactions, such that for each waiter we have one outgoing edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outgoing</td><td>The outgoing[from] will contain either the index such that infos[outgoing[from]].trx is the reason infos[from].trx has to wait, or -1 if the reason for waiting is not among transactions in infos[].trx. </td></tr>
  </table>
  </dd>
</dl>
<p>We are going to use int and uint to store positions within infos </p>

</div>
</div>
<a id="aea8b54ea9aaa53f5f623bd5979437cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8b54ea9aaa53f5f623bd5979437cb8">&#9670;&nbsp;</a></span>lock_wait_check_and_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_check_and_cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsrv__slot__t.html">srv_slot_t</a> *&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the thread lock wait has timed out. </p>
<p>Release its locks if the wait has actually timed out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>in: slot reserved by a user thread when the wait started </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78e0981f86842eeb9174ad70dcc10857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e0981f86842eeb9174ad70dcc10857">&#9670;&nbsp;</a></span>lock_wait_check_candidate_cycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_wait_check_candidate_cycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, checks if the transactions allegedly forming the deadlock cycle, indeed are still waiting, and if so, chooses a victim and handles the deadlock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_weights</td><td>schedule weights of transactions computed for all transactions except those which are on the cycle. In case it is a real deadlock cycle, this function will update the new_weights entries for transactions involved in this cycle (as it will unfold to a path, and schedule weight can be thus computed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the cycle found was indeed a deadlock cycle, false if it was a false positive </dd></dl>

</div>
</div>
<a id="af12287cdbcac42eca4b992e9d6cbdc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12287cdbcac42eca4b992e9d6cbdc98">&#9670;&nbsp;</a></span>lock_wait_check_slots_for_timeouts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_check_slots_for_timeouts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check all slots for user threads that are waiting on locks, and if they have exceeded the time limit. </p>

</div>
</div>
<a id="a232bff112733db6018120480a04251f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232bff112733db6018120480a04251f0">&#9670;&nbsp;</a></span>lock_wait_choose_victim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtrx__t.html">trx_t</a>* lock_wait_choose_victim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, picks the transaction to rollback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transaction chosen as a victim </dd></dl>

</div>
</div>
<a id="a454e860fe8e3f9502c148f5da810da66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454e860fe8e3f9502c148f5da810da66">&#9670;&nbsp;</a></span>lock_wait_compute_and_publish_weights_except_cycles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_compute_and_publish_weights_except_cycles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>table_reservations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the <code>infos</code> snapshot about transactions, the value of lock_wait_table_reservations before taking the snapshot and the edges of the wait-for-graph relation between the transactions in the snapshot, computes the schedule weight for each transaction, which is the sum of initial weight of the transaction and all transactions that are blocked by it. </p>
<p>This definition does not apply to transactions on deadlock cycles, thus this function will not compute the final schedule weight for transactions on the cycle, but rather leave it as the partial sum of the tree rooted at the transaction hanging off the cycle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>Information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_reservations</td><td>value of lock_wait_table_reservations at before taking the <code>infos</code>snapshot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outgoing</td><td>The ids of edge endpoints. If outgoing[id] == -1, then there is no edge going out of id, otherwise infos[id].trx waits for infos[outgoing[id]].trx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_weights</td><td>schedule weights of transactions computed for all transactions except those which are on a cycle. For those on cycle we only compute the partial sum of the weights in the tree hanging off the cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee77ab45d8befa5cf02432d7392e8b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee77ab45d8befa5cf02432d7392e8b07">&#9670;&nbsp;</a></span>lock_wait_compute_incoming_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_compute_incoming_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>incoming_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of incoming edges for each node of a given graph, in which each node has zero or one outgoing edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outgoing</td><td>The ids of edge endpoints. If outgoing[id] == -1, then there is no edge going out of id, otherwise there is an edge from id to outgoing[id]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">incoming_count</td><td>The place to store the results. After the call the incoming_count[id] will be the number of edges ending in id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42c4a13e74c824050239ca11d3792232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c4a13e74c824050239ca11d3792232">&#9670;&nbsp;</a></span>lock_wait_compute_initial_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_compute_initial_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>table_reservations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to initialize schedule weights of nodes in wait-for-graph for the computation. </p>
<p>Initially all nodes have weight 1, except for nodes which waited very long, for which we set the weight to WEIGHT_BOOST </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_reservations</td><td>value of lock_wait_table_reservations at before taking the <code>infos</code> snapshot </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_weights</td><td>place to store initial weights of nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f404da347a74d7a62a6573eef88d30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f404da347a74d7a62a6573eef88d30a">&#9670;&nbsp;</a></span>lock_wait_extract_cycle_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_extract_cycle_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a list of <code>cycle_ids</code> by following <code>outgoing</code> edges from the <code>start</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cycle_ids</td><td>will contain the list of ids on cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>the first id on the cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outgoing</td><td>the ids of edge endpoints: id -&gt; outgoing[id] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1b4812f489c2c15845b401927ac79a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b4812f489c2c15845b401927ac79a7">&#9670;&nbsp;</a></span>lock_wait_find_and_handle_deadlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_find_and_handle_deadlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that <code>infos</code> contains information about all waiting transactions, and <code>outgoing[i]</code> is the endpoint of wait-for edge going out of infos[i].trx, or -1 if the transaction is not waiting, it identifies and handles all cycles in the wait-for graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>Information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outgoing</td><td>The ids of edge endpoints. If outgoing[id] == -1, then there is no edge going out of id, otherwise infos[id].trx waits for infos[outgoing[id]].trx </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_weights</td><td>schedule weights of transactions computed for all transactions except those which are on a cycle. In case we find a real deadlock cycle, and decide to rollback one of transactions, this function will update the new_weights entries for transactions involved in this cycle (as it will unfold to a path, and schedule weight can be thus computed) </td></tr>
  </table>
  </dd>
</dl>
<p>We are going to use int and uint to store positions within infos </p>

</div>
</div>
<a id="ac0b6354f337961fa65338098a9fa4a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b6354f337961fa65338098a9fa4a05">&#9670;&nbsp;</a></span>lock_wait_find_latest_pos_on_cycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t lock_wait_find_latest_pos_on_cycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the <code>infos</code> about transactions and indexes in <code>infos</code> which form a deadlock cycle, identifies the transaction with the largest <code>reservation_no</code>, that is the one which was the latest to join the cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position in cycle_ids, such that infos[cycle_ids[pos]].reservation_no is the largest </dd></dl>

</div>
</div>
<a id="a457409fcb892f8229fcc59f4a8cd47d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457409fcb892f8229fcc59f4a8cd47d9">&#9670;&nbsp;</a></span>lock_wait_get_slot_if_still_reserved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structsrv__slot__t.html">srv_slot_t</a>* lock_wait_get_slot_if_still_reserved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if info[id].slot is still in use and has not been freed and reserved again since we took the info snapshot ("ABA" type of race condition). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>index to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>info[id].slot if the slot was reserved whole time since taking the info snapshot. Otherwise: nullptr. </dd></dl>

</div>
</div>
<a id="a2da41865c8d9c5ac68a9aa1e98a3155e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da41865c8d9c5ac68a9aa1e98a3155e">&#9670;&nbsp;</a></span>lock_wait_handle_deadlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_handle_deadlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>chosen_victim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a deadlock found, by notifying about it, rolling back the chosen victim and updating schedule weights of transactions on the deadlock cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">chosen_victim</td><td>the transaction to roll back </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_weights</td><td>schedule weights of transactions computed for all transactions except those which are on a cycle. This function will update the new_weights entries for transactions involved in deadlock cycle (as it will unfold to a path, and schedule weight can be thus computed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7031c19a856c3ab0ea4bbeccde725659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7031c19a856c3ab0ea4bbeccde725659">&#9670;&nbsp;</a></span>lock_wait_map_ids_to_trxs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt;T&gt; lock_wait_map_ids_to_trxs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper, which extracts transactions with given indexes from the <code>infos</code> array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>indexes of transactions in the <code>infos</code> array to extract </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array formed by infos[ids[i]].trx </dd></dl>

</div>
</div>
<a id="aed0850191c063448a7798002971b7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0850191c063448a7798002971b7d04">&#9670;&nbsp;</a></span>lock_wait_order_for_choosing_victim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt;<a class="el" href="structtrx__t.html">trx_t</a> *&gt; lock_wait_order_for_choosing_victim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Orders the transactions from deadlock cycle in such a backward-compatible way, from the point of view of algorithm with picks the victim. </p>
<p>From correctness point of view this could be a no-op, but we have test cases which assume some determinism in that which trx is selected as the victim. These tests usually depend on the old behaviour in which the order in which trxs attempted to wait was meaningful. In the past we have only considered two candidates for victim: (a) the transaction which closed the cycle by adding last wait-for edge (b) the transaction which is waiting for (a) and it favored to pick (a) in case of ties. To make these test pass we find the trx with most recent reservation_no (a), and the one before it in the cycle (b), and move them to the end of collection So that we consider them in order: ...,...,...,(b),(a), resolving ties by picking the latest one as victim. In other words we rotate the cycle so that the most recent waiter becomes the last. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transactions from the deadlock cycle sorted in the optimal way for choosing a victim </dd></dl>

</div>
</div>
<a id="a8b88c45a56387d6603310f17a45354af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b88c45a56387d6603310f17a45354af">&#9670;&nbsp;</a></span>lock_wait_publish_new_weights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_publish_new_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_on_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the newly computed schedule weights to the transactions fields. </p>
<p>Ignores transactions which take part in cycles, because for them we don't have a final value of the schedule weight yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is_on_cycle</td><td>A positive value is_on_cycle[id] means that <code>id</code> is on a cycle in the graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_weights</td><td>schedule weights of transactions computed for all transactions except those which are on a cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3baeed3d2175d88f21d37128c1b57e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baeed3d2175d88f21d37128c1b57e32">&#9670;&nbsp;</a></span>lock_wait_release_thread_if_suspended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_release_thread_if_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a user OS thread waiting for a lock to be released, if the thread is already suspended. </p>
<p>Please do not call it directly, but rather use the lock_reset_wait_and_release_thread_if_suspended() wrapper. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread associated with the user OS thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a791dd54f6bbed78c9fc0f94c454f18da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791dd54f6bbed78c9fc0f94c454f18da">&#9670;&nbsp;</a></span>lock_wait_request_check_for_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_wait_request_check_for_cycles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies the thread which analyzes wait-for-graph that there was at least one new edge added or modified ( trx-&gt;blocking_trx has changed ), so that the thread will know it has to analyze it. </p>

</div>
</div>
<a id="a2b57d21d502607a49400532cb5e61fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b57d21d502607a49400532cb5e61fe7">&#9670;&nbsp;</a></span>lock_wait_rollback_deadlock_victim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_rollback_deadlock_victim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>chosen_victim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the chosen_victim that it should roll back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">chosen_victim</td><td>the transaction that should be rolled back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c5dbb2f4532bfe27275d612574ffb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5dbb2f4532bfe27275d612574ffb4e">&#9670;&nbsp;</a></span>lock_wait_rotate_cycle_ids_for_notification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt;<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&gt; lock_wait_rotate_cycle_ids_for_notification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7249118f406050e30c72a62b8be1bc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7249118f406050e30c72a62b8be1bc33">&#9670;&nbsp;</a></span>lock_wait_rotate_cycle_ids_to_so_trx_is_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt;<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&gt; lock_wait_rotate_cycle_ids_to_so_trx_is_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function which rotates the deadlock cycle, so that the specified trx is the first one on the cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>The transaction we wish to be the first after the rotation. There must exist x, such that infos[cycle_ids[x]].trx == trx. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Assuming that infos[cycle_ids[x]].trx == trx the result will be a copy of [cycle_ids[x],cycle_ids[x+1 mod N],...,cycle_ids[x-1+N mod N]]. </dd></dl>

</div>
</div>
<a id="a338719dbcfbd12968b1f999b83b8eb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338719dbcfbd12968b1f999b83b8eb0b">&#9670;&nbsp;</a></span>lock_wait_rotate_so_pos_is_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt;<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&gt; lock_wait_rotate_so_pos_is_first </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates the deadlock cycle so that it starts from desired item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_pos</td><td>the position which should become first after rotation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>the array to rotate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of cycle_ids rotated in such a way, that the element which was at position <code>first_pos</code> is now the first </dd></dl>

</div>
</div>
<a id="ad19ce13e638057751b819dbc59cd661b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19ce13e638057751b819dbc59cd661b">&#9670;&nbsp;</a></span>lock_wait_snapshot_waiting_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t lock_wait_snapshot_waiting_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a snapshot of the content of slots which are in use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">infos</td><td>Will contain the information about slots which are in use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of lock_wait_table_reservations before taking the snapshot </dd></dl>

</div>
</div>
<a id="ae4ef9abc31e16983f141559c65f7582d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef9abc31e16983f141559c65f7582d">&#9670;&nbsp;</a></span>lock_wait_suspend_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_wait_suspend_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a user OS thread to wait for a lock to be released. </p>
<p>If an error occurs during the wait trx-&gt;error_state associated with thr is != DB_SUCCESS when we return. DB_LOCK_WAIT_TIMEOUT and DB_DEADLOCK are possible errors. DB_DEADLOCK is returned if selective deadlock resolution chose this transaction as a victim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread associated with the user OS thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84fab6fdaf6aa9752239617c53eb0868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fab6fdaf6aa9752239617c53eb0868">&#9670;&nbsp;</a></span>lock_wait_table_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_table_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the contents of the lock_sys_t::waiting_threads array. </p>

</div>
</div>
<a id="af27dbbe515cb4e94068d9ccddc46faa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27dbbe515cb4e94068d9ccddc46faa7">&#9670;&nbsp;</a></span>lock_wait_table_release_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_table_release_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsrv__slot__t.html">srv_slot_t</a> *&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a slot in the lock_sys_t::waiting_threads. </p>
<p>Adjust the array last pointer if there are empty slots towards the end of the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>in: slot to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ae13697fd14a07ff1d7a546aa94601d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae13697fd14a07ff1d7a546aa94601d">&#9670;&nbsp;</a></span>lock_wait_table_reserve_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structsrv__slot__t.html">srv_slot_t</a>* lock_wait_table_reserve_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves a slot in the thread table for the current user OS thread. </p>
<dl class="section return"><dt>Returns</dt><dd>reserved slot </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread associated with the user OS thread </td></tr>
    <tr><td class="paramname">wait_timeout</td><td>in: lock wait timeout value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82b7ab612695ece320a4731a8f69e8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b7ab612695ece320a4731a8f69e8cb">&#9670;&nbsp;</a></span>lock_wait_timeout_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_wait_timeout_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A thread which wakes up threads whose lock wait may have lasted too long, analyzes wait-for-graph changes, checks for deadlocks and resolves them, and updates schedule weights. </p>
<p>A thread which wakes up threads whose lock wait may have lasted too long.</p>
<p>The last time we've checked for timeouts. </p>

</div>
</div>
<a id="aafa2d5ebd83a77df656600aea2bfdaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa2d5ebd83a77df656600aea2bfdaa2">&#9670;&nbsp;</a></span>lock_wait_trxs_are_still_in_slots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_wait_trxs_are_still_in_slots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, checks if the transactions allegedly forming the deadlock have actually stayed in slots since we've last checked, as opposed to say, not leaving a slot, and/or re-entering the slot ("ABA" situation). </p>
<p>This is done by comparing the current reservation_no for each slot, with the reservation_no from the <code>info</code> snapshot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all given transactions resided in their slots for the whole time since the snapshot was taken, and in particular are still there right now </dd></dl>

</div>
</div>
<a id="a57ed4d74f30b04a3b725afadbfb2c34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ed4d74f30b04a3b725afadbfb2c34a">&#9670;&nbsp;</a></span>lock_wait_trxs_are_still_waiting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_wait_trxs_are_still_waiting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an array with information about all waiting transactions and indexes in it which form a deadlock cycle, checks if the transactions allegedly forming the deadlock have actually still wait for a lock, as opposed to being already notified about lock being granted or timeout, but still being present in the slot. </p>
<p>This is done by checking trx-&gt;lock.wait_lock under exclusive global lock_sys latch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all given transactions are still waiting for locks </dd></dl>

</div>
</div>
<a id="aa3adffc8b48e7521cf526fa97e67ce53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3adffc8b48e7521cf526fa97e67ce53">&#9670;&nbsp;</a></span>lock_wait_trxs_rotated_for_notification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt;const <a class="el" href="structtrx__t.html">trx_t</a> *&gt; lock_wait_trxs_rotated_for_notification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function which rotates the deadlock cycle, so that the order of transactions in it is suitable for notification. </p>
<p>From correctness perspective this could be a no-op, but we have tests which depend on deterministic output from such notifications, and we want to be backward compatible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transactions from cycle_ids rotated in backward-compatible way </dd></dl>

</div>
</div>
<a id="ac31b56de0481a893677edddfdc690a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31b56de0481a893677edddfdc690a67">&#9670;&nbsp;</a></span>lock_wait_update_schedule_and_check_for_deadlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_update_schedule_and_check_for_deadlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a snapshot of transactions in waiting currently in slots, updates their schedule weights, searches for deadlocks among them and resolves them. </p>

</div>
</div>
<a id="ae77cb096185f824eeb4be5c4af5a0d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77cb096185f824eeb4be5c4af5a0d07">&#9670;&nbsp;</a></span>lock_wait_update_weights_on_cycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_wait_update_weights_on_cycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>chosen_victim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cycle_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>infos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; <a class="el" href="lock0types_8h.html#a4c42529c140b2f13eff9722657c0883d">trx_schedule_weight_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizes the computation of new schedule weights, by providing missing information about transactions located on a deadlock cycle. </p>
<p>Assuming that we know the list of transactions on a cycle, which transaction will be chosen as a victim, and what are the weights of trees hanging off the cycle, it computes the final schedule weight for each of transactions to be equal to its weight in a graph with the victim's node missing </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chosen_victim</td><td>The transaction chosen to be rolled back </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle_ids</td><td>indexes in <code>infos</code> array, of transactions forming the deadlock cycle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">infos</td><td>information about all waiting transactions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_weights</td><td>schedule weights of transactions computed for all transactions except those which are on a cycle. This function will update the new_weights entries for transactions involved in deadlock cycle (as it will unfold to a path, and schedule weight can be thus computed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dadd7cdbddf344153403cd53d923258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dadd7cdbddf344153403cd53d923258">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwaiting__trx__info__t.html">waiting_trx_info_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As we want to quickly find a given trx_t within the snapshot, we use a sorting criterion which is based on trx only. </p>
<p>We use the pointer address, as any deterministic rule without ties will do. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8c1aae5a72412d8f54c1231d63d8acd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1aae5a72412d8f54c1231d63d8acd0">&#9670;&nbsp;</a></span>lock_wait_table_reservations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lock_wait_table_reservations = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts number of calls to lock_wait_table_reserve_slot. </p>
<p>It is protected by lock_wait_mutex. Current value of this counter is stored in the slot a transaction has chosen for sleeping during suspension, and thus serves as "reservation number" which can be used to check if the owner of the slot has changed (perhaps multiple times, in "ABA" manner). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_a92a0f1911438c718531eeaff646b0b5.html">lock</a></li><li class="navelem"><a class="el" href="lock0wait_8cc.html">lock0wait.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
