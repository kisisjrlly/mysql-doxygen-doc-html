<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/trx/trx0i_s.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trx0i__s_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">trx0i_s.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>INFORMATION SCHEMA innodb_trx, innodb_locks and innodb_lock_waits tables fetch code.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="sql__class_8h_source.html">sql_class.h</a>&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha0storage_8h_source.html">ha0storage.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0iter_8h_source.html">lock0iter.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="include_2mysql_2plugin_8h_source.html">mysql/plugin.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0rec_8h_source.html">rem0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0i__s_8h_source.html">trx0i_s.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pfs__data__lock_8h_source.html">storage/perfschema/pfs_data_lock.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi__s__mem__chunk__t.html">i_s_mem_chunk_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory for each table in the intermediate buffer is allocated in separate chunks.  <a href="structi__s__mem__chunk__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents one table's cache.  <a href="structi__s__table__cache__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure describes the intermediate buffer.  <a href="structtrx__i__s__cache__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a01f0f3f3d1bf9116a90f06be4a55c646"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a01f0f3f3d1bf9116a90f06be4a55c646">TABLE_CACHE_INITIAL_ROWSNUM</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:a01f0f3f3d1bf9116a90f06be4a55c646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial number of rows in the table cache.  <a href="#a01f0f3f3d1bf9116a90f06be4a55c646">More...</a><br /></td></tr>
<tr class="separator:a01f0f3f3d1bf9116a90f06be4a55c646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0cca06ba6aeaeb82876fd21a0331f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aee0cca06ba6aeaeb82876fd21a0331f4">MEM_CHUNKS_IN_TABLE_CACHE</a>&#160;&#160;&#160;39</td></tr>
<tr class="memdesc:aee0cca06ba6aeaeb82876fd21a0331f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of chunks to allocate for a table cache.  <a href="#aee0cca06ba6aeaeb82876fd21a0331f4">More...</a><br /></td></tr>
<tr class="separator:aee0cca06ba6aeaeb82876fd21a0331f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36763bce6a91af48841bee6df67ef7d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a36763bce6a91af48841bee6df67ef7d6">MAX_ALLOWED_FOR_STORAGE</a>(cache)&#160;&#160;&#160;(<a class="el" href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a> - (cache)-&gt;mem_allocd)</td></tr>
<tr class="memdesc:a36763bce6a91af48841bee6df67ef7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following are some testing auxiliary macros.  <a href="#a36763bce6a91af48841bee6df67ef7d6">More...</a><br /></td></tr>
<tr class="separator:a36763bce6a91af48841bee6df67ef7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99e0c0334d3e63e23d35f654079ccb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ac99e0c0334d3e63e23d35f654079ccb4">MAX_ALLOWED_FOR_ALLOC</a>(cache)</td></tr>
<tr class="memdesc:ac99e0c0334d3e63e23d35f654079ccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory limit in table_cache_create_empty_row().  <a href="#ac99e0c0334d3e63e23d35f654079ccb4">More...</a><br /></td></tr>
<tr class="separator:ac99e0c0334d3e63e23d35f654079ccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57e256193b9d5aced6f200585d82a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a5b57e256193b9d5aced6f200585d82a2">LOCKS_HASH_CELLS_NUM</a>&#160;&#160;&#160;10000</td></tr>
<tr class="memdesc:a5b57e256193b9d5aced6f200585d82a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the hash table size is LOCKS_HASH_CELLS_NUM * sizeof(void*) bytes  <a href="#a5b57e256193b9d5aced6f200585d82a2">More...</a><br /></td></tr>
<tr class="separator:a5b57e256193b9d5aced6f200585d82a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858fa143a71f61e3096fe65a429a0fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aa858fa143a71f61e3096fe65a429a0fe">CACHE_STORAGE_INITIAL_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:aa858fa143a71f61e3096fe65a429a0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial size of the cache storage.  <a href="#aa858fa143a71f61e3096fe65a429a0fe">More...</a><br /></td></tr>
<tr class="separator:aa858fa143a71f61e3096fe65a429a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b3957e13b039b02e104799cdf71292"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a52b3957e13b039b02e104799cdf71292">CACHE_STORAGE_HASH_CELLS</a>&#160;&#160;&#160;2048</td></tr>
<tr class="memdesc:a52b3957e13b039b02e104799cdf71292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of hash cells in the cache storage.  <a href="#a52b3957e13b039b02e104799cdf71292">More...</a><br /></td></tr>
<tr class="separator:a52b3957e13b039b02e104799cdf71292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c06168ee6b384103efe5ef9968a4e15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a2c06168ee6b384103efe5ef9968a4e15">CACHE_MIN_IDLE_TIME_US</a>&#160;&#160;&#160;100000 /* 0.1 <a class="el" href="ctype_8cc.html#abe7970caf4b4a5acc5ddc69da9a6ddb1">sec</a> */</td></tr>
<tr class="memdesc:a2c06168ee6b384103efe5ef9968a4e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum time that a cache must not be updated after it has been read for the last time; measured in microseconds.  <a href="#a2c06168ee6b384103efe5ef9968a4e15">More...</a><br /></td></tr>
<tr class="separator:a2c06168ee6b384103efe5ef9968a4e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae6eaaebecf6b68bdbafcff69320d95f5"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ae6eaaebecf6b68bdbafcff69320d95f5">wait_lock_get_heap_no</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ae6eaaebecf6b68bdbafcff69320d95f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a record lock that is in waiting state retrieves the only bit that is set, for a table lock returns ULINT_UNDEFINED.  <a href="#ae6eaaebecf6b68bdbafcff69320d95f5">More...</a><br /></td></tr>
<tr class="separator:ae6eaaebecf6b68bdbafcff69320d95f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf61aa32949295fdd25b9d69964f83d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a0cf61aa32949295fdd25b9d69964f83d">table_cache_init</a> (<a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *table_cache, size_t row_size)</td></tr>
<tr class="memdesc:a0cf61aa32949295fdd25b9d69964f83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the members of a table cache.  <a href="#a0cf61aa32949295fdd25b9d69964f83d">More...</a><br /></td></tr>
<tr class="separator:a0cf61aa32949295fdd25b9d69964f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692c274041f49e80c3e170b240ab30cf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a692c274041f49e80c3e170b240ab30cf">table_cache_free</a> (<a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *table_cache)</td></tr>
<tr class="memdesc:a692c274041f49e80c3e170b240ab30cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a table cache.  <a href="#a692c274041f49e80c3e170b240ab30cf">More...</a><br /></td></tr>
<tr class="separator:a692c274041f49e80c3e170b240ab30cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1d6a8d0d3e571fcfc7c405b2458cb8"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a7a1d6a8d0d3e571fcfc7c405b2458cb8">table_cache_create_empty_row</a> (<a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *table_cache, <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a7a1d6a8d0d3e571fcfc7c405b2458cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty row from a table cache.  <a href="#a7a1d6a8d0d3e571fcfc7c405b2458cb8">More...</a><br /></td></tr>
<tr class="separator:a7a1d6a8d0d3e571fcfc7c405b2458cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59fccd516205a584c8b59a3c35a6570"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ab59fccd516205a584c8b59a3c35a6570">i_s_locks_row_validate</a> (const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *row)</td></tr>
<tr class="memdesc:ab59fccd516205a584c8b59a3c35a6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates a row in the locks cache.  <a href="#ab59fccd516205a584c8b59a3c35a6570">More...</a><br /></td></tr>
<tr class="separator:ab59fccd516205a584c8b59a3c35a6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e1b41c44dd1f948c6475758192de28"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ab2e1b41c44dd1f948c6475758192de28">fill_trx_row</a> (<a class="el" href="structi__s__trx__row__t.html">i_s_trx_row_t</a> *row, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *requested_lock_row, <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:ab2e1b41c44dd1f948c6475758192de28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills i_s_trx_row_t object.  <a href="#ab2e1b41c44dd1f948c6475758192de28">More...</a><br /></td></tr>
<tr class="separator:ab2e1b41c44dd1f948c6475758192de28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea746ef8e0aa961a089254b7b83d65b9"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aea746ef8e0aa961a089254b7b83d65b9">put_nth_field</a> (char *buf, ulint <a class="el" href="create__def_8cc.html#a83a426bc389379d92979b5248e18877c">buf_size</a>, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets)</td></tr>
<tr class="memdesc:aea746ef8e0aa961a089254b7b83d65b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the nth field of "rec" and put it in "buf".  <a href="#aea746ef8e0aa961a089254b7b83d65b9">More...</a><br /></td></tr>
<tr class="separator:aea746ef8e0aa961a089254b7b83d65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70d5013c637aa3c757840e656542de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#afa70d5013c637aa3c757840e656542de">p_s_fill_lock_data</a> (const char **lock_data, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no, <a class="el" href="classPSI__server__data__lock__container.html">PSI_server_data_lock_container</a> *<a class="el" href="innodb__config_8h.html#a030ecaa2a61b422a8ca7422403ad8c77">container</a>)</td></tr>
<tr class="memdesc:afa70d5013c637aa3c757840e656542de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill performance schema lock data.  <a href="#afa70d5013c637aa3c757840e656542de">More...</a><br /></td></tr>
<tr class="separator:afa70d5013c637aa3c757840e656542de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e99af7313f7624bad13e1f69ea5058"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a35e99af7313f7624bad13e1f69ea5058">fill_locks_row</a> (<a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *row, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="memdesc:a35e99af7313f7624bad13e1f69ea5058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills i_s_locks_row_t object with data about the lock.  <a href="#a35e99af7313f7624bad13e1f69ea5058">More...</a><br /></td></tr>
<tr class="separator:a35e99af7313f7624bad13e1f69ea5058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf7fe2d991779bb79eb9bf85e307bd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aadf7fe2d991779bb79eb9bf85e307bd2">add_lock_to_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="memdesc:aadf7fe2d991779bb79eb9bf85e307bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds new element to the locks cache, enlarging it if necessary.  <a href="#aadf7fe2d991779bb79eb9bf85e307bd2">More...</a><br /></td></tr>
<tr class="separator:aadf7fe2d991779bb79eb9bf85e307bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fe829b4dd47e1cf2e897769c0482e6"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a80fe829b4dd47e1cf2e897769c0482e6">add_trx_relevant_locks_to_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> **requested_lock_row)</td></tr>
<tr class="memdesc:a80fe829b4dd47e1cf2e897769c0482e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds transaction's relevant (important) locks to cache.  <a href="#a80fe829b4dd47e1cf2e897769c0482e6">More...</a><br /></td></tr>
<tr class="separator:a80fe829b4dd47e1cf2e897769c0482e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ebecc6d9f2669b9384f6f256fe1478"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a94ebecc6d9f2669b9384f6f256fe1478">can_cache_be_updated</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a94ebecc6d9f2669b9384f6f256fe1478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the cache can safely be updated.  <a href="#a94ebecc6d9f2669b9384f6f256fe1478">More...</a><br /></td></tr>
<tr class="separator:a94ebecc6d9f2669b9384f6f256fe1478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b73d6eb69e73c6558f8ee97e21e097d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a6b73d6eb69e73c6558f8ee97e21e097d">trx_i_s_cache_clear</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a6b73d6eb69e73c6558f8ee97e21e097d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a cache empty, preparing it to be filled up.  <a href="#a6b73d6eb69e73c6558f8ee97e21e097d">More...</a><br /></td></tr>
<tr class="separator:a6b73d6eb69e73c6558f8ee97e21e097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3861ffbaeefb86371c8d606b62acd310"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a3861ffbaeefb86371c8d606b62acd310">fetch_data_into_cache_low</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> read_write, trx_ut_list_t *trx_list)</td></tr>
<tr class="memdesc:a3861ffbaeefb86371c8d606b62acd310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the data needed to fill the 3 INFORMATION SCHEMA tables into the table cache buffer.  <a href="#a3861ffbaeefb86371c8d606b62acd310">More...</a><br /></td></tr>
<tr class="separator:a3861ffbaeefb86371c8d606b62acd310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c73dfc1d549e29a263af5e11909bdf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a93c73dfc1d549e29a263af5e11909bdf">fetch_data_into_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a93c73dfc1d549e29a263af5e11909bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the data needed to fill the 3 INFORMATION SCHEMA tables into the table cache buffer.  <a href="#a93c73dfc1d549e29a263af5e11909bdf">More...</a><br /></td></tr>
<tr class="separator:a93c73dfc1d549e29a263af5e11909bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa070c7602c8996c58468f95e29b5fb76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aa070c7602c8996c58468f95e29b5fb76">trx_i_s_possibly_fetch_data_into_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:aa070c7602c8996c58468f95e29b5fb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the transactions cache if it has not been read for some time.  <a href="#aa070c7602c8996c58468f95e29b5fb76">More...</a><br /></td></tr>
<tr class="separator:aa070c7602c8996c58468f95e29b5fb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2e1366d36dbdce51996df969f44b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a3e2e1366d36dbdce51996df969f44b6b">trx_i_s_cache_is_truncated</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a3e2e1366d36dbdce51996df969f44b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the data in the cache is truncated due to the memory limit posed by TRX_I_S_MEM_LIMIT.  <a href="#a3e2e1366d36dbdce51996df969f44b6b">More...</a><br /></td></tr>
<tr class="separator:a3e2e1366d36dbdce51996df969f44b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6e37691cd8be8e0a636d471a243238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aff6e37691cd8be8e0a636d471a243238">trx_i_s_cache_init</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:aff6e37691cd8be8e0a636d471a243238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize INFORMATION SCHEMA trx related cache.  <a href="#aff6e37691cd8be8e0a636d471a243238">More...</a><br /></td></tr>
<tr class="separator:aff6e37691cd8be8e0a636d471a243238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98ffa7fe0c173b75525eadc392863ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ad98ffa7fe0c173b75525eadc392863ae">trx_i_s_cache_free</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:ad98ffa7fe0c173b75525eadc392863ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the INFORMATION SCHEMA trx related cache.  <a href="#ad98ffa7fe0c173b75525eadc392863ae">More...</a><br /></td></tr>
<tr class="separator:ad98ffa7fe0c173b75525eadc392863ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa579e6ee53c138cfe0273cea60a161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a0aa579e6ee53c138cfe0273cea60a161">trx_i_s_cache_start_read</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a0aa579e6ee53c138cfe0273cea60a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue a shared/read lock on the tables cache.  <a href="#a0aa579e6ee53c138cfe0273cea60a161">More...</a><br /></td></tr>
<tr class="separator:a0aa579e6ee53c138cfe0273cea60a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022ba6bc11e4aad5a7848b34712f5891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a022ba6bc11e4aad5a7848b34712f5891">trx_i_s_cache_end_read</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a022ba6bc11e4aad5a7848b34712f5891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a shared/read lock on the tables cache.  <a href="#a022ba6bc11e4aad5a7848b34712f5891">More...</a><br /></td></tr>
<tr class="separator:a022ba6bc11e4aad5a7848b34712f5891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332b4c742bec60712cc241d013881614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a332b4c742bec60712cc241d013881614">trx_i_s_cache_start_write</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:a332b4c742bec60712cc241d013881614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue an exclusive/write lock on the tables cache.  <a href="#a332b4c742bec60712cc241d013881614">More...</a><br /></td></tr>
<tr class="separator:a332b4c742bec60712cc241d013881614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e21422c1d882e1100d5610b76335e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ab9e21422c1d882e1100d5610b76335e9">trx_i_s_cache_end_write</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="memdesc:ab9e21422c1d882e1100d5610b76335e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an exclusive/write lock on the tables cache.  <a href="#ab9e21422c1d882e1100d5610b76335e9">More...</a><br /></td></tr>
<tr class="separator:ab9e21422c1d882e1100d5610b76335e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117cfd2ddf19d1f50f8e7593e712a048"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a117cfd2ddf19d1f50f8e7593e712a048">cache_select_table</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a> table)</td></tr>
<tr class="memdesc:a117cfd2ddf19d1f50f8e7593e712a048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a INFORMATION SCHEMA table cache from the whole cache.  <a href="#a117cfd2ddf19d1f50f8e7593e712a048">More...</a><br /></td></tr>
<tr class="separator:a117cfd2ddf19d1f50f8e7593e712a048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9943f9b1ae6005747b245d0b046fb49a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a9943f9b1ae6005747b245d0b046fb49a">trx_i_s_cache_get_rows_used</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a> table)</td></tr>
<tr class="memdesc:a9943f9b1ae6005747b245d0b046fb49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of used rows in the cache for a given INFORMATION SCHEMA table.  <a href="#a9943f9b1ae6005747b245d0b046fb49a">More...</a><br /></td></tr>
<tr class="separator:a9943f9b1ae6005747b245d0b046fb49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd126598c3e4405111a2e20fd0fa6e2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#afdd126598c3e4405111a2e20fd0fa6e2">trx_i_s_cache_get_nth_row</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a> table, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:afdd126598c3e4405111a2e20fd0fa6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the nth row (zero-based) in the cache for a given INFORMATION SCHEMA table.  <a href="#afdd126598c3e4405111a2e20fd0fa6e2">More...</a><br /></td></tr>
<tr class="separator:afdd126598c3e4405111a2e20fd0fa6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177f2ea3aaba8523c2255b2d042df5d1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a177f2ea3aaba8523c2255b2d042df5d1">trx_i_s_create_lock_id</a> (const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *row, char *lock_id, ulint lock_id_size)</td></tr>
<tr class="memdesc:a177f2ea3aaba8523c2255b2d042df5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crafts a lock id string from a i_s_locks_row_t object.  <a href="#a177f2ea3aaba8523c2255b2d042df5d1">More...</a><br /></td></tr>
<tr class="separator:a177f2ea3aaba8523c2255b2d042df5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf99212d031b207506164bfcf879c30c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#adf99212d031b207506164bfcf879c30c">trx_i_s_parse_lock_id</a> (const char *lock_id, <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *row)</td></tr>
<tr class="memdesc:adf99212d031b207506164bfcf879c30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses lock id into row.  <a href="#adf99212d031b207506164bfcf879c30c">More...</a><br /></td></tr>
<tr class="separator:adf99212d031b207506164bfcf879c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:addf3c2fcb0413ec13456ef23a7ceb374"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#addf3c2fcb0413ec13456ef23a7ceb374">trx_i_s_cache_static</a></td></tr>
<tr class="memdesc:addf3c2fcb0413ec13456ef23a7ceb374"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the intermediate buffer where data needed to fill the INFORMATION SCHEMA tables is fetched and later retrieved by the C++ code in handler/i_s.cc.  <a href="#addf3c2fcb0413ec13456ef23a7ceb374">More...</a><br /></td></tr>
<tr class="separator:addf3c2fcb0413ec13456ef23a7ceb374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1b818f2d1a1be140a20a25978cbdc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a4c1b818f2d1a1be140a20a25978cbdc6">trx_i_s_cache</a> = &amp;<a class="el" href="trx0i__s_8cc.html#addf3c2fcb0413ec13456ef23a7ceb374">trx_i_s_cache_static</a></td></tr>
<tr class="memdesc:a4c1b818f2d1a1be140a20a25978cbdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the intermediate buffer where data needed to fill the INFORMATION SCHEMA tables is fetched and later retrieved by the C++ code in handler/i_s.cc.  <a href="#a4c1b818f2d1a1be140a20a25978cbdc6">More...</a><br /></td></tr>
<tr class="separator:a4c1b818f2d1a1be140a20a25978cbdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae776510bfef6b30178572502d665622a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ae776510bfef6b30178572502d665622a">LOCK_RECORD_ID_FORMAT</a></td></tr>
<tr class="separator:ae776510bfef6b30178572502d665622a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a65b757088a0f0d5502c3aaef8239"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aa54a65b757088a0f0d5502c3aaef8239">LOCK_TABLE_ID_FORMAT</a> = UINT64PF &quot;:&quot; UINT64PF &quot;:&quot; UINT64PF</td></tr>
<tr class="separator:aa54a65b757088a0f0d5502c3aaef8239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>INFORMATION SCHEMA innodb_trx, innodb_locks and innodb_lock_waits tables fetch code. </p>
<p>The code below fetches information needed to fill those 3 dynamic tables and uploads it into a "transactions
table cache" for later retrieval.</p>
<p>Created July 17, 2007 Vasil Dimov </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2c06168ee6b384103efe5ef9968a4e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c06168ee6b384103efe5ef9968a4e15">&#9670;&nbsp;</a></span>CACHE_MIN_IDLE_TIME_US</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_MIN_IDLE_TIME_US&#160;&#160;&#160;100000 /* 0.1 <a class="el" href="ctype_8cc.html#abe7970caf4b4a5acc5ddc69da9a6ddb1">sec</a> */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum time that a cache must not be updated after it has been read for the last time; measured in microseconds. </p>
<p>We use this technique to ensure that SELECTs which join several INFORMATION SCHEMA tables read the same version of the cache. </p>

</div>
</div>
<a id="a52b3957e13b039b02e104799cdf71292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b3957e13b039b02e104799cdf71292">&#9670;&nbsp;</a></span>CACHE_STORAGE_HASH_CELLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_STORAGE_HASH_CELLS&#160;&#160;&#160;2048</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of hash cells in the cache storage. </p>

</div>
</div>
<a id="aa858fa143a71f61e3096fe65a429a0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa858fa143a71f61e3096fe65a429a0fe">&#9670;&nbsp;</a></span>CACHE_STORAGE_INITIAL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_STORAGE_INITIAL_SIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial size of the cache storage. </p>

</div>
</div>
<a id="a5b57e256193b9d5aced6f200585d82a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57e256193b9d5aced6f200585d82a2">&#9670;&nbsp;</a></span>LOCKS_HASH_CELLS_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCKS_HASH_CELLS_NUM&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the hash table size is LOCKS_HASH_CELLS_NUM * sizeof(void*) bytes </p>

</div>
</div>
<a id="ac99e0c0334d3e63e23d35f654079ccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99e0c0334d3e63e23d35f654079ccb4">&#9670;&nbsp;</a></span>MAX_ALLOWED_FOR_ALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_ALLOWED_FOR_ALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cache</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a> - (cache)-&gt;mem_allocd - \</div><div class="line">   <a class="code" href="ha0storage_8h.html#a525903647192e960bac5334b4374f263">ha_storage_get_size</a>((cache)-&gt;storage))</div><div class="ttc" id="trx0i__s_8h_html_a35fce873dd0c620970148a47b1131924"><div class="ttname"><a href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a></div><div class="ttdeci">#define TRX_I_S_MEM_LIMIT</div><div class="ttdoc">The maximum amount of memory that can be consumed by innodb_trx, innodb_locks and innodb_lock_waits i...</div><div class="ttdef"><b>Definition:</b> trx0i_s.h:46</div></div>
<div class="ttc" id="ha0storage_8h_html_a525903647192e960bac5334b4374f263"><div class="ttname"><a href="ha0storage_8h.html#a525903647192e960bac5334b4374f263">ha_storage_get_size</a></div><div class="ttdeci">UNIV_INLINE ulint ha_storage_get_size(const ha_storage_t *storage)</div><div class="ttdoc">Gets the size of the memory used by a storage. </div></div>
</div><!-- fragment -->
<p>Memory limit in table_cache_create_empty_row(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>hash storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum allowed allocation size </dd></dl>

</div>
</div>
<a id="a36763bce6a91af48841bee6df67ef7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36763bce6a91af48841bee6df67ef7d6">&#9670;&nbsp;</a></span>MAX_ALLOWED_FOR_STORAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_ALLOWED_FOR_STORAGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cache</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a> - (cache)-&gt;mem_allocd)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following are some testing auxiliary macros. </p>
<p>Do not enable them in a production environment. Memory limit passed to ha_storage_put_memlim(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>hash storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum allowed allocation size </dd></dl>

</div>
</div>
<a id="aee0cca06ba6aeaeb82876fd21a0331f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0cca06ba6aeaeb82876fd21a0331f4">&#9670;&nbsp;</a></span>MEM_CHUNKS_IN_TABLE_CACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_CHUNKS_IN_TABLE_CACHE&#160;&#160;&#160;39</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of chunks to allocate for a table cache. </p>
<p>The rows of a table cache are stored in a set of chunks. When a new row is added a new chunk is allocated if necessary. Assuming that the first one is 1024 rows (TABLE_CACHE_INITIAL_ROWSNUM) and each subsequent is N/2 where N is the number of rows we have allocated till now, then 39th chunk would accommodate 1677416425 rows and all chunks would accommodate 3354832851 rows. </p>

</div>
</div>
<a id="a01f0f3f3d1bf9116a90f06be4a55c646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f0f3f3d1bf9116a90f06be4a55c646">&#9670;&nbsp;</a></span>TABLE_CACHE_INITIAL_ROWSNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TABLE_CACHE_INITIAL_ROWSNUM&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial number of rows in the table cache. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aadf7fe2d991779bb79eb9bf85e307bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf7fe2d991779bb79eb9bf85e307bd2">&#9670;&nbsp;</a></span>add_lock_to_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a>* add_lock_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds new element to the locks cache, enlarging it if necessary. </p>
<p>Returns a pointer to the added row. If the row is already present then no row is added and a pointer to the existing row is returned. If row can not be allocated then NULL is returned. </p><dl class="section return"><dt>Returns</dt><dd>row </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
    <tr><td class="paramname">lock</td><td>in: the element to add </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: lock's record number or ULINT_UNDEFINED if the lock is a table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80fe829b4dd47e1cf2e897769c0482e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fe829b4dd47e1cf2e897769c0482e6">&#9670;&nbsp;</a></span>add_trx_relevant_locks_to_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool add_trx_relevant_locks_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> **&#160;</td>
          <td class="paramname"><em>requested_lock_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds transaction's relevant (important) locks to cache. </p>
<p>If the transaction is waiting, then the wait lock is added to innodb_locks and a pointer to the added row is returned in requested_lock_row, otherwise requested_lock_row is set to NULL. If rows can not be allocated then FALSE is returned and the value of requested_lock_row is undefined. </p><dl class="section return"><dt>Returns</dt><dd>false if allocation fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">requested_lock_row</td><td>out: pointer to the requested lock row, or NULL or undefined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a117cfd2ddf19d1f50f8e7593e712a048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117cfd2ddf19d1f50f8e7593e712a048">&#9670;&nbsp;</a></span>cache_select_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a>* cache_select_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a>&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects a INFORMATION SCHEMA table cache from the whole cache. </p>
<dl class="section return"><dt>Returns</dt><dd>table cache </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: whole cache </td></tr>
    <tr><td class="paramname">table</td><td>in: which table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94ebecc6d9f2669b9384f6f256fe1478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ebecc6d9f2669b9384f6f256fe1478">&#9670;&nbsp;</a></span>can_cache_be_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool can_cache_be_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the cache can safely be updated. </p>
<dl class="section return"><dt>Returns</dt><dd>true if can be updated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93c73dfc1d549e29a263af5e11909bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c73dfc1d549e29a263af5e11909bdf">&#9670;&nbsp;</a></span>fetch_data_into_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fetch_data_into_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the data needed to fill the 3 INFORMATION SCHEMA tables into the table cache buffer. </p>
<p>Cache must be locked for write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3861ffbaeefb86371c8d606b62acd310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3861ffbaeefb86371c8d606b62acd310">&#9670;&nbsp;</a></span>fetch_data_into_cache_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fetch_data_into_cache_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>read_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">trx_ut_list_t *&#160;</td>
          <td class="paramname"><em>trx_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the data needed to fill the 3 INFORMATION SCHEMA tables into the table cache buffer. </p>
<p>Cache must be locked for write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
    <tr><td class="paramname">read_write</td><td>in: only read-write transactions </td></tr>
    <tr><td class="paramname">trx_list</td><td>in: trx list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35e99af7313f7624bad13e1f69ea5058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e99af7313f7624bad13e1f69ea5058">&#9670;&nbsp;</a></span>fill_locks_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fill_locks_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills i_s_locks_row_t object with data about the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">row</td><td>Result object that's filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>Lock to get data from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>Lock's record number or ULINT_UNDEFINED if the lock is a table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2e1b41c44dd1f948c6475758192de28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e1b41c44dd1f948c6475758192de28">&#9670;&nbsp;</a></span>fill_trx_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fill_trx_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__trx__row__t.html">i_s_trx_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>requested_lock_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills i_s_trx_row_t object. </p>
<p>If memory can not be allocated then FALSE is returned. </p><dl class="section return"><dt>Returns</dt><dd>false if allocation fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>out: result object that's filled </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction to get data from </td></tr>
    <tr><td class="paramname">requested_lock_row</td><td>in: pointer to the corresponding row in innodb_locks if trx is waiting or NULL if trx is not waiting </td></tr>
    <tr><td class="paramname">cache</td><td>in/out: cache into which to copy volatile strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab59fccd516205a584c8b59a3c35a6570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59fccd516205a584c8b59a3c35a6570">&#9670;&nbsp;</a></span>i_s_locks_row_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool i_s_locks_row_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates a row in the locks cache. </p>
<dl class="section return"><dt>Returns</dt><dd>true if valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>in: row to validate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa70d5013c637aa3c757840e656542de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa70d5013c637aa3c757840e656542de">&#9670;&nbsp;</a></span>p_s_fill_lock_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_s_fill_lock_data </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>lock_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPSI__server__data__lock__container.html">PSI_server_data_lock_container</a> *&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill performance schema lock data. </p>
<p>Create a string that represents the LOCK_DATA column, for a given lock record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_data</td><td>Lock data string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>Lock to inspect </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>Lock heap number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Data container to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea746ef8e0aa961a089254b7b83d65b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea746ef8e0aa961a089254b7b83d65b9">&#9670;&nbsp;</a></span>put_nth_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint put_nth_field </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the nth field of "rec" and put it in "buf". </p>
<p>The result is always NUL-terminated. Returns the number of bytes that were written to "buf" (including the terminating NUL). </p><dl class="section return"><dt>Returns</dt><dd>end of the result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: buffer </td></tr>
    <tr><td class="paramname">buf_size</td><td>in: buffer size in bytes </td></tr>
    <tr><td class="paramname">n</td><td>in: number of field </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: record offsets, returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a1d6a8d0d3e571fcfc7c405b2458cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1d6a8d0d3e571fcfc7c405b2458cb8">&#9670;&nbsp;</a></span>table_cache_create_empty_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* table_cache_create_empty_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td>
          <td class="paramname"><em>table_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an empty row from a table cache. </p>
<p>The row is allocated if no more empty rows are available. The number of used rows is incremented. If the memory limit is hit then NULL is returned and nothing is allocated. </p><dl class="section return"><dt>Returns</dt><dd>empty row, or NULL if out of memory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_cache</td><td>in/out: table cache </td></tr>
    <tr><td class="paramname">cache</td><td>in/out: cache to record how many bytes are allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692c274041f49e80c3e170b240ab30cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692c274041f49e80c3e170b240ab30cf">&#9670;&nbsp;</a></span>table_cache_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void table_cache_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td>
          <td class="paramname"><em>table_cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a table cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_cache</td><td>in/out: table cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf61aa32949295fdd25b9d69964f83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf61aa32949295fdd25b9d69964f83d">&#9670;&nbsp;</a></span>table_cache_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void table_cache_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td>
          <td class="paramname"><em>table_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the members of a table cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_cache</td><td>out: table cache </td></tr>
    <tr><td class="paramname">row_size</td><td>in: the size of a row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b73d6eb69e73c6558f8ee97e21e097d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b73d6eb69e73c6558f8ee97e21e097d">&#9670;&nbsp;</a></span>trx_i_s_cache_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trx_i_s_cache_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a cache empty, preparing it to be filled up. </p>
<p>Not all resources are freed because they can be reused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>out: cache to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a022ba6bc11e4aad5a7848b34712f5891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022ba6bc11e4aad5a7848b34712f5891">&#9670;&nbsp;</a></span>trx_i_s_cache_end_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trx_i_s_cache_end_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a shared/read lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9e21422c1d882e1100d5610b76335e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e21422c1d882e1100d5610b76335e9">&#9670;&nbsp;</a></span>trx_i_s_cache_end_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trx_i_s_cache_end_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release an exclusive/write lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad98ffa7fe0c173b75525eadc392863ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98ffa7fe0c173b75525eadc392863ae">&#9670;&nbsp;</a></span>trx_i_s_cache_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trx_i_s_cache_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the INFORMATION SCHEMA trx related cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in, own: cache to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdd126598c3e4405111a2e20fd0fa6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd126598c3e4405111a2e20fd0fa6e2">&#9670;&nbsp;</a></span>trx_i_s_cache_get_nth_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* trx_i_s_cache_get_nth_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a>&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the nth row (zero-based) in the cache for a given INFORMATION SCHEMA table. </p>
<p>Retrieves the nth row in the cache for a given INFORMATION SCHEMA table.</p>
<dl class="section return"><dt>Returns</dt><dd>row </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
    <tr><td class="paramname">table</td><td>in: which table </td></tr>
    <tr><td class="paramname">n</td><td>in: row number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9943f9b1ae6005747b245d0b046fb49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9943f9b1ae6005747b245d0b046fb49a">&#9670;&nbsp;</a></span>trx_i_s_cache_get_rows_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint trx_i_s_cache_get_rows_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a>&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of used rows in the cache for a given INFORMATION SCHEMA table. </p>
<dl class="section return"><dt>Returns</dt><dd>number of rows </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
    <tr><td class="paramname">table</td><td>in: which table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff6e37691cd8be8e0a636d471a243238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6e37691cd8be8e0a636d471a243238">&#9670;&nbsp;</a></span>trx_i_s_cache_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trx_i_s_cache_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize INFORMATION SCHEMA trx related cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>out: cache to init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e2e1366d36dbdce51996df969f44b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2e1366d36dbdce51996df969f44b6b">&#9670;&nbsp;</a></span>trx_i_s_cache_is_truncated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> trx_i_s_cache_is_truncated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the data in the cache is truncated due to the memory limit posed by TRX_I_S_MEM_LIMIT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>The cache </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if truncated </dd></dl>

</div>
</div>
<a id="a0aa579e6ee53c138cfe0273cea60a161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa579e6ee53c138cfe0273cea60a161">&#9670;&nbsp;</a></span>trx_i_s_cache_start_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trx_i_s_cache_start_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue a shared/read lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a332b4c742bec60712cc241d013881614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332b4c742bec60712cc241d013881614">&#9670;&nbsp;</a></span>trx_i_s_cache_start_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trx_i_s_cache_start_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issue an exclusive/write lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a177f2ea3aaba8523c2255b2d042df5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177f2ea3aaba8523c2255b2d042df5d1">&#9670;&nbsp;</a></span>trx_i_s_create_lock_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* trx_i_s_create_lock_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>lock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_id_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crafts a lock id string from a i_s_locks_row_t object. </p>
<p>Returns its second argument. This function aborts if there is not enough space in lock_id. Be sure to provide at least TRX_I_S_LOCK_ID_MAX_LEN + 1 if you want to be 100% sure that it will not abort. </p><dl class="section return"><dt>Returns</dt><dd>resulting lock id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>in: innodb_locks row </td></tr>
    <tr><td class="paramname">lock_id</td><td>out: resulting lock_id </td></tr>
    <tr><td class="paramname">lock_id_size</td><td>in: size of the lock id buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf99212d031b207506164bfcf879c30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf99212d031b207506164bfcf879c30c">&#9670;&nbsp;</a></span>trx_i_s_parse_lock_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trx_i_s_parse_lock_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses lock id into row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_id</td><td>Lock id generated with trx_i_s_create_lock_id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">row</td><td>Row to be filled in with data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LOCK_REC, LOCK_TABLE or 0 if failed to parse </dd></dl>

</div>
</div>
<a id="aa070c7602c8996c58468f95e29b5fb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa070c7602c8996c58468f95e29b5fb76">&#9670;&nbsp;</a></span>trx_i_s_possibly_fetch_data_into_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trx_i_s_possibly_fetch_data_into_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the transactions cache if it has not been read for some time. </p>
<p>Called from handler/i_s.cc. </p><dl class="section return"><dt>Returns</dt><dd>0 - fetched, 1 - not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6eaaebecf6b68bdbafcff69320d95f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eaaebecf6b68bdbafcff69320d95f5">&#9670;&nbsp;</a></span>wait_lock_get_heap_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint wait_lock_get_heap_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a record lock that is in waiting state retrieves the only bit that is set, for a table lock returns ULINT_UNDEFINED. </p>
<dl class="section return"><dt>Returns</dt><dd>record number within the heap </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae776510bfef6b30178572502d665622a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae776510bfef6b30178572502d665622a">&#9670;&nbsp;</a></span>LOCK_RECORD_ID_FORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* LOCK_RECORD_ID_FORMAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    UINT64PF <span class="stringliteral">&quot;:&quot;</span> SPACE_ID_PF <span class="stringliteral">&quot;:&quot;</span> PAGE_NO_PF <span class="stringliteral">&quot;:&quot;</span> ULINTPF <span class="stringliteral">&quot;:&quot;</span> UINT64PF</div></div><!-- fragment -->
</div>
</div>
<a id="aa54a65b757088a0f0d5502c3aaef8239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54a65b757088a0f0d5502c3aaef8239">&#9670;&nbsp;</a></span>LOCK_TABLE_ID_FORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* LOCK_TABLE_ID_FORMAT = UINT64PF &quot;:&quot; UINT64PF &quot;:&quot; UINT64PF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c1b818f2d1a1be140a20a25978cbdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1b818f2d1a1be140a20a25978cbdc6">&#9670;&nbsp;</a></span>trx_i_s_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a>* trx_i_s_cache = &amp;<a class="el" href="trx0i__s_8cc.html#addf3c2fcb0413ec13456ef23a7ceb374">trx_i_s_cache_static</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the intermediate buffer where data needed to fill the INFORMATION SCHEMA tables is fetched and later retrieved by the C++ code in handler/i_s.cc. </p>

</div>
</div>
<a id="addf3c2fcb0413ec13456ef23a7ceb374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf3c2fcb0413ec13456ef23a7ceb374">&#9670;&nbsp;</a></span>trx_i_s_cache_static</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> trx_i_s_cache_static</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the intermediate buffer where data needed to fill the INFORMATION SCHEMA tables is fetched and later retrieved by the C++ code in handler/i_s.cc. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_7d6b8692e14baa729600e27a3e4f8b7c.html">trx</a></li><li class="navelem"><a class="el" href="trx0i__s_8cc.html">trx0i_s.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
