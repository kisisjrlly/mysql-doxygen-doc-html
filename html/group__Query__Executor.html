<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Query Executor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Query__Executor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Query Executor</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPendingInvalidator.html">PendingInvalidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to PendingCondition, but for cache invalidator iterators.  <a href="structPendingInvalidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8c797c5c988bd78790c147c626a4ed98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga8c797c5c988bd78790c147c626a4ed98">CallingContext</a> { <a class="el" href="group__Query__Executor.html#gga8c797c5c988bd78790c147c626a4ed98a51f6c706c1d0e0d7a5f4ae4530b52179">TOP_LEVEL</a>, 
<a class="el" href="group__Query__Executor.html#gga8c797c5c988bd78790c147c626a4ed98a7783926cbb6e963ecc8b23d047baf823">DIRECTLY_UNDER_SEMIJOIN</a>, 
<a class="el" href="group__Query__Executor.html#gga8c797c5c988bd78790c147c626a4ed98a3b24fe729895ed418faa2c63bb97c410">DIRECTLY_UNDER_OUTER_JOIN</a>, 
<a class="el" href="group__Query__Executor.html#gga8c797c5c988bd78790c147c626a4ed98a6fa28ce960e1bf879278a8f2c353c201">DIRECTLY_UNDER_WEEDOUT</a>
 }</td></tr>
<tr class="separator:ga8c797c5c988bd78790c147c626a4ed98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4f36f2eb08c32a2b6e1ca17af68b8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga3f4f36f2eb08c32a2b6e1ca17af68b8d">Substructure</a> { <a class="el" href="group__Query__Executor.html#gga3f4f36f2eb08c32a2b6e1ca17af68b8dab50339a10e1de285ac99d4c3990b8693">Substructure::NONE</a>, 
<a class="el" href="group__Query__Executor.html#gga3f4f36f2eb08c32a2b6e1ca17af68b8dabd2f93b6a8d173bc0cd3085d57241289">Substructure::OUTER_JOIN</a>, 
<a class="el" href="group__Query__Executor.html#gga3f4f36f2eb08c32a2b6e1ca17af68b8da8e910ccf0b077f4ec0307c7a21a8832a">Substructure::SEMIJOIN</a>, 
<a class="el" href="group__Query__Executor.html#gga3f4f36f2eb08c32a2b6e1ca17af68b8daccb0239da87e8136e88f9e805098367a">Substructure::WEEDOUT</a>
 }</td></tr>
<tr class="separator:ga3f4f36f2eb08c32a2b6e1ca17af68b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga93e1c9349177ad00a2e6d12407948983"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga93e1c9349177ad00a2e6d12407948983">read_system</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:ga93e1c9349177ad00a2e6d12407948983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a constant table when there is at most one matching row, using a table scan.  <a href="#ga93e1c9349177ad00a2e6d12407948983">More...</a><br /></td></tr>
<tr class="separator:ga93e1c9349177ad00a2e6d12407948983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7395c445fc104deabd71269c781f72e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gad7395c445fc104deabd71269c781f72e">read_const</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref)</td></tr>
<tr class="separator:gad7395c445fc104deabd71269c781f72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52ebe3c9c6871fef6843897b1b19128"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa52ebe3c9c6871fef6843897b1b19128">alloc_group_fields</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structORDER.html">ORDER</a> *group)</td></tr>
<tr class="memdesc:gaa52ebe3c9c6871fef6843897b1b19128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of buffers for saveing last group.  <a href="#gaa52ebe3c9c6871fef6843897b1b19128">More...</a><br /></td></tr>
<tr class="separator:gaa52ebe3c9c6871fef6843897b1b19128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed6faa31b5e6c2a133319003750c40c"><td class="memItemLeft" align="right" valign="top">static pair&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga6ed6faa31b5e6c2a133319003750c40c">FindKeyBufferAndMap</a> (const <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref)</td></tr>
<tr class="separator:ga6ed6faa31b5e6c2a133319003750c40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36761d9bbac5b5399388f60ff5681874"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga36761d9bbac5b5399388f60ff5681874">RefToString</a> (const <a class="el" href="structTABLE__REF.html">TABLE_REF</a> &amp;ref, const <a class="el" href="classKEY.html">KEY</a> *<a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> include_nulls)</td></tr>
<tr class="separator:ga36761d9bbac5b5399388f60ff5681874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3515e68b7acd867a377778b9d2502876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga3515e68b7acd867a377778b9d2502876">has_rollup_result</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:ga3515e68b7acd867a377778b9d2502876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an item has a ROLLUP NULL which needs to be written to temp table.  <a href="#ga3515e68b7acd867a377778b9d2502876">More...</a><br /></td></tr>
<tr class="separator:ga3515e68b7acd867a377778b9d2502876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150aaa4485e63c642a36e69cb19e9579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga150aaa4485e63c642a36e69cb19e9579">is_rollup_group_wrapper</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:ga150aaa4485e63c642a36e69cb19e9579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc8ddae35cf7e68020a89d25189fb7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gacdc8ddae35cf7e68020a89d25189fb7e">is_rollup_sum_wrapper</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:gacdc8ddae35cf7e68020a89d25189fb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f275d3bce8cc10d2f624b3ed824b01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga58f275d3bce8cc10d2f624b3ed824b01">unwrap_rollup_group</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:ga58f275d3bce8cc10d2f624b3ed824b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbccddf1e369c7c5d7604c4ed6634ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gafbccddf1e369c7c5d7604c4ed6634ae3">prepare_sum_aggregators</a> (<a class="el" href="classItem__sum.html">Item_sum</a> **sum_funcs, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> need_distinct)</td></tr>
<tr class="separator:gafbccddf1e369c7c5d7604c4ed6634ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1125b75ed00a408f039bb83de7c480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1b1125b75ed00a408f039bb83de7c480">setup_sum_funcs</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem__sum.html">Item_sum</a> **func_ptr)</td></tr>
<tr class="memdesc:ga1b1125b75ed00a408f039bb83de7c480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>setup()</code> for all sum functions.  <a href="#ga1b1125b75ed00a408f039bb83de7c480">More...</a><br /></td></tr>
<tr class="separator:ga1b1125b75ed00a408f039bb83de7c480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f722697f934789019b3a9395ac72f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga08f722697f934789019b3a9395ac72f7">init_tmptable_sum_functions</a> (<a class="el" href="classItem__sum.html">Item_sum</a> **func_ptr)</td></tr>
<tr class="separator:ga08f722697f934789019b3a9395ac72f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c7ce3fe066b0eef700dde8c8c11a9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gab9c7ce3fe066b0eef700dde8c8c11a9e">update_tmptable_sum_func</a> (<a class="el" href="classItem__sum.html">Item_sum</a> **func_ptr, <a class="el" href="structTABLE.html">TABLE</a> *tmp_table)</td></tr>
<tr class="memdesc:gab9c7ce3fe066b0eef700dde8c8c11a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update record 0 in tmp_table from record 1.  <a href="#gab9c7ce3fe066b0eef700dde8c8c11a9e">More...</a><br /></td></tr>
<tr class="separator:gab9c7ce3fe066b0eef700dde8c8c11a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21679aa16ae84b53b4c55d5e023c1dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga21679aa16ae84b53b4c55d5e023c1dec">copy_funcs</a> (<a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="sql__executor_8h.html#adacecf3d31cd9bd64698758b3365995c">Copy_func_type</a> type)</td></tr>
<tr class="memdesc:ga21679aa16ae84b53b4c55d5e023c1dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy result of functions to record in tmp_table.  <a href="#ga21679aa16ae84b53b4c55d5e023c1dec">More...</a><br /></td></tr>
<tr class="separator:ga21679aa16ae84b53b4c55d5e023c1dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa992f905fbc700aa838569b164c7da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga7aa992f905fbc700aa838569b164c7da">update_const_equal_items</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="memdesc:ga7aa992f905fbc700aa838569b164c7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check appearance of new constant items in multiple equalities of a condition after reading a constant table.  <a href="#ga7aa992f905fbc700aa838569b164c7da">More...</a><br /></td></tr>
<tr class="separator:ga7aa992f905fbc700aa838569b164c7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5120e564d6decdcc43526a56a05fb81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga5120e564d6decdcc43526a56a05fb81b">setup_tmptable_write_func</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *trace)</td></tr>
<tr class="memdesc:ga5120e564d6decdcc43526a56a05fb81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup write_func of QEP_tmp_table object.  <a href="#ga5120e564d6decdcc43526a56a05fb81b">More...</a><br /></td></tr>
<tr class="separator:ga5120e564d6decdcc43526a56a05fb81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426a26799906018ac4c241e6a9f82c19"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga426a26799906018ac4c241e6a9f82c19">record_prefix_size</a> (const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab)</td></tr>
<tr class="memdesc:ga426a26799906018ac4c241e6a9f82c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out how many bytes it takes to store the smallest prefix which covers all the columns that will be read from a table.  <a href="#ga426a26799906018ac4c241e6a9f82c19">More...</a><br /></td></tr>
<tr class="separator:ga426a26799906018ac4c241e6a9f82c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23917fca2e9514cd1d23a434e4b629e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae23917fca2e9514cd1d23a434e4b629e">set_record_buffer</a> (const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="memdesc:gae23917fca2e9514cd1d23a434e4b629e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a data buffer that the storage engine can use for fetching batches of records.  <a href="#gae23917fca2e9514cd1d23a434e4b629e">More...</a><br /></td></tr>
<tr class="separator:gae23917fca2e9514cd1d23a434e4b629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf367b44a0b89dec84a3f5fee35d7bf0b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf367b44a0b89dec84a3f5fee35d7bf0b">ExtractConditions</a> (<a class="el" href="classItem.html">Item</a> *condition, vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *condition_parts)</td></tr>
<tr class="memdesc:gaf367b44a0b89dec84a3f5fee35d7bf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split AND conditions into their constituent parts, recursively.  <a href="#gaf367b44a0b89dec84a3f5fee35d7bf0b">More...</a><br /></td></tr>
<tr class="separator:gaf367b44a0b89dec84a3f5fee35d7bf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78957c24392854d2c20e7a6893bd6201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga78957c24392854d2c20e7a6893bd6201">PossiblyAttachFilter</a> (<a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>, const vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;conditions, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *conditions_depend_on_outer_tables)</td></tr>
<tr class="memdesc:ga78957c24392854d2c20e7a6893bd6201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new iterator that wraps "iterator" and that tests all of the given conditions (if any), ANDed together.  <a href="#ga78957c24392854d2c20e7a6893bd6201">More...</a><br /></td></tr>
<tr class="separator:ga78957c24392854d2c20e7a6893bd6201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aedc885dff47075d06cf4e589406fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4aedc885dff47075d06cf4e589406fec">CreateNestedLoopAccessPath</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structAccessPath.html">AccessPath</a> *outer, <a class="el" href="structAccessPath.html">AccessPath</a> *inner, <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> pfs_batch_mode)</td></tr>
<tr class="separator:ga4aedc885dff47075d06cf4e589406fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc32faacc661ed367fa2bb66d6912d17"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gadc32faacc661ed367fa2bb66d6912d17">NewInvalidatorAccessPathForTable</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab)</td></tr>
<tr class="separator:gadc32faacc661ed367fa2bb66d6912d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35edd7d52f8679c5837117f19debccac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga35edd7d52f8679c5837117f19debccac">ConvertQepTabMapToTableMap</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> tables)</td></tr>
<tr class="separator:ga35edd7d52f8679c5837117f19debccac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db7421445cca3a7f481d534789f42c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga2db7421445cca3a7f481d534789f42c5">CreateBKAAccessPath</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structAccessPath.html">AccessPath</a> *outer_path, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> left_tables, <a class="el" href="structAccessPath.html">AccessPath</a> *inner_path, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> right_tables, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>)</td></tr>
<tr class="separator:ga2db7421445cca3a7f481d534789f42c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0797342b3cb61f1a67d219711d840f41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga0797342b3cb61f1a67d219711d840f41">PossiblyAttachFilter</a> (<a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>, const vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; &amp;conditions, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *conditions_depend_on_outer_tables)</td></tr>
<tr class="separator:ga0797342b3cb61f1a67d219711d840f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91943ce2f0f43e926db7ed885d704405"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem__func__trig__cond.html">Item_func_trig_cond</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga91943ce2f0f43e926db7ed885d704405">GetTriggerCondOrNull</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:ga91943ce2f0f43e926db7ed885d704405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7987a8fe4b52b792ff19c3dde8eaf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga7d7987a8fe4b52b792ff19c3dde8eaf5">ConvertItemsToCopy</a> (const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;<a class="el" href="structitems.html">items</a>, <a class="el" href="classField.html">Field</a> **fields, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param)</td></tr>
<tr class="memdesc:ga7d7987a8fe4b52b792ff19c3dde8eaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For historical reasons, derived table materialization and temporary table materialization didn't specify the fields to materialize in the same way.  <a href="#ga7d7987a8fe4b52b792ff19c3dde8eaf5">More...</a><br /></td></tr>
<tr class="separator:ga7d7987a8fe4b52b792ff19c3dde8eaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f7d5f437c2749423958ecfe058d467"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga45f7d5f437c2749423958ecfe058d467">IsJoinCondition</a> (const <a class="el" href="classItem.html">Item</a> *item, const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab)</td></tr>
<tr class="separator:ga45f7d5f437c2749423958ecfe058d467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa876a1a74a29fb3705e13b39603fd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gadaa876a1a74a29fb3705e13b39603fd2">GetInnermostCondition</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:gadaa876a1a74a29fb3705e13b39603fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace896571e2a7a64f937cad6454eae05f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gace896571e2a7a64f937cad6454eae05f">SplitConditions</a> (<a class="el" href="classItem.html">Item</a> *condition, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *current_table, vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *predicates_below_join, vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *predicates_above_join, vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *join_conditions)</td></tr>
<tr class="separator:gace896571e2a7a64f937cad6454eae05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ee5f67ddaa4ee2097b0a5b8491ad7f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga72ee5f67ddaa4ee2097b0a5b8491ad7f">MarkUnhandledDuplicates</a> (<a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *weedout, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> weedout_start, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> weedout_end, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> *unhandled_duplicates)</td></tr>
<tr class="memdesc:ga72ee5f67ddaa4ee2097b0a5b8491ad7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given duplicate weedout operation, figure out which tables are supposed to be deduplicated by it, and add those to unhandled_duplicates.  <a href="#ga72ee5f67ddaa4ee2097b0a5b8491ad7f">More...</a><br /></td></tr>
<tr class="separator:ga72ee5f67ddaa4ee2097b0a5b8491ad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2fe7152960dd8e79c1e0c540f4b28f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae2fe7152960dd8e79c1e0c540f4b28f7">CreateWeedoutOrLimitAccessPath</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>, <a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *weedout_table)</td></tr>
<tr class="separator:gae2fe7152960dd8e79c1e0c540f4b28f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535c87c5015da40c4fbef0fd02908757"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga535c87c5015da40c4fbef0fd02908757">NewWeedoutAccessPathForTables</a> (<a class="el" href="classTHD.html">THD</a> *thd, const <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> tables_to_deduplicate, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tabs, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> primary_tables, <a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>)</td></tr>
<tr class="separator:ga535c87c5015da40c4fbef0fd02908757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d358a3f43ff185b9d70ce002581cc29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__Query__Executor.html#ga3f4f36f2eb08c32a2b6e1ca17af68b8d">Substructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1d358a3f43ff185b9d70ce002581cc29">FindSubstructure</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tabs, const <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> first_idx, const <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> this_idx, const <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> last_idx, <a class="el" href="group__Query__Executor.html#ga8c797c5c988bd78790c147c626a4ed98">CallingContext</a> calling_context, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *add_limit_1, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> *substructure_end, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> *unhandled_duplicates)</td></tr>
<tr class="memdesc:ga1d358a3f43ff185b9d70ce002581cc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a range of tables (where we assume that we've already handled first_idx..(this_idx-1) as inner joins), figure out whether this is a semijoin, an outer join or a weedout.  <a href="#ga1d358a3f43ff185b9d70ce002581cc29">More...</a><br /></td></tr>
<tr class="separator:ga1d358a3f43ff185b9d70ce002581cc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2359b14612486e60a65a29391e19ac87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga2359b14612486e60a65a29391e19ac87">IsTableScan</a> (<a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>)</td></tr>
<tr class="separator:ga2359b14612486e60a65a29391e19ac87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20722285e2e89c53db1e5cfc52ca1862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga20722285e2e89c53db1e5cfc52ca1862">GetAccessPathForDerivedTable</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, <a class="el" href="structAccessPath.html">AccessPath</a> *table_path)</td></tr>
<tr class="separator:ga20722285e2e89c53db1e5cfc52ca1862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4937df76f2f72e5bac829a2aca40f0cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4937df76f2f72e5bac829a2aca40f0cf">GetTableAccessPath</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tabs)</td></tr>
<tr class="memdesc:ga4937df76f2f72e5bac829a2aca40f0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RowIterator used for scanning the given table, with any required materialization operations done first.  <a href="#ga4937df76f2f72e5bac829a2aca40f0cf">More...</a><br /></td></tr>
<tr class="separator:ga4937df76f2f72e5bac829a2aca40f0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b0d6fb3a7d21883b27bab7d679116d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gab9b0d6fb3a7d21883b27bab7d679116d">SetCostOnTableAccessPath</a> (const <a class="el" href="classCost__model__server.html">Cost_model_server</a> &amp;cost_model, const <a class="el" href="structPOSITION.html">POSITION</a> *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_after_filter, <a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>)</td></tr>
<tr class="separator:gab9b0d6fb3a7d21883b27bab7d679116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f19e20c1f1fe8b9e9abb4781c51202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga51f19e20c1f1fe8b9e9abb4781c51202">SetCostOnNestedLoopAccessPath</a> (const <a class="el" href="classCost__model__server.html">Cost_model_server</a> &amp;cost_model, const <a class="el" href="structPOSITION.html">POSITION</a> *pos_inner, <a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>)</td></tr>
<tr class="separator:ga51f19e20c1f1fe8b9e9abb4781c51202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c05864b7f384582256d95e7e98dbc82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga6c05864b7f384582256d95e7e98dbc82">SetCostOnHashJoinAccessPath</a> (const <a class="el" href="classCost__model__server.html">Cost_model_server</a> &amp;cost_model, const <a class="el" href="structPOSITION.html">POSITION</a> *pos_outer, <a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>)</td></tr>
<tr class="separator:ga6c05864b7f384582256d95e7e98dbc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcbd7d6f284c82e15bca0918f4ce7ac0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gadcbd7d6f284c82e15bca0918f4ce7ac0">ConditionIsAlwaysTrue</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:gadcbd7d6f284c82e15bca0918f4ce7ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17886ea0f6b2f0b69395ede8958c305a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga17886ea0f6b2f0b69395ede8958c305a">ItemRefersToOneSideOnly</a> (<a class="el" href="classItem.html">Item</a> *item, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> left_side, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> right_side)</td></tr>
<tr class="separator:ga17886ea0f6b2f0b69395ede8958c305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa90f6e2da30eb7413fc1a656491cfc31"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa90f6e2da30eb7413fc1a656491cfc31">CreateHashJoinAccessPath</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, <a class="el" href="structAccessPath.html">AccessPath</a> *build_path, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> build_tables, <a class="el" href="structAccessPath.html">AccessPath</a> *probe_path, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> probe_tables, <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>, vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *join_conditions, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *conditions_depend_on_outer_tables)</td></tr>
<tr class="separator:gaa90f6e2da30eb7413fc1a656491cfc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ccef0cc2bf69c64b536a599cd0dd68"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga34ccef0cc2bf69c64b536a599cd0dd68">ExtractJoinConditions</a> (const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *current_table, vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *predicates, vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *join_conditions)</td></tr>
<tr class="separator:ga34ccef0cc2bf69c64b536a599cd0dd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc42681cef0b442738f450f9992c3fd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gafc42681cef0b442738f450f9992c3fd2">SubtreeHasIncompletePushedJoin</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> subtree)</td></tr>
<tr class="separator:gafc42681cef0b442738f450f9992c3fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ee97e14497da8883a660e09671b250"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga25ee97e14497da8883a660e09671b250">PushedJoinRejectsHashJoin</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> left_subtree, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> right_subtree, <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>)</td></tr>
<tr class="separator:ga25ee97e14497da8883a660e09671b250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf488e159058bf20eebc5447769fcf41a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf488e159058bf20eebc5447769fcf41a">UseHashJoin</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab)</td></tr>
<tr class="separator:gaf488e159058bf20eebc5447769fcf41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga298707b5a21869b33bcf463a5b89de0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga298707b5a21869b33bcf463a5b89de0b">UseBKA</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab)</td></tr>
<tr class="separator:ga298707b5a21869b33bcf463a5b89de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga536ddcdca5d3f80469f97fb4a07d4d28"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga536ddcdca5d3f80469f97fb4a07d4d28">QueryMixesOuterBKAAndBNL</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="separator:ga536ddcdca5d3f80469f97fb4a07d4d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085cd005174ba9cb76f820c8a6523643"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga085cd005174ba9cb76f820c8a6523643">InsideOuterOrAntiJoin</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab)</td></tr>
<tr class="separator:ga085cd005174ba9cb76f820c8a6523643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c4b8b00c1ff454f9600b1d3095c329"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae9c4b8b00c1ff454f9600b1d3095c329"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae9c4b8b00c1ff454f9600b1d3095c329">PickOutConditionsForTableIndex</a> (int table_idx, vector&lt; T &gt; *from, vector&lt; T &gt; *to)</td></tr>
<tr class="separator:gae9c4b8b00c1ff454f9600b1d3095c329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9fef0d874bc0ace0b6bf6b7d99ed01d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa9fef0d874bc0ace0b6bf6b7d99ed01d">PickOutConditionsForTableIndex</a> (int table_idx, vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *from, vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *to)</td></tr>
<tr class="separator:gaa9fef0d874bc0ace0b6bf6b7d99ed01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780b0a041678fa78ec4816f4c0562117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga780b0a041678fa78ec4816f4c0562117">FinishPendingOperations</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *remove_duplicates_loose_scan_qep_tab, const vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; &amp;pending_conditions, const vector&lt; <a class="el" href="structPendingInvalidator.html">PendingInvalidator</a> &gt; &amp;pending_invalidators, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *conditions_depend_on_outer_tables)</td></tr>
<tr class="separator:ga780b0a041678fa78ec4816f4c0562117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058767e277320c8f6d94be22e070f52d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga058767e277320c8f6d94be22e070f52d">ConnectJoins</a> (<a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> upper_first_idx, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> first_idx, <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> last_idx, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tabs, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="group__Query__Executor.html#ga8c797c5c988bd78790c147c626a4ed98">CallingContext</a> calling_context, vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *pending_conditions, vector&lt; <a class="el" href="structPendingInvalidator.html">PendingInvalidator</a> &gt; *pending_invalidators, vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *pending_join_conditions, <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> *unhandled_duplicates, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *conditions_depend_on_outer_tables)</td></tr>
<tr class="memdesc:ga058767e277320c8f6d94be22e070f52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given slice of the table list, build up the iterator tree corresponding to the tables in that slice.  <a href="#ga058767e277320c8f6d94be22e070f52d">More...</a><br /></td></tr>
<tr class="separator:ga058767e277320c8f6d94be22e070f52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3b77b483fa5b7bcefe0f38587480c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *sjtbl)</td></tr>
<tr class="memdesc:ga4c3b77b483fa5b7bcefe0f38587480c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SemiJoinDuplicateElimination: Weed out duplicate row combinations.  <a href="#ga4c3b77b483fa5b7bcefe0f38587480c8">More...</a><br /></td></tr>
<tr class="separator:ga4c3b77b483fa5b7bcefe0f38587480c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb800e0e68d03a1b49a9cf66fda4006"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4fb800e0e68d03a1b49a9cf66fda4006">report_handler_error</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, int error)</td></tr>
<tr class="memdesc:ga4fb800e0e68d03a1b49a9cf66fda4006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Help function when we get some an error from the table handler.  <a href="#ga4fb800e0e68d03a1b49a9cf66fda4006">More...</a><br /></td></tr>
<tr class="separator:ga4fb800e0e68d03a1b49a9cf66fda4006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c659fe42f396022e5186e7a848c1501"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4c659fe42f396022e5186e7a848c1501">init_index_and_record_buffer</a> (const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, <a class="el" href="classhandler.html">handler</a> *file, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sorted)</td></tr>
<tr class="memdesc:ga4c659fe42f396022e5186e7a848c1501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an index scan and the record buffer to use in the scan.  <a href="#ga4c659fe42f396022e5186e7a848c1501">More...</a><br /></td></tr>
<tr class="separator:ga4c659fe42f396022e5186e7a848c1501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6634e09c549559c5547496bf849a6c0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga6634e09c549559c5547496bf849a6c0d">safe_index_read</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:ga6634e09c549559c5547496bf849a6c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c30d89f411ee0d12ecd4824f9aae1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga39c30d89f411ee0d12ecd4824f9aae1a">join_read_const_table</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="structPOSITION.html">POSITION</a> *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>)</td></tr>
<tr class="memdesc:ga39c30d89f411ee0d12ecd4824f9aae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads content of constant table.  <a href="#ga39c30d89f411ee0d12ecd4824f9aae1a">More...</a><br /></td></tr>
<tr class="separator:ga39c30d89f411ee0d12ecd4824f9aae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62593e120f4a7daddbbab4ffbe862485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga62593e120f4a7daddbbab4ffbe862485">get_exact_record_count</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> table_count, int *error)</td></tr>
<tr class="memdesc:ga62593e120f4a7daddbbab4ffbe862485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get exact count of rows in all tables.  <a href="#ga62593e120f4a7daddbbab4ffbe862485">More...</a><br /></td></tr>
<tr class="separator:ga62593e120f4a7daddbbab4ffbe862485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9c09ad4f484a72f2c19c44127be744"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga2b9c09ad4f484a72f2c19c44127be744">cmp_field_value</a> (<a class="el" href="classField.html">Field</a> *field, ptrdiff_t <a class="el" href="dtoa_8cc.html#a158860430cb5f139d88fdf19cf9ad511">diff</a>)</td></tr>
<tr class="separator:ga2b9c09ad4f484a72f2c19c44127be744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edde56152f96e1f2abf26e65dea232f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1edde56152f96e1f2abf26e65dea232f">group_rec_cmp</a> (<a class="el" href="structORDER.html">ORDER</a> *group, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *rec0, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *rec1)</td></tr>
<tr class="memdesc:ga1edde56152f96e1f2abf26e65dea232f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare GROUP BY in from tmp table's record[0] and record[1].  <a href="#ga1edde56152f96e1f2abf26e65dea232f">More...</a><br /></td></tr>
<tr class="separator:ga1edde56152f96e1f2abf26e65dea232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8033260452204b4682aa0acfa55e672d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga8033260452204b4682aa0acfa55e672d">table_rec_cmp</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:ga8033260452204b4682aa0acfa55e672d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare GROUP BY in from tmp table's record[0] and record[1].  <a href="#ga8033260452204b4682aa0acfa55e672d">More...</a><br /></td></tr>
<tr class="separator:ga8033260452204b4682aa0acfa55e672d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cf740429a9794655ec3c658f85e331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga43cf740429a9794655ec3c658f85e331">unique_hash</a> (const <a class="el" href="classField.html">Field</a> *field, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *hash_val)</td></tr>
<tr class="memdesc:ga43cf740429a9794655ec3c658f85e331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate hash for a field.  <a href="#ga43cf740429a9794655ec3c658f85e331">More...</a><br /></td></tr>
<tr class="separator:ga43cf740429a9794655ec3c658f85e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efd0b16d185a2051ee62e2d11fa5284"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga9efd0b16d185a2051ee62e2d11fa5284">unique_hash_group</a> (<a class="el" href="structORDER.html">ORDER</a> *group)</td></tr>
<tr class="memdesc:ga9efd0b16d185a2051ee62e2d11fa5284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate hash for unique constraint according to group-by list.  <a href="#ga9efd0b16d185a2051ee62e2d11fa5284">More...</a><br /></td></tr>
<tr class="separator:ga9efd0b16d185a2051ee62e2d11fa5284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a419d73d40c0de7432c6c09caf076d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1a419d73d40c0de7432c6c09caf076d8">unique_hash_fields</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga1a419d73d40c0de7432c6c09caf076d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90a4e0bf6e706b42c25d6649e105bd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga90a4e0bf6e706b42c25d6649e105bd87">check_unique_constraint</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:ga90a4e0bf6e706b42c25d6649e105bd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check unique_constraint.  <a href="#ga90a4e0bf6e706b42c25d6649e105bd87">More...</a><br /></td></tr>
<tr class="separator:ga90a4e0bf6e706b42c25d6649e105bd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a12f9d0a65ad11750f6fdd206a6759"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gad4a12f9d0a65ad11750f6fdd206a6759">reset_wf_states</a> (<a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *func_ptr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> framing)</td></tr>
<tr class="memdesc:gad4a12f9d0a65ad11750f6fdd206a6759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minion for reset_framing_wf_states and reset_non_framing_wf_state, q.v.  <a href="#gad4a12f9d0a65ad11750f6fdd206a6759">More...</a><br /></td></tr>
<tr class="separator:gad4a12f9d0a65ad11750f6fdd206a6759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ff8f5c3f225f3116905dd3ea4c7080"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga26ff8f5c3f225f3116905dd3ea4c7080">reset_framing_wf_states</a> (<a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *func_ptr)</td></tr>
<tr class="memdesc:ga26ff8f5c3f225f3116905dd3ea4c7080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the function calls and reset any framing window function's window state.  <a href="#ga26ff8f5c3f225f3116905dd3ea4c7080">More...</a><br /></td></tr>
<tr class="separator:ga26ff8f5c3f225f3116905dd3ea4c7080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199450a2c1eb75877618451735691489"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga199450a2c1eb75877618451735691489">reset_non_framing_wf_state</a> (<a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *func_ptr)</td></tr>
<tr class="memdesc:ga199450a2c1eb75877618451735691489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the function calls and reset any non-framing window function's window state.  <a href="#ga199450a2c1eb75877618451735691489">More...</a><br /></td></tr>
<tr class="separator:ga199450a2c1eb75877618451735691489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cda020c5f3fd5bf648021dad869b54"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga10cda020c5f3fd5bf648021dad869b54">buffer_record_somewhere</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classWindow.html">Window</a> *w, <a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rowno)</td></tr>
<tr class="memdesc:ga10cda020c5f3fd5bf648021dad869b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a window frame buffer to frame buffer temporary table.  <a href="#ga10cda020c5f3fd5bf648021dad869b54">More...</a><br /></td></tr>
<tr class="separator:ga10cda020c5f3fd5bf648021dad869b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff47721cb11cd1727801c0d6f2b27cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaff47721cb11cd1727801c0d6f2b27cfa">buffer_windowing_record</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *new_partition)</td></tr>
<tr class="memdesc:gaff47721cb11cd1727801c0d6f2b27cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we cannot evaluate all window functions for a window on the fly, buffer the current row for later processing by process_buffered_windowing_record.  <a href="#gaff47721cb11cd1727801c0d6f2b27cfa">More...</a><br /></td></tr>
<tr class="separator:gaff47721cb11cd1727801c0d6f2b27cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf318e26d5c9edfd906c39cdcdb274b91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf318e26d5c9edfd906c39cdcdb274b91">read_frame_buffer_row</a> (<a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rowno, <a class="el" href="classWindow.html">Window</a> *w, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> for_nth_value)</td></tr>
<tr class="memdesc:gaf318e26d5c9edfd906c39cdcdb274b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read row rowno from frame buffer tmp file using cached row positions to minimize positioning work.  <a href="#gaf318e26d5c9edfd906c39cdcdb274b91">More...</a><br /></td></tr>
<tr class="separator:gaf318e26d5c9edfd906c39cdcdb274b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137a2027c57feb8037c9702db709286a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga137a2027c57feb8037c9702db709286a">dbug_allow_write_all_columns</a> (<a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, std::map&lt; <a class="el" href="structTABLE.html">TABLE</a> *, <a class="el" href="my__bitmap_8h.html#a0e2e55f75043954d274fc72371eb3a08">my_bitmap_map</a> *&gt; &amp;map)</td></tr>
<tr class="separator:ga137a2027c57feb8037c9702db709286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc59132a8690c65e93e77c1202e14454"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gabc59132a8690c65e93e77c1202e14454">dbug_restore_all_columns</a> (std::map&lt; <a class="el" href="structTABLE.html">TABLE</a> *, <a class="el" href="my__bitmap_8h.html#a0e2e55f75043954d274fc72371eb3a08">my_bitmap_map</a> *&gt; &amp;map)</td></tr>
<tr class="separator:gabc59132a8690c65e93e77c1202e14454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ee8b05bc58208fcc22e122e1a67dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf0ee8b05bc58208fcc22e122e1a67dd0">bring_back_frame_row</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classWindow.html">Window</a> *w, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *out_param, <a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> rowno, <a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a> reason, int fno)</td></tr>
<tr class="memdesc:gaf0ee8b05bc58208fcc22e122e1a67dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bring back buffered data to the record of qep_tab-1 [1], and optionally execute copy_fields() to the OUT table.  <a href="#gaf0ee8b05bc58208fcc22e122e1a67dd0">More...</a><br /></td></tr>
<tr class="separator:gaf0ee8b05bc58208fcc22e122e1a67dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05e3a4b9671ea418312965cf95a85a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gab05e3a4b9671ea418312965cf95a85a0">process_wfs_needing_card</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, const <a class="el" href="structWindow_1_1st__nth.html">Window::st_nth</a> &amp;have_nth_value, const <a class="el" href="structWindow_1_1st__lead__lag.html">Window::st_lead_lag</a> &amp;have_lead_lag, const <a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a> current_row, <a class="el" href="classWindow.html">Window</a> *w, <a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a> current_row_reason)</td></tr>
<tr class="memdesc:gab05e3a4b9671ea418312965cf95a85a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process window functions that need partition cardinality.  <a href="#gab05e3a4b9671ea418312965cf95a85a0">More...</a><br /></td></tr>
<tr class="separator:gab05e3a4b9671ea418312965cf95a85a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f2f4b89ac061448e138b0126f8a582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gac5f2f4b89ac061448e138b0126f8a582">process_buffered_windowing_record</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> new_partition_or_eof, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *output_row_ready)</td></tr>
<tr class="memdesc:gac5f2f4b89ac061448e138b0126f8a582"><td class="mdescLeft">&#160;</td><td class="mdescRight">While there are more unprocessed rows ready to process given the current partition/frame state, process such buffered rows by evaluating/aggregating the window functions defined over this window on the current frame, moving the frame if required.  <a href="#gac5f2f4b89ac061448e138b0126f8a582">More...</a><br /></td></tr>
<tr class="separator:gac5f2f4b89ac061448e138b0126f8a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fc6ed4bd78e82a16f09c4a36bf768b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gad4fc6ed4bd78e82a16f09c4a36bf768b">construct_lookup_ref</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref)</td></tr>
<tr class="memdesc:gad4fc6ed4bd78e82a16f09c4a36bf768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the lookup key into the table ref's key buffer.  <a href="#gad4fc6ed4bd78e82a16f09c4a36bf768b">More...</a><br /></td></tr>
<tr class="separator:gad4fc6ed4bd78e82a16f09c4a36bf768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bd2dbcf106da50227e2eb4932b588d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa0bd2dbcf106da50227e2eb4932b588d">make_group_fields</a> (<a class="el" href="classJOIN.html">JOIN</a> *main_join, <a class="el" href="classJOIN.html">JOIN</a> *curr_join)</td></tr>
<tr class="memdesc:gaa0bd2dbcf106da50227e2eb4932b588d"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate group fields or take prepared (cached).  <a href="#gaa0bd2dbcf106da50227e2eb4932b588d">More...</a><br /></td></tr>
<tr class="separator:gaa0bd2dbcf106da50227e2eb4932b588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5698b0cbef211efe2edf7bc2897f7e25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga5698b0cbef211efe2edf7bc2897f7e25">update_item_cache_if_changed</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCached__item.html">Cached_item</a> &gt; &amp;<a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">list</a>)</td></tr>
<tr class="separator:ga5698b0cbef211efe2edf7bc2897f7e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64fd19acccb626499e8b730439ca83f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga64fd19acccb626499e8b730439ca83f2">setup_copy_fields</a> (const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *res_fields)</td></tr>
<tr class="memdesc:ga64fd19acccb626499e8b730439ca83f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up caches for holding the values of non-aggregated expressions.  <a href="#ga64fd19acccb626499e8b730439ca83f2">More...</a><br /></td></tr>
<tr class="separator:ga64fd19acccb626499e8b730439ca83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad746e2883a2e4618d2acbb7736750070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gad746e2883a2e4618d2acbb7736750070">copy_fields</a> (<a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reverse_copy)</td></tr>
<tr class="memdesc:gad746e2883a2e4618d2acbb7736750070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of all simple SELECT'ed fields.  <a href="#gad746e2883a2e4618d2acbb7736750070">More...</a><br /></td></tr>
<tr class="separator:gad746e2883a2e4618d2acbb7736750070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ccbb1decda5b649a2cb9b327b8e7f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga9ccbb1decda5b649a2cb9b327b8e7f7f">copy_fields_and_funcs</a> (<a class="el" href="classTemp__table__param.html">Temp_table_param</a> *param, const <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="sql__executor_8h.html#adacecf3d31cd9bd64698758b3365995c">Copy_func_type</a> type)</td></tr>
<tr class="separator:ga9ccbb1decda5b649a2cb9b327b8e7f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4798eb113599c9b1f81fdb94a60d79a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4798eb113599c9b1f81fdb94a60d79a8">replace_embedded_rollup_references_with_tmp_fields</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields)</td></tr>
<tr class="memdesc:ga4798eb113599c9b1f81fdb94a60d79a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each rollup wrapper below the given item, replace it with a temporary field, e.g.  <a href="#ga4798eb113599c9b1f81fdb94a60d79a8">More...</a><br /></td></tr>
<tr class="separator:ga4798eb113599c9b1f81fdb94a60d79a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2327f19582cc172cacfcb3e7b4eb770d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga2327f19582cc172cacfcb3e7b4eb770d">change_to_use_tmp_fields</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *res_fields)</td></tr>
<tr class="memdesc:ga2327f19582cc172cacfcb3e7b4eb770d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change all funcs and sum_funcs to fields in tmp table, and create new list of all items.  <a href="#ga2327f19582cc172cacfcb3e7b4eb770d">More...</a><br /></td></tr>
<tr class="separator:ga2327f19582cc172cacfcb3e7b4eb770d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b11db7a1b6f33befa12f10a3fc5f6e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga0b11db7a1b6f33befa12f10a3fc5f6e1">replace_contents_of_rollup_wrappers_with_tmp_fields</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, <a class="el" href="classItem.html">Item</a> *item_arg)</td></tr>
<tr class="memdesc:ga0b11db7a1b6f33befa12f10a3fc5f6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each rollup wrapper below the given item, replace its argument with a temporary field, e.g.  <a href="#ga0b11db7a1b6f33befa12f10a3fc5f6e1">More...</a><br /></td></tr>
<tr class="separator:ga0b11db7a1b6f33befa12f10a3fc5f6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013b282a51d071fc499e52ef901bb877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga013b282a51d071fc499e52ef901bb877">change_to_use_tmp_fields_except_sums</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *res_fields)</td></tr>
<tr class="memdesc:ga013b282a51d071fc499e52ef901bb877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change all sum_func refs to fields to point at fields in tmp table.  <a href="#ga013b282a51d071fc499e52ef901bb877">More...</a><br /></td></tr>
<tr class="separator:ga013b282a51d071fc499e52ef901bb877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b001e6d45eab20782b8b3f2f7f0b3ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga3b001e6d45eab20782b8b3f2f7f0b3ea">JOIN::create_intermediate_table</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;tmp_table_fields, <a class="el" href="classORDER__with__src.html">ORDER_with_src</a> &amp;tmp_table_group, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> save_sum_fields)</td></tr>
<tr class="memdesc:ga3b001e6d45eab20782b8b3f2f7f0b3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a temporary table to be used for processing DISTINCT/ORDER BY/GROUP BY.  <a href="#ga3b001e6d45eab20782b8b3f2f7f0b3ea">More...</a><br /></td></tr>
<tr class="separator:ga3b001e6d45eab20782b8b3f2f7f0b3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c1673adeda51cbb4befa2faa444d10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga09c1673adeda51cbb4befa2faa444d10">JOIN::optimize_distinct</a> ()</td></tr>
<tr class="memdesc:ga09c1673adeda51cbb4befa2faa444d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize distinct when used on a subset of the tables.  <a href="#ga09c1673adeda51cbb4befa2faa444d10">More...</a><br /></td></tr>
<tr class="separator:ga09c1673adeda51cbb4befa2faa444d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa466010f700bf26cf0ea53bafe44bb5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQEP__TAB.html#ad047353d9aefbec7e174d5792c6941e9">QEP_TAB::enum_op_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa466010f700bf26cf0ea53bafe44bb5f">JOIN::get_end_select_func</a> ()</td></tr>
<tr class="separator:gaa466010f700bf26cf0ea53bafe44bb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01edc56308a73d4939bb025aef61595"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gad01edc56308a73d4939bb025aef61595">JOIN::create_access_paths</a> ()</td></tr>
<tr class="memdesc:gad01edc56308a73d4939bb025aef61595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the executor structures to a set of access paths, storing the result in m_root_access_path.  <a href="#gad01edc56308a73d4939bb025aef61595">More...</a><br /></td></tr>
<tr class="separator:gad01edc56308a73d4939bb025aef61595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5348aefb47d30e3dada46fc69dcfdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaef5348aefb47d30e3dada46fc69dcfdd">JOIN::create_access_paths_for_index_subquery</a> ()</td></tr>
<tr class="separator:gaef5348aefb47d30e3dada46fc69dcfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd2fd614d9da7c946afdc5ac517a590"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gacdd2fd614d9da7c946afdc5ac517a590">ConstIterator::ConstIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *table_ref, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *examined_rows)</td></tr>
<tr class="separator:gacdd2fd614d9da7c946afdc5ac517a590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96bbfdba2340f046d6e5b9647d21a1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gac96bbfdba2340f046d6e5b9647d21a1d">ConstIterator::Init</a> () override</td></tr>
<tr class="memdesc:gac96bbfdba2340f046d6e5b9647d21a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#gac96bbfdba2340f046d6e5b9647d21a1d">More...</a><br /></td></tr>
<tr class="separator:gac96bbfdba2340f046d6e5b9647d21a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d057d6520cc208b236fb30684ef006"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gab8d057d6520cc208b236fb30684ef006">ConstIterator::Read</a> () override</td></tr>
<tr class="memdesc:gab8d057d6520cc208b236fb30684ef006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a constant table when there is at most one matching row, using an index lookup.  <a href="#gab8d057d6520cc208b236fb30684ef006">More...</a><br /></td></tr>
<tr class="separator:gab8d057d6520cc208b236fb30684ef006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1774ffe21a67e18fc047b7785e849bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gab1774ffe21a67e18fc047b7785e849bd">EQRefIterator::EQRefIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_order, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *examined_rows)</td></tr>
<tr class="separator:gab1774ffe21a67e18fc047b7785e849bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984f71a7d852a3ad88e645662207128a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga984f71a7d852a3ad88e645662207128a">EQRefIterator::Init</a> () override</td></tr>
<tr class="memdesc:ga984f71a7d852a3ad88e645662207128a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read row using unique key: eq_ref access method implementation.  <a href="#ga984f71a7d852a3ad88e645662207128a">More...</a><br /></td></tr>
<tr class="separator:ga984f71a7d852a3ad88e645662207128a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36eaaaa690e7ed40b88de669f91454e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga36eaaaa690e7ed40b88de669f91454e8">EQRefIterator::Read</a> () override</td></tr>
<tr class="memdesc:ga36eaaaa690e7ed40b88de669f91454e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read row using unique key: eq_ref access method implementation.  <a href="#ga36eaaaa690e7ed40b88de669f91454e8">More...</a><br /></td></tr>
<tr class="separator:ga36eaaaa690e7ed40b88de669f91454e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c36c7359faa0ad5c352d48b671874a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga02c36c7359faa0ad5c352d48b671874a">EQRefIterator::UnlockRow</a> () override</td></tr>
<tr class="memdesc:ga02c36c7359faa0ad5c352d48b671874a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since EQRefIterator may buffer a record, do not unlock it if it was not used in this invocation of EQRefIterator::Read().  <a href="#ga02c36c7359faa0ad5c352d48b671874a">More...</a><br /></td></tr>
<tr class="separator:ga02c36c7359faa0ad5c352d48b671874a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6501ef40446b03e31dc19ed71c9242"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga6f6501ef40446b03e31dc19ed71c9242">PushedJoinRefIterator::PushedJoinRefIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_order, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_unique, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *examined_rows)</td></tr>
<tr class="separator:ga6f6501ef40446b03e31dc19ed71c9242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967aaa22180a5e8797c959902a38b7c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga967aaa22180a5e8797c959902a38b7c6">PushedJoinRefIterator::Init</a> () override</td></tr>
<tr class="memdesc:ga967aaa22180a5e8797c959902a38b7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#ga967aaa22180a5e8797c959902a38b7c6">More...</a><br /></td></tr>
<tr class="separator:ga967aaa22180a5e8797c959902a38b7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e2b9dbfd2a00d167b332ff0c582b0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga17e2b9dbfd2a00d167b332ff0c582b0b">PushedJoinRefIterator::Read</a> () override</td></tr>
<tr class="memdesc:ga17e2b9dbfd2a00d167b332ff0c582b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single row.  <a href="#ga17e2b9dbfd2a00d167b332ff0c582b0b">More...</a><br /></td></tr>
<tr class="separator:ga17e2b9dbfd2a00d167b332ff0c582b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f61fbd97c37e7c587bb8cc3a569702a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga8f61fbd97c37e7c587bb8cc3a569702a">RefIterator&lt; Reverse &gt;::Init</a> () override</td></tr>
<tr class="memdesc:ga8f61fbd97c37e7c587bb8cc3a569702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#ga8f61fbd97c37e7c587bb8cc3a569702a">More...</a><br /></td></tr>
<tr class="separator:ga8f61fbd97c37e7c587bb8cc3a569702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0c4436d64e3e8afc6b1bf3c5dc4928"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaef0c4436d64e3e8afc6b1bf3c5dc4928">DynamicRangeIterator::DynamicRangeIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *examined_rows)</td></tr>
<tr class="separator:gaef0c4436d64e3e8afc6b1bf3c5dc4928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594c4ca57165f5be306b2115cb0e5dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga594c4ca57165f5be306b2115cb0e5dc1">DynamicRangeIterator::Init</a> () override</td></tr>
<tr class="memdesc:ga594c4ca57165f5be306b2115cb0e5dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#ga594c4ca57165f5be306b2115cb0e5dc1">More...</a><br /></td></tr>
<tr class="separator:ga594c4ca57165f5be306b2115cb0e5dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae544cfbf4ebbef3a53dec28ee7fc00ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae544cfbf4ebbef3a53dec28ee7fc00ab">DynamicRangeIterator::Read</a> () override</td></tr>
<tr class="memdesc:gae544cfbf4ebbef3a53dec28ee7fc00ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single row.  <a href="#gae544cfbf4ebbef3a53dec28ee7fc00ab">More...</a><br /></td></tr>
<tr class="separator:gae544cfbf4ebbef3a53dec28ee7fc00ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685838679adf501ece418d4bd969f2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga685838679adf501ece418d4bd969f2ea">QEP_TAB::use_order</a> () const</td></tr>
<tr class="memdesc:ga685838679adf501ece418d4bd969f2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use ordering provided by chosen index?  <a href="#ga685838679adf501ece418d4bd969f2ea">More...</a><br /></td></tr>
<tr class="separator:ga685838679adf501ece418d4bd969f2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced2a407342ab1188955c747d158d4fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaced2a407342ab1188955c747d158d4fc">FullTextSearchIterator::FullTextSearchIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_order, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *examined_rows)</td></tr>
<tr class="separator:gaced2a407342ab1188955c747d158d4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec624913104ccd6bc62d6d1998816a4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaec624913104ccd6bc62d6d1998816a4a">FullTextSearchIterator::~FullTextSearchIterator</a> () override</td></tr>
<tr class="separator:gaec624913104ccd6bc62d6d1998816a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4b7c89b186af70757a686aee2f5afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga6a4b7c89b186af70757a686aee2f5afb">FullTextSearchIterator::Init</a> () override</td></tr>
<tr class="memdesc:ga6a4b7c89b186af70757a686aee2f5afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#ga6a4b7c89b186af70757a686aee2f5afb">More...</a><br /></td></tr>
<tr class="separator:ga6a4b7c89b186af70757a686aee2f5afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9e5a62f40c54dced584b807b9c601b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga9a9e5a62f40c54dced584b807b9c601b">FullTextSearchIterator::Read</a> () override</td></tr>
<tr class="memdesc:ga9a9e5a62f40c54dced584b807b9c601b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single row.  <a href="#ga9a9e5a62f40c54dced584b807b9c601b">More...</a><br /></td></tr>
<tr class="separator:ga9a9e5a62f40c54dced584b807b9c601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a3b4971231656f05c780e0b91d0ae1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga51a3b4971231656f05c780e0b91d0ae1">RefOrNullIterator::RefOrNullIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_order, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *examined_rows)</td></tr>
<tr class="memdesc:ga51a3b4971231656f05c780e0b91d0ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading of key with key reference and one part that may be NULL.  <a href="#ga51a3b4971231656f05c780e0b91d0ae1">More...</a><br /></td></tr>
<tr class="separator:ga51a3b4971231656f05c780e0b91d0ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga616970533a33a9fdc2494219b513ec9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga616970533a33a9fdc2494219b513ec9f">RefOrNullIterator::Init</a> () override</td></tr>
<tr class="memdesc:ga616970533a33a9fdc2494219b513ec9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#ga616970533a33a9fdc2494219b513ec9f">More...</a><br /></td></tr>
<tr class="separator:ga616970533a33a9fdc2494219b513ec9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399f6885d81a6f25375578864c3298e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga399f6885d81a6f25375578864c3298e9">RefOrNullIterator::Read</a> () override</td></tr>
<tr class="memdesc:ga399f6885d81a6f25375578864c3298e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single row.  <a href="#ga399f6885d81a6f25375578864c3298e9">More...</a><br /></td></tr>
<tr class="separator:ga399f6885d81a6f25375578864c3298e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac606deae3532b056e82b4eb5ab8667eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gac606deae3532b056e82b4eb5ab8667eb">AlternativeIterator::AlternativeIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; source, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; table_scan_iterator, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref)</td></tr>
<tr class="separator:gac606deae3532b056e82b4eb5ab8667eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5051d63142c46e9fc9c9e1be869114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga8e5051d63142c46e9fc9c9e1be869114">AlternativeIterator::Init</a> () override</td></tr>
<tr class="memdesc:ga8e5051d63142c46e9fc9c9e1be869114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#ga8e5051d63142c46e9fc9c9e1be869114">More...</a><br /></td></tr>
<tr class="separator:ga8e5051d63142c46e9fc9c9e1be869114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66460b9e721ff31724aa42022501efc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga66460b9e721ff31724aa42022501efc7">QEP_TAB::access_path</a> ()</td></tr>
<tr class="memdesc:ga66460b9e721ff31724aa42022501efc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an access path for reading from this table in the query, using the access method that has been determined previously (e.g., table scan, ref access, optional sort afterwards, etc.).  <a href="#ga66460b9e721ff31724aa42022501efc7">More...</a><br /></td></tr>
<tr class="separator:ga66460b9e721ff31724aa42022501efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a4ed26b9591fd1aa44477ce7711ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf5a4ed26b9591fd1aa44477ce7711ccf">Window::save_special_record</a> (<a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> special_rowno, <a class="el" href="structTABLE.html">TABLE</a> *t)</td></tr>
<tr class="memdesc:gaf5a4ed26b9591fd1aa44477ce7711ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save row special_rowno in table t-&gt;record[0] to an in-memory copy for later restoration.  <a href="#gaf5a4ed26b9591fd1aa44477ce7711ccf">More...</a><br /></td></tr>
<tr class="separator:gaf5a4ed26b9591fd1aa44477ce7711ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56193ae529e5919b702ada22af55d242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga56193ae529e5919b702ada22af55d242">Window::restore_special_record</a> (<a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a> special_rowno, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="memdesc:ga56193ae529e5919b702ada22af55d242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore row special_rowno into record from in-memory copy.  <a href="#ga56193ae529e5919b702ada22af55d242">More...</a><br /></td></tr>
<tr class="separator:ga56193ae529e5919b702ada22af55d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe273c16723cd0967fe58196140d4e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gafe273c16723cd0967fe58196140d4e76">JOIN::clear_fields</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *save_nullinfo)</td></tr>
<tr class="memdesc:gafe273c16723cd0967fe58196140d4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all result fields.  <a href="#gafe273c16723cd0967fe58196140d4e76">More...</a><br /></td></tr>
<tr class="separator:gafe273c16723cd0967fe58196140d4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f0928188542530ccca88b0f7c1576e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga84f0928188542530ccca88b0f7c1576e">JOIN::restore_fields</a> (<a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> save_nullinfo)</td></tr>
<tr class="memdesc:ga84f0928188542530ccca88b0f7c1576e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore all result fields for all tables specified in save_nullinfo.  <a href="#ga84f0928188542530ccca88b0f7c1576e">More...</a><br /></td></tr>
<tr class="separator:ga84f0928188542530ccca88b0f7c1576e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aab8b4f0d5f429b7339b2d5e4ef8980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga0aab8b4f0d5f429b7339b2d5e4ef8980">QEP_TAB::pfs_batch_update</a> (const <a class="el" href="classJOIN.html">JOIN</a> *<a class="el" href="classQEP__shared__owner.html#a43d1b0de8e7765c2fded3dc3beef39c5">join</a>) const</td></tr>
<tr class="separator:ga0aab8b4f0d5f429b7339b2d5e4ef8980"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaddf402a0aa4cdd7bdc55f9d50b88ac71"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaddf402a0aa4cdd7bdc55f9d50b88ac71">MAX_RECORD_BUFFER_SIZE</a> = 128 * 1024</td></tr>
<tr class="memdesc:gaddf402a0aa4cdd7bdc55f9d50b88ac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum amount of space (in bytes) to allocate for a Record_buffer.  <a href="#gaddf402a0aa4cdd7bdc55f9d50b88ac71">More...</a><br /></td></tr>
<tr class="separator:gaddf402a0aa4cdd7bdc55f9d50b88ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa395c04235b7c45d6a03bb3cf71615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga0fa395c04235b7c45d6a03bb3cf71615">JOIN::create_root_access_path_for_join</a> ()</td></tr>
<tr class="separator:ga0fa395c04235b7c45d6a03bb3cf71615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913f9924b8c56f23e74b8f6369306676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga913f9924b8c56f23e74b8f6369306676">JOIN::attach_access_paths_for_having_and_limit</a> (<a class="el" href="structAccessPath.html">AccessPath</a> *<a class="el" href="mysqldump_8cc.html#a38dcf0baefa35c1961c23cf3e06002b5">path</a>)</td></tr>
<tr class="separator:ga913f9924b8c56f23e74b8f6369306676"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga8c797c5c988bd78790c147c626a4ed98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c797c5c988bd78790c147c626a4ed98">&#9670;&nbsp;</a></span>CallingContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Query__Executor.html#ga8c797c5c988bd78790c147c626a4ed98">CallingContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8c797c5c988bd78790c147c626a4ed98a51f6c706c1d0e0d7a5f4ae4530b52179"></a>TOP_LEVEL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga8c797c5c988bd78790c147c626a4ed98a7783926cbb6e963ecc8b23d047baf823"></a>DIRECTLY_UNDER_SEMIJOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga8c797c5c988bd78790c147c626a4ed98a3b24fe729895ed418faa2c63bb97c410"></a>DIRECTLY_UNDER_OUTER_JOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga8c797c5c988bd78790c147c626a4ed98a6fa28ce960e1bf879278a8f2c353c201"></a>DIRECTLY_UNDER_WEEDOUT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga3f4f36f2eb08c32a2b6e1ca17af68b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4f36f2eb08c32a2b6e1ca17af68b8d">&#9670;&nbsp;</a></span>Substructure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Query__Executor.html#ga3f4f36f2eb08c32a2b6e1ca17af68b8d">Substructure</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3f4f36f2eb08c32a2b6e1ca17af68b8dab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3f4f36f2eb08c32a2b6e1ca17af68b8dabd2f93b6a8d173bc0cd3085d57241289"></a>OUTER_JOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3f4f36f2eb08c32a2b6e1ca17af68b8da8e910ccf0b077f4ec0307c7a21a8832a"></a>SEMIJOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3f4f36f2eb08c32a2b6e1ca17af68b8daccb0239da87e8136e88f9e805098367a"></a>WEEDOUT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac606deae3532b056e82b4eb5ab8667eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac606deae3532b056e82b4eb5ab8667eb">&#9670;&nbsp;</a></span>AlternativeIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AlternativeIterator::AlternativeIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>table_scan_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacdd2fd614d9da7c946afdc5ac517a590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdd2fd614d9da7c946afdc5ac517a590">&#9670;&nbsp;</a></span>ConstIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator::ConstIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>table_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>examined_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaef0c4436d64e3e8afc6b1bf3c5dc4928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef0c4436d64e3e8afc6b1bf3c5dc4928">&#9670;&nbsp;</a></span>DynamicRangeIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicRangeIterator::DynamicRangeIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>examined_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab1774ffe21a67e18fc047b7785e849bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1774ffe21a67e18fc047b7785e849bd">&#9670;&nbsp;</a></span>EQRefIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EQRefIterator::EQRefIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>examined_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaced2a407342ab1188955c747d158d4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced2a407342ab1188955c747d158d4fc">&#9670;&nbsp;</a></span>FullTextSearchIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FullTextSearchIterator::FullTextSearchIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>examined_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6f6501ef40446b03e31dc19ed71c9242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f6501ef40446b03e31dc19ed71c9242">&#9670;&nbsp;</a></span>PushedJoinRefIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PushedJoinRefIterator::PushedJoinRefIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>examined_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga51a3b4971231656f05c780e0b91d0ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51a3b4971231656f05c780e0b91d0ae1">&#9670;&nbsp;</a></span>RefOrNullIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RefOrNullIterator::RefOrNullIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>examined_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading of key with key reference and one part that may be NULL. </p>

</div>
</div>
<a id="gaec624913104ccd6bc62d6d1998816a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec624913104ccd6bc62d6d1998816a4a">&#9670;&nbsp;</a></span>~FullTextSearchIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FullTextSearchIterator::~FullTextSearchIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga66460b9e721ff31724aa42022501efc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66460b9e721ff31724aa42022501efc7">&#9670;&nbsp;</a></span>access_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a> * QEP_TAB::access_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an access path for reading from this table in the query, using the access method that has been determined previously (e.g., table scan, ref access, optional sort afterwards, etc.). </p>

</div>
</div>
<a id="gaa52ebe3c9c6871fef6843897b1b19128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52ebe3c9c6871fef6843897b1b19128">&#9670;&nbsp;</a></span>alloc_group_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> alloc_group_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of buffers for saveing last group. </p>
<p>Groups are saved in reverse order for easyer check loop. </p>

</div>
</div>
<a id="ga913f9924b8c56f23e74b8f6369306676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga913f9924b8c56f23e74b8f6369306676">&#9670;&nbsp;</a></span>attach_access_paths_for_having_and_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a> * JOIN::attach_access_paths_for_having_and_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf0ee8b05bc58208fcc22e122e1a67dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ee8b05bc58208fcc22e122e1a67dd0">&#9670;&nbsp;</a></span>bring_back_frame_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> bring_back_frame_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWindow.html">Window</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>out_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rowno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bring back buffered data to the record of qep_tab-1 [1], and optionally execute copy_fields() to the OUT table. </p>
<p>[1] This is not always the case. For the first window, if we have no PARTITION BY or ORDER BY in the window, and there is more than one table in the join, the logical input can consist of more than one table (qep_tab-1 .. qep_tab-n), so the record accordingly.</p>
<p>This method works by temporarily reversing the "normal" direction of the field copying.</p>
<p>Also make a note of the position of the record we retrieved in the window's m_frame_buffer_positions to be able to optimize succeeding retrievals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">w</td><td>The current window </td></tr>
    <tr><td class="paramname">out_param</td><td>OUT table; if not nullptr, does copy_fields() to OUT </td></tr>
    <tr><td class="paramname">rowno</td><td>The row number (in the partition) to set up </td></tr>
    <tr><td class="paramname">reason</td><td>What kind of row to retrieve </td></tr>
    <tr><td class="paramname">fno</td><td>Used with NTH_VALUE and LEAD/LAG to specify which window function's position cache to use, i.e. what index of m_frame_buffer_positions to update. For the second LEAD/LAG window function in a query, the index would be REA_MISC_POSITIONS (reason) + &lt;no of NTH functions&gt; + 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error </dd></dl>

</div>
</div>
<a id="ga10cda020c5f3fd5bf648021dad869b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10cda020c5f3fd5bf648021dad869b54">&#9670;&nbsp;</a></span>buffer_record_somewhere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buffer_record_somewhere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWindow.html">Window</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rowno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save a window frame buffer to frame buffer temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">w</td><td>The current window </td></tr>
    <tr><td class="paramname">rowno</td><td>The rowno in the current partition (1-based) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff47721cb11cd1727801c0d6f2b27cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff47721cb11cd1727801c0d6f2b27cfa">&#9670;&nbsp;</a></span>buffer_windowing_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buffer_windowing_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>new_partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we cannot evaluate all window functions for a window on the fly, buffer the current row for later processing by process_buffered_windowing_record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Current thread </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">param</td><td>The temporary table parameter</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">new_partition</td><td>If input is not nullptr: sets the bool pointed to to true if a new partition was found and there was a previous partition; if so the buffering of the first row in new partition isn't done and must be repeated later: we save away the row as rowno FBC_FIRST_IN_NEXT_PARTITION, then fetch it back later, cf. end_write_wf. If input is nullptr, this is the "later" call to buffer the first row of the new partition: buffer the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error. </dd></dl>

</div>
</div>
<a id="ga2327f19582cc172cacfcb3e7b4eb770d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2327f19582cc172cacfcb3e7b4eb770d">&#9670;&nbsp;</a></span>change_to_use_tmp_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> change_to_use_tmp_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>res_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change all funcs and sum_funcs to fields in tmp table, and create new list of all items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fields</td><td>list of all fields; should really be const, but Item does not always respect constness </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ref_item_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res_fields</td><td>new list of all items</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga013b282a51d071fc499e52ef901bb877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga013b282a51d071fc499e52ef901bb877">&#9670;&nbsp;</a></span>change_to_use_tmp_fields_except_sums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> change_to_use_tmp_fields_except_sums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>res_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change all sum_func refs to fields to point at fields in tmp table. </p>
<p>Change all funcs to be fields in tmp table.</p>
<p>This is used when we set up a temporary table, but aggregate functions (sum_funcs) cannot be evaluated yet, for instance because data is not sorted in the right order. (Otherwise, change_to_use_tmp_fields() would be used.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fields</td><td>list of all fields; should really be const, but Item does not always respect constness </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select</td><td>the query block we are doing this to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ref_item_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res_fields</td><td>new list of items of select item list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga90a4e0bf6e706b42c25d6649e105bd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90a4e0bf6e706b42c25d6649e105bd87">&#9670;&nbsp;</a></span>check_unique_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> check_unique_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check unique_constraint. </p>
<p>Calculates record's hash and checks whether the record given in table-&gt;record[0] is already present in the tmp table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>JOIN_TAB of tmp table to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes record[0] is already filled by the caller. Depending on presence of table-&gt;group, it's or full list of table's fields are used to calculate hash.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false same record was found true record wasn't found </dd></dl>

</div>
</div>
<a id="gafe273c16723cd0967fe58196140d4e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe273c16723cd0967fe58196140d4e76">&#9670;&nbsp;</a></span>clear_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::clear_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>save_nullinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all result fields. </p>
<p>Non-aggregated fields are set to NULL, aggregated fields are set to their special "clear" value.</p>
<p>Result fields can be fields from input tables, field values generated by sum functions and literal values.</p>
<p>This is used when no rows are found during grouping: for FROM clause, a result row of all NULL values will be output; then SELECT list expressions get evaluated. E.g. SUM() will be NULL (the special "clear" value) and thus SUM() IS NULL will be true.</p>
<dl class="section note"><dt>Note</dt><dd>Setting field values for input tables is a destructive operation, since it overwrite the NULL value flags with 1 bits. Rows from const tables are never re-read, hence their NULL value flags must be saved by this function and later restored by JOIN::restore_fields(). This is generally not necessary for non-const tables, since field values are overwritten when new rows are read.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">save_nullinfo</td><td>Map of tables whose fields were set to NULL, and for which NULL values must be restored. Should be set to all zeroes on entry to function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga2b9c09ad4f484a72f2c19c44127be744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b9c09ad4f484a72f2c19c44127be744">&#9670;&nbsp;</a></span>cmp_field_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> cmp_field_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gadcbd7d6f284c82e15bca0918f4ce7ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcbd7d6f284c82e15bca0918f4ce7ac0">&#9670;&nbsp;</a></span>ConditionIsAlwaysTrue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ConditionIsAlwaysTrue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga058767e277320c8f6d94be22e070f52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058767e277320c8f6d94be22e070f52d">&#9670;&nbsp;</a></span>ConnectJoins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structAccessPath.html">AccessPath</a>* ConnectJoins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>upper_first_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>first_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>last_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Query__Executor.html#ga8c797c5c988bd78790c147c626a4ed98">CallingContext</a>&#160;</td>
          <td class="paramname"><em>calling_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *&#160;</td>
          <td class="paramname"><em>pending_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structPendingInvalidator.html">PendingInvalidator</a> &gt; *&#160;</td>
          <td class="paramname"><em>pending_invalidators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *&#160;</td>
          <td class="paramname"><em>pending_join_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> *&#160;</td>
          <td class="paramname"><em>unhandled_duplicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>conditions_depend_on_outer_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given slice of the table list, build up the iterator tree corresponding to the tables in that slice. </p>
<p>It handles inner and outer joins, as well as semijoins (“first match”).</p>
<p>The join tree in MySQL is generally a left-deep tree of inner joins, so we can start at the left, make an inner join against the next table, join the result of that against the next table, etc.. However, a given sub-slice of the table list can be designated as an outer join, by setting first_inner() and last_inner() on the first table of said slice. (It is also set in some, but not all, of the other tables in the slice.) If so, we call ourselves recursively with that slice, put it as the right (inner) arm of an outer join, and then continue with our inner join.</p>
<p>Similarly, if a table N has set “first match” to table M (ie., jump back to table M whenever we see a non-filtered record in table N), then there is a subslice from [M+1,N] that we need to process recursively before putting it as the right side of a semijoin. Every semijoin can be implemented with a LIMIT 1, but for clarity and performance, we prefer to use a NestedLoopJoin with a special SEMI join type whenever possible. Sometimes, we have no choice, though (see the comments below). Note that we cannot use first_sj_inner() for detecting semijoins, as it is not updated when tables are reordered by the join optimizer. Outer joins and semijoins can nest, so we need to take some care to make sure that we pick the outermost structure to recurse on.</p>
<p>Conditions are a bit tricky. Conceptually, SQL evaluates conditions only after all tables have been joined; however, for efficiency reasons, we want to evaluate them as early as possible. As long as we are only dealing with inner joins, this is as soon as we've read all tables participating in the condition, but for outer joins, we need to wait until the join has happened. See pending_conditions below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">upper_first_idx</td><td>gives us the first table index of the other side of the join. Only valid if we are inside a substructure (outer join, semijoin or antijoin). I.e., if we are processing the right side of the query 't1 LEFT JOIN t2', upper_first_idx gives us the table index of 't1'. Used by hash join to determine the table map for each side of the join. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">first_idx</td><td>index of the first table in the slice we are creating a tree for (inclusive) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">last_idx</td><td>index of the last table in the slice we are creating a tree for (exclusive) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">qep_tabs</td><td>the full list of tables we are joining </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>the THD to allocate the iterators on </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">calling_context</td><td>what situation we have immediately around is in the tree (ie., whether we are called to resolve the inner part of an outer join, a semijoin, etc.); mostly used to avoid infinite recursion where we would process e.g. the same semijoin over and over again </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pending_conditions</td><td>if nullptr, we are not at the right (inner) side of any outer join and can evaluate conditions immediately. If not, we need to push any WHERE predicates to that vector and evaluate them only after joins. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pending_invalidators</td><td>similar to pending_conditions, but for tables that should have a CacheInvalidatorIterator synthesized for them; NULL-complemented rows must also invalidate materialized lateral derived tables. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pending_join_conditions</td><td>if not nullptr, we are at the inner side of semijoin/antijoin. The join iterator is created at the outer side, so any join conditions at the inner side needs to be pushed to this vector so that they can be attached to the join iterator. Note that this is currently only used by hash join. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unhandled_duplicates</td><td>list of tables we should have deduplicated using duplicate weedout, but could not; append-only. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">conditions_depend_on_outer_tables</td><td>For each condition we have applied on the inside of these iterators, their dependent tables are appended to this set. Thus, if conditions_depend_on_outer_tables contain something from outside the tables covered by [first_idx,last_idx) (ie., after translation from QEP_TAB indexes to table indexes), we cannot use a hash join, since the returned iterator depends on seeing outer rows when evaluating its conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4fc6ed4bd78e82a16f09c4a36bf768b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4fc6ed4bd78e82a16f09c4a36bf768b">&#9670;&nbsp;</a></span>construct_lookup_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> construct_lookup_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the lookup key into the table ref's key buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>pointer to the THD object </td></tr>
    <tr><td class="paramname">table</td><td>the table to read </td></tr>
    <tr><td class="paramname">ref</td><td>information about the index lookup key</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>ref key copied successfully </td></tr>
    <tr><td class="paramname">true</td><td>error dectected during copying of key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d7987a8fe4b52b792ff19c3dde8eaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7987a8fe4b52b792ff19c3dde8eaf5">&#9670;&nbsp;</a></span>ConvertItemsToCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConvertItemsToCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For historical reasons, derived table materialization and temporary table materialization didn't specify the fields to materialize in the same way. </p>
<p>Temporary table materialization used copy_fields() and copy_funcs() (also reused for aggregation; see the comments on AggregateIterator for the relation between aggregations and temporary tables) to get the data into the Field pointers of the temporary table to be written, storing the lists in copy_fields and items_to_copy.</p>
<p>However, derived table materialization used JOIN::fields (which is a set of Item, not Field!) for the same purpose, calling fill_record() (which originally was meant for INSERT and UPDATE) instead. Thus, we have to rewrite one to the other, so that we can have only one MaterializeIterator. We choose to rewrite JOIN::fields to copy_fields/items_to_copy.</p>
<p>TODO: The optimizer should output just one kind of structure directly. </p>

</div>
</div>
<a id="ga35edd7d52f8679c5837117f19debccac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35edd7d52f8679c5837117f19debccac">&#9670;&nbsp;</a></span>ConvertQepTabMapToTableMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> ConvertQepTabMapToTableMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad746e2883a2e4618d2acbb7736750070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad746e2883a2e4618d2acbb7736750070">&#9670;&nbsp;</a></span>copy_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> copy_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reverse_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of all simple SELECT'ed fields. </p>
<p>This is done at the start of a new group so that we can retrieve these later when the group changes. It is also used in materialization, to copy the values into the temporary table's fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Represents the current temporary file being produced </td></tr>
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">reverse_copy</td><td>If true, copies fields <em>back</em> from the frame buffer tmp table to the input table's buffer, cf. bring_back_frame_row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if OK, true on error. </dd></dl>

</div>
</div>
<a id="ga9ccbb1decda5b649a2cb9b327b8e7f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ccbb1decda5b649a2cb9b327b8e7f7f">&#9670;&nbsp;</a></span>copy_fields_and_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> copy_fields_and_funcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__executor_8h.html#adacecf3d31cd9bd64698758b3365995c">Copy_func_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga21679aa16ae84b53b4c55d5e023c1dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21679aa16ae84b53b4c55d5e023c1dec">&#9670;&nbsp;</a></span>copy_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> copy_funcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__executor_8h.html#adacecf3d31cd9bd64698758b3365995c">Copy_func_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy result of functions to record in tmp_table. </p>
<p>Uses the thread pointer to check for errors in some of the val_xxx() methods called by the save_in_result_field() function. TODO: make the Item::val_xxx() return error code</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Copy functions of tmp table specified by param </td></tr>
    <tr><td class="paramname">thd</td><td>pointer to the current thread for error checking </td></tr>
    <tr><td class="paramname">type</td><td>type of function Items that need to be copied (used w.r.t windowing functions). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if OK </td></tr>
    <tr><td class="paramname">true</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad01edc56308a73d4939bb025aef61595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01edc56308a73d4939bb025aef61595">&#9670;&nbsp;</a></span>create_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::create_access_paths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the executor structures to a set of access paths, storing the result in m_root_access_path. </p>

</div>
</div>
<a id="gaef5348aefb47d30e3dada46fc69dcfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5348aefb47d30e3dada46fc69dcfdd">&#9670;&nbsp;</a></span>create_access_paths_for_index_subquery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::create_access_paths_for_index_subquery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3b001e6d45eab20782b8b3f2f7f0b3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b001e6d45eab20782b8b3f2f7f0b3ea">&#9670;&nbsp;</a></span>create_intermediate_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> JOIN::create_intermediate_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp_table_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classORDER__with__src.html">ORDER_with_src</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp_table_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>save_sum_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a temporary table to be used for processing DISTINCT/ORDER BY/GROUP BY. </p>
<dl class="section note"><dt>Note</dt><dd>Will modify JOIN object wrt sort/group attributes</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the JOIN_TAB object to attach created table to </td></tr>
    <tr><td class="paramname">tmp_table_fields</td><td>List of items that will be used to define column types of the table. </td></tr>
    <tr><td class="paramname">tmp_table_group</td><td>Group key to use for temporary table, empty if none. </td></tr>
    <tr><td class="paramname">save_sum_fields</td><td>If true, do not replace Item_sum items in <code>tmp_fields</code> list with Item_field items referring to fields in temporary table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on failure </dd></dl>
<p>If this is a window's OUT table, any final DISTINCT, ORDER BY will lead to windows showing use of tmp table in the final windowing step, so no need to signal use of tmp table unless we are here for another tmp table.</p>

</div>
</div>
<a id="ga0fa395c04235b7c45d6a03bb3cf71615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa395c04235b7c45d6a03bb3cf71615">&#9670;&nbsp;</a></span>create_root_access_path_for_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a> * JOIN::create_root_access_path_for_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helpers for create_access_paths. </p>

</div>
</div>
<a id="ga2db7421445cca3a7f481d534789f42c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db7421445cca3a7f481d534789f42c5">&#9670;&nbsp;</a></span>CreateBKAAccessPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a>* CreateBKAAccessPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>outer_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>left_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>inner_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>right_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td>
          <td class="paramname"><em>join_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa90f6e2da30eb7413fc1a656491cfc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa90f6e2da30eb7413fc1a656491cfc31">&#9670;&nbsp;</a></span>CreateHashJoinAccessPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structAccessPath.html">AccessPath</a>* CreateHashJoinAccessPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>build_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>build_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>probe_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>probe_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td>
          <td class="paramname"><em>join_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>conditions_depend_on_outer_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4aedc885dff47075d06cf4e589406fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aedc885dff47075d06cf4e589406fec">&#9670;&nbsp;</a></span>CreateNestedLoopAccessPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a>* CreateNestedLoopAccessPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td>
          <td class="paramname"><em>join_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>pfs_batch_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae2fe7152960dd8e79c1e0c540f4b28f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2fe7152960dd8e79c1e0c540f4b28f7">&#9670;&nbsp;</a></span>CreateWeedoutOrLimitAccessPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structAccessPath.html">AccessPath</a>* CreateWeedoutOrLimitAccessPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>weedout_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga137a2027c57feb8037c9702db709286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga137a2027c57feb8037c9702db709286a">&#9670;&nbsp;</a></span>dbug_allow_write_all_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dbug_allow_write_all_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="structTABLE.html">TABLE</a> *, <a class="el" href="my__bitmap_8h.html#a0e2e55f75043954d274fc72371eb3a08">my_bitmap_map</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gabc59132a8690c65e93e77c1202e14454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc59132a8690c65e93e77c1202e14454">&#9670;&nbsp;</a></span>dbug_restore_all_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dbug_restore_all_columns </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="structTABLE.html">TABLE</a> *, <a class="el" href="my__bitmap_8h.html#a0e2e55f75043954d274fc72371eb3a08">my_bitmap_map</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4c3b77b483fa5b7bcefe0f38587480c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3b77b483fa5b7bcefe0f38587480c8">&#9670;&nbsp;</a></span>do_sj_dups_weedout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int do_sj_dups_weedout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>sjtbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SemiJoinDuplicateElimination: Weed out duplicate row combinations. </p>
<p>SYNPOSIS do_sj_dups_weedout() thd Thread handle sjtbl Duplicate weedout table</p>
<p>DESCRIPTION Try storing current record combination of outer tables (i.e. their rowids) in the temporary table. This records the fact that we've seen this record combination and also tells us if we've seen it before.</p>
<p>RETURN -1 Error 1 The row combination is a duplicate (discard it) 0 The row combination is not a duplicate (continue) </p>

</div>
</div>
<a id="gaf367b44a0b89dec84a3f5fee35d7bf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf367b44a0b89dec84a3f5fee35d7bf0b">&#9670;&nbsp;</a></span>ExtractConditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ExtractConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>condition_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split AND conditions into their constituent parts, recursively. </p>
<p>Conditions that are not AND conditions are appended unchanged onto condition_parts. E.g. if you have ((a AND b) AND c), condition_parts will contain [a, b, c], plus whatever it contained before the call. </p>

</div>
</div>
<a id="ga34ccef0cc2bf69c64b536a599cd0dd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34ccef0cc2bf69c64b536a599cd0dd68">&#9670;&nbsp;</a></span>ExtractJoinConditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ExtractJoinConditions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>current_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>predicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_conditions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6ed6faa31b5e6c2a133319003750c40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ed6faa31b5e6c2a133319003750c40c">&#9670;&nbsp;</a></span>FindKeyBufferAndMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pair&lt; <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *, <a class="el" href="my__base_8h.html#a87b4676a4f56ae55858619dc7ec70193">key_part_map</a> &gt; FindKeyBufferAndMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1d358a3f43ff185b9d70ce002581cc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d358a3f43ff185b9d70ce002581cc29">&#9670;&nbsp;</a></span>FindSubstructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__Query__Executor.html#ga3f4f36f2eb08c32a2b6e1ca17af68b8d">Substructure</a> FindSubstructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>first_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>this_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>last_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Query__Executor.html#ga8c797c5c988bd78790c147c626a4ed98">CallingContext</a>&#160;</td>
          <td class="paramname"><em>calling_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>add_limit_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a> *&#160;</td>
          <td class="paramname"><em>substructure_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> *&#160;</td>
          <td class="paramname"><em>unhandled_duplicates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a range of tables (where we assume that we've already handled first_idx..(this_idx-1) as inner joins), figure out whether this is a semijoin, an outer join or a weedout. </p>
<p>In general, the outermost structure wins; if we are in one of the rare cases where there are e.g. coincident (first match) semijoins and weedouts, we do various forms of conflict resolution:</p>
<ul>
<li>Unhandled weedouts will add elements to unhandled_duplicates (to be handled at the top level of the query).</li>
<li>Unhandled semijoins will either: Set add_limit_1 to true, which means a LIMIT 1 iterator should be added, or Add elements to unhandled_duplicates in situations that cannot be solved by a simple one-table, one-row LIMIT.</li>
</ul>
<p>If not returning NONE, substructure_end will also be filled with where this sub-join ends (exclusive). </p>

</div>
</div>
<a id="ga780b0a041678fa78ec4816f4c0562117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga780b0a041678fa78ec4816f4c0562117">&#9670;&nbsp;</a></span>FinishPendingOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a>* FinishPendingOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>remove_duplicates_loose_scan_qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pending_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structPendingInvalidator.html">PendingInvalidator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pending_invalidators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>conditions_depend_on_outer_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa466010f700bf26cf0ea53bafe44bb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa466010f700bf26cf0ea53bafe44bb5f">&#9670;&nbsp;</a></span>get_end_select_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQEP__TAB.html#ad047353d9aefbec7e174d5792c6941e9">QEP_TAB::enum_op_type</a> JOIN::get_end_select_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rows produced by a join sweep may end up in a temporary table or be sent to a client. Setup the function of the nested loop join algorithm which handles final fully constructed and matched records.</p>
<dl class="section return"><dt>Returns</dt><dd>end_select function to use. This function can't fail. </dd></dl>

</div>
</div>
<a id="ga62593e120f4a7daddbbab4ffbe862485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62593e120f4a7daddbbab4ffbe862485">&#9670;&nbsp;</a></span>get_exact_record_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> get_exact_record_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>table_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get exact count of rows in all tables. </p>
<p>When this is called, at least one table's SE doesn't include HA_COUNT_ROWS_INSTANT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qep_tab</td><td>List of qep_tab in this JOIN. </td></tr>
    <tr><td class="paramname">table_count</td><td>Count of qep_tab in the JOIN. </td></tr>
    <tr><td class="paramname">error</td><td>[out] Return any possible error. Else return 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cartesian product of count of the rows in all tables if success 0 if error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The "error" parameter is required for the sake of testcases like the one in innodb-wl6742.test:272. Earlier if an error was raised by ha_records, it wasn't handled by get_exact_record_count. Instead it was just allowed to go to the execution phase, where end_send_group would see the same error and raise it.</dd></dl>
<p>But with the new function 'end_send_count' in the execution phase, such an error should be properly returned so that it can be raised. </p>

</div>
</div>
<a id="ga20722285e2e89c53db1e5cfc52ca1862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20722285e2e89c53db1e5cfc52ca1862">&#9670;&nbsp;</a></span>GetAccessPathForDerivedTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a>* GetAccessPathForDerivedTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>table_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadaa876a1a74a29fb3705e13b39603fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa876a1a74a29fb3705e13b39603fd2">&#9670;&nbsp;</a></span>GetInnermostCondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem.html">Item</a>* GetInnermostCondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the innermost condition of a nested trigger condition. If the item is not a trigger condition, the item itself is returned. </dd></dl>

</div>
</div>
<a id="ga4937df76f2f72e5bac829a2aca40f0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4937df76f2f72e5bac829a2aca40f0cf">&#9670;&nbsp;</a></span>GetTableAccessPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a>* GetTableAccessPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tabs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RowIterator used for scanning the given table, with any required materialization operations done first. </p>

</div>
</div>
<a id="ga91943ce2f0f43e926db7ed885d704405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91943ce2f0f43e926db7ed885d704405">&#9670;&nbsp;</a></span>GetTriggerCondOrNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classItem__func__trig__cond.html">Item_func_trig_cond</a>* GetTriggerCondOrNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1edde56152f96e1f2abf26e65dea232f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1edde56152f96e1f2abf26e65dea232f">&#9670;&nbsp;</a></span>group_rec_cmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> group_rec_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>rec0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>rec1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare GROUP BY in from tmp table's record[0] and record[1]. </p>
<dl class="section return"><dt>Returns</dt><dd>true records are different false records are the same </dd></dl>

</div>
</div>
<a id="ga3515e68b7acd867a377778b9d2502876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3515e68b7acd867a377778b9d2502876">&#9670;&nbsp;</a></span>has_rollup_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> has_rollup_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an item has a ROLLUP NULL which needs to be written to temp table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item for which we need to detect if ROLLUP NULL has to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if ROLLUP NULL need not be written for this item. true if it has to be written. </dd></dl>

</div>
</div>
<a id="ga8f61fbd97c37e7c587bb8cc3a569702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f61fbd97c37e7c587bb8cc3a569702a">&#9670;&nbsp;</a></span>Init() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Reverse&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classRefIterator.html">RefIterator</a>&lt; Reverse &gt;::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ga616970533a33a9fdc2494219b513ec9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga616970533a33a9fdc2494219b513ec9f">&#9670;&nbsp;</a></span>Init() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> RefOrNullIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ga984f71a7d852a3ad88e645662207128a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984f71a7d852a3ad88e645662207128a">&#9670;&nbsp;</a></span>Init() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> EQRefIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read row using unique key: eq_ref access method implementation. </p>
<p>This is the "read_first" function for the eq_ref access method. The difference from ref access function is that it has a one-element lookup cache, maintained in record[0]. Since the eq_ref access method will always return the same row, it is not necessary to read the row more than once, regardless of how many times it is needed in execution. This cache element is used when a row is needed after it has been read once, unless a key conversion error has occurred, or the cache has been disabled.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- Ok </td></tr>
    <tr><td class="paramname">-1</td><td>- Row not found </td></tr>
    <tr><td class="paramname">1</td><td>- Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="gac96bbfdba2340f046d6e5b9647d21a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac96bbfdba2340f046d6e5b9647d21a1d">&#9670;&nbsp;</a></span>Init() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ConstIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ga6a4b7c89b186af70757a686aee2f5afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a4b7c89b186af70757a686aee2f5afb">&#9670;&nbsp;</a></span>Init() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> FullTextSearchIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ga594c4ca57165f5be306b2115cb0e5dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga594c4ca57165f5be306b2115cb0e5dc1">&#9670;&nbsp;</a></span>Init() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> DynamicRangeIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ga967aaa22180a5e8797c959902a38b7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga967aaa22180a5e8797c959902a38b7c6">&#9670;&nbsp;</a></span>Init() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> PushedJoinRefIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ga8e5051d63142c46e9fc9c9e1be869114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e5051d63142c46e9fc9c9e1be869114">&#9670;&nbsp;</a></span>Init() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> AlternativeIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ga4c659fe42f396022e5186e7a848c1501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c659fe42f396022e5186e7a848c1501">&#9670;&nbsp;</a></span>init_index_and_record_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> init_index_and_record_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html">handler</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an index scan and the record buffer to use in the scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qep_tab</td><td>the table to read </td></tr>
    <tr><td class="paramname">file</td><td>the handler to initialize </td></tr>
    <tr><td class="paramname">idx</td><td>the index to use </td></tr>
    <tr><td class="paramname">sorted</td><td>use the sorted order of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">false</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08f722697f934789019b3a9395ac72f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08f722697f934789019b3a9395ac72f7">&#9670;&nbsp;</a></span>init_tmptable_sum_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_tmptable_sum_functions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga085cd005174ba9cb76f820c8a6523643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga085cd005174ba9cb76f820c8a6523643">&#9670;&nbsp;</a></span>InsideOuterOrAntiJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> InsideOuterOrAntiJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga150aaa4485e63c642a36e69cb19e9579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga150aaa4485e63c642a36e69cb19e9579">&#9670;&nbsp;</a></span>is_rollup_group_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_rollup_group_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacdc8ddae35cf7e68020a89d25189fb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc8ddae35cf7e68020a89d25189fb7e">&#9670;&nbsp;</a></span>is_rollup_sum_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_rollup_sum_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga45f7d5f437c2749423958ecfe058d467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f7d5f437c2749423958ecfe058d467">&#9670;&nbsp;</a></span>IsJoinCondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> IsJoinCondition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item we want to see if is a join condition. </td></tr>
    <tr><td class="paramname">qep_tab</td><td>The table we are joining in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 'item' is a join condition for a join involving the given table (both equi-join and non-equi-join condition). </dd></dl>

</div>
</div>
<a id="ga2359b14612486e60a65a29391e19ac87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2359b14612486e60a65a29391e19ac87">&#9670;&nbsp;</a></span>IsTableScan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> IsTableScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga17886ea0f6b2f0b69395ede8958c305a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17886ea0f6b2f0b69395ede8958c305a">&#9670;&nbsp;</a></span>ItemRefersToOneSideOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ItemRefersToOneSideOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>left_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>right_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga39c30d89f411ee0d12ecd4824f9aae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c30d89f411ee0d12ecd4824f9aae1a">&#9670;&nbsp;</a></span>join_read_const_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join_read_const_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads content of constant table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>table </td></tr>
    <tr><td class="paramname">pos</td><td>position of table in query plan </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok, one row was found or one NULL-complemented row was created </td></tr>
    <tr><td class="paramname">-1</td><td>ok, no row was found and no NULL-complemented row was created </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0bd2dbcf106da50227e2eb4932b588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0bd2dbcf106da50227e2eb4932b588d">&#9670;&nbsp;</a></span>make_group_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> make_group_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>main_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>curr_join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate group fields or take prepared (cached). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_join</td><td>join of current select </td></tr>
    <tr><td class="paramname">curr_join</td><td>current join (join of current select or temporary copy of it)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga72ee5f67ddaa4ee2097b0a5b8491ad7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ee5f67ddaa4ee2097b0a5b8491ad7f">&#9670;&nbsp;</a></span>MarkUnhandledDuplicates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MarkUnhandledDuplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>weedout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>weedout_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sql__opt__exec__shared_8h.html#af1615e3a69c4742a4c81ed928ed2ac76">plan_idx</a>&#160;</td>
          <td class="paramname"><em>weedout_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a> *&#160;</td>
          <td class="paramname"><em>unhandled_duplicates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given duplicate weedout operation, figure out which tables are supposed to be deduplicated by it, and add those to unhandled_duplicates. </p>
<p>(SJ_TMP_TABLE contains the deduplication key, which is exactly the complement of the tables to be deduplicated.) </p>

</div>
</div>
<a id="gadc32faacc661ed367fa2bb66d6912d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc32faacc661ed367fa2bb66d6912d17">&#9670;&nbsp;</a></span>NewInvalidatorAccessPathForTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structAccessPath.html">AccessPath</a>* NewInvalidatorAccessPathForTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga535c87c5015da40c4fbef0fd02908757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535c87c5015da40c4fbef0fd02908757">&#9670;&nbsp;</a></span>NewWeedoutAccessPathForTables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structAccessPath.html">AccessPath</a>* NewWeedoutAccessPathForTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>tables_to_deduplicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>primary_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga09c1673adeda51cbb4befa2faa444d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c1673adeda51cbb4befa2faa444d10">&#9670;&nbsp;</a></span>optimize_distinct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::optimize_distinct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimize distinct when used on a subset of the tables. </p>
<p>E.g.,: SELECT DISTINCT t1.a FROM t1,t2 WHERE t1.b=t2.b In this case we can stop scanning t2 when we have found one t1.a </p>

</div>
</div>
<a id="ga0aab8b4f0d5f429b7339b2d5e4ef8980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aab8b4f0d5f429b7339b2d5e4ef8980">&#9670;&nbsp;</a></span>pfs_batch_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> QEP_TAB::pfs_batch_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae9c4b8b00c1ff454f9600b1d3095c329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c4b8b00c1ff454f9600b1d3095c329">&#9670;&nbsp;</a></span>PickOutConditionsForTableIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PickOutConditionsForTableIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>table_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa9fef0d874bc0ace0b6bf6b7d99ed01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9fef0d874bc0ace0b6bf6b7d99ed01d">&#9670;&nbsp;</a></span>PickOutConditionsForTableIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PickOutConditionsForTableIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>table_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga78957c24392854d2c20e7a6893bd6201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78957c24392854d2c20e7a6893bd6201">&#9670;&nbsp;</a></span>PossiblyAttachFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAccessPath.html">AccessPath</a>* PossiblyAttachFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>conditions_depend_on_outer_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new iterator that wraps "iterator" and that tests all of the given conditions (if any), ANDed together. </p>
<p>If there are no conditions, just return the given iterator back. </p>

</div>
</div>
<a id="ga0797342b3cb61f1a67d219711d840f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0797342b3cb61f1a67d219711d840f41">&#9670;&nbsp;</a></span>PossiblyAttachFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structAccessPath.html">AccessPath</a>* PossiblyAttachFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> *&#160;</td>
          <td class="paramname"><em>conditions_depend_on_outer_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gafbccddf1e369c7c5d7604c4ed6634ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbccddf1e369c7c5d7604c4ed6634ae3">&#9670;&nbsp;</a></span>prepare_sum_aggregators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> prepare_sum_aggregators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>sum_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>need_distinct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac5f2f4b89ac061448e138b0126f8a582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5f2f4b89ac061448e138b0126f8a582">&#9670;&nbsp;</a></span>process_buffered_windowing_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> process_buffered_windowing_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>new_partition_or_eof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>output_row_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>While there are more unprocessed rows ready to process given the current partition/frame state, process such buffered rows by evaluating/aggregating the window functions defined over this window on the current frame, moving the frame if required. </p>
<p>This method contains the main execution time logic of the evaluation window functions if we need buffering for one or more of the window functions defined on the window.</p>
<p>Moving (sliding) frames can be executed using a naive or optimized strategy for aggregate window functions, like SUM or AVG (but not MAX, or MIN). In the naive approach, for each row considered for processing from the buffer, we visit all the rows defined in the frame for that row, essentially leading to N*M complexity, where N is the number of rows in the result set, and M is the number for rows in the frame. This can be slow for large frames, obviously, so we can choose an optimized evaluation strategy using inversion. This means that when rows leave the frame as we move it forward, we re-use the previous aggregate state, but compute the <em>inverse</em> function to eliminate the contribution to the aggregate by the row(s) leaving the frame, and then use the normal aggregate function to add the contribution of the rows moving into the frame. The present method contains code paths for both strategies.</p>
<p>For integral data types, this is safe in the sense that the result will be the same if no overflow occurs during normal evaluation. For floating numbers, optimizing in this way may lead to different results, so it is not done by default, cf the session variable "windowing_use_high_precision".</p>
<p>Since the evaluation strategy is chosen based on the "most difficult" window function defined on the window, we must also be able to evaluate non-aggregates like ROW_NUMBER, NTILE, FIRST_VALUE in the code path of the optimized aggregates, so there is redundant code for those in the naive and optimized code paths. Note that NTILE forms a class of its own of the non-aggregates: it needs two passes over the partition's rows since the cardinality is needed to compute it. Furthermore, FIRST_VALUE and LAST_VALUE heed the frames, but they are not aggregates.</p>
<p>The is a special optimized code path for <em>static aggregates</em>: when the window frame is the default, e.g. the entire partition and there is no ORDER BY specified, the value of the framing window functions, i.e. SUM, AVG, FIRST_VALUE, LAST_VALUE can be evaluated once and for all and saved when we visit and evaluate the first row of the partition. For later rows we restore the aggregate values and just fill in the other fields and evaluate non-framing window functions for the row.</p>
<p>The code paths both for naive execution and optimized execution differ depending on whether we have ROW or RANGE boundaries in a explicit frame.</p>
<p>A word on BLOBs. Below we make copies of rows into the frame buffer. This is a temporary table, so BLOBs get copied in the normal way.</p>
<p>Sometimes we save records containing already computed framing window functions away into memory only: is the lifetime of the referenced BLOBs long enough? We have two cases:</p>
<p>BLOB results from wfs: Any BLOB results will reside in the copies in result fields of the Items ready for the out file, so they no longer need any BLOB memory read from the frame buffer tmp file.</p>
<p>BLOB fields not evaluated by wfs: Any other BLOB field will be copied as well, and would not have life-time past the next read from the frame buffer, but they are never used since we fill in the fields from the current row after evaluation of the window functions, so we don't need to make special copies of such BLOBs. This can be (and was) tested by shredding any BLOBs deallocated by InnoDB at the next read.</p>
<p>We also save away in memory the next record of the next partition while processing the current partition. Any blob there will have its storage from the read of the input file, but we won't be touching that for reading again until after we start processing the next partition and save the saved away next partition row to the frame buffer.</p>
<p>Note that the logic of this function is centered around the window, not around the window function. It is about putting rows in a partition, in a frame, in a set of peers, and passing this information to all window functions attached to this window; each function looks at the partition, frame, or peer set in its own particular way (for example RANK looks at the partition, SUM looks at the frame).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Current thread </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">param</td><td>Current temporary table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_partition_or_eof</td><td>True if (we are about to start a new partition and there was a previous partition) or eof </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_row_ready</td><td>True if there is a row record ready to write to the out table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error </dd></dl>
<p>The current window</p>
<p>The frame</p>
<p>This is the row we are currently considering for processing and getting ready for output, cf. output_row_ready.</p>
<p>This is the row number of the last row we have buffered so far.</p>
<p>If true, use code path for static aggregates</p>
<p>If true, use code path for ROW bounds with optimized strategy</p>
<p>If true, use code path for RANGE bounds with optimized strategy</p>
<p>We need to evaluate FIRST_VALUE, or optimized MIN/MAX</p>
<p>We need to evaluate LAST_VALUE, or optimized MIN/MAX</p>
<p>We need to evaluate NTH_VALUE</p>
<p>We need to evaluate LEAD/LAG rows</p>
<p>True if an inversion optimization strategy is used. For common code paths.</p>
<p>RANGE was specified as the bounds unit for the frame</p>
<p>UNBOUNDED FOLLOWING was specified for the frame</p>
<p>Row_number of the first row in the frame. Invariant: lower_limit &gt;= 1 after initialization.</p>
<p>Row_number of the logically last row to be computed in the frame, may be higher than the number of rows in the partition. The actual highest row number is computed later, see upper below.</p>
<p>needs peerset of current row to evaluate a wf for the current row.</p>
<p>needs the last peer of the current row within a frame.</p>
<p>For optimized strategy we want to save away the previous aggregate result and reuse in later round by inversion. This keeps track of whether we managed to compute results for this current row (result are "primed"), so we can use inversion in later rows. Cf Window::m_aggregates_primed.</p>
<p>Possible adjustment of the logical upper_limit: no rows exist beyond last_rowno_in_cache.</p>
<p>&lt; iterates over rows in a frame</p>
<p>&lt; RANGE: # of visited rows seen before the frame</p>
<p>Whether we know the start of the frame yet. The a priori setting is inherited from the previous current row.</p>

</div>
</div>
<a id="gab05e3a4b9671ea418312965cf95a85a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab05e3a4b9671ea418312965cf95a85a0">&#9670;&nbsp;</a></span>process_wfs_needing_card()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> process_wfs_needing_card </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structWindow_1_1st__nth.html">Window::st_nth</a> &amp;&#160;</td>
          <td class="paramname"><em>have_nth_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structWindow_1_1st__lead__lag.html">Window::st_lead_lag</a> &amp;&#160;</td>
          <td class="paramname"><em>have_lead_lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>current_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWindow.html">Window</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="window_8h.html#aa1a426efe3df5da9b1e0a0f7f0e99a7f">Window_retrieve_cached_row_reason</a>&#160;</td>
          <td class="paramname"><em>current_row_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process window functions that need partition cardinality. </p>

</div>
</div>
<a id="ga25ee97e14497da8883a660e09671b250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25ee97e14497da8883a660e09671b250">&#9670;&nbsp;</a></span>PushedJoinRejectsHashJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> PushedJoinRejectsHashJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>left_subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>right_subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td>
          <td class="paramname"><em>join_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga536ddcdca5d3f80469f97fb4a07d4d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga536ddcdca5d3f80469f97fb4a07d4d28">&#9670;&nbsp;</a></span>QueryMixesOuterBKAAndBNL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> QueryMixesOuterBKAAndBNL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga399f6885d81a6f25375578864c3298e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399f6885d81a6f25375578864c3298e9">&#9670;&nbsp;</a></span>Read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int RefOrNullIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single row. </p>
<p>The row data is not actually returned from the function; it is put in the table's (or tables', in case of a join) record buffer, ie., table-&gt;records[0].</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="ga36eaaaa690e7ed40b88de669f91454e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36eaaaa690e7ed40b88de669f91454e8">&#9670;&nbsp;</a></span>Read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int EQRefIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read row using unique key: eq_ref access method implementation. </p>
<p>The difference from RefIterator is that it has a one-element lookup cache, maintained in record[0]. Since the eq_ref access method will always return the same row, it is not necessary to read the row more than once, regardless of how many times it is needed in execution. This cache element is used when a row is needed after it has been read once, unless a key conversion error has occurred, or the cache has been disabled.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- Ok </td></tr>
    <tr><td class="paramname">-1</td><td>- Row not found </td></tr>
    <tr><td class="paramname">1</td><td>- Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="gab8d057d6520cc208b236fb30684ef006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8d057d6520cc208b236fb30684ef006">&#9670;&nbsp;</a></span>Read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ConstIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a constant table when there is at most one matching row, using an index lookup. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Row was found </td></tr>
    <tr><td class="paramname">-1</td><td>Row was not found </td></tr>
    <tr><td class="paramname">1</td><td>Got an error (other than row not found) during read </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="ga9a9e5a62f40c54dced584b807b9c601b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9e5a62f40c54dced584b807b9c601b">&#9670;&nbsp;</a></span>Read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FullTextSearchIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single row. </p>
<p>The row data is not actually returned from the function; it is put in the table's (or tables', in case of a join) record buffer, ie., table-&gt;records[0].</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="gae544cfbf4ebbef3a53dec28ee7fc00ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae544cfbf4ebbef3a53dec28ee7fc00ab">&#9670;&nbsp;</a></span>Read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DynamicRangeIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single row. </p>
<p>The row data is not actually returned from the function; it is put in the table's (or tables', in case of a join) record buffer, ie., table-&gt;records[0].</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="ga17e2b9dbfd2a00d167b332ff0c582b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e2b9dbfd2a00d167b332ff0c582b0b">&#9670;&nbsp;</a></span>Read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PushedJoinRefIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single row. </p>
<p>The row data is not actually returned from the function; it is put in the table's (or tables', in case of a join) record buffer, ie., table-&gt;records[0].</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="gad7395c445fc104deabd71269c781f72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7395c445fc104deabd71269c781f72e">&#9670;&nbsp;</a></span>read_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int read_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf318e26d5c9edfd906c39cdcdb274b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf318e26d5c9edfd906c39cdcdb274b91">&#9670;&nbsp;</a></span>read_frame_buffer_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> read_frame_buffer_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a7cde0074dfd288f2d70c0e035dacb28a">int64</a>&#160;</td>
          <td class="paramname"><em>rowno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWindow.html">Window</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>for_nth_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read row rowno from frame buffer tmp file using cached row positions to minimize positioning work. </p>

</div>
</div>
<a id="ga93e1c9349177ad00a2e6d12407948983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93e1c9349177ad00a2e6d12407948983">&#9670;&nbsp;</a></span>read_system()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int read_system </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a constant table when there is at most one matching row, using a table scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Row was found </td></tr>
    <tr><td class="paramname">-1</td><td>Row was not found </td></tr>
    <tr><td class="paramname">1</td><td>Got an error (other than row not found) during read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga426a26799906018ac4c241e6a9f82c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426a26799906018ac4c241e6a9f82c19">&#9670;&nbsp;</a></span>record_prefix_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t record_prefix_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out how many bytes it takes to store the smallest prefix which covers all the columns that will be read from a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qep_tab</td><td>the table to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the smallest prefix that covers all records to be read from the table </dd></dl>

</div>
</div>
<a id="ga36761d9bbac5b5399388f60ff5681874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36761d9bbac5b5399388f60ff5681874">&#9670;&nbsp;</a></span>RefToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string RefToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__REF.html">TABLE_REF</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKEY.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>include_nulls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0b11db7a1b6f33befa12f10a3fc5f6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b11db7a1b6f33befa12f10a3fc5f6e1">&#9670;&nbsp;</a></span>replace_contents_of_rollup_wrappers_with_tmp_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> replace_contents_of_rollup_wrappers_with_tmp_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each rollup wrapper below the given item, replace its argument with a temporary field, e.g. </p>
<p>1 + rollup_group_item(a) -&gt; 1 + rollup_group_item(&lt;temporary&gt;.a).</p>
<p>Which temporary field to use is found by looking at the SELECT_LEX's group items, and looking up their (previously set) result fields. </p>

</div>
</div>
<a id="ga4798eb113599c9b1f81fdb94a60d79a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4798eb113599c9b1f81fdb94a60d79a8">&#9670;&nbsp;</a></span>replace_embedded_rollup_references_with_tmp_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> replace_embedded_rollup_references_with_tmp_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each rollup wrapper below the given item, replace it with a temporary field, e.g. </p>
<p>1 + rollup_group_item(a) -&gt; 1 + &lt;temporary&gt;.<code>rollup_group_item(a)</code></p>
<p>Which temporary field to use is found by looking at the other fields; the rollup_group_item should already exist earlier in the list (and having a temporary table field set up), simply by virtue of being a group item. </p>

</div>
</div>
<a id="ga4fb800e0e68d03a1b49a9cf66fda4006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb800e0e68d03a1b49a9cf66fda4006">&#9670;&nbsp;</a></span>report_handler_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int report_handler_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Help function when we get some an error from the table handler. </p>

</div>
</div>
<a id="ga26ff8f5c3f225f3116905dd3ea4c7080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ff8f5c3f225f3116905dd3ea4c7080">&#9670;&nbsp;</a></span>reset_framing_wf_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reset_framing_wf_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *&#160;</td>
          <td class="paramname"><em>func_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk the function calls and reset any framing window function's window state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_ptr</td><td>an array of function call items which might represent or contain window function calls </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga199450a2c1eb75877618451735691489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga199450a2c1eb75877618451735691489">&#9670;&nbsp;</a></span>reset_non_framing_wf_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reset_non_framing_wf_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *&#160;</td>
          <td class="paramname"><em>func_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk the function calls and reset any non-framing window function's window state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_ptr</td><td>an array of function call items which might represent or contain window function calls </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4a12f9d0a65ad11750f6fdd206a6759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4a12f9d0a65ad11750f6fdd206a6759">&#9670;&nbsp;</a></span>reset_wf_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reset_wf_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="temp__table__param_8h.html#ac2dd7a67711e7058b87c8f6a8befe560">Func_ptr_array</a> *&#160;</td>
          <td class="paramname"><em>func_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>framing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minion for reset_framing_wf_states and reset_non_framing_wf_state, q.v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_ptr</td><td>the set of functions </td></tr>
    <tr><td class="paramname">framing</td><td>true if we want to reset for framing window functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84f0928188542530ccca88b0f7c1576e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84f0928188542530ccca88b0f7c1576e">&#9670;&nbsp;</a></span>restore_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::restore_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>save_nullinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore all result fields for all tables specified in save_nullinfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">save_nullinfo</td><td>Set of tables for which restore is necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Const tables must have their NULL value flags restored, </dd></dl>
<dl class="section see"><dt>See also</dt><dd>JOIN::clear_fields(). </dd></dl>

</div>
</div>
<a id="ga56193ae529e5919b702ada22af55d242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56193ae529e5919b702ada22af55d242">&#9670;&nbsp;</a></span>restore_special_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::restore_special_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td>
          <td class="paramname"><em>special_rowno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore row special_rowno into record from in-memory copy. </p>
<p>Any fields not the result of window functions are not used, but they do tag along here (unnecessary copying..). BLOBs: have storage in result_field of Item for the window function although the pointer is copied here. The result field storage is stable across reads from the frame buffer, so safe. </p>

</div>
</div>
<a id="ga6634e09c549559c5547496bf849a6c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6634e09c549559c5547496bf849a6c0d">&#9670;&nbsp;</a></span>safe_index_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int safe_index_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf5a4ed26b9591fd1aa44477ce7711ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5a4ed26b9591fd1aa44477ce7711ccf">&#9670;&nbsp;</a></span>save_special_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Window::save_special_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#abc0f5bc07737e498f287334775dff2b6">uint64</a>&#160;</td>
          <td class="paramname"><em>special_rowno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save row special_rowno in table t-&gt;record[0] to an in-memory copy for later restoration. </p>

</div>
</div>
<a id="gae23917fca2e9514cd1d23a434e4b629e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae23917fca2e9514cd1d23a434e4b629e">&#9670;&nbsp;</a></span>set_record_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> set_record_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a data buffer that the storage engine can use for fetching batches of records. </p>
<p>A buffer is only allocated if ha_is_record_buffer_wanted() returns true for the handler, and the scan in question is of a kind that could be expected to benefit from fetching records in batches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the table to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if an error occurred when allocating the buffer </td></tr>
    <tr><td class="paramname">false</td><td>if a buffer was successfully allocated, or if a buffer was not attempted allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c05864b7f384582256d95e7e98dbc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c05864b7f384582256d95e7e98dbc82">&#9670;&nbsp;</a></span>SetCostOnHashJoinAccessPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCostOnHashJoinAccessPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCost__model__server.html">Cost_model_server</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga51f19e20c1f1fe8b9e9abb4781c51202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f19e20c1f1fe8b9e9abb4781c51202">&#9670;&nbsp;</a></span>SetCostOnNestedLoopAccessPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCostOnNestedLoopAccessPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCost__model__server.html">Cost_model_server</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab9b0d6fb3a7d21883b27bab7d679116d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b0d6fb3a7d21883b27bab7d679116d">&#9670;&nbsp;</a></span>SetCostOnTableAccessPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCostOnTableAccessPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCost__model__server.html">Cost_model_server</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPOSITION.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_after_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAccessPath.html">AccessPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga64fd19acccb626499e8b730439ca83f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64fd19acccb626499e8b730439ca83f2">&#9670;&nbsp;</a></span>setup_copy_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_copy_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>res_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up caches for holding the values of non-aggregated expressions. </p>
<p>The values are saved at the start of every new group.</p>
<p>This code path is used in the cases when aggregation can be performed without a temporary table. Why it still uses a Temp_table_param is a mystery.</p>
<p>Only FIELD_ITEM:s and FUNC_ITEM:s needs to be saved between groups. Change old item_field to use a new field with points at saved fieldvalue This function is only called before use of send_result_set_metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">fields</td><td>list of all fields; should really be const, but Item does not always respect constness </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param</td><td>temporary table parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ref_item_array</td><td>array of pointers to top elements of field list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res_fields</td><td>new list of items of select item list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga1b1125b75ed00a408f039bb83de7c480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1125b75ed00a408f039bb83de7c480">&#9670;&nbsp;</a></span>setup_sum_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_sum_funcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call <code>setup()</code> for all sum functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">func_ptr</td><td>sum function list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>ok </td></tr>
    <tr><td class="paramname">true</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5120e564d6decdcc43526a56a05fb81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5120e564d6decdcc43526a56a05fb81b">&#9670;&nbsp;</a></span>setup_tmptable_write_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup_tmptable_write_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup write_func of QEP_tmp_table object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>QEP_TAB of a tmp table </td></tr>
    <tr><td class="paramname">trace</td><td>Opt_trace_object to add to</td></tr>
  </table>
  </dd>
</dl>
<p>Function sets up write_func according to how QEP_tmp_table object that is attached to the given join_tab will be used in the query. </p>

</div>
</div>
<a id="gace896571e2a7a64f937cad6454eae05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace896571e2a7a64f937cad6454eae05f">&#9670;&nbsp;</a></span>SplitConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SplitConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>current_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>predicates_below_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *&#160;</td>
          <td class="paramname"><em>predicates_above_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structPendingCondition.html">PendingCondition</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_conditions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafc42681cef0b442738f450f9992c3fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc42681cef0b442738f450f9992c3fd2">&#9670;&nbsp;</a></span>SubtreeHasIncompletePushedJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SubtreeHasIncompletePushedJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#ac2ccedf01a51d672ab7af38745e7b4fe">qep_tab_map</a>&#160;</td>
          <td class="paramname"><em>subtree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8033260452204b4682aa0acfa55e672d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8033260452204b4682aa0acfa55e672d">&#9670;&nbsp;</a></span>table_rec_cmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> table_rec_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare GROUP BY in from tmp table's record[0] and record[1]. </p>
<dl class="section return"><dt>Returns</dt><dd>true records are different false records are the same </dd></dl>

</div>
</div>
<a id="ga43cf740429a9794655ec3c658f85e331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43cf740429a9794655ec3c658f85e331">&#9670;&nbsp;</a></span>unique_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> unique_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>hash_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate hash for a field. </p>
<dl class="section return"><dt>Returns</dt><dd>generated hash </dd></dl>

</div>
</div>
<a id="ga1a419d73d40c0de7432c6c09caf076d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a419d73d40c0de7432c6c09caf076d8">&#9670;&nbsp;</a></span>unique_hash_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> unique_hash_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9efd0b16d185a2051ee62e2d11fa5284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9efd0b16d185a2051ee62e2d11fa5284">&#9670;&nbsp;</a></span>unique_hash_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> unique_hash_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate hash for unique constraint according to group-by list. </p>
<p>This reads the values of the GROUP BY expressions from fields so assumes those expressions have been computed and stored into fields of a temporary table; in practice this means that copy_fields() and copy_funcs() must have been called. </p>

</div>
</div>
<a id="ga02c36c7359faa0ad5c352d48b671874a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02c36c7359faa0ad5c352d48b671874a">&#9670;&nbsp;</a></span>UnlockRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EQRefIterator::UnlockRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Since EQRefIterator may buffer a record, do not unlock it if it was not used in this invocation of EQRefIterator::Read(). </p>
<p>Only count locks, thus remembering if the record was left unused, and unlock already when pruning the current value of TABLE_REF buffer. </p><dl class="section see"><dt>See also</dt><dd>EQRefIterator::Read() </dd></dl>

<p>Implements <a class="el" href="classRowIterator.html#a7590a98b54a85d3624cd9667c2da0764">RowIterator</a>.</p>

</div>
</div>
<a id="ga58f275d3bce8cc10d2f624b3ed824b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f275d3bce8cc10d2f624b3ed824b01">&#9670;&nbsp;</a></span>unwrap_rollup_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* unwrap_rollup_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7aa992f905fbc700aa838569b164c7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa992f905fbc700aa838569b164c7da">&#9670;&nbsp;</a></span>update_const_equal_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> update_const_equal_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check appearance of new constant items in multiple equalities of a condition after reading a constant table. </p>
<p>The function retrieves the cond condition and for each encountered multiple equality checks whether new constants have appeared after reading the constant (single row) table tab. If so it adjusts the multiple equality appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">cond</td><td>condition whose multiple equalities are to be checked </td></tr>
    <tr><td class="paramname">tab</td><td>constant table that has been read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5698b0cbef211efe2edf7bc2897f7e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5698b0cbef211efe2edf7bc2897f7e25">&#9670;&nbsp;</a></span>update_item_cache_if_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int update_item_cache_if_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCached__item.html">Cached_item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab9c7ce3fe066b0eef700dde8c8c11a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c7ce3fe066b0eef700dde8c8c11a9e">&#9670;&nbsp;</a></span>update_tmptable_sum_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_tmptable_sum_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>tmp_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update record 0 in tmp_table from record 1. </p>

</div>
</div>
<a id="ga685838679adf501ece418d4bd969f2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685838679adf501ece418d4bd969f2ea">&#9670;&nbsp;</a></span>use_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> QEP_TAB::use_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use ordering provided by chosen index? </p>
<p>Check if access to this JOIN_TAB has to retrieve rows in sorted order as defined by the ordered index used to access this table. </p>

</div>
</div>
<a id="ga298707b5a21869b33bcf463a5b89de0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga298707b5a21869b33bcf463a5b89de0b">&#9670;&nbsp;</a></span>UseBKA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> UseBKA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf488e159058bf20eebc5447769fcf41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf488e159058bf20eebc5447769fcf41a">&#9670;&nbsp;</a></span>UseHashJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> UseHashJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaddf402a0aa4cdd7bdc55f9d50b88ac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddf402a0aa4cdd7bdc55f9d50b88ac71">&#9670;&nbsp;</a></span>MAX_RECORD_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t MAX_RECORD_BUFFER_SIZE = 128 * 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum amount of space (in bytes) to allocate for a Record_buffer. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
