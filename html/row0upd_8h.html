<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/row0upd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('row0upd_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">row0upd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Update of a row.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stack&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="data0data_8h_source.html">data0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lob0lob_8h_source.html">lob0lob.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql_2table_8h_source.html">table.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0pcur_8h_source.html">btr0pcur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0types_8h_source.html">pars0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br />
<code>#include &quot;row0upd.ic&quot;</code><br />
</div>
<p><a href="row0upd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlob__index__diff__t.html">lob_index_diff_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used for undo logging of LOB index changes.  <a href="structlob__index__diff__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLob__diff.html">Lob_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The modification done to the LOB.  <a href="structLob__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__field__t.html">upd_field_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__t.html">upd_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__node__t.html">upd_node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8970df395a8d7c0590e52270e9803037"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a8970df395a8d7c0590e52270e9803037">row_upd_changes_ord_field_binary</a>(<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>,  <a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>,  thr,  row,  ext,  non_mv_upd)</td></tr>
<tr class="separator:a8970df395a8d7c0590e52270e9803037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9de46e091d1fa137b2d8d2c855665a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a0a9de46e091d1fa137b2d8d2c855665a">upd_fld_is_virtual_col</a>(upd_fld)&#160;&#160;&#160;(((upd_fld)-&gt;new_val.type.prtype &amp; <a class="el" href="data0type_8h.html#a232c49e6bcfce2e4efb7d27ea6d7719c">DATA_VIRTUAL</a>) == <a class="el" href="data0type_8h.html#a232c49e6bcfce2e4efb7d27ea6d7719c">DATA_VIRTUAL</a>)</td></tr>
<tr class="separator:a0a9de46e091d1fa137b2d8d2c855665a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64127ec7ade5c887ac2f9849d5533d61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a64127ec7ade5c887ac2f9849d5533d61">upd_fld_is_multi_value_col</a>(upd_fld)&#160;&#160;&#160;(<a class="el" href="data0data_8h.html#ad79e05d68cd6ae496c4144c6c7b81cc7">dfield_is_multi_value</a>(&amp;((upd_fld)-&gt;new_val)))</td></tr>
<tr class="separator:a64127ec7ade5c887ac2f9849d5533d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c93eed92cd93144eeaa7f264adabc45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a5c93eed92cd93144eeaa7f264adabc45">upd_fld_set_virtual_col</a>(upd_fld)&#160;&#160;&#160;((upd_fld)-&gt;new_val.type.prtype |= <a class="el" href="data0type_8h.html#a232c49e6bcfce2e4efb7d27ea6d7719c">DATA_VIRTUAL</a>)</td></tr>
<tr class="separator:a5c93eed92cd93144eeaa7f264adabc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c347f996e51f6fb49ef6c067ba04bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a96c347f996e51f6fb49ef6c067ba04bf">UPD_NODE_MAGIC_N</a>&#160;&#160;&#160;1579975</td></tr>
<tr class="separator:a96c347f996e51f6fb49ef6c067ba04bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44102f8533c40d47458f13aac650ef38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a44102f8533c40d47458f13aac650ef38">UPD_NODE_SET_IX_LOCK</a></td></tr>
<tr class="separator:a44102f8533c40d47458f13aac650ef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ed1fcdf27db3b4ada62729f09fd233"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a78ed1fcdf27db3b4ada62729f09fd233">UPD_NODE_UPDATE_CLUSTERED</a></td></tr>
<tr class="separator:a78ed1fcdf27db3b4ada62729f09fd233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0446f02f1cc4570e730ed640bf311493"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a0446f02f1cc4570e730ed640bf311493">UPD_NODE_INSERT_CLUSTERED</a></td></tr>
<tr class="separator:a0446f02f1cc4570e730ed640bf311493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1678d94ec05825c81d2a4748f19c4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#acc1678d94ec05825c81d2a4748f19c4a">UPD_NODE_UPDATE_ALL_SEC</a></td></tr>
<tr class="separator:acc1678d94ec05825c81d2a4748f19c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5381bd0d873234a70f103df73b1b02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#abe5381bd0d873234a70f103df73b1b02">UPD_NODE_UPDATE_SOME_SEC</a></td></tr>
<tr class="separator:abe5381bd0d873234a70f103df73b1b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521a1927c7f930bb014e8697bcc579cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a521a1927c7f930bb014e8697bcc579cf">UPD_NODE_NO_ORD_CHANGE</a></td></tr>
<tr class="separator:a521a1927c7f930bb014e8697bcc579cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f48e6b565f0a43dce9888b2d23d16e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ac1f48e6b565f0a43dce9888b2d23d16e">UPD_NODE_NO_SIZE_CHANGE</a></td></tr>
<tr class="separator:ac1f48e6b565f0a43dce9888b2d23d16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a457641854a34ad6c7872675ee93265f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a457641854a34ad6c7872675ee93265f7">Lob_index_diff_vec</a> = std::vector&lt; <a class="el" href="structlob__index__diff__t.html">lob_index_diff_t</a>, <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; <a class="el" href="structlob__index__diff__t.html">lob_index_diff_t</a> &gt; &gt;</td></tr>
<tr class="separator:a457641854a34ad6c7872675ee93265f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49846971910ff699a3422b5fb5f41565"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a49846971910ff699a3422b5fb5f41565">Lob_diff_vector</a> = std::vector&lt; <a class="el" href="structLob__diff.html">Lob_diff</a>, <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; <a class="el" href="structLob__diff.html">Lob_diff</a> &gt; &gt;</td></tr>
<tr class="separator:a49846971910ff699a3422b5fb5f41565"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4662cf8a186586e3caad5a7a28cf9ec"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae4662cf8a186586e3caad5a7a28cf9ec">upd_create</a> (ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:ae4662cf8a186586e3caad5a7a28cf9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an update vector object.  <a href="#ae4662cf8a186586e3caad5a7a28cf9ec">More...</a><br /></td></tr>
<tr class="separator:ae4662cf8a186586e3caad5a7a28cf9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0bebe9c2bdc7ec292e9784374476f2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#adc0bebe9c2bdc7ec292e9784374476f2">upd_get_n_fields</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:adc0bebe9c2bdc7ec292e9784374476f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of fields in the update vector == number of columns to be updated by an update vector.  <a href="#adc0bebe9c2bdc7ec292e9784374476f2">More...</a><br /></td></tr>
<tr class="separator:adc0bebe9c2bdc7ec292e9784374476f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc9824c435b30f9957b9864ce39c8ad"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a1cc9824c435b30f9957b9864ce39c8ad">upd_get_nth_field</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:a1cc9824c435b30f9957b9864ce39c8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth field of an update vector.  <a href="#a1cc9824c435b30f9957b9864ce39c8ad">More...</a><br /></td></tr>
<tr class="separator:a1cc9824c435b30f9957b9864ce39c8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6626ce48273c089093d1a95b5a32b20"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ad6626ce48273c089093d1a95b5a32b20">upd_field_set_field_no</a> (<a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field, ulint field_no, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:ad6626ce48273c089093d1a95b5a32b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an index field number to be updated by an update vector field.  <a href="#ad6626ce48273c089093d1a95b5a32b20">More...</a><br /></td></tr>
<tr class="separator:ad6626ce48273c089093d1a95b5a32b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f6386e3414d3baee23fd9ba70cb8a1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#af3f6386e3414d3baee23fd9ba70cb8a1">upd_field_set_v_field_no</a> (<a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field, ulint field_no, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:af3f6386e3414d3baee23fd9ba70cb8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set field number to a update vector field, marks this field is updated  <a href="#af3f6386e3414d3baee23fd9ba70cb8a1">More...</a><br /></td></tr>
<tr class="separator:af3f6386e3414d3baee23fd9ba70cb8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef1a621ff94f9f0dcd3e996c8c01eba"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a6ef1a621ff94f9f0dcd3e996c8c01eba">upd_get_field_by_field_no</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint no, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_virtual)</td></tr>
<tr class="memdesc:a6ef1a621ff94f9f0dcd3e996c8c01eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a field of an update vector by field_no.  <a href="#a6ef1a621ff94f9f0dcd3e996c8c01eba">More...</a><br /></td></tr>
<tr class="separator:a6ef1a621ff94f9f0dcd3e996c8c01eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2720d792e43ac476db80779bba13544c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a2720d792e43ac476db80779bba13544c">row_upd_write_sys_vals_to_log</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a2720d792e43ac476db80779bba13544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes into the redo log the values of trx id and roll ptr and enough info to determine their positions within a clustered index record.  <a href="#a2720d792e43ac476db80779bba13544c">More...</a><br /></td></tr>
<tr class="separator:a2720d792e43ac476db80779bba13544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b7c860ec8f58d4fa4d79ad85c95f1b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a01b7c860ec8f58d4fa4d79ad85c95f1b">row_upd_rec_sys_fields</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr)</td></tr>
<tr class="memdesc:a01b7c860ec8f58d4fa4d79ad85c95f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the trx id and roll ptr field in a clustered index record when a row is updated or marked deleted.  <a href="#a01b7c860ec8f58d4fa4d79ad85c95f1b">More...</a><br /></td></tr>
<tr class="separator:a01b7c860ec8f58d4fa4d79ad85c95f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa516d2dc3d1ddcdf1a73b31cd5cbce0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#aa516d2dc3d1ddcdf1a73b31cd5cbce0b">row_upd_index_entry_sys_field</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint type, ib_uint64_t val)</td></tr>
<tr class="memdesc:aa516d2dc3d1ddcdf1a73b31cd5cbce0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the trx id or roll ptr field of a clustered index entry.  <a href="#aa516d2dc3d1ddcdf1a73b31cd5cbce0b">More...</a><br /></td></tr>
<tr class="separator:aa516d2dc3d1ddcdf1a73b31cd5cbce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655590bf847503b6297d9d8d246201ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a655590bf847503b6297d9d8d246201ff">upd_node_create</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a655590bf847503b6297d9d8d246201ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an update node for a query graph.  <a href="#a655590bf847503b6297d9d8d246201ff">More...</a><br /></td></tr>
<tr class="separator:a655590bf847503b6297d9d8d246201ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7fba00a40039307f4605056af9c54b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a3b7fba00a40039307f4605056af9c54b">row_upd_index_write_log</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a3b7fba00a40039307f4605056af9c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the redo log the new values of the fields occurring in the index.  <a href="#a3b7fba00a40039307f4605056af9c54b">More...</a><br /></td></tr>
<tr class="separator:a3b7fba00a40039307f4605056af9c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8da72b47b7afc4a67c12584cce14db"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a5c8da72b47b7afc4a67c12584cce14db">row_upd_changes_field_size_or_external</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:a5c8da72b47b7afc4a67c12584cce14db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if row update changes size of some field in index or if some field to be updated is stored externally in rec or update.  <a href="#a5c8da72b47b7afc4a67c12584cce14db">More...</a><br /></td></tr>
<tr class="separator:a5c8da72b47b7afc4a67c12584cce14db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902192e6824406c3796068d2173b2aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a902192e6824406c3796068d2173b2aff">row_upd_changes_disowned_external</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:a902192e6824406c3796068d2173b2aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if row update contains disowned external fields.  <a href="#a902192e6824406c3796068d2173b2aff">More...</a><br /></td></tr>
<tr class="separator:a902192e6824406c3796068d2173b2aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4c4ef5c26a83086f51130897c89dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#add4c4ef5c26a83086f51130897c89dd9">row_upd_rec_in_place</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="memdesc:add4c4ef5c26a83086f51130897c89dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector to the record given.  <a href="#add4c4ef5c26a83086f51130897c89dd9">More...</a><br /></td></tr>
<tr class="separator:add4c4ef5c26a83086f51130897c89dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cf371b11d50c6ad635038a71306b73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a00cf371b11d50c6ad635038a71306b73">row_upd_build_sec_rec_difference_binary</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a00cf371b11d50c6ad635038a71306b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an update vector from those fields which in a secondary index entry differ from a record that has the equal ordering fields.  <a href="#a00cf371b11d50c6ad635038a71306b73">More...</a><br /></td></tr>
<tr class="separator:a00cf371b11d50c6ad635038a71306b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838bfedaa4543cf09a38da782a458217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a838bfedaa4543cf09a38da782a458217">row_upd_build_difference_binary</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> no_sys, <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structTABLE.html">TABLE</a> *mysql_table, <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *error)</td></tr>
<tr class="memdesc:a838bfedaa4543cf09a38da782a458217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an update vector from those fields, excluding the roll ptr and trx id fields, which in an index entry differ from a record that has the equal ordering fields.  <a href="#a838bfedaa4543cf09a38da782a458217">More...</a><br /></td></tr>
<tr class="separator:a838bfedaa4543cf09a38da782a458217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdbead3f6bc4683c091c025761b28c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#afbdbead3f6bc4683c091c025761b28c7">row_upd_index_replace_new_col_vals_index_pos</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ibool order_only, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:afbdbead3f6bc4683c091c025761b28c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector to the index entry given.  <a href="#afbdbead3f6bc4683c091c025761b28c7">More...</a><br /></td></tr>
<tr class="separator:afbdbead3f6bc4683c091c025761b28c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9a7b3c3d7c1127f608f91ae11b41ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a9a9a7b3c3d7c1127f608f91ae11b41ef">row_upd_index_replace_new_col_vals</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a9a9a7b3c3d7c1127f608f91ae11b41ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector to the index entry given.  <a href="#a9a9a7b3c3d7c1127f608f91ae11b41ef">More...</a><br /></td></tr>
<tr class="separator:a9a9a7b3c3d7c1127f608f91ae11b41ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc29008c34ee2e8c776a6d73b76f61e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#acc29008c34ee2e8c776a6d73b76f61e4">row_upd_replace</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdtuple__t.html">dtuple_t</a> *row, <a class="el" href="structrow__ext__t.html">row_ext_t</a> **ext, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:acc29008c34ee2e8c776a6d73b76f61e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the new column values stored in the update vector.  <a href="#acc29008c34ee2e8c776a6d73b76f61e4">More...</a><br /></td></tr>
<tr class="separator:acc29008c34ee2e8c776a6d73b76f61e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0039db94d3ed183135cfa8d4a49b42d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae0039db94d3ed183135cfa8d4a49b42d">row_upd_replace_vcol</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *row, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> upd_new, <a class="el" href="structdtuple__t.html">dtuple_t</a> *undo_row, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr)</td></tr>
<tr class="memdesc:ae0039db94d3ed183135cfa8d4a49b42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the virtual column values stored in a dtuple with that of a update vector.  <a href="#ae0039db94d3ed183135cfa8d4a49b42d">More...</a><br /></td></tr>
<tr class="separator:ae0039db94d3ed183135cfa8d4a49b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a462bcc93bd912d846fb253463bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#af70a462bcc93bd912d846fb253463bf0">row_upd_changes_ord_field_binary_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, const <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *row, const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *ext, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *non_mv_upd, ulint <a class="el" href="hp__test2_8cc.html#a49fd07a69e183ac48c658336ad8bbb27">flag</a>)</td></tr>
<tr class="memdesc:af70a462bcc93bd912d846fb253463bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an update vector changes an ordering field of an index record.  <a href="#af70a462bcc93bd912d846fb253463bf0">More...</a><br /></td></tr>
<tr class="separator:af70a462bcc93bd912d846fb253463bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34c7757393893c9ac19cd3dfaf1befe"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ab34c7757393893c9ac19cd3dfaf1befe">row_upd_changes_fts_column</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field)</td></tr>
<tr class="memdesc:ab34c7757393893c9ac19cd3dfaf1befe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an FTS indexed column is affected by an UPDATE.  <a href="#ab34c7757393893c9ac19cd3dfaf1befe">More...</a><br /></td></tr>
<tr class="separator:ab34c7757393893c9ac19cd3dfaf1befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedafd388956767bd826a954029de13f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#aedafd388956767bd826a954029de13f4">row_upd_changes_doc_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field)</td></tr>
<tr class="memdesc:aedafd388956767bd826a954029de13f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an FTS Doc ID column is affected by an UPDATE.  <a href="#aedafd388956767bd826a954029de13f4">More...</a><br /></td></tr>
<tr class="separator:aedafd388956767bd826a954029de13f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e7dba0ba7d65289f702a3d3f8ec00"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a0b3e7dba0ba7d65289f702a3d3f8ec00">row_upd_changes_some_index_ord_field_binary</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>)</td></tr>
<tr class="memdesc:a0b3e7dba0ba7d65289f702a3d3f8ec00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an update vector changes an ordering field of an index record.  <a href="#a0b3e7dba0ba7d65289f702a3d3f8ec00">More...</a><br /></td></tr>
<tr class="separator:a0b3e7dba0ba7d65289f702a3d3f8ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b88335c2bea8df94e814325e117c491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a8b88335c2bea8df94e814325e117c491">row_upd_store_row</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE.html">TABLE</a> *mysql_table)</td></tr>
<tr class="memdesc:a8b88335c2bea8df94e814325e117c491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores to the heap the row on which the node-&gt;pcur is positioned.  <a href="#a8b88335c2bea8df94e814325e117c491">More...</a><br /></td></tr>
<tr class="separator:a8b88335c2bea8df94e814325e117c491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33265d5ab656dba287eb974c407bcf18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a33265d5ab656dba287eb974c407bcf18">row_upd_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a33265d5ab656dba287eb974c407bcf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a row in a table.  <a href="#a33265d5ab656dba287eb974c407bcf18">More...</a><br /></td></tr>
<tr class="separator:a33265d5ab656dba287eb974c407bcf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae304da2bc13e35c67c164467960b27ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae304da2bc13e35c67c164467960b27ac">row_upd_parse_sys_vals</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, ulint *<a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *roll_ptr)</td></tr>
<tr class="memdesc:ae304da2bc13e35c67c164467960b27ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the log data of system field values.  <a href="#ae304da2bc13e35c67c164467960b27ac">More...</a><br /></td></tr>
<tr class="separator:ae304da2bc13e35c67c164467960b27ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb05f212ddac2808ee035ef4d22f917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#abfb05f212ddac2808ee035ef4d22f917">row_upd_rec_sys_fields_in_recovery</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const ulint *offsets, ulint <a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr)</td></tr>
<tr class="memdesc:abfb05f212ddac2808ee035ef4d22f917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the trx id and roll ptr field in a clustered index record in database recovery.  <a href="#abfb05f212ddac2808ee035ef4d22f917">More...</a><br /></td></tr>
<tr class="separator:abfb05f212ddac2808ee035ef4d22f917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0960639c762f39cce1d29241e8b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a8bf0960639c762f39cce1d29241e8b1e">row_upd_index_parse</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structupd__t.html">upd_t</a> **update_out)</td></tr>
<tr class="memdesc:a8bf0960639c762f39cce1d29241e8b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the log data written by row_upd_index_write_log.  <a href="#a8bf0960639c762f39cce1d29241e8b1e">More...</a><br /></td></tr>
<tr class="separator:a8bf0960639c762f39cce1d29241e8b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfdb6c921068d3859455412321acc28"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a5cfdb6c921068d3859455412321acc28">row_upd_get_new_autoinc_counter</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, ulint autoinc_field_no)</td></tr>
<tr class="memdesc:a5cfdb6c921068d3859455412321acc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the new autoinc counter from the update vector when there is an autoinc field defined in this table.  <a href="#a5cfdb6c921068d3859455412321acc28">More...</a><br /></td></tr>
<tr class="separator:a5cfdb6c921068d3859455412321acc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66c139b895a217591a0e987a6870d50"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae66c139b895a217591a0e987a6870d50">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structlob__index__diff__t.html">lob_index_diff_t</a> &amp;obj)</td></tr>
<tr class="memdesc:ae66c139b895a217591a0e987a6870d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloading the global output operator to print lob_index_diff_t object.  <a href="#ae66c139b895a217591a0e987a6870d50">More...</a><br /></td></tr>
<tr class="separator:ae66c139b895a217591a0e987a6870d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b9fd5c9abaed8e55aaa412b17a4a20"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae7b9fd5c9abaed8e55aaa412b17a4a20">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structLob__diff.html">Lob_diff</a> &amp;obj)</td></tr>
<tr class="separator:ae7b9fd5c9abaed8e55aaa412b17a4a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab109239003466d6abc85ad1cf081c596"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ab109239003466d6abc85ad1cf081c596">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structupd__field__t.html">upd_field_t</a> &amp;obj)</td></tr>
<tr class="separator:ab109239003466d6abc85ad1cf081c596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2522b883af6618c18e80d1427d467d38"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a2522b883af6618c18e80d1427d467d38">print_binary_diff</a> (std::ostream &amp;out, const <a class="el" href="classBinary__diff.html">Binary_diff</a> *bdiff, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr class="memdesc:a2522b883af6618c18e80d1427d467d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given binary diff into the given output stream.  <a href="#a2522b883af6618c18e80d1427d467d38">More...</a><br /></td></tr>
<tr class="separator:a2522b883af6618c18e80d1427d467d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab7cfc9eb856416686a54a7cc96df71"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#acab7cfc9eb856416686a54a7cc96df71">print_binary_diff</a> (std::ostream &amp;out, const <a class="el" href="classBinary__diff.html">Binary_diff</a> *bdiff)</td></tr>
<tr class="separator:acab7cfc9eb856416686a54a7cc96df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff98575fe5088121ea9f66cb649e7df"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#afff98575fe5088121ea9f66cb649e7df">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structupd__t.html">upd_t</a> &amp;obj)</td></tr>
<tr class="separator:afff98575fe5088121ea9f66cb649e7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae568f74fa2ed2cb5b3c9cbd99652696e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae568f74fa2ed2cb5b3c9cbd99652696e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="sql_2table_8h.html#a639813cd7039c2f15c2e7984541af5b5">Binary_diff_vector</a> &amp;obj)</td></tr>
<tr class="separator:ae568f74fa2ed2cb5b3c9cbd99652696e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Update of a row. </p>
<p>Created 12/27/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8970df395a8d7c0590e52270e9803037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8970df395a8d7c0590e52270e9803037">&#9670;&nbsp;</a></span>row_upd_changes_ord_field_binary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define row_upd_changes_ord_field_binary</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ext, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">non_mv_upd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="row0upd_8h.html#af70a462bcc93bd912d846fb253463bf0">row_upd_changes_ord_field_binary_func</a>(<a class="code" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="code" href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a>, thr, row, ext,  \</div><div class="line">                                        non_mv_upd, 0)</div><div class="ttc" id="mysql_8cc_html_adfa69ae672499b1037123a1f17c5552b"><div class="ttname"><a href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a></div><div class="ttdeci">char * index(const char *, int c)</div><div class="ttdef"><b>Definition:</b> mysql.cc:2928</div></div>
<div class="ttc" id="myisamlog_8cc_html_a63c3b620cc1cd0b4a2850c8d9804fde2"><div class="ttname"><a href="myisamlog_8cc.html#a63c3b620cc1cd0b4a2850c8d9804fde2">update</a></div><div class="ttdeci">static uint update</div><div class="ttdef"><b>Definition:</b> myisamlog.cc:90</div></div>
<div class="ttc" id="row0upd_8h_html_af70a462bcc93bd912d846fb253463bf0"><div class="ttname"><a href="row0upd_8h.html#af70a462bcc93bd912d846fb253463bf0">row_upd_changes_ord_field_binary_func</a></div><div class="ttdeci">bool row_upd_changes_ord_field_binary_func(dict_index_t *index, const upd_t *update, const que_thr_t *thr, const dtuple_t *row, const row_ext_t *ext, bool *non_mv_upd, ulint flag)</div><div class="ttdoc">Checks if an update vector changes an ordering field of an index record. </div><div class="ttdef"><b>Definition:</b> row0upd.cc:1450</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a64127ec7ade5c887ac2f9849d5533d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64127ec7ade5c887ac2f9849d5533d61">&#9670;&nbsp;</a></span>upd_fld_is_multi_value_col</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define upd_fld_is_multi_value_col</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">upd_fld</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="data0data_8h.html#ad79e05d68cd6ae496c4144c6c7b81cc7">dfield_is_multi_value</a>(&amp;((upd_fld)-&gt;new_val)))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a9de46e091d1fa137b2d8d2c855665a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9de46e091d1fa137b2d8d2c855665a">&#9670;&nbsp;</a></span>upd_fld_is_virtual_col</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define upd_fld_is_virtual_col</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">upd_fld</td><td>)</td>
          <td>&#160;&#160;&#160;(((upd_fld)-&gt;new_val.type.prtype &amp; <a class="el" href="data0type_8h.html#a232c49e6bcfce2e4efb7d27ea6d7719c">DATA_VIRTUAL</a>) == <a class="el" href="data0type_8h.html#a232c49e6bcfce2e4efb7d27ea6d7719c">DATA_VIRTUAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c93eed92cd93144eeaa7f264adabc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c93eed92cd93144eeaa7f264adabc45">&#9670;&nbsp;</a></span>upd_fld_set_virtual_col</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define upd_fld_set_virtual_col</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">upd_fld</td><td>)</td>
          <td>&#160;&#160;&#160;((upd_fld)-&gt;new_val.type.prtype |= <a class="el" href="data0type_8h.html#a232c49e6bcfce2e4efb7d27ea6d7719c">DATA_VIRTUAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0446f02f1cc4570e730ed640bf311493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0446f02f1cc4570e730ed640bf311493">&#9670;&nbsp;</a></span>UPD_NODE_INSERT_CLUSTERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_INSERT_CLUSTERED</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">3 <span class="comment">/* clustered index record should be    \</span></div><div class="line"><span class="comment">    inserted, old record is already delete \</span></div><div class="line"><span class="comment">    marked */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a96c347f996e51f6fb49ef6c067ba04bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c347f996e51f6fb49ef6c067ba04bf">&#9670;&nbsp;</a></span>UPD_NODE_MAGIC_N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_MAGIC_N&#160;&#160;&#160;1579975</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a521a1927c7f930bb014e8697bcc579cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521a1927c7f930bb014e8697bcc579cf">&#9670;&nbsp;</a></span>UPD_NODE_NO_ORD_CHANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_NO_ORD_CHANGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">1 <span class="comment">/* no secondary index record will be  \</span></div><div class="line"><span class="comment">    changed in the update and no ordering \</span></div><div class="line"><span class="comment">    field of the clustered index */</span></div></div><!-- fragment -->
</div>
</div>
<a id="ac1f48e6b565f0a43dce9888b2d23d16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f48e6b565f0a43dce9888b2d23d16e">&#9670;&nbsp;</a></span>UPD_NODE_NO_SIZE_CHANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_NO_SIZE_CHANGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2    <span class="comment">/* no record field size will be \</span></div><div class="line"><span class="comment">       changed in the update */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a44102f8533c40d47458f13aac650ef38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44102f8533c40d47458f13aac650ef38">&#9670;&nbsp;</a></span>UPD_NODE_SET_IX_LOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_SET_IX_LOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">1 <span class="comment">/* execution came to the node from \</span></div><div class="line"><span class="comment">    a node above and if the field      \</span></div><div class="line"><span class="comment">    has_clust_rec_x_lock is FALSE, we  \</span></div><div class="line"><span class="comment">    should set an intention x-lock on  \</span></div><div class="line"><span class="comment">    the table */</span></div></div><!-- fragment -->
</div>
</div>
<a id="acc1678d94ec05825c81d2a4748f19c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1678d94ec05825c81d2a4748f19c4a">&#9670;&nbsp;</a></span>UPD_NODE_UPDATE_ALL_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_ALL_SEC</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">5 <span class="comment">/* an ordering field of the clustered \</span></div><div class="line"><span class="comment">    index record was changed, or this is  \</span></div><div class="line"><span class="comment">    a delete operation: should update     \</span></div><div class="line"><span class="comment">    all the secondary index records */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a78ed1fcdf27db3b4ada62729f09fd233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ed1fcdf27db3b4ada62729f09fd233">&#9670;&nbsp;</a></span>UPD_NODE_UPDATE_CLUSTERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_CLUSTERED</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2 <span class="comment">/* clustered index record should be \</span></div><div class="line"><span class="comment">    updated */</span></div></div><!-- fragment -->
</div>
</div>
<a id="abe5381bd0d873234a70f103df73b1b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5381bd0d873234a70f103df73b1b02">&#9670;&nbsp;</a></span>UPD_NODE_UPDATE_SOME_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_SOME_SEC</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">6 <span class="comment">/* secondary index entries should be \</span></div><div class="line"><span class="comment">    looked at and updated if an ordering \</span></div><div class="line"><span class="comment">    field changed */</span></div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a49846971910ff699a3422b5fb5f41565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49846971910ff699a3422b5fb5f41565">&#9670;&nbsp;</a></span>Lob_diff_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="row0upd_8h.html#a49846971910ff699a3422b5fb5f41565">Lob_diff_vector</a> =  std::vector&lt;<a class="el" href="structLob__diff.html">Lob_diff</a>, <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt;<a class="el" href="structLob__diff.html">Lob_diff</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a457641854a34ad6c7872675ee93265f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457641854a34ad6c7872675ee93265f7">&#9670;&nbsp;</a></span>Lob_index_diff_vec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="row0upd_8h.html#a457641854a34ad6c7872675ee93265f7">Lob_index_diff_vec</a> =  std::vector&lt;<a class="el" href="structlob__index__diff__t.html">lob_index_diff_t</a>, <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt;<a class="el" href="structlob__index__diff__t.html">lob_index_diff_t</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae66c139b895a217591a0e987a6870d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66c139b895a217591a0e987a6870d50">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlob__index__diff__t.html">lob_index_diff_t</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloading the global output operator to print lob_index_diff_t object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>the object to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream. </dd></dl>

</div>
</div>
<a id="ae7b9fd5c9abaed8e55aaa412b17a4a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b9fd5c9abaed8e55aaa412b17a4a20">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLob__diff.html">Lob_diff</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab109239003466d6abc85ad1cf081c596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab109239003466d6abc85ad1cf081c596">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__field__t.html">upd_field_t</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afff98575fe5088121ea9f66cb649e7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff98575fe5088121ea9f66cb649e7df">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae568f74fa2ed2cb5b3c9cbd99652696e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae568f74fa2ed2cb5b3c9cbd99652696e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sql_2table_8h.html#a639813cd7039c2f15c2e7984541af5b5">Binary_diff_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2522b883af6618c18e80d1427d467d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2522b883af6618c18e80d1427d467d38">&#9670;&nbsp;</a></span>print_binary_diff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; print_binary_diff </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBinary__diff.html">Binary_diff</a> *&#160;</td>
          <td class="paramname"><em>bdiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the given binary diff into the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bdiff</td><td>binary diff to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table dictionary object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>mysql field object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<a id="acab7cfc9eb856416686a54a7cc96df71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab7cfc9eb856416686a54a7cc96df71">&#9670;&nbsp;</a></span>print_binary_diff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; print_binary_diff </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBinary__diff.html">Binary_diff</a> *&#160;</td>
          <td class="paramname"><em>bdiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a838bfedaa4543cf09a38da782a458217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838bfedaa4543cf09a38da782a458217">&#9670;&nbsp;</a></span>row_upd_build_difference_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_difference_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>no_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>mysql_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an update vector from those fields, excluding the roll ptr and trx id fields, which in an index entry differ from a record that has the equal ordering fields. </p>
<p>NOTE: we compare the fields as binary strings! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>clustered index entry to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>clustered index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec,index), or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_sys</td><td>skip the system columns DB_TRX_ID and DB_ROLL_PTR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction (for diagnostics), or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap from which allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mysql_table</td><td>NULL, or mysql table object when user thread invokes dml </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>error number in case of failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields, excluding roll ptr and trx id </dd></dl>

</div>
</div>
<a id="a00cf371b11d50c6ad635038a71306b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cf371b11d50c6ad635038a71306b73">&#9670;&nbsp;</a></span>row_upd_build_sec_rec_difference_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_sec_rec_difference_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an update vector from those fields which in a secondary index entry differ from a record that has the equal ordering fields. </p>
<p>NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: secondary index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap from which allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a902192e6824406c3796068d2173b2aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902192e6824406c3796068d2173b2aff">&#9670;&nbsp;</a></span>row_upd_changes_disowned_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_upd_changes_disowned_external </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if row update contains disowned external fields. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the update contains disowned external fields. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedafd388956767bd826a954029de13f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedafd388956767bd826a954029de13f4">&#9670;&nbsp;</a></span>row_upd_changes_doc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_upd_changes_doc_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an FTS Doc ID column is affected by an UPDATE. </p>
<dl class="section return"><dt>Returns</dt><dd>whether Doc ID column is affected</dd>
<dd>
whether the Doc ID column is changed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">upd_field</td><td>in: field to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c8da72b47b7afc4a67c12584cce14db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8da72b47b7afc4a67c12584cce14db">&#9670;&nbsp;</a></span>row_upd_changes_field_size_or_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_upd_changes_field_size_or_external </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if row update changes size of some field in index or if some field to be updated is stored externally in rec or update. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the update changes the size of some field in index or the field is external in rec or update in: update vector</dd>
<dd>
true if the update changes the size of some field in index or the field is external in rec or update </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34c7757393893c9ac19cd3dfaf1befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34c7757393893c9ac19cd3dfaf1befe">&#9670;&nbsp;</a></span>row_upd_changes_fts_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_upd_changes_fts_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an FTS indexed column is affected by an UPDATE. </p>
<dl class="section return"><dt>Returns</dt><dd>offset within fts_t::indexes if FTS indexed column updated else ULINT_UNDEFINED in: field to check</dd>
<dd>
offset within fts_t::indexes if FTS indexed column updated else ULINT_UNDEFINED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">upd_field</td><td>in: field to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af70a462bcc93bd912d846fb253463bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70a462bcc93bd912d846fb253463bf0">&#9670;&nbsp;</a></span>row_upd_changes_ord_field_binary_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_upd_changes_ord_field_binary_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>non_mv_upd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an update vector changes an ordering field of an index record. </p>
<p>It will also help check if any non-multi-value field on the multi-value index gets updated or not.</p>
<p>This function is fast if the update vector is short or the number of ordering fields in the index is small. Otherwise, this can be quadratic. NOTE: we compare the fields as binary strings! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>update vector for the row; NOTE: the field numbers in this MUST be clustered index positions! </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread, or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>old value of row, or NULL if the row and the data values in update are not known when this function is called, e.g., at compile time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>NULL, or prefixes of the externally stored columns in the old row </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">non_mv_upd</td><td>NULL, or not NULL pointer to get the information about whether any non-multi-value field on the multi-value index gets updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>ROW_BUILD_NORMAL, ROW_BUILD_FOR_PURGE or ROW_BUILD_FOR_UNDO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if update vector changes an ordering field in the index record </dd></dl>

</div>
</div>
<a id="a0b3e7dba0ba7d65289f702a3d3f8ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e7dba0ba7d65289f702a3d3f8ec00">&#9670;&nbsp;</a></span>row_upd_changes_some_index_ord_field_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_upd_changes_some_index_ord_field_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an update vector changes an ordering field of an index record. </p>
<p>This function is fast if the update vector is short or the number of ordering fields in the index is small. Otherwise, this can be quadratic. NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>true if update vector may change an ordering field in an index record in: update vector for the row</dd></dl>
<p>NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>true if update vector may change an ordering field in an index record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector for the row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cfdb6c921068d3859455412321acc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfdb6c921068d3859455412321acc28">&#9670;&nbsp;</a></span>row_upd_get_new_autoinc_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t row_upd_get_new_autoinc_counter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>autoinc_field_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the new autoinc counter from the update vector when there is an autoinc field defined in this table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>update vector for the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoinc_field_no</td><td>autoinc field's order in clustered index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new counter if we find it in the update vector, otherwise 0. We don't mind that the new counter happens to be 0, we just care about non-zero counters. </dd></dl>

</div>
</div>
<a id="aa516d2dc3d1ddcdf1a73b31cd5cbce0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa516d2dc3d1ddcdf1a73b31cd5cbce0b">&#9670;&nbsp;</a></span>row_upd_index_entry_sys_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_entry_sys_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the trx id or roll ptr field of a clustered index entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>Index entry, where the memory buffers for sys fields are already allocated: the function just copies the new values to them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Data_trx_id or data_roll_ptr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bf0960639c762f39cce1d29241e8b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf0960639c762f39cce1d29241e8b1e">&#9670;&nbsp;</a></span>row_upd_index_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_upd_index_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__t.html">upd_t</a> **&#160;</td>
          <td class="paramname"><em>update_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the log data written by row_upd_index_write_log. </p>
<dl class="section return"><dt>Returns</dt><dd>log data end or NULL out: update vector</dd>
<dd>
log data end or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where update vector is built </td></tr>
    <tr><td class="paramname">update_out</td><td>out: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9a7b3c3d7c1127f608f91ae11b41ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9a7b3c3d7c1127f608f91ae11b41ef">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_replace_new_col_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>Index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index; note that this may also be a non-clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>An update vector built for the clustered index so that the field number in an upd_field is the clustered index position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbdbead3f6bc4683c091c025761b28c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdbead3f6bc4683c091c025761b28c7">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_vals_index_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_replace_new_col_vals_index_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>order_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">entry</td><td>Index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion [rollback or purge] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index; note that this may also be a non-clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>An update vector built for the index so that the field number in an upd_field is the index position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order_only</td><td>If true, limit the replacement to ordering fields of index; note that this does not work for non-clustered indexes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b7fba00a40039307f4605056af9c54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7fba00a40039307f4605056af9c54b">&#9670;&nbsp;</a></span>row_upd_index_write_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_index_write_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to the redo log the new values of the fields occurring in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index which to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>update vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_ptr</td><td>pointer to mlog buffer: must contain at least MLOG_BUF_MARGIN bytes of free space; the buffer is closed within this function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr into whose log to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae304da2bc13e35c67c164467960b27ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae304da2bc13e35c67c164467960b27ac">&#9670;&nbsp;</a></span>row_upd_parse_sys_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_upd_parse_sys_vals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the log data of system field values. </p>
<dl class="section return"><dt>Returns</dt><dd>log data end or NULL out: roll ptr</dd>
<dd>
log data end or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">pos</td><td>out: TRX_ID position in record </td></tr>
    <tr><td class="paramname">trx_id</td><td>out: trx id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>out: roll ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add4c4ef5c26a83086f51130897c89dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4c4ef5c26a83086f51130897c89dd9">&#9670;&nbsp;</a></span>row_upd_rec_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_rec_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector to the record given. </p>
<p>No field size changes are allowed. This function is usually invoked on a clustered index. The only use case for a secondary index is row_ins_sec_index_entry_by_modify() or its counterpart in ibuf_insert_to_index_page(). in: compressed page with enough space available, or NULL</p>
<p>No field size changes are allowed. This function is usually invoked on a clustered index. The only use case for a secondary index is row_ins_sec_index_entry_by_modify() or its counterpart in ibuf_insert_to_index_page(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record where replaced </td></tr>
    <tr><td class="paramname">index</td><td>in: the index the record belongs to </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page with enough space available, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01b7c860ec8f58d4fa4d79ad85c95f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b7c860ec8f58d4fa4d79ad85c95f1b">&#9670;&nbsp;</a></span>row_upd_rec_sys_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_upd_rec_sys_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the trx id and roll ptr field in a clustered index record when a row is updated or marked deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page_zip</td><td>compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll_ptr</td><td>roll ptr of the undo log record, can be 0 during IMPORT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb05f212ddac2808ee035ef4d22f917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb05f212ddac2808ee035ef4d22f917">&#9670;&nbsp;</a></span>row_upd_rec_sys_fields_in_recovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_rec_sys_fields_in_recovery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the trx id and roll ptr field in a clustered index record in database recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page_zip</td><td>Compressed page, or null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Trx_id position in rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Transaction id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll_ptr</td><td>Roll ptr of the undo log record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc29008c34ee2e8c776a6d73b76f61e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc29008c34ee2e8c776a6d73b76f61e4">&#9670;&nbsp;</a></span>row_upd_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__ext__t.html">row_ext_t</a> **&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the new column values stored in the update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>Current transaction. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">row</td><td>Row where replaced, indexed by col_no; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ext</td><td>Null, or externally stored column prefixes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>An update vector built for the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>Memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0039db94d3ed183135cfa8d4a49b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0039db94d3ed183135cfa8d4a49b42d">&#9670;&nbsp;</a></span>row_upd_replace_vcol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_replace_vcol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>upd_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>undo_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the virtual column values stored in a dtuple with that of a update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">row</td><td>dtuple whose column to be updated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>an update vector built for the clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upd_new</td><td>update to new or old value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">undo_row</td><td>undo row (if needs to be updated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>remaining part in update undo log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33265d5ab656dba287eb974c407bcf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33265d5ab656dba287eb974c407bcf18">&#9670;&nbsp;</a></span>row_upd_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* row_upd_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a row in a table. </p>
<p>This is a high-level function used in SQL execution graphs. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL in: query thread</dd></dl>
<p>This is a high-level function used in SQL execution graphs. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b88335c2bea8df94e814325e117c491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b88335c2bea8df94e814325e117c491">&#9670;&nbsp;</a></span>row_upd_store_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_upd_store_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>mysql_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores to the heap the row on which the node-&gt;pcur is positioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the transaction object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>row update node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>mysql thread handle </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mysql_table</td><td>NULL, or mysql table object when user thread invokes dml </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2720d792e43ac476db80779bba13544c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2720d792e43ac476db80779bba13544c">&#9670;&nbsp;</a></span>row_upd_write_sys_vals_to_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_upd_write_sys_vals_to_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes into the redo log the values of trx id and roll ptr and enough info to determine their positions within a clustered index record. </p>
<dl class="section return"><dt>Returns</dt><dd>new pointer to mlog in: mtr</dd>
<dd>
new pointer to mlog </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr of the undo log record </td></tr>
    <tr><td class="paramname">log_ptr</td><td>pointer to a buffer of size &gt; 20 opened in mlog </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4662cf8a186586e3caad5a7a28cf9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4662cf8a186586e3caad5a7a28cf9ec">&#9670;&nbsp;</a></span>upd_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structupd__t.html">upd_t</a>* upd_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an update vector object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>heap from which memory allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>own: update vector object </dd></dl>

</div>
</div>
<a id="ad6626ce48273c089093d1a95b5a32b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6626ce48273c089093d1a95b5a32b20">&#9670;&nbsp;</a></span>upd_field_set_field_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void upd_field_set_field_no </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>field_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an index field number to be updated by an update vector field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">upd_field</td><td>update vector field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_no</td><td>field number in a clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3f6386e3414d3baee23fd9ba70cb8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f6386e3414d3baee23fd9ba70cb8a1">&#9670;&nbsp;</a></span>upd_field_set_v_field_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void upd_field_set_v_field_no </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>field_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set field number to a update vector field, marks this field is updated </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">upd_field</td><td>update vector field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_no</td><td>virtual column sequence num </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ef1a621ff94f9f0dcd3e996c8c01eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef1a621ff94f9f0dcd3e996c8c01eba">&#9670;&nbsp;</a></span>upd_get_field_by_field_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structupd__field__t.html">upd_field_t</a>* upd_get_field_by_field_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_virtual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a field of an update vector by field_no. </p>
<dl class="section return"><dt>Returns</dt><dd>update vector field, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">no</td><td>in: field_no </td></tr>
    <tr><td class="paramname">is_virtual</td><td>in: if it is a virtual column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0bebe9c2bdc7ec292e9784374476f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0bebe9c2bdc7ec292e9784374476f2">&#9670;&nbsp;</a></span>upd_get_n_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint upd_get_n_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of fields in the update vector == number of columns to be updated by an update vector. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields in: update vector </dd></dl>

</div>
</div>
<a id="a1cc9824c435b30f9957b9864ce39c8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc9824c435b30f9957b9864ce39c8ad">&#9670;&nbsp;</a></span>upd_get_nth_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structupd__field__t.html">upd_field_t</a>* upd_get_nth_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nth field of an update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>update vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>field position in update vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>update vector field </dd></dl>

</div>
</div>
<a id="a655590bf847503b6297d9d8d246201ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655590bf847503b6297d9d8d246201ff">&#9670;&nbsp;</a></span>upd_node_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__node__t.html">upd_node_t</a>* upd_node_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an update node for a query graph. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update node in: mem heap where created</dd>
<dd>
own: update node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: mem heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="row0upd_8h.html">row0upd.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
