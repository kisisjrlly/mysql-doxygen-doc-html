<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Connection Phase</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_protocol_connection_phase.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Connection Phase </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Connection Phase performs these tasks:</p>
<ul>
<li>exchange the capabilities of client and server</li>
<li>setup SSL communication channel if requested</li>
<li>authenticate the client against the server</li>
</ul>
<p>It starts with the client connect()ing to the server which may send a ERR packet and finish the handshake or send a Initial Handshake Packet which the client answers with a Handshake Response Packet. At this stage client can request SSL connection, in which case an SSL communication channel is established before client sends its authentication response.</p>
<dl class="section note"><dt>Note</dt><dd>In case the server sent a ERR packet as first packet it will happen before the client and server negotiated any capabilities. Therefore the ERR packet will not contain the SQL-state.</dd></dl>
<p>After initial handshake, server informs client about the method to be used for authentication (unless it was already established during the handshake) and the authentication exchange continues until server either accepts connection by sending an <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> or rejects it with <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a>.</p>
<h1><a class="anchor" id="sect_protocol_connection_phase_initial_handshake"></a>
Initial Handshake</h1>
<p>The initial handshake starts with the server sending the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a> packet. After this, optionally, the client can request an SSL connection to be established with the <a class="el" href="page_protocol_connection_phase_packets_protocol_ssl_request.html">Protocol::SSLRequest:</a> packet and then the client sends the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> packet.</p>
<h2><a class="anchor" id="sect_protocol_connection_phase_initial_handshake_plain_handshake"></a>
Plain Handshake</h2>
<ol type="1">
<li>Server sending <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a>.</li>
<li>Client replying with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a></li>
</ol>
<h2><a class="anchor" id="sect_protocol_connection_phase_initial_handshake_ssl_handshake"></a>
SSL Handshake</h2>
<ol type="1">
<li>Server sending <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a></li>
<li>Client replying with <a class="el" href="page_protocol_connection_phase_packets_protocol_ssl_request.html">Protocol::SSLRequest:</a></li>
<li>The usual SSL exchange leading to establishing SSL connection</li>
<li>Client sends <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a></li>
</ol>
<h2><a class="anchor" id="sect_protocol_connection_phase_initial_handshake_capabilities"></a>
Capability Negotiation</h2>
<p>To permit an old client to connect to newer servers, the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a> contains</p>
<p>the MySQL Server version the server's <a class="el" href="group__group__cs__capabilities__flags.html">Capabilities Flags</a></p>
<p>The client should only announce the capabilities in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> that it has in common with the server.</p>
<p>They can agree on: use of <a class="el" href="group__group__cs__capabilities__flags.html#ga536a91524dc8d56bcac63aadc8811f1d">status flags</a> use of <a class="el" href="group__group__cs__capabilities__flags.html#gacde6ac915ca4c7bc88ae19d7dd9a04c4">SQL states for error codes</a> <a class="el" href="page_protocol_connection_phase.html#sect_protocol_connection_phase_initial_handshake_auth_method">authentication methods</a> <a class="el" href="group__group__cs__capabilities__flags.html#gaa7b23d0f15fbcd6f975df1d6204ea5a2">SSL Support</a> <a class="el" href="group__group__cs__capabilities__flags.html#ga69668fa642cd688ab5a3c24de87c0b9a">Compression</a></p>
<h2><a class="anchor" id="sect_protocol_connection_phase_initial_handshake_auth_method"></a>
Determining Authentication Method</h2>
<p>Method used for authentication is tied to the user account and stored in the plugin column of mysql.user table. Client informs about the user account it wants to log into in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> packet. Only then server can look up the mysql.user table and find the authentication method to be used.</p>
<p>However, to save round-trips, server and client start authentication exchange already in the initial handshake using an optimistic guess of the authentication method to be used.</p>
<p>Server uses its default authentication method <a class="el" href="mysqld_8h.html#acc739922cbf31469dcded61f221ac65f">default_auth_plugin</a> to produce initial authentication data payload and sends it to the client inside <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a>, together with the name of the method used.</p>
<p>Client can include in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> packet its reply to the authentication data sent by the server.</p>
<p>When including authentication reply in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a>, client is not obligated to use the same authentication method that was used by the server in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a> packet. The name of the authentication method used by the client is stored in the packet. If the guessed authentication method used either by the client or the server in the initial handshake was not correct, server informs client which authentication method should be used using <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_switch_request.html">Protocol::AuthSwitchRequest:</a>. See section <a class="el" href="page_protocol_connection_phase.html#sect_protocol_connection_phase_auth_method_mismatch">Authentication Method Mismatch</a> for more details.</p>
<p>Up to MySQL 4.0 the MySQL protocol only supported the <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a>. In MySQL 4.1 the <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a> method was added and in MySQL 5.5 arbitrtary authentication methods can be implemented by means of authentication plugins.</p>
<p>If the client or server do no support pluggable authentication (i.e. <a class="el" href="group__group__cs__capabilities__flags.html#ga2a6cb83350f95a382a35de3021904012">CLIENT_PLUGIN_AUTH</a> capability flag is not set) then authentication method used is inherited from client and server capabilities as follows: The method used is <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a> if <a class="el" href="group__group__cs__capabilities__flags.html#gacde6ac915ca4c7bc88ae19d7dd9a04c4">CLIENT_PROTOCOL_41</a> or <a class="el" href="group__group__cs__capabilities__flags.html#ga8be684cc38eeca913698414efec06933">CLIENT_SECURE_CONNECTION</a> are not set. The method used is <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a> if both <a class="el" href="group__group__cs__capabilities__flags.html#gacde6ac915ca4c7bc88ae19d7dd9a04c4">CLIENT_PROTOCOL_41</a> and <a class="el" href="group__group__cs__capabilities__flags.html#ga8be684cc38eeca913698414efec06933">CLIENT_SECURE_CONNECTION</a> are set, but <a class="el" href="group__group__cs__capabilities__flags.html#ga2a6cb83350f95a382a35de3021904012">CLIENT_PLUGIN_AUTH</a> is not set.</p>
<h1><a class="anchor" id="sect_protocol_connection_phase_fast_path"></a>
Authentication Phase Fast Path</h1>
<p>Assume the client wants to log in via user account U and that user account is defined to use authentication method <code>server_method</code>. The fast authentication path is used when: </p><ul>
<li>
the server used <code>server_method</code> to generate authentication data in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a> packet. </li>
<li>
the client used a <code>client_authentication_method</code> in <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> that is compatible with the <code>server_method</code> used by the server. </li>
</ul>
<p>In that case the first round of authentication has been already commenced during the hanshake. Now, depending on the authentication method <code>server_method</code>, further authentication can be exchanged until the server either accepts or refuses the authentication.</p>
<h2><a class="anchor" id="sect_protocol_connection_phase_fast_path_success"></a>
Successful Authentication</h2>
<p>A successful fast authentication path looks as follows:</p>
<ol type="1">
<li>The client connects to the server</li>
<li>The server sends <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a></li>
<li>The client respons with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a></li>
<li>Client and server possibly exchange further packets as required by the server authentication method for the user account the client is trying to authenticate against.</li>
<li>The server responds with an <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a></li>
</ol>
<p>The packets the server sends in step 4 are a <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_more_data.html">Protocol::AuthMoreData:</a> packet prefixed with 0x01 to distinguish them from <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> and <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a></p>
<dl class="section note"><dt>Note</dt><dd>Many authentication methods, including the mysql_native_password method consist of a single challenge-response exchange. In that case no extra packet are exchanged in step 4 and the server sends an <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> directly after receiving the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> packet (provided the authentication was successful).</dd></dl>
<h2><a class="anchor" id="sect_protocol_connection_phase_fast_path_fails"></a>
Authentication Fails</h2>
<p>It goes exactly like <a class="el" href="page_protocol_connection_phase.html#sect_protocol_connection_phase_fast_path_success">Successful Authentication</a> , but if the server decides that it won't authenticate the user it replies with an <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> instead of <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a>.</p>
<ol type="1">
<li>The client connects to the server</li>
<li>The server sends <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a></li>
<li>The client respons with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a></li>
<li>Client and server possibly exchange further packets as required by the server authentication method for the user account the client is trying to authenticate against.</li>
<li>The server responds with an <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a></li>
</ol>
<p>Again, the <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_more_data.html">Protocol::AuthMoreData:</a> packets sent by the server during step 4 start with 0x01 byte and thus can never be confused with the <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a>.</p>
<h1><a class="anchor" id="sect_protocol_connection_phase_auth_method_mismatch"></a>
Authentication Method Mismatch</h1>
<p>Assume that client wants to log in as user U and that user account uses authentication method M. If:</p>
<ol type="1">
<li>Server's default method used to generate authentication payload for <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a> was different from M or</li>
<li>Method used by the client to generate authentication reply in <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> was not compatible with M</li>
</ol>
<p>then there is an authentication method mismatch and authentication exchange must be restarted using the correct authentication method.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>The mismatch can happen even if client and server used compatible authentication methods in the intial handshake, but the method the server used was different from the method required by the user account.</li>
<li>In the 4.1-5.7 server and client the default authentication method is <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a>.</li>
<li>In 8.0 server and client the default authentication method is <a class="el" href="page_caching_sha2_authentication_exchanges.html">Caching_sha2_password information</a>.</li>
<li>The client and the server can change their default authentication method via the <code>--default-auth</code> option.</li>
<li>A sensibe thing to do for a client would be to see the server's default authentication method announced in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a> packet and infer the authentication method from it instead of using the client default authentication method when producing <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a>. But since there can be one to many server to client plugins and the clients generally do not know the mapping from server authentication methods to client authentication methods this is not implemented in the client mysql library.</li>
</ol>
</dd></dl>
<p>If authentication method missmatch happens, server sends to client the <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_switch_request.html">Protocol::AuthSwitchRequest:</a> which contains the name of the client authentication method to be used and the first authentication payload generated by the new method. Client should switch to the requested authentication method and continue the exchange as dictated by that method.</p>
<p>If the client does not know the requested method it should disconnect.</p>
<h2><a class="anchor" id="sect_protocol_connection_phase_auth_method_mismatch_method_change"></a>
Authentication Method Change</h2>
<ol type="1">
<li>The client connects to the server</li>
<li>The server sends <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a></li>
<li>The client respons with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a></li>
<li>The server sends the <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_switch_request.html">Protocol::AuthSwitchRequest:</a> to tell the client that it needs to switch to a new authentication method.</li>
<li>Client and server possibly exchange further packets as required by the server authentication method for the user account the client is trying to authenticate against.</li>
<li>The server responds with an <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> or rejects with <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a></li>
</ol>
<h2><a class="anchor" id="sect_protocol_connection_phase_auth_method_mismatch_insuficcient_client"></a>
Insufficient Client Capabilities</h2>
<p>Server will reject with <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> if it discovers that client capabilities are not sufficient to complete authentication. This can happen in the following situations:</p>
<ul>
<li>
A client which does not support pluggable authentication (<a class="el" href="group__group__cs__capabilities__flags.html#ga2a6cb83350f95a382a35de3021904012">CLIENT_PLUGIN_AUTH</a> flag not set) connects to an account which uses authentication method different from <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a>  </li>
<li>
A client which does not support secure authentication ( <a class="el" href="group__group__cs__capabilities__flags.html#ga8be684cc38eeca913698414efec06933">CLIENT_SECURE_CONNECTION</a> flag not set) attempts to connect.  </li>
<li>
Server's default authentication method used to generate authentication data in <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a> is incomaptible with <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a> and client does not support pluggable authentication (<a class="el" href="group__group__cs__capabilities__flags.html#ga2a6cb83350f95a382a35de3021904012">CLIENT_PLUGIN_AUTH</a> flag is not set).  </li>
</ul>
<p>In either of these cases authentication phase will look as follows:</p>
<ol type="1">
<li>The client connects to the server</li>
<li>The server sends <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a></li>
<li>The client respons with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a></li>
<li>The server recognizes that the client does not have enough capabilities to handle the required authentication method, sends <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> and closes the connection.</li>
</ol>
<h2><a class="anchor" id="sect_protocol_connection_phase_auth_method_mismatch_unknown_auth_method"></a>
New Authentication Method Not Known by Client</h2>
<p>Even if client supports external authentication (<a class="el" href="group__group__cs__capabilities__flags.html#ga2a6cb83350f95a382a35de3021904012">CLIENT_PLUGIN_AUTH</a> flag is set) the new authentication method indicated in <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_switch_request.html">Protocol::AuthSwitchRequest:</a> might not be known to it. In that case the client simply disconnects.</p>
<ol type="1">
<li>The client connects to the server</li>
<li>The server sends <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a></li>
<li>The client respons with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a></li>
<li>The server sends the <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_switch_request.html">Protocol::AuthSwitchRequest:</a> to tell the client that it needs to switch to a new authentication method.</li>
<li>client discovers that it does not know the authentication method requested by the server - it disconnects.</li>
</ol>
<h2><a class="anchor" id="sect_protocol_connection_phase_auth_method_mismatch_non_client_plugin_auth"></a>
Non-CLIENT_PLUGIN_AUTH Clients</h2>
<dl class="section note"><dt>Note</dt><dd>This can only happen on pre-8.0 servers. 8.0 has the <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a> removed.</dd></dl>
<p>The only situation where server will request authentication method change from a client which does not set <a class="el" href="group__group__cs__capabilities__flags.html#ga2a6cb83350f95a382a35de3021904012">CLIENT_PLUGIN_AUTH</a> flag is when the following conditions hold:</p>
<ol type="1">
<li>The client uses <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a> for the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html">Protocol::HandshakeResponse:</a> packet.</li>
<li>The client supports secure authentication (<a class="el" href="group__group__cs__capabilities__flags.html#ga8be684cc38eeca913698414efec06933">CLIENT_SECURE_CONNECTION</a> is set)</li>
<li>Server's default authentication method is <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a></li>
</ol>
<p>In this case server sends <a class="el" href="page_protocol_connection_phase_packets_protocol_old_auth_switch_request.html">Protocol::OldAuthSwitchRequest:</a>. This packet does not contain a new authenticartion method name because it's implicitly assumed to be <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a> and it does not contain authentication data. Client replies with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html#sect_protocol_connection_phase_packets_protocol_handshake_response320">Protocol::HandshakeResponse320</a>. To generate a password hash the client should re-use the random bytes sent by the server in the <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake.html">Protocol::Handshake</a>.</p>
<h1><a class="anchor" id="sect_protocol_connection_phase_com_change_user_auth"></a>
Authentication After COM_CHANGE_USER Command</h1>
<p>During <a class="el" href="page_protocol_command_phase.html">Command Phase</a> a client can send a COM_CHANGE_USER command which will trigger authenticating into a new account via a full authentication handshake.</p>
<p>Similarly to the <a class="el" href="page_protocol_connection_phase.html">Connection Phase</a> the server may reply with a <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> or <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> for the usual fast-path or with <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_switch_request.html">Protocol::AuthSwitchRequest:</a> containing the authentication method to be used for the new account and the first authentication data payload to be consumed by the client. Further handshake continues as usual, as defined by the authentication method of the new account. Eventually the server will accept the new account with <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> or it will reject the change with an <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> and disconnect.</p>
<ol type="1">
<li>The client sends COM_CHANGE_USER packet</li>
<li>The server responds with the <a class="el" href="page_protocol_connection_phase_packets_protocol_auth_switch_request.html">Protocol::AuthSwitchRequest:</a> which initiates authentication handshake using the correct authentication method</li>
<li>Client and server exchange further packets as required by the authentication method for the new account</li>
<li>The server responds with <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> and returns to command phase or <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> and closes the connection.</li>
</ol>
<h2><a class="anchor" id="sect_protocol_connection_phase_com_change_user_auth_non_plugin"></a>
COM_CHANGE_USER and Non-CLIENT_PLUGIN_AUTH Clients</h2>
<p>Clients which do not support pluggable authentication can send COM_CHANGE_USER command for accounts which use <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a> or <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a>. In this case it is assumed that server has already sent the authentication challenge - the same which was sent when the client connected for the first time - and client's reply to that challenge, i.e. the hash of the new password, should be sent in the <code>auth_response</code> field of COM_CHANGE_USER.</p>
<ol type="1">
<li>The client sends COM_CHANGE_USER packet with authentication response (hash of the password) for <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a> (post 4.1 clients) or <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a> (pre 4.1 clients) method.</li>
<li>The server responds with an <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> and returns to <a class="el" href="page_protocol_command_phase.html">Command Phase</a> or with an <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> and closes the connection.</li>
</ol>
<p>As during normal connection, it is also possible that a post 4.1 client which does not support pluggable authentication connects to an account which uses <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a> In that case server will send <a class="el" href="page_protocol_connection_phase_packets_protocol_old_auth_switch_request.html">Protocol::OldAuthSwitchRequest:</a> and expect the client to reply with <a class="el" href="page_protocol_connection_phase_packets_protocol_handshake_response.html#sect_protocol_connection_phase_packets_protocol_handshake_response320">Protocol::HandshakeResponse320</a></p>
<ol type="1">
<li>The client sends COM_CHANGE_USER packet with response for <a class="el" href="page_protocol_connection_phase_authentication_methods_native_password_authentication.html">Native Authentication</a></li>
<li>The server replies with <a class="el" href="page_protocol_connection_phase_packets_protocol_old_auth_switch_request.html">Protocol::OldAuthSwitchRequest:</a> (0xFE byte)</li>
<li>The client sends response again, this time in the form required by <a class="el" href="page_protocol_connection_phase_authentication_methods.html#page_protocol_connection_phase_authentication_methods_old_password_authentication">Old Password Authentication</a></li>
<li>The server responds with an <a class="el" href="page_protocol_basic_ok_packet.html">OK_Packet</a> and returns to <a class="el" href="page_protocol_command_phase.html">Command Phase</a> or an <a class="el" href="page_protocol_basic_err_packet.html">ERR_Packet</a> and disconnects</li>
</ol>
<dl class="section see"><dt>See also</dt><dd>group_cs_capabilities_flags </dd>
<dd>
unknown_accounts <a class="el" href="page_protocol_connection_phase_packets.html">Connection Phase Packets</a> <a class="el" href="page_protocol_connection_phase_authentication_methods.html">Authentication Methods</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_PROTOCOL.html">Client/Server Protocol</a></li><li class="navelem"><a class="el" href="page_protocol_connection_lifecycle.html">Connection Lifecycle</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
