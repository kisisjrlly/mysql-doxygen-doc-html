<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: MultiRangeRowIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classMultiRangeRowIterator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMultiRangeRowIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultiRangeRowIterator Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The iterator actually doing the reads from the inner table during BKA.  
 <a href="classMultiRangeRowIterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bka__iterator_8h_source.html">bka_iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MultiRangeRowIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMultiRangeRowIterator.png" usemap="#MultiRangeRowIterator_map" alt=""/>
  <map id="MultiRangeRowIterator_map" name="MultiRangeRowIterator_map">
<area href="classTableRowIterator.html" alt="TableRowIterator" shape="rect" coords="0,56,139,80"/>
<area href="classRowIterator.html" title="A context for reading through a single table using a chosen access method: index read, scan, etc, use of cache, etc. " alt="RowIterator" shape="rect" coords="0,0,139,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc372a9de5b5486aef478692872508cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#afc372a9de5b5486aef478692872508cf">MultiRangeRowIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="classItem.html">Item</a> *cache_idx_cond, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="structTABLE__REF.html">TABLE_REF</a> *ref, int mrr_flags, <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> <a class="el" href="sql__opt__exec__shared_8h.html#a1aa258a4b1427766c283c1ae9ea81f05">join_type</a>, <a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> outer_input_tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> store_rowids, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tables_to_get_rowid_for)</td></tr>
<tr class="separator:afc372a9de5b5486aef478692872508cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6d27ced33a106e9640098a0d2c5479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#aea6d27ced33a106e9640098a0d2c5479">set_rows</a> (const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *begin, const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *end)</td></tr>
<tr class="memdesc:aea6d27ced33a106e9640098a0d2c5479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify which outer rows to read inner rows for.  <a href="#aea6d27ced33a106e9640098a0d2c5479">More...</a><br /></td></tr>
<tr class="separator:aea6d27ced33a106e9640098a0d2c5479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2f54fe0fb6dec85242698628678137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#aed2f54fe0fb6dec85242698628678137">set_mrr_buffer</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ptr, size_t size)</td></tr>
<tr class="memdesc:aed2f54fe0fb6dec85242698628678137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an unused chunk of memory MRR can use for the returned inner rows.  <a href="#aed2f54fe0fb6dec85242698628678137">More...</a><br /></td></tr>
<tr class="separator:aed2f54fe0fb6dec85242698628678137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6b302cfe1d2a15259d09dd0a0de79e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a1a6b302cfe1d2a15259d09dd0a0de79e">set_match_flag_buffer</a> (<a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *ptr)</td></tr>
<tr class="memdesc:a1a6b302cfe1d2a15259d09dd0a0de79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify an unused chunk of memory that we can use to mark which inner rows have been read (by the parent BKA iterator) or not.  <a href="#a1a6b302cfe1d2a15259d09dd0a0de79e">More...</a><br /></td></tr>
<tr class="separator:a1a6b302cfe1d2a15259d09dd0a0de79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f8995b87d1bcc5f65a88413c14a323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a17f8995b87d1bcc5f65a88413c14a323">MarkLastRowAsRead</a> ()</td></tr>
<tr class="memdesc:a17f8995b87d1bcc5f65a88413c14a323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the BKA iterator has seen the last row we returned from Read().  <a href="#a17f8995b87d1bcc5f65a88413c14a323">More...</a><br /></td></tr>
<tr class="separator:a17f8995b87d1bcc5f65a88413c14a323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3076f75379454e47fd1a9c5ca48d6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#aeb3076f75379454e47fd1a9c5ca48d6d">RowHasBeenRead</a> (const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *row) const</td></tr>
<tr class="memdesc:aeb3076f75379454e47fd1a9c5ca48d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the given row has been marked as read (using MarkLastRowAsRead()) or not.  <a href="#aeb3076f75379454e47fd1a9c5ca48d6d">More...</a><br /></td></tr>
<tr class="separator:aeb3076f75379454e47fd1a9c5ca48d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592999ca2419280a3f5747032608d8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a592999ca2419280a3f5747032608d8dd">Init</a> () override</td></tr>
<tr class="memdesc:a592999ca2419280a3f5747032608d8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the actual multi-range read with the rows given by set_rows() and using the temporary buffer given in set_mrr_buffer().  <a href="#a592999ca2419280a3f5747032608d8dd">More...</a><br /></td></tr>
<tr class="separator:a592999ca2419280a3f5747032608d8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fd1517fc721ef64a4bea9b0a0e345c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a24fd1517fc721ef64a4bea9b0a0e345c">Read</a> () override</td></tr>
<tr class="memdesc:a24fd1517fc721ef64a4bea9b0a0e345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read another inner row (if any) and load the appropriate outer row(s) into the associated table buffers.  <a href="#a24fd1517fc721ef64a4bea9b0a0e345c">More...</a><br /></td></tr>
<tr class="separator:a24fd1517fc721ef64a4bea9b0a0e345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classTableRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classTableRowIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classTableRowIterator.html">TableRowIterator</a></td></tr>
<tr class="memitem:a6cebbaf17776a508905ab89dda56bb80 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a6cebbaf17776a508905ab89dda56bb80">TableRowIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>)</td></tr>
<tr class="separator:a6cebbaf17776a508905ab89dda56bb80 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c97ddb280f9183ebf46a9cbcc4a9202 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a1c97ddb280f9183ebf46a9cbcc4a9202">UnlockRow</a> () override</td></tr>
<tr class="memdesc:a1c97ddb280f9183ebf46a9cbcc4a9202 inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of unlock-row method of RowIterator, used in all access methods except EQRefIterator.  <a href="classTableRowIterator.html#a1c97ddb280f9183ebf46a9cbcc4a9202">More...</a><br /></td></tr>
<tr class="separator:a1c97ddb280f9183ebf46a9cbcc4a9202 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b44792464cb2c5070c1305f121f68a5 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a8b44792464cb2c5070c1305f121f68a5">SetNullRowFlag</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_null_row) override</td></tr>
<tr class="memdesc:a8b44792464cb2c5070c1305f121f68a5 inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row).  <a href="classTableRowIterator.html#a8b44792464cb2c5070c1305f121f68a5">More...</a><br /></td></tr>
<tr class="separator:a8b44792464cb2c5070c1305f121f68a5 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779598be87550cbb91e8cbb9a6c8ac38 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a779598be87550cbb91e8cbb9a6c8ac38">StartPSIBatchMode</a> () override</td></tr>
<tr class="memdesc:a779598be87550cbb91e8cbb9a6c8ac38 inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start performance schema batch mode, if supported (otherwise ignored).  <a href="classTableRowIterator.html#a779598be87550cbb91e8cbb9a6c8ac38">More...</a><br /></td></tr>
<tr class="separator:a779598be87550cbb91e8cbb9a6c8ac38 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4eefdbacd421a23d688cc2adab1a3e inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a3e4eefdbacd421a23d688cc2adab1a3e">EndPSIBatchModeIfStarted</a> () override</td></tr>
<tr class="memdesc:a3e4eefdbacd421a23d688cc2adab1a3e inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends performance schema batch mode, if started.  <a href="classTableRowIterator.html#a3e4eefdbacd421a23d688cc2adab1a3e">More...</a><br /></td></tr>
<tr class="separator:a3e4eefdbacd421a23d688cc2adab1a3e inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a9e730a0c6722be2f9841fd6b7a3f6a52">RowIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>)</td></tr>
<tr class="separator:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a8778b8e93d01e1e47f0e98804882ea8e">~RowIterator</a> ()</td></tr>
<tr class="separator:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#acb75cd99708ea3f1d62b41c8072f1d96">TimingString</a> () const</td></tr>
<tr class="separator:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">real_iterator</a> ()</td></tr>
<tr class="memdesc:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this iterator is wrapping a different iterator (e.g.  <a href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">More...</a><br /></td></tr>
<tr class="separator:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#ad0baf633d8ed8803dc77c86a2c9faeda">real_iterator</a> () const</td></tr>
<tr class="separator:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab7594d512405479e04646ce5e9e9cdfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#ab7594d512405479e04646ce5e9e9cdfc">MrrInitCallback</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="separator:ab7594d512405479e04646ce5e9e9cdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dfe7f5647999423d5130022e1b7266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#aa9dfe7f5647999423d5130022e1b7266">MrrNextCallback</a> (<a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *<a class="el" href="structrange.html">range</a>)</td></tr>
<tr class="separator:aa9dfe7f5647999423d5130022e1b7266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2809f34eace8e7b62c5037b56cfc456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#aa2809f34eace8e7b62c5037b56cfc456">MrrSkipIndexTuple</a> (char *range_info)</td></tr>
<tr class="separator:aa2809f34eace8e7b62c5037b56cfc456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8329a9e54afe87c6014fb02f7e073547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a8329a9e54afe87c6014fb02f7e073547">MrrSkipRecord</a> (char *range_info)</td></tr>
<tr class="separator:a8329a9e54afe87c6014fb02f7e073547"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ab69a519a83e8a7ca97dfd79f18de47c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#ab69a519a83e8a7ca97dfd79f18de47c2">MrrInitCallbackThunk</a> (void *init_params, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> n_ranges, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="separator:ab69a519a83e8a7ca97dfd79f18de47c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803f05bacd06f4ebfa48240d8c3690a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a803f05bacd06f4ebfa48240d8c3690a6">MrrNextCallbackThunk</a> (void *init_params, <a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *<a class="el" href="structrange.html">range</a>)</td></tr>
<tr class="separator:a803f05bacd06f4ebfa48240d8c3690a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7748005274539669832c09c2aa20f13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#ae7748005274539669832c09c2aa20f13">MrrSkipIndexTupleCallbackThunk</a> (<a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> seq, char *range_info)</td></tr>
<tr class="separator:ae7748005274539669832c09c2aa20f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4100a9ba89f9b1e89a4152389151754a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a4100a9ba89f9b1e89a4152389151754a">MrrSkipRecordCallbackThunk</a> (<a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> seq, char *range_info, <a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)</td></tr>
<tr class="separator:a4100a9ba89f9b1e89a4152389151754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abbae259ba11cfa2b7020e579cb4038c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#abbae259ba11cfa2b7020e579cb4038c3">m_cache_idx_cond</a></td></tr>
<tr class="memdesc:abbae259ba11cfa2b7020e579cb4038c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are certain conditions that would normally be pushed down to indexes, but that depend on the values of outer tables in the BKA join (ie., they are join conditions), which are not set when we actually read the inner row.  <a href="#abbae259ba11cfa2b7020e579cb4038c3">More...</a><br /></td></tr>
<tr class="separator:abbae259ba11cfa2b7020e579cb4038c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf955ba3aa2a709c0222e8eae6ee5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html">handler</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a2cf955ba3aa2a709c0222e8eae6ee5b6">m_file</a></td></tr>
<tr class="memdesc:a2cf955ba3aa2a709c0222e8eae6ee5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for the table we are reading from.  <a href="#a2cf955ba3aa2a709c0222e8eae6ee5b6">More...</a><br /></td></tr>
<tr class="separator:a2cf955ba3aa2a709c0222e8eae6ee5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781f2bc1065327def385e2ed9725e9d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a781f2bc1065327def385e2ed9725e9d0">m_ref</a></td></tr>
<tr class="memdesc:a781f2bc1065327def385e2ed9725e9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index condition.  <a href="#a781f2bc1065327def385e2ed9725e9d0">More...</a><br /></td></tr>
<tr class="separator:a781f2bc1065327def385e2ed9725e9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232b97802672f263e163ccc6ba82451d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a232b97802672f263e163ccc6ba82451d">m_mrr_flags</a></td></tr>
<tr class="memdesc:a232b97802672f263e163ccc6ba82451d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags passed on to MRR.  <a href="#a232b97802672f263e163ccc6ba82451d">More...</a><br /></td></tr>
<tr class="separator:a232b97802672f263e163ccc6ba82451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ee7e810158554ce46d249f6a3be104"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#ae5ee7e810158554ce46d249f6a3be104">m_begin</a></td></tr>
<tr class="memdesc:ae5ee7e810158554ce46d249f6a3be104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current outer rows to read inner rows for. Set by set_rows().  <a href="#ae5ee7e810158554ce46d249f6a3be104">More...</a><br /></td></tr>
<tr class="separator:ae5ee7e810158554ce46d249f6a3be104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af495a463ca7587c2cc0b419b5a4e2830"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#af495a463ca7587c2cc0b419b5a4e2830">m_end</a></td></tr>
<tr class="separator:af495a463ca7587c2cc0b419b5a4e2830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53840cc874ebc6ddbd50d83e6f8dd60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#ae53840cc874ebc6ddbd50d83e6f8dd60">m_current_pos</a></td></tr>
<tr class="memdesc:ae53840cc874ebc6ddbd50d83e6f8dd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which row we are at in the [m_begin, m_end) range.  <a href="#ae53840cc874ebc6ddbd50d83e6f8dd60">More...</a><br /></td></tr>
<tr class="separator:ae53840cc874ebc6ddbd50d83e6f8dd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af168994c827db6aff1d97ce1268505c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#af168994c827db6aff1d97ce1268505c1">m_last_row_returned</a></td></tr>
<tr class="memdesc:af168994c827db6aff1d97ce1268505c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">What row we last returned from Read() (used for MarkLastRowAsRead()).  <a href="#af168994c827db6aff1d97ce1268505c1">More...</a><br /></td></tr>
<tr class="separator:af168994c827db6aff1d97ce1268505c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b4edd6881e48cbc69449a483723ad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a85b4edd6881e48cbc69449a483723ad6">m_mrr_buffer</a></td></tr>
<tr class="memdesc:a85b4edd6881e48cbc69449a483723ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary space for storing inner rows, used by MRR.  <a href="#a85b4edd6881e48cbc69449a483723ad6">More...</a><br /></td></tr>
<tr class="separator:a85b4edd6881e48cbc69449a483723ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c5ceadc00cbc46497ae09c837d61f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#aa54c5ceadc00cbc46497ae09c837d61f">m_match_flag_buffer</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="memdesc:aa54c5ceadc00cbc46497ae09c837d61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See set_match_flag_buffer().  <a href="#aa54c5ceadc00cbc46497ae09c837d61f">More...</a><br /></td></tr>
<tr class="separator:aa54c5ceadc00cbc46497ae09c837d61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7f0402dcbfd47a9dcbcb88be48f2e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhash__join__buffer_1_1TableCollection.html">hash_join_buffer::TableCollection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a2f7f0402dcbfd47a9dcbcb88be48f2e1">m_outer_input_tables</a></td></tr>
<tr class="memdesc:a2f7f0402dcbfd47a9dcbcb88be48f2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tables and columns needed for each outer row.  <a href="#a2f7f0402dcbfd47a9dcbcb88be48f2e1">More...</a><br /></td></tr>
<tr class="separator:a2f7f0402dcbfd47a9dcbcb88be48f2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43884e7ce5ed9f1880d639c9e7525942"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultiRangeRowIterator.html#a43884e7ce5ed9f1880d639c9e7525942">m_join_type</a></td></tr>
<tr class="memdesc:a43884e7ce5ed9f1880d639c9e7525942"><td class="mdescLeft">&#160;</td><td class="mdescRight">The join type of the BKA join we are part of.  <a href="#a43884e7ce5ed9f1880d639c9e7525942">More...</a><br /></td></tr>
<tr class="separator:a43884e7ce5ed9f1880d639c9e7525942"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classTableRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classTableRowIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classTableRowIterator.html">TableRowIterator</a></td></tr>
<tr class="memitem:a2781c058240b4ee66675869a8f992cc7 inherit pro_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a2781c058240b4ee66675869a8f992cc7">HandleError</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="separator:a2781c058240b4ee66675869a8f992cc7 inherit pro_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456045aad51c0414e3fee2c5274684cd inherit pro_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a456045aad51c0414e3fee2c5274684cd">PrintError</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="separator:a456045aad51c0414e3fee2c5274684cd inherit pro_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d19ba7984ab821a048b6274e712a9 inherit pro_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a> () const</td></tr>
<tr class="separator:a5f1d19ba7984ab821a048b6274e712a9 inherit pro_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a> () const</td></tr>
<tr class="separator:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The iterator actually doing the reads from the inner table during BKA. </p>
<p>See file comment. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc372a9de5b5486aef478692872508cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc372a9de5b5486aef478692872508cf">&#9670;&nbsp;</a></span>MultiRangeRowIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MultiRangeRowIterator::MultiRangeRowIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cache_idx_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__REF.html">TABLE_REF</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mrr_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a>&#160;</td>
          <td class="paramname"><em>join_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>outer_input_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>store_rowids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>tables_to_get_rowid_for</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle. </td></tr>
    <tr><td class="paramname">cache_idx_cond</td><td>See m_cache_idx_cond. </td></tr>
    <tr><td class="paramname">table</td><td>The inner table to scan. </td></tr>
    <tr><td class="paramname">ref</td><td>The index condition we are looking up on. </td></tr>
    <tr><td class="paramname">mrr_flags</td><td>Flags passed on to MRR. </td></tr>
    <tr><td class="paramname">join_type</td><td>What kind of BKA join this MRR iterator is part of. </td></tr>
    <tr><td class="paramname">join</td><td>Reference for outer_input_tables and tables_to_get_rowid_for. </td></tr>
    <tr><td class="paramname">outer_input_tables</td><td>Which tables are on the left side of the BKA join (the MRR iterator is always alone on the right side). This is needed so that it can unpack the rows into the right tables, with the right format. </td></tr>
    <tr><td class="paramname">store_rowids</td><td>Whether we need to keep row IDs. </td></tr>
    <tr><td class="paramname">tables_to_get_rowid_for</td><td>Tables we need to call table-&gt;file-&gt;position() for; if a table is present in outer_input_tables but not this, some other iterator will make sure that table has the correct row ID already present after Read(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a592999ca2419280a3f5747032608d8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592999ca2419280a3f5747032608d8dd">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MultiRangeRowIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the actual multi-range read with the rows given by set_rows() and using the temporary buffer given in set_mrr_buffer(). </p>
<p>We don't send a set of rows directly to MRR; instead, we give it a set of function pointers to iterate over the rows, and a pointer to ourselves. The handler will call our callbacks as follows:</p>
<ol type="1">
<li>MrrInitCallback at the start, to initialize iteration.</li>
<li>MrrNextCallback is called to yield ranges to scan, until it returns 1.</li>
<li>If we have dependent index conditions (see the comment on m_cache_idx_cond), MrrSkipIndexTuple will be called back for each range that returned an inner row, and can choose to discard the row there and then if it doesn't match the dependent index condition.</li>
</ol>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="a17f8995b87d1bcc5f65a88413c14a323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f8995b87d1bcc5f65a88413c14a323">&#9670;&nbsp;</a></span>MarkLastRowAsRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultiRangeRowIterator::MarkLastRowAsRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark that the BKA iterator has seen the last row we returned from Read(). </p>
<p>(It could have been discarded by a FilterIterator before it reached them.) Will be a no-op for inner joins; see set_match_flag_buffer().. </p>

</div>
</div>
<a id="ab7594d512405479e04646ce5e9e9cdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7594d512405479e04646ce5e9e9cdfc">&#9670;&nbsp;</a></span>MrrInitCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> MultiRangeRowIterator::MrrInitCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab69a519a83e8a7ca97dfd79f18de47c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69a519a83e8a7ca97dfd79f18de47c2">&#9670;&nbsp;</a></span>MrrInitCallbackThunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a> MultiRangeRowIterator::MrrInitCallbackThunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9dfe7f5647999423d5130022e1b7266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dfe7f5647999423d5130022e1b7266">&#9670;&nbsp;</a></span>MrrNextCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> MultiRangeRowIterator::MrrNextCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a803f05bacd06f4ebfa48240d8c3690a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803f05bacd06f4ebfa48240d8c3690a6">&#9670;&nbsp;</a></span>MrrNextCallbackThunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> MultiRangeRowIterator::MrrNextCallbackThunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>init_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structKEY__MULTI__RANGE.html">KEY_MULTI_RANGE</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2809f34eace8e7b62c5037b56cfc456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2809f34eace8e7b62c5037b56cfc456">&#9670;&nbsp;</a></span>MrrSkipIndexTuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MultiRangeRowIterator::MrrSkipIndexTuple </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7748005274539669832c09c2aa20f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7748005274539669832c09c2aa20f13">&#9670;&nbsp;</a></span>MrrSkipIndexTupleCallbackThunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MultiRangeRowIterator::MrrSkipIndexTupleCallbackThunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>range_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8329a9e54afe87c6014fb02f7e073547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8329a9e54afe87c6014fb02f7e073547">&#9670;&nbsp;</a></span>MrrSkipRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MultiRangeRowIterator::MrrSkipRecord </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4100a9ba89f9b1e89a4152389151754a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4100a9ba89f9b1e89a4152389151754a">&#9670;&nbsp;</a></span>MrrSkipRecordCallbackThunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MultiRangeRowIterator::MrrSkipRecordCallbackThunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sql_2handler_8h.html#adf51a5b0b21b1af418122c4fc7144a9f">range_seq_t</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>range_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24fd1517fc721ef64a4bea9b0a0e345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fd1517fc721ef64a4bea9b0a0e345c">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MultiRangeRowIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read another inner row (if any) and load the appropriate outer row(s) into the associated table buffers. </p>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="aeb3076f75379454e47fd1a9c5ca48d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3076f75379454e47fd1a9c5ca48d6d">&#9670;&nbsp;</a></span>RowHasBeenRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MultiRangeRowIterator::RowHasBeenRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the given row has been marked as read (using MarkLastRowAsRead()) or not. </p>
<p>Used internally when doing semijoins, and also by the BKAIterator when synthesizing NULL-complemented rows for outer joins or antijoins. </p>

</div>
</div>
<a id="a1a6b302cfe1d2a15259d09dd0a0de79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6b302cfe1d2a15259d09dd0a0de79e">&#9670;&nbsp;</a></span>set_match_flag_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultiRangeRowIterator::set_match_flag_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify an unused chunk of memory that we can use to mark which inner rows have been read (by the parent BKA iterator) or not. </p>
<p>This is used for outer joins to know which rows need NULL-complemented versions, and for semijoins and antijoins to avoid matching the same inner row more than once.</p>
<p>Must be called before Init() for semijoins, outer joins and antijoins, and never called otherwise. There must be room at least for one bit per row given in set_rows(). </p>

</div>
</div>
<a id="aed2f54fe0fb6dec85242698628678137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2f54fe0fb6dec85242698628678137">&#9670;&nbsp;</a></span>set_mrr_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultiRangeRowIterator::set_mrr_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify an unused chunk of memory MRR can use for the returned inner rows. </p>
<p>Must be called before Init(), and must be at least big enough to hold one inner row. </p>

</div>
</div>
<a id="aea6d27ced33a106e9640098a0d2c5479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6d27ced33a106e9640098a0d2c5479">&#9670;&nbsp;</a></span>set_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultiRangeRowIterator::set_rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify which outer rows to read inner rows for. </p>
<p>Must be called before Init(), and be valid until the last Read(). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae5ee7e810158554ce46d249f6a3be104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ee7e810158554ce46d249f6a3be104">&#9670;&nbsp;</a></span>m_begin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a>* MultiRangeRowIterator::m_begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current outer rows to read inner rows for. Set by set_rows(). </p>

</div>
</div>
<a id="abbae259ba11cfa2b7020e579cb4038c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbae259ba11cfa2b7020e579cb4038c3">&#9670;&nbsp;</a></span>m_cache_idx_cond</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* const MultiRangeRowIterator::m_cache_idx_cond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There are certain conditions that would normally be pushed down to indexes, but that depend on the values of outer tables in the BKA join (ie., they are join conditions), which are not set when we actually read the inner row. </p>
<p>[1] Thus, we cannot push them all the way down to the handler; however, MRR gives us a similar mechanism that we can use. Specifically, if we set skip_index_tuple to a function pointer, we will be called back for each row, and can load the outer table row(s) we need to evaluate the condition. This allows us to reject the rows based on the index entry alone, without loading the row itself.</p>
<p>It is unclear how much benefit this gives us over simply not pushing these conditions at all. The case of a join condition that is satisfiable using the index tuple but not simply pushable down into the ref is rare; it has to either be on a keypart we couldn't use (e.g., an index on A,B,C where we join A and C but not B &ndash; A then becomes part of our ref, but C needs to be an index condition) or a condition that needs to be rechecked, which happens only when mixing PAD SPACE / NO PAD in a join (e.g. looking up in a CHAR column, but wanting the comparison as NO PAD). Especially the latter case would seem unlikely to filter away a significant amount of rows.</p>
<p>[1] In the DebugString output, we call such conditions dependent index conditions, since they depend on values from other tables, analogous to dependent subqueries. Internally, they are called cache_idx_cond, presumably because BKA originated in join buffering, also known as join cache. </p>

</div>
</div>
<a id="ae53840cc874ebc6ddbd50d83e6f8dd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53840cc874ebc6ddbd50d83e6f8dd60">&#9670;&nbsp;</a></span>m_current_pos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a>* MultiRangeRowIterator::m_current_pos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Which row we are at in the [m_begin, m_end) range. </p>
<p>Used during the MRR callbacks. </p>

</div>
</div>
<a id="af495a463ca7587c2cc0b419b5a4e2830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af495a463ca7587c2cc0b419b5a4e2830">&#9670;&nbsp;</a></span>m_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a>* MultiRangeRowIterator::m_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cf955ba3aa2a709c0222e8eae6ee5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf955ba3aa2a709c0222e8eae6ee5b6">&#9670;&nbsp;</a></span>m_file</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhandler.html">handler</a>* const MultiRangeRowIterator::m_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for the table we are reading from. </p>

</div>
</div>
<a id="a43884e7ce5ed9f1880d639c9e7525942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43884e7ce5ed9f1880d639c9e7525942">&#9670;&nbsp;</a></span>m_join_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395d">JoinType</a> MultiRangeRowIterator::m_join_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The join type of the BKA join we are part of. </p>
<p>Same as m_join_type in the corresponding BKAIterator. </p>

</div>
</div>
<a id="af168994c827db6aff1d97ce1268505c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af168994c827db6aff1d97ce1268505c1">&#9670;&nbsp;</a></span>m_last_row_returned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacehash__join__buffer.html#a3b286b8b28700500939ff9bf68bbb912">hash_join_buffer::BufferRow</a>* MultiRangeRowIterator::m_last_row_returned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What row we last returned from Read() (used for MarkLastRowAsRead()). </p>

</div>
</div>
<a id="aa54c5ceadc00cbc46497ae09c837d61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54c5ceadc00cbc46497ae09c837d61f">&#9670;&nbsp;</a></span>m_match_flag_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* MultiRangeRowIterator::m_match_flag_buffer = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See set_match_flag_buffer(). </p>

</div>
</div>
<a id="a85b4edd6881e48cbc69449a483723ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b4edd6881e48cbc69449a483723ad6">&#9670;&nbsp;</a></span>m_mrr_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structHANDLER__BUFFER.html">HANDLER_BUFFER</a> MultiRangeRowIterator::m_mrr_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary space for storing inner rows, used by MRR. </p>
<p>Set by set_mrr_buffer(). </p>

</div>
</div>
<a id="a232b97802672f263e163ccc6ba82451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232b97802672f263e163ccc6ba82451d">&#9670;&nbsp;</a></span>m_mrr_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int MultiRangeRowIterator::m_mrr_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags passed on to MRR. </p>

</div>
</div>
<a id="a2f7f0402dcbfd47a9dcbcb88be48f2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7f0402dcbfd47a9dcbcb88be48f2e1">&#9670;&nbsp;</a></span>m_outer_input_tables</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhash__join__buffer_1_1TableCollection.html">hash_join_buffer::TableCollection</a> MultiRangeRowIterator::m_outer_input_tables</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tables and columns needed for each outer row. </p>
<p>Same as m_outer_input_tables in the corresponding BKAIterator. </p>

</div>
</div>
<a id="a781f2bc1065327def385e2ed9725e9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781f2bc1065327def385e2ed9725e9d0">&#9670;&nbsp;</a></span>m_ref</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__REF.html">TABLE_REF</a>* const MultiRangeRowIterator::m_ref</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index condition. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="bka__iterator_8h_source.html">bka_iterator.h</a></li>
<li>sql/<a class="el" href="bka__iterator_8cc.html">bka_iterator.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMultiRangeRowIterator.html">MultiRangeRowIterator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
