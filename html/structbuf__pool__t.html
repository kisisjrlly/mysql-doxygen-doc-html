<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: buf_pool_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structbuf__pool__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="structbuf__pool__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">buf_pool_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The buffer pool structure.  
 <a href="structbuf__pool__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">General fields</div></td></tr>
<tr class="memitem:a5a47267e7a08944d5d0c6b7d3a7d9006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a5a47267e7a08944d5d0c6b7d3a7d9006">chunks_mutex</a></td></tr>
<tr class="memdesc:a5a47267e7a08944d5d0c6b7d3a7d9006"><td class="mdescLeft">&#160;</td><td class="mdescRight">protects (de)allocation of chunks:  <a href="#a5a47267e7a08944d5d0c6b7d3a7d9006">More...</a><br /></td></tr>
<tr class="separator:a5a47267e7a08944d5d0c6b7d3a7d9006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db1ee56155c14ea2870bc74b3443d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a9db1ee56155c14ea2870bc74b3443d9b">LRU_list_mutex</a></td></tr>
<tr class="memdesc:a9db1ee56155c14ea2870bc74b3443d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">LRU list mutex.  <a href="#a9db1ee56155c14ea2870bc74b3443d9b">More...</a><br /></td></tr>
<tr class="separator:a9db1ee56155c14ea2870bc74b3443d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a36a64c9775f590dfae2e47516b16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ae2a36a64c9775f590dfae2e47516b16b">free_list_mutex</a></td></tr>
<tr class="memdesc:ae2a36a64c9775f590dfae2e47516b16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">free and withdraw list mutex  <a href="#ae2a36a64c9775f590dfae2e47516b16b">More...</a><br /></td></tr>
<tr class="separator:ae2a36a64c9775f590dfae2e47516b16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6291c0c70a786c113c2d7c7bfe6afbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a6291c0c70a786c113c2d7c7bfe6afbb9">zip_free_mutex</a></td></tr>
<tr class="memdesc:a6291c0c70a786c113c2d7c7bfe6afbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">buddy allocator mutex  <a href="#a6291c0c70a786c113c2d7c7bfe6afbb9">More...</a><br /></td></tr>
<tr class="separator:a6291c0c70a786c113c2d7c7bfe6afbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82b0a923041e5ddad344c8f1d177c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#af82b0a923041e5ddad344c8f1d177c14">zip_hash_mutex</a></td></tr>
<tr class="memdesc:af82b0a923041e5ddad344c8f1d177c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip_hash mutex  <a href="#af82b0a923041e5ddad344c8f1d177c14">More...</a><br /></td></tr>
<tr class="separator:af82b0a923041e5ddad344c8f1d177c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96040907b997b91c51feda9ba0b87d1f"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a96040907b997b91c51feda9ba0b87d1f">flush_state_mutex</a></td></tr>
<tr class="memdesc:a96040907b997b91c51feda9ba0b87d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush state protection mutex.  <a href="#a96040907b997b91c51feda9ba0b87d1f">More...</a><br /></td></tr>
<tr class="separator:a96040907b997b91c51feda9ba0b87d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663da445248d1af7f38b75dddd4ff9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a12e6e65b485343049745e6ec5d7513c6">BufPoolZipMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ae663da445248d1af7f38b75dddd4ff9b">zip_mutex</a></td></tr>
<tr class="memdesc:ae663da445248d1af7f38b75dddd4ff9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip mutex of this buffer pool instance, protects compressed only pages (of type buf_page_t, not buf_block_t.  <a href="#ae663da445248d1af7f38b75dddd4ff9b">More...</a><br /></td></tr>
<tr class="separator:ae663da445248d1af7f38b75dddd4ff9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7264f647475c1a97e2aa54210750563"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ac7264f647475c1a97e2aa54210750563">instance_no</a></td></tr>
<tr class="memdesc:ac7264f647475c1a97e2aa54210750563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array index of this buffer pool instance.  <a href="#ac7264f647475c1a97e2aa54210750563">More...</a><br /></td></tr>
<tr class="separator:ac7264f647475c1a97e2aa54210750563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30577642b259b121117a1eb513ea1ed"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ab30577642b259b121117a1eb513ea1ed">curr_pool_size</a></td></tr>
<tr class="memdesc:ab30577642b259b121117a1eb513ea1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current pool size in bytes.  <a href="#ab30577642b259b121117a1eb513ea1ed">More...</a><br /></td></tr>
<tr class="separator:ab30577642b259b121117a1eb513ea1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5517fb979475c6b799d10dd7b294094a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a5517fb979475c6b799d10dd7b294094a">LRU_old_ratio</a></td></tr>
<tr class="memdesc:a5517fb979475c6b799d10dd7b294094a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve this much of the buffer pool for "old" blocks.  <a href="#a5517fb979475c6b799d10dd7b294094a">More...</a><br /></td></tr>
<tr class="separator:a5517fb979475c6b799d10dd7b294094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261df28273a07d8e17e6236267c7dfde"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a261df28273a07d8e17e6236267c7dfde">buddy_n_frames</a></td></tr>
<tr class="memdesc:a261df28273a07d8e17e6236267c7dfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of frames allocated from the buffer pool to the buddy system.  <a href="#a261df28273a07d8e17e6236267c7dfde">More...</a><br /></td></tr>
<tr class="separator:a261df28273a07d8e17e6236267c7dfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f584acf0bdd4be17836f67e4827d736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classut__allocator.html">ut_allocator</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a0f584acf0bdd4be17836f67e4827d736">allocator</a></td></tr>
<tr class="memdesc:a0f584acf0bdd4be17836f67e4827d736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator used for allocating memory for the the "chunks" member.  <a href="#a0f584acf0bdd4be17836f67e4827d736">More...</a><br /></td></tr>
<tr class="separator:a0f584acf0bdd4be17836f67e4827d736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6656602570ef2b8d7f060a90daee9b9e"><td class="memItemLeft" align="right" valign="top">volatile ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a6656602570ef2b8d7f060a90daee9b9e">n_chunks</a></td></tr>
<tr class="memdesc:a6656602570ef2b8d7f060a90daee9b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of buffer pool chunks  <a href="#a6656602570ef2b8d7f060a90daee9b9e">More...</a><br /></td></tr>
<tr class="separator:a6656602570ef2b8d7f060a90daee9b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef956328cfbb74ebd474074aafc7175a"><td class="memItemLeft" align="right" valign="top">volatile ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#aef956328cfbb74ebd474074aafc7175a">n_chunks_new</a></td></tr>
<tr class="memdesc:aef956328cfbb74ebd474074aafc7175a"><td class="mdescLeft">&#160;</td><td class="mdescRight">new number of buffer pool chunks  <a href="#aef956328cfbb74ebd474074aafc7175a">More...</a><br /></td></tr>
<tr class="separator:aef956328cfbb74ebd474074aafc7175a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f49acd5b9e826b2fc59f60f197d78"><td class="memItemLeft" align="right" valign="top">buf_chunk_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a9a0f49acd5b9e826b2fc59f60f197d78">chunks</a></td></tr>
<tr class="memdesc:a9a0f49acd5b9e826b2fc59f60f197d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer pool chunks  <a href="#a9a0f49acd5b9e826b2fc59f60f197d78">More...</a><br /></td></tr>
<tr class="separator:a9a0f49acd5b9e826b2fc59f60f197d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081fb5b9138e111af2d85a333f4165ac"><td class="memItemLeft" align="right" valign="top">buf_chunk_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a081fb5b9138e111af2d85a333f4165ac">chunks_old</a></td></tr>
<tr class="memdesc:a081fb5b9138e111af2d85a333f4165ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">old buffer pool chunks to be freed after resizing buffer pool  <a href="#a081fb5b9138e111af2d85a333f4165ac">More...</a><br /></td></tr>
<tr class="separator:a081fb5b9138e111af2d85a333f4165ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48e5a71d543c485fbc2ab315a7a4eef"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ac48e5a71d543c485fbc2ab315a7a4eef">curr_size</a></td></tr>
<tr class="memdesc:ac48e5a71d543c485fbc2ab315a7a4eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">current pool size in pages  <a href="#ac48e5a71d543c485fbc2ab315a7a4eef">More...</a><br /></td></tr>
<tr class="separator:ac48e5a71d543c485fbc2ab315a7a4eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a47af710b9f9e7af5354de5b23fba7a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a7a47af710b9f9e7af5354de5b23fba7a">old_size</a></td></tr>
<tr class="memdesc:a7a47af710b9f9e7af5354de5b23fba7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">previous pool size in pages  <a href="#a7a47af710b9f9e7af5354de5b23fba7a">More...</a><br /></td></tr>
<tr class="separator:a7a47af710b9f9e7af5354de5b23fba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27b834468362ae6517566bc23d4db12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ab27b834468362ae6517566bc23d4db12">read_ahead_area</a></td></tr>
<tr class="memdesc:ab27b834468362ae6517566bc23d4db12"><td class="mdescLeft">&#160;</td><td class="mdescRight">size in pages of the area which the read-ahead algorithms read if invoked  <a href="#ab27b834468362ae6517566bc23d4db12">More...</a><br /></td></tr>
<tr class="separator:ab27b834468362ae6517566bc23d4db12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02ce633a1ca3d49d78df3d2ea3c9472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#aa02ce633a1ca3d49d78df3d2ea3c9472">page_hash</a></td></tr>
<tr class="memdesc:aa02ce633a1ca3d49d78df3d2ea3c9472"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash table of buf_page_t or buf_block_t file pages, buf_page_in_file() == TRUE, indexed by (space_id, offset).  <a href="#aa02ce633a1ca3d49d78df3d2ea3c9472">More...</a><br /></td></tr>
<tr class="separator:aa02ce633a1ca3d49d78df3d2ea3c9472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5af0004d4b47625984d89f02bdc132f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#af5af0004d4b47625984d89f02bdc132f">page_hash_old</a></td></tr>
<tr class="memdesc:af5af0004d4b47625984d89f02bdc132f"><td class="mdescLeft">&#160;</td><td class="mdescRight">old pointer to page_hash to be freed after resizing buffer pool  <a href="#af5af0004d4b47625984d89f02bdc132f">More...</a><br /></td></tr>
<tr class="separator:af5af0004d4b47625984d89f02bdc132f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a16d528a553e5e4f8e11820402d9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a10a16d528a553e5e4f8e11820402d9db">zip_hash</a></td></tr>
<tr class="memdesc:a10a16d528a553e5e4f8e11820402d9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash table of buf_block_t blocks whose frames are allocated to the zip buddy system, indexed by block-&gt;frame  <a href="#a10a16d528a553e5e4f8e11820402d9db">More...</a><br /></td></tr>
<tr class="separator:a10a16d528a553e5e4f8e11820402d9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46d7942520722ff424b9f39d711ec68"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ab46d7942520722ff424b9f39d711ec68">n_pend_reads</a></td></tr>
<tr class="memdesc:ab46d7942520722ff424b9f39d711ec68"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pending read operations.  <a href="#ab46d7942520722ff424b9f39d711ec68">More...</a><br /></td></tr>
<tr class="separator:ab46d7942520722ff424b9f39d711ec68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bf877482c603a94dd03de812a0a3fb"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a44bf877482c603a94dd03de812a0a3fb">n_pend_unzip</a></td></tr>
<tr class="memdesc:a44bf877482c603a94dd03de812a0a3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pending decompressions.  <a href="#a44bf877482c603a94dd03de812a0a3fb">More...</a><br /></td></tr>
<tr class="separator:a44bf877482c603a94dd03de812a0a3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355670cec77c64853441e307472e660a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ut0ut_8h.html#a3d7efb6a0ff993a01dd08a7fa914056a">ib_time_monotonic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a355670cec77c64853441e307472e660a">last_printout_time</a></td></tr>
<tr class="memdesc:a355670cec77c64853441e307472e660a"><td class="mdescLeft">&#160;</td><td class="mdescRight">when buf_print_io was last time called.  <a href="#a355670cec77c64853441e307472e660a">More...</a><br /></td></tr>
<tr class="separator:a355670cec77c64853441e307472e660a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1545c7cead3e42152069f1a86e6bbbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__buddy__stat__t.html">buf_buddy_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a1545c7cead3e42152069f1a86e6bbbd3">buddy_stat</a> [<a class="el" href="buf0types_8h.html#aa202293f585f6fafe890a11f6e275f82">BUF_BUDDY_SIZES_MAX</a>+1]</td></tr>
<tr class="memdesc:a1545c7cead3e42152069f1a86e6bbbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics of buddy system, indexed by block size.  <a href="#a1545c7cead3e42152069f1a86e6bbbd3">More...</a><br /></td></tr>
<tr class="separator:a1545c7cead3e42152069f1a86e6bbbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b6ff232ef55a6ccfedd3b5ec94bc6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#aa6b6ff232ef55a6ccfedd3b5ec94bc6d">stat</a></td></tr>
<tr class="memdesc:aa6b6ff232ef55a6ccfedd3b5ec94bc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">current statistics  <a href="#aa6b6ff232ef55a6ccfedd3b5ec94bc6d">More...</a><br /></td></tr>
<tr class="separator:aa6b6ff232ef55a6ccfedd3b5ec94bc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d825ac141e650cd211452c45e3f394f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a1d825ac141e650cd211452c45e3f394f">old_stat</a></td></tr>
<tr class="memdesc:a1d825ac141e650cd211452c45e3f394f"><td class="mdescLeft">&#160;</td><td class="mdescRight">old statistics  <a href="#a1d825ac141e650cd211452c45e3f394f">More...</a><br /></td></tr>
<tr class="separator:a1d825ac141e650cd211452c45e3f394f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Page flushing algorithm fields</h2></td></tr>
<tr class="memitem:a8b4f8f85e5d1b1008ddf8080c6c90744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a8b4f8f85e5d1b1008ddf8080c6c90744">flush_list_mutex</a></td></tr>
<tr class="memdesc:a8b4f8f85e5d1b1008ddf8080c6c90744"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex protecting the flush list access.  <a href="#a8b4f8f85e5d1b1008ddf8080c6c90744">More...</a><br /></td></tr>
<tr class="separator:a8b4f8f85e5d1b1008ddf8080c6c90744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c1280cf5bf44e12745e1ebe9c5897f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFlushHp.html">FlushHp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a11c1280cf5bf44e12745e1ebe9c5897f">flush_hp</a></td></tr>
<tr class="memdesc:a11c1280cf5bf44e12745e1ebe9c5897f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"hazard pointer" used during scan of flush_list while doing flush list batch.  <a href="#a11c1280cf5bf44e12745e1ebe9c5897f">More...</a><br /></td></tr>
<tr class="separator:a11c1280cf5bf44e12745e1ebe9c5897f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4334d6ec9729a43095755d6f445443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFlushHp.html">FlushHp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a7d4334d6ec9729a43095755d6f445443">oldest_hp</a></td></tr>
<tr class="memdesc:a7d4334d6ec9729a43095755d6f445443"><td class="mdescLeft">&#160;</td><td class="mdescRight">entry pointer to scan the oldest page except for system temporary  <a href="#a7d4334d6ec9729a43095755d6f445443">More...</a><br /></td></tr>
<tr class="separator:a7d4334d6ec9729a43095755d6f445443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530c64c0638ab3422b434b02a037116b"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a530c64c0638ab3422b434b02a037116b">init_flush</a> [<a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73cab382ac3a7501526d7a81edcf0925be47">BUF_FLUSH_N_TYPES</a>]</td></tr>
<tr class="memdesc:a530c64c0638ab3422b434b02a037116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is TRUE when a flush of the given type is being initialized.  <a href="#a530c64c0638ab3422b434b02a037116b">More...</a><br /></td></tr>
<tr class="separator:a530c64c0638ab3422b434b02a037116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8672d592d9f8260163a32461eba1f8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a9c8672d592d9f8260163a32461eba1f8">n_flush</a> [<a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73cab382ac3a7501526d7a81edcf0925be47">BUF_FLUSH_N_TYPES</a>]</td></tr>
<tr class="memdesc:a9c8672d592d9f8260163a32461eba1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the number of pending writes in the given flush type.  <a href="#a9c8672d592d9f8260163a32461eba1f8">More...</a><br /></td></tr>
<tr class="separator:a9c8672d592d9f8260163a32461eba1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41261b7d8bccfb6771b679c58648d6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#aa41261b7d8bccfb6771b679c58648d6d">no_flush</a> [<a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73cab382ac3a7501526d7a81edcf0925be47">BUF_FLUSH_N_TYPES</a>]</td></tr>
<tr class="memdesc:aa41261b7d8bccfb6771b679c58648d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is in the set state when there is no flush batch of the given type running.  <a href="#aa41261b7d8bccfb6771b679c58648d6d">More...</a><br /></td></tr>
<tr class="separator:aa41261b7d8bccfb6771b679c58648d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9885e7719ec8de34ee9860ee1a662f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a9885e7719ec8de34ee9860ee1a662f54">flush_rbt</a></td></tr>
<tr class="memdesc:a9885e7719ec8de34ee9860ee1a662f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">a red-black tree is used exclusively during recovery to speed up insertions in the flush_list.  <a href="#a9885e7719ec8de34ee9860ee1a662f54">More...</a><br /></td></tr>
<tr class="separator:a9885e7719ec8de34ee9860ee1a662f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aed6254f53462f6e6c406dae78c1f2"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ae0aed6254f53462f6e6c406dae78c1f2">freed_page_clock</a></td></tr>
<tr class="memdesc:ae0aed6254f53462f6e6c406dae78c1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">a sequence number used to count the number of buffer blocks removed from the end of the LRU list; NOTE that this counter may wrap around at 4 billion! A thread is allowed to read this for heuristic purposes without holding any mutex or latch.  <a href="#ae0aed6254f53462f6e6c406dae78c1f2">More...</a><br /></td></tr>
<tr class="separator:ae0aed6254f53462f6e6c406dae78c1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaedf5345e73786752c837141f44b6f"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#accaedf5345e73786752c837141f44b6f">try_LRU_scan</a></td></tr>
<tr class="memdesc:accaedf5345e73786752c837141f44b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to FALSE when an LRU scan for free block fails.  <a href="#accaedf5345e73786752c837141f44b6f">More...</a><br /></td></tr>
<tr class="separator:accaedf5345e73786752c837141f44b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ec626b6766fbf8dd21843c46a9e702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a61ec626b6766fbf8dd21843c46a9e702">track_page_lsn</a></td></tr>
<tr class="separator:a61ec626b6766fbf8dd21843c46a9e702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd2d13b530b284242790ee3b1c1f639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#adbd2d13b530b284242790ee3b1c1f639">max_lsn_io</a></td></tr>
<tr class="separator:adbd2d13b530b284242790ee3b1c1f639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b498b6812f3a5294ef48be39c196c03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a5b498b6812f3a5294ef48be39c196c03">UT_LIST_BASE_NODE_T</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a>) flush_list</td></tr>
<tr class="memdesc:a5b498b6812f3a5294ef48be39c196c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">base node of the modified block list  <a href="#a5b498b6812f3a5294ef48be39c196c03">More...</a><br /></td></tr>
<tr class="separator:a5b498b6812f3a5294ef48be39c196c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LRU replacement algorithm fields</h2></td></tr>
<tr class="memitem:aa359723790414b5ba219540c76ac91cd"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#aa359723790414b5ba219540c76ac91cd">withdraw_target</a></td></tr>
<tr class="memdesc:aa359723790414b5ba219540c76ac91cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">target length of withdraw block list, when withdrawing  <a href="#aa359723790414b5ba219540c76ac91cd">More...</a><br /></td></tr>
<tr class="separator:aa359723790414b5ba219540c76ac91cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cb8d5f5c4dd23c8717943daa751a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLRUHp.html">LRUHp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a37cb8d5f5c4dd23c8717943daa751a7b">lru_hp</a></td></tr>
<tr class="memdesc:a37cb8d5f5c4dd23c8717943daa751a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">"hazard pointer" used during scan of LRU while doing LRU list batch.  <a href="#a37cb8d5f5c4dd23c8717943daa751a7b">More...</a><br /></td></tr>
<tr class="separator:a37cb8d5f5c4dd23c8717943daa751a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a098537ebd743d59aab402cece965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLRUItr.html">LRUItr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a755a098537ebd743d59aab402cece965">lru_scan_itr</a></td></tr>
<tr class="memdesc:a755a098537ebd743d59aab402cece965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator used to scan the LRU list when searching for replacable victim.  <a href="#a755a098537ebd743d59aab402cece965">More...</a><br /></td></tr>
<tr class="separator:a755a098537ebd743d59aab402cece965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdae3322515ebcad8439bcf0bbac9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLRUItr.html">LRUItr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a1bdae3322515ebcad8439bcf0bbac9dd">single_scan_itr</a></td></tr>
<tr class="memdesc:a1bdae3322515ebcad8439bcf0bbac9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator used to scan the LRU list when searching for single page flushing victim.  <a href="#a1bdae3322515ebcad8439bcf0bbac9dd">More...</a><br /></td></tr>
<tr class="separator:a1bdae3322515ebcad8439bcf0bbac9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f98404f9e6016d7c78bafbb01d89657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a7f98404f9e6016d7c78bafbb01d89657">LRU_old</a></td></tr>
<tr class="memdesc:a7f98404f9e6016d7c78bafbb01d89657"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the about LRU_old_ratio/BUF_LRU_OLD_RATIO_DIV oldest blocks in the LRU list; NULL if LRU length less than BUF_LRU_OLD_MIN_LEN; NOTE: when LRU_old != NULL, its length should always equal LRU_old_len  <a href="#a7f98404f9e6016d7c78bafbb01d89657">More...</a><br /></td></tr>
<tr class="separator:a7f98404f9e6016d7c78bafbb01d89657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a49e54a5249cf5cef9c55c3221241f"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ac8a49e54a5249cf5cef9c55c3221241f">LRU_old_len</a></td></tr>
<tr class="memdesc:ac8a49e54a5249cf5cef9c55c3221241f"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of the LRU list from the block to which LRU_old points onward, including that block; see buf0lru.cc for the restrictions on this value; 0 if LRU_old == NULL; NOTE: LRU_old_len must be adjusted whenever LRU_old shrinks or grows!  <a href="#ac8a49e54a5249cf5cef9c55c3221241f">More...</a><br /></td></tr>
<tr class="separator:ac8a49e54a5249cf5cef9c55c3221241f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e328229c28186101ad337252fdfc20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a55e328229c28186101ad337252fdfc20">UT_LIST_BASE_NODE_T</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a>) <a class="el" href="lexyy_8cc.html#ab2d959f7fd0a704078b7e2d78a4d116d">free</a></td></tr>
<tr class="memdesc:a55e328229c28186101ad337252fdfc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">base node of the free block list  <a href="#a55e328229c28186101ad337252fdfc20">More...</a><br /></td></tr>
<tr class="separator:a55e328229c28186101ad337252fdfc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82d93dd02c6f567b28ae692f7789886"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#ae82d93dd02c6f567b28ae692f7789886">UT_LIST_BASE_NODE_T</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a>) withdraw</td></tr>
<tr class="memdesc:ae82d93dd02c6f567b28ae692f7789886"><td class="mdescLeft">&#160;</td><td class="mdescRight">base node of the withdraw block list.  <a href="#ae82d93dd02c6f567b28ae692f7789886">More...</a><br /></td></tr>
<tr class="separator:ae82d93dd02c6f567b28ae692f7789886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f67a41fc9a3c1ba2bfbb77184fc7f68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a0f67a41fc9a3c1ba2bfbb77184fc7f68">UT_LIST_BASE_NODE_T</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a>) LRU</td></tr>
<tr class="memdesc:a0f67a41fc9a3c1ba2bfbb77184fc7f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">base node of the LRU list  <a href="#a0f67a41fc9a3c1ba2bfbb77184fc7f68">More...</a><br /></td></tr>
<tr class="separator:a0f67a41fc9a3c1ba2bfbb77184fc7f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de7558becfdf00af66d5d3b2d4c4c8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a7de7558becfdf00af66d5d3b2d4c4c8d">UT_LIST_BASE_NODE_T</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a>) unzip_LRU</td></tr>
<tr class="memdesc:a7de7558becfdf00af66d5d3b2d4c4c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">base node of the unzip_LRU list.  <a href="#a7de7558becfdf00af66d5d3b2d4c4c8d">More...</a><br /></td></tr>
<tr class="separator:a7de7558becfdf00af66d5d3b2d4c4c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Buddy allocator fields</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb682869f1446a79ea87d7f0dacdd5202"></a>The buddy allocator is used for allocating compressed page frames and buf_page_t descriptors of blocks that exist in the buffer pool only in compressed form.</p>
</td></tr>
<tr class="memitem:a85b353f8c15266560701a4e4577c4940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a85b353f8c15266560701a4e4577c4940">watch</a></td></tr>
<tr class="memdesc:a85b353f8c15266560701a4e4577c4940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel records for buffer pool watches.  <a href="#a85b353f8c15266560701a4e4577c4940">More...</a><br /></td></tr>
<tr class="separator:a85b353f8c15266560701a4e4577c4940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06254fd05aa27c729f1c587da9345968"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a06254fd05aa27c729f1c587da9345968">UT_LIST_BASE_NODE_T</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a>) zip_clean</td></tr>
<tr class="memdesc:a06254fd05aa27c729f1c587da9345968"><td class="mdescLeft">&#160;</td><td class="mdescRight">unmodified compressed pages  <a href="#a06254fd05aa27c729f1c587da9345968">More...</a><br /></td></tr>
<tr class="separator:a06254fd05aa27c729f1c587da9345968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2e2dd3df90afa9f8e209fbac67da17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a4e2e2dd3df90afa9f8e209fbac67da17">UT_LIST_BASE_NODE_T</a> (<a class="el" href="structbuf__buddy__free__t.html">buf_buddy_free_t</a>) zip_free[<a class="el" href="buf0types_8h.html#aa202293f585f6fafe890a11f6e275f82">BUF_BUDDY_SIZES_MAX</a>]</td></tr>
<tr class="memdesc:a4e2e2dd3df90afa9f8e209fbac67da17"><td class="mdescLeft">&#160;</td><td class="mdescRight">buddy free lists  <a href="#a4e2e2dd3df90afa9f8e209fbac67da17">More...</a><br /></td></tr>
<tr class="separator:a4e2e2dd3df90afa9f8e209fbac67da17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afb63d802716f53a4fdd52cbc11157b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a3afb63d802716f53a4fdd52cbc11157b">allocate_chunk</a> (<a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> mem_size, buf_chunk_t *chunk)</td></tr>
<tr class="memdesc:a3afb63d802716f53a4fdd52cbc11157b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for buf_pool_t::allocator.alocate_large which also advices the OS that this chunk should not be dumped to a core file if that was requested.  <a href="#a3afb63d802716f53a4fdd52cbc11157b">More...</a><br /></td></tr>
<tr class="separator:a3afb63d802716f53a4fdd52cbc11157b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e289b88cc0f4a8d0e76e1cf6937a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a20e289b88cc0f4a8d0e76e1cf6937a1e">deallocate_chunk</a> (buf_chunk_t *chunk)</td></tr>
<tr class="memdesc:a20e289b88cc0f4a8d0e76e1cf6937a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for buf_pool_t::allocator.deallocate_large which also advices the OS that this chunk can be dumped to a core file.  <a href="#a20e289b88cc0f4a8d0e76e1cf6937a1e">More...</a><br /></td></tr>
<tr class="separator:a20e289b88cc0f4a8d0e76e1cf6937a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a3f2a01d95e76e587fd1c3580bd9ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#a78a3f2a01d95e76e587fd1c3580bd9ac">madvise_dump</a> ()</td></tr>
<tr class="memdesc:a78a3f2a01d95e76e587fd1c3580bd9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advices the OS that all chunks in this buffer pool instance can be dumped to a core file.  <a href="#a78a3f2a01d95e76e587fd1c3580bd9ac">More...</a><br /></td></tr>
<tr class="separator:a78a3f2a01d95e76e587fd1c3580bd9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef41cf6019b2fb6647d16b23ae814a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html#aef41cf6019b2fb6647d16b23ae814a3a">madvise_dont_dump</a> ()</td></tr>
<tr class="memdesc:aef41cf6019b2fb6647d16b23ae814a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advices the OS that all chunks in this buffer pool instance should not be dumped to a core file.  <a href="#aef41cf6019b2fb6647d16b23ae814a3a">More...</a><br /></td></tr>
<tr class="separator:aef41cf6019b2fb6647d16b23ae814a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The buffer pool structure. </p>
<p>NOTE! The definition appears here only for other modules of this directory (buf) to see it. Do not use from outside! </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3afb63d802716f53a4fdd52cbc11157b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afb63d802716f53a4fdd52cbc11157b">&#9670;&nbsp;</a></span>allocate_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_pool_t::allocate_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a>&#160;</td>
          <td class="paramname"><em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper for buf_pool_t::allocator.alocate_large which also advices the OS that this chunk should not be dumped to a core file if that was requested. </p>
<p>Emits a warning to the log and disables @global.core_file if advising was requested but could not be performed, but still return true as the allocation itself succeeded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_size</td><td>number of bytes to allocate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">chunk</td><td>mem and mem_pfx fields of this chunk will be updated to contain information about allocated memory region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff allocated successfully </dd></dl>

</div>
</div>
<a id="a20e289b88cc0f4a8d0e76e1cf6937a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e289b88cc0f4a8d0e76e1cf6937a1e">&#9670;&nbsp;</a></span>deallocate_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_pool_t::deallocate_chunk </td>
          <td>(</td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper for buf_pool_t::allocator.deallocate_large which also advices the OS that this chunk can be dumped to a core file. </p>
<p>Emits a warning to the log and disables @global.core_file if advising was requested but could not be performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>mem and mem_pfx fields of this chunk will be used to locate the memory region to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef41cf6019b2fb6647d16b23ae814a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef41cf6019b2fb6647d16b23ae814a3a">&#9670;&nbsp;</a></span>madvise_dont_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_pool_t::madvise_dont_dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advices the OS that all chunks in this buffer pool instance should not be dumped to a core file. </p>
<p>Emits a warning to the log if could not succeed. </p><dl class="section return"><dt>Returns</dt><dd>true iff succeeded, false if no OS support or failed </dd></dl>

</div>
</div>
<a id="a78a3f2a01d95e76e587fd1c3580bd9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a3f2a01d95e76e587fd1c3580bd9ac">&#9670;&nbsp;</a></span>madvise_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_pool_t::madvise_dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advices the OS that all chunks in this buffer pool instance can be dumped to a core file. </p>
<p>Emits a warning to the log if could not succeed. </p><dl class="section return"><dt>Returns</dt><dd>true iff succeeded, false if no OS support or failed </dd></dl>

</div>
</div>
<a id="a5b498b6812f3a5294ef48be39c196c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b498b6812f3a5294ef48be39c196c03">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_pool_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>base node of the modified block list </p>

</div>
</div>
<a id="a55e328229c28186101ad337252fdfc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e328229c28186101ad337252fdfc20">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_pool_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>base node of the free block list </p>

</div>
</div>
<a id="ae82d93dd02c6f567b28ae692f7789886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82d93dd02c6f567b28ae692f7789886">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_pool_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>base node of the withdraw block list. </p>
<p>It is only used during shrinking buffer pool size, not to reuse the blocks will be removed. Protected by free_list_mutex </p>

</div>
</div>
<a id="a0f67a41fc9a3c1ba2bfbb77184fc7f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f67a41fc9a3c1ba2bfbb77184fc7f68">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_pool_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>base node of the LRU list </p>

</div>
</div>
<a id="a7de7558becfdf00af66d5d3b2d4c4c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de7558becfdf00af66d5d3b2d4c4c8d">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_pool_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>base node of the unzip_LRU list. </p>
<p>The list is protected by LRU_list_mutex. </p>

</div>
</div>
<a id="a06254fd05aa27c729f1c587da9345968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06254fd05aa27c729f1c587da9345968">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_pool_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unmodified compressed pages </p>

</div>
</div>
<a id="a4e2e2dd3df90afa9f8e209fbac67da17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2e2dd3df90afa9f8e209fbac67da17">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_pool_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__buddy__free__t.html">buf_buddy_free_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buddy free lists </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0f584acf0bdd4be17836f67e4827d736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f584acf0bdd4be17836f67e4827d736">&#9670;&nbsp;</a></span>allocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classut__allocator.html">ut_allocator</a>&lt;unsigned char&gt; buf_pool_t::allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator used for allocating memory for the the "chunks" member. </p>

</div>
</div>
<a id="a261df28273a07d8e17e6236267c7dfde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261df28273a07d8e17e6236267c7dfde">&#9670;&nbsp;</a></span>buddy_n_frames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::buddy_n_frames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of frames allocated from the buffer pool to the buddy system. </p>
<p>Protected by zip_hash_mutex. </p>

</div>
</div>
<a id="a1545c7cead3e42152069f1a86e6bbbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1545c7cead3e42152069f1a86e6bbbd3">&#9670;&nbsp;</a></span>buddy_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__buddy__stat__t.html">buf_buddy_stat_t</a> buf_pool_t::buddy_stat[<a class="el" href="buf0types_8h.html#aa202293f585f6fafe890a11f6e275f82">BUF_BUDDY_SIZES_MAX</a>+1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statistics of buddy system, indexed by block size. </p>
<p>Protected by zip_free mutex, except for the used field, which is also accessed atomically </p>

</div>
</div>
<a id="a9a0f49acd5b9e826b2fc59f60f197d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0f49acd5b9e826b2fc59f60f197d78">&#9670;&nbsp;</a></span>chunks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_chunk_t* buf_pool_t::chunks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer pool chunks </p>

</div>
</div>
<a id="a5a47267e7a08944d5d0c6b7d3a7d9006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a47267e7a08944d5d0c6b7d3a7d9006">&#9670;&nbsp;</a></span>chunks_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a> buf_pool_t::chunks_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>protects (de)allocation of chunks: </p>
<ul>
<li>changes to chunks, n_chunks are performed while holding this latch,</li>
<li>reading buf_pool_should_madvise requires holding this latch for any buf_pool_t</li>
<li>writing to buf_pool_should_madvise requires holding these latches for all buf_pool_t-s </li>
</ul>

</div>
</div>
<a id="a081fb5b9138e111af2d85a333f4165ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081fb5b9138e111af2d85a333f4165ac">&#9670;&nbsp;</a></span>chunks_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buf_chunk_t* buf_pool_t::chunks_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>old buffer pool chunks to be freed after resizing buffer pool </p>

</div>
</div>
<a id="ab30577642b259b121117a1eb513ea1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30577642b259b121117a1eb513ea1ed">&#9670;&nbsp;</a></span>curr_pool_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::curr_pool_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current pool size in bytes. </p>

</div>
</div>
<a id="ac48e5a71d543c485fbc2ab315a7a4eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48e5a71d543c485fbc2ab315a7a4eef">&#9670;&nbsp;</a></span>curr_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::curr_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>current pool size in pages </p>

</div>
</div>
<a id="a11c1280cf5bf44e12745e1ebe9c5897f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c1280cf5bf44e12745e1ebe9c5897f">&#9670;&nbsp;</a></span>flush_hp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFlushHp.html">FlushHp</a> buf_pool_t::flush_hp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"hazard pointer" used during scan of flush_list while doing flush list batch. </p>
<p>Protected by flush_list_mutex </p>

</div>
</div>
<a id="a8b4f8f85e5d1b1008ddf8080c6c90744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f8f85e5d1b1008ddf8080c6c90744">&#9670;&nbsp;</a></span>flush_list_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a> buf_pool_t::flush_list_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mutex protecting the flush list access. </p>
<p>This mutex protects flush_list, flush_rbt and bpage::list pointers when the bpage is on flush_list. It also protects writes to bpage::oldest_modification and flush_list_hp </p>

</div>
</div>
<a id="a9885e7719ec8de34ee9860ee1a662f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9885e7719ec8de34ee9860ee1a662f54">&#9670;&nbsp;</a></span>flush_rbt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a>* buf_pool_t::flush_rbt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a red-black tree is used exclusively during recovery to speed up insertions in the flush_list. </p>
<p>This tree contains blocks in order of oldest_modification LSN and is kept in sync with the flush_list. Each member of the tree MUST also be on the flush_list. This tree is relevant only in recovery and is set to NULL once the recovery is over. Protected by flush_list_mutex </p>

</div>
</div>
<a id="a96040907b997b91c51feda9ba0b87d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96040907b997b91c51feda9ba0b87d1f">&#9670;&nbsp;</a></span>flush_state_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t buf_pool_t::flush_state_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush state protection mutex. </p>

</div>
</div>
<a id="ae2a36a64c9775f590dfae2e47516b16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a36a64c9775f590dfae2e47516b16b">&#9670;&nbsp;</a></span>free_list_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a> buf_pool_t::free_list_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free and withdraw list mutex </p>

</div>
</div>
<a id="ae0aed6254f53462f6e6c406dae78c1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0aed6254f53462f6e6c406dae78c1f2">&#9670;&nbsp;</a></span>freed_page_clock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::freed_page_clock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a sequence number used to count the number of buffer blocks removed from the end of the LRU list; NOTE that this counter may wrap around at 4 billion! A thread is allowed to read this for heuristic purposes without holding any mutex or latch. </p>
<p>For non-heuristic purposes protected by LRU_list_mutex </p>

</div>
</div>
<a id="a530c64c0638ab3422b434b02a037116b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530c64c0638ab3422b434b02a037116b">&#9670;&nbsp;</a></span>init_flush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_pool_t::init_flush[<a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73cab382ac3a7501526d7a81edcf0925be47">BUF_FLUSH_N_TYPES</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this is TRUE when a flush of the given type is being initialized. </p>
<p>Protected by flush_state_mutex. </p>

</div>
</div>
<a id="ac7264f647475c1a97e2aa54210750563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7264f647475c1a97e2aa54210750563">&#9670;&nbsp;</a></span>instance_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::instance_no</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array index of this buffer pool instance. </p>

</div>
</div>
<a id="a355670cec77c64853441e307472e660a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355670cec77c64853441e307472e660a">&#9670;&nbsp;</a></span>last_printout_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ut0ut_8h.html#a3d7efb6a0ff993a01dd08a7fa914056a">ib_time_monotonic_t</a> buf_pool_t::last_printout_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>when buf_print_io was last time called. </p>
<p>Accesses not protected. </p>

</div>
</div>
<a id="a37cb8d5f5c4dd23c8717943daa751a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cb8d5f5c4dd23c8717943daa751a7b">&#9670;&nbsp;</a></span>lru_hp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLRUHp.html">LRUHp</a> buf_pool_t::lru_hp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"hazard pointer" used during scan of LRU while doing LRU list batch. </p>
<p>Protected by buf_pool::LRU_list_mutex </p>

</div>
</div>
<a id="a9db1ee56155c14ea2870bc74b3443d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db1ee56155c14ea2870bc74b3443d9b">&#9670;&nbsp;</a></span>LRU_list_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a> buf_pool_t::LRU_list_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LRU list mutex. </p>

</div>
</div>
<a id="a7f98404f9e6016d7c78bafbb01d89657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f98404f9e6016d7c78bafbb01d89657">&#9670;&nbsp;</a></span>LRU_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_pool_t::LRU_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to the about LRU_old_ratio/BUF_LRU_OLD_RATIO_DIV oldest blocks in the LRU list; NULL if LRU length less than BUF_LRU_OLD_MIN_LEN; NOTE: when LRU_old != NULL, its length should always equal LRU_old_len </p>

</div>
</div>
<a id="ac8a49e54a5249cf5cef9c55c3221241f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a49e54a5249cf5cef9c55c3221241f">&#9670;&nbsp;</a></span>LRU_old_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::LRU_old_len</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>length of the LRU list from the block to which LRU_old points onward, including that block; see buf0lru.cc for the restrictions on this value; 0 if LRU_old == NULL; NOTE: LRU_old_len must be adjusted whenever LRU_old shrinks or grows! </p>

</div>
</div>
<a id="a5517fb979475c6b799d10dd7b294094a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5517fb979475c6b799d10dd7b294094a">&#9670;&nbsp;</a></span>LRU_old_ratio</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::LRU_old_ratio</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve this much of the buffer pool for "old" blocks. </p>

</div>
</div>
<a id="a755a098537ebd743d59aab402cece965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755a098537ebd743d59aab402cece965">&#9670;&nbsp;</a></span>lru_scan_itr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLRUItr.html">LRUItr</a> buf_pool_t::lru_scan_itr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator used to scan the LRU list when searching for replacable victim. </p>
<p>Protected by buf_pool::LRU_list_mutex. </p>

</div>
</div>
<a id="adbd2d13b530b284242790ee3b1c1f639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd2d13b530b284242790ee3b1c1f639">&#9670;&nbsp;</a></span>max_lsn_io</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_pool_t::max_lsn_io</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6656602570ef2b8d7f060a90daee9b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6656602570ef2b8d7f060a90daee9b9e">&#9670;&nbsp;</a></span>n_chunks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ulint buf_pool_t::n_chunks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of buffer pool chunks </p>

</div>
</div>
<a id="aef956328cfbb74ebd474074aafc7175a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef956328cfbb74ebd474074aafc7175a">&#9670;&nbsp;</a></span>n_chunks_new</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ulint buf_pool_t::n_chunks_new</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>new number of buffer pool chunks </p>

</div>
</div>
<a id="a9c8672d592d9f8260163a32461eba1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8672d592d9f8260163a32461eba1f8">&#9670;&nbsp;</a></span>n_flush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::n_flush[<a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73cab382ac3a7501526d7a81edcf0925be47">BUF_FLUSH_N_TYPES</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this is the number of pending writes in the given flush type. </p>
<p>Protected by flush_state_mutex. </p>

</div>
</div>
<a id="ab46d7942520722ff424b9f39d711ec68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46d7942520722ff424b9f39d711ec68">&#9670;&nbsp;</a></span>n_pend_reads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::n_pend_reads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of pending read operations. </p>
<p>Accessed atomically </p>

</div>
</div>
<a id="a44bf877482c603a94dd03de812a0a3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bf877482c603a94dd03de812a0a3fb">&#9670;&nbsp;</a></span>n_pend_unzip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::n_pend_unzip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of pending decompressions. </p>
<p>Accessed atomically. </p>

</div>
</div>
<a id="aa41261b7d8bccfb6771b679c58648d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41261b7d8bccfb6771b679c58648d6d">&#9670;&nbsp;</a></span>no_flush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> buf_pool_t::no_flush[<a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73cab382ac3a7501526d7a81edcf0925be47">BUF_FLUSH_N_TYPES</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this is in the set state when there is no flush batch of the given type running. </p>
<p>Protected by flush_state_mutex. </p>

</div>
</div>
<a id="a7a47af710b9f9e7af5354de5b23fba7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a47af710b9f9e7af5354de5b23fba7a">&#9670;&nbsp;</a></span>old_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::old_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>previous pool size in pages </p>

</div>
</div>
<a id="a1d825ac141e650cd211452c45e3f394f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d825ac141e650cd211452c45e3f394f">&#9670;&nbsp;</a></span>old_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> buf_pool_t::old_stat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>old statistics </p>

</div>
</div>
<a id="a7d4334d6ec9729a43095755d6f445443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4334d6ec9729a43095755d6f445443">&#9670;&nbsp;</a></span>oldest_hp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFlushHp.html">FlushHp</a> buf_pool_t::oldest_hp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>entry pointer to scan the oldest page except for system temporary </p>

</div>
</div>
<a id="aa02ce633a1ca3d49d78df3d2ea3c9472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02ce633a1ca3d49d78df3d2ea3c9472">&#9670;&nbsp;</a></span>page_hash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhash__table__t.html">hash_table_t</a>* buf_pool_t::page_hash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hash table of buf_page_t or buf_block_t file pages, buf_page_in_file() == TRUE, indexed by (space_id, offset). </p>
<p>page_hash is protected by an array of mutexes. </p>

</div>
</div>
<a id="af5af0004d4b47625984d89f02bdc132f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5af0004d4b47625984d89f02bdc132f">&#9670;&nbsp;</a></span>page_hash_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhash__table__t.html">hash_table_t</a>* buf_pool_t::page_hash_old</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>old pointer to page_hash to be freed after resizing buffer pool </p>

</div>
</div>
<a id="ab27b834468362ae6517566bc23d4db12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27b834468362ae6517566bc23d4db12">&#9670;&nbsp;</a></span>read_ahead_area</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> buf_pool_t::read_ahead_area</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size in pages of the area which the read-ahead algorithms read if invoked </p>

</div>
</div>
<a id="a1bdae3322515ebcad8439bcf0bbac9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdae3322515ebcad8439bcf0bbac9dd">&#9670;&nbsp;</a></span>single_scan_itr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLRUItr.html">LRUItr</a> buf_pool_t::single_scan_itr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator used to scan the LRU list when searching for single page flushing victim. </p>
<p>Protected by buf_pool::LRU_list_mutex. </p>

</div>
</div>
<a id="aa6b6ff232ef55a6ccfedd3b5ec94bc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b6ff232ef55a6ccfedd3b5ec94bc6d">&#9670;&nbsp;</a></span>stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> buf_pool_t::stat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>current statistics </p>

</div>
</div>
<a id="a61ec626b6766fbf8dd21843c46a9e702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ec626b6766fbf8dd21843c46a9e702">&#9670;&nbsp;</a></span>track_page_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> buf_pool_t::track_page_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accaedf5345e73786752c837141f44b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaedf5345e73786752c837141f44b6f">&#9670;&nbsp;</a></span>try_LRU_scan</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_pool_t::try_LRU_scan</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set to FALSE when an LRU scan for free block fails. </p>
<p>This flag is used to avoid repeated scans of LRU list when we know that there is no free block available in the scan depth for eviction. Set to TRUE whenever we flush a batch from the buffer pool. Accessed protected by memory barriers. </p>

</div>
</div>
<a id="a85b353f8c15266560701a4e4577c4940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b353f8c15266560701a4e4577c4940">&#9670;&nbsp;</a></span>watch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbuf__page__t.html">buf_page_t</a>* buf_pool_t::watch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sentinel records for buffer pool watches. </p>
<p>Scanning the array is protected by taking all page_hash latches in X. Updating or reading an individual watch page is protected by a corresponding individual page_hash latch. </p>

</div>
</div>
<a id="aa359723790414b5ba219540c76ac91cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa359723790414b5ba219540c76ac91cd">&#9670;&nbsp;</a></span>withdraw_target</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_t::withdraw_target</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>target length of withdraw block list, when withdrawing </p>

</div>
</div>
<a id="a6291c0c70a786c113c2d7c7bfe6afbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6291c0c70a786c113c2d7c7bfe6afbb9">&#9670;&nbsp;</a></span>zip_free_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a> buf_pool_t::zip_free_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buddy allocator mutex </p>

</div>
</div>
<a id="a10a16d528a553e5e4f8e11820402d9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a16d528a553e5e4f8e11820402d9db">&#9670;&nbsp;</a></span>zip_hash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhash__table__t.html">hash_table_t</a>* buf_pool_t::zip_hash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hash table of buf_block_t blocks whose frames are allocated to the zip buddy system, indexed by block-&gt;frame </p>

</div>
</div>
<a id="af82b0a923041e5ddad344c8f1d177c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82b0a923041e5ddad344c8f1d177c14">&#9670;&nbsp;</a></span>zip_hash_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a728aa61522bdb760bd9bd2914513a36c">BufListMutex</a> buf_pool_t::zip_hash_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zip_hash mutex </p>

</div>
</div>
<a id="ae663da445248d1af7f38b75dddd4ff9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae663da445248d1af7f38b75dddd4ff9b">&#9670;&nbsp;</a></span>zip_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0types_8h.html#a12e6e65b485343049745e6ec5d7513c6">BufPoolZipMutex</a> buf_pool_t::zip_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zip mutex of this buffer pool instance, protects compressed only pages (of type buf_page_t, not buf_block_t. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>storage/innobase/include/<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a></li>
<li>storage/innobase/buf/<a class="el" href="buf0buf_8cc.html">buf0buf.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
