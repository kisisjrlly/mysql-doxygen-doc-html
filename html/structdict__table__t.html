<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: dict_table_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structdict__table__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structdict__table__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dict_table_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data structure for a database table.  
 <a href="structdict__table__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7fae6cef3d665457b58a0faff4279f30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a7fae6cef3d665457b58a0faff4279f30">is_compressed</a> () const</td></tr>
<tr class="memdesc:a7fae6cef3d665457b58a0faff4279f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the table is compressed.  <a href="#a7fae6cef3d665457b58a0faff4279f30">More...</a><br /></td></tr>
<tr class="separator:a7fae6cef3d665457b58a0faff4279f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dd2ee137e3fa90e9b566b0f454fec8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ad3dd2ee137e3fa90e9b566b0f454fec8">get_ref_count</a> () const</td></tr>
<tr class="memdesc:ad3dd2ee137e3fa90e9b566b0f454fec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference count.  <a href="#ad3dd2ee137e3fa90e9b566b0f454fec8">More...</a><br /></td></tr>
<tr class="separator:ad3dd2ee137e3fa90e9b566b0f454fec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6eed6b6945fb05503b75b68f8d0786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5c6eed6b6945fb05503b75b68f8d0786">acquire</a> ()</td></tr>
<tr class="memdesc:a5c6eed6b6945fb05503b75b68f8d0786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the table handle.  <a href="#a5c6eed6b6945fb05503b75b68f8d0786">More...</a><br /></td></tr>
<tr class="separator:a5c6eed6b6945fb05503b75b68f8d0786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e540428610d66a5fe72cedad6623128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6e540428610d66a5fe72cedad6623128">acquire_with_lock</a> ()</td></tr>
<tr class="memdesc:a6e540428610d66a5fe72cedad6623128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the table handle, with lock() and unlock() the table.  <a href="#a6e540428610d66a5fe72cedad6623128">More...</a><br /></td></tr>
<tr class="separator:a6e540428610d66a5fe72cedad6623128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8ad836fdb0a3a96680924d3dd2497d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a7f8ad836fdb0a3a96680924d3dd2497d">release</a> ()</td></tr>
<tr class="memdesc:a7f8ad836fdb0a3a96680924d3dd2497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the table handle.  <a href="#a7f8ad836fdb0a3a96680924d3dd2497d">More...</a><br /></td></tr>
<tr class="separator:a7f8ad836fdb0a3a96680924d3dd2497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47118143cd6d22ccee12d18861f70915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a47118143cd6d22ccee12d18861f70915">lock</a> ()</td></tr>
<tr class="memdesc:a47118143cd6d22ccee12d18861f70915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the table handle.  <a href="#a47118143cd6d22ccee12d18861f70915">More...</a><br /></td></tr>
<tr class="separator:a47118143cd6d22ccee12d18861f70915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a44213d144410d2720a777df71c2f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a1a44213d144410d2720a777df71c2f25">unlock</a> ()</td></tr>
<tr class="memdesc:a1a44213d144410d2720a777df71c2f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the table handle.  <a href="#a1a44213d144410d2720a777df71c2f25">More...</a><br /></td></tr>
<tr class="separator:a1a44213d144410d2720a777df71c2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdc13336db5bd8dbb409a3dfeabe86c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a2cdc13336db5bd8dbb409a3dfeabe86c">get_table_name</a> (std::string &amp;schema, std::string &amp;table)</td></tr>
<tr class="memdesc:a2cdc13336db5bd8dbb409a3dfeabe86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get schema and table name in system character set.  <a href="#a2cdc13336db5bd8dbb409a3dfeabe86c">More...</a><br /></td></tr>
<tr class="separator:a2cdc13336db5bd8dbb409a3dfeabe86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db4b878402c1953674932acd1b8df48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5db4b878402c1953674932acd1b8df48">UT_LIST_BASE_NODE_T</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a>) indexes</td></tr>
<tr class="memdesc:a5db4b878402c1953674932acd1b8df48"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of indexes of the table.  <a href="#a5db4b878402c1953674932acd1b8df48">More...</a><br /></td></tr>
<tr class="separator:a5db4b878402c1953674932acd1b8df48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8089c9339b60883976e93c2b66bdca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aab8089c9339b60883976e93c2b66bdca">UT_LIST_BASE_NODE_T</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a>) foreign_list</td></tr>
<tr class="memdesc:aab8089c9339b60883976e93c2b66bdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of foreign key constraints in the table.  <a href="#aab8089c9339b60883976e93c2b66bdca">More...</a><br /></td></tr>
<tr class="separator:aab8089c9339b60883976e93c2b66bdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b1b47d4685c1d7bac1663083af39b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#af5b1b47d4685c1d7bac1663083af39b1">UT_LIST_BASE_NODE_T</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a>) referenced_list</td></tr>
<tr class="memdesc:af5b1b47d4685c1d7bac1663083af39b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of foreign key constraints which refer to this table.  <a href="#af5b1b47d4685c1d7bac1663083af39b1">More...</a><br /></td></tr>
<tr class="separator:af5b1b47d4685c1d7bac1663083af39b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65384443f4c7eb48945f1432eff479e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a65384443f4c7eb48945f1432eff479e0">UT_LIST_NODE_T</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a>) table_LRU</td></tr>
<tr class="memdesc:a65384443f4c7eb48945f1432eff479e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node of the LRU list of tables.  <a href="#a65384443f4c7eb48945f1432eff479e0">More...</a><br /></td></tr>
<tr class="separator:a65384443f4c7eb48945f1432eff479e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c0c833841c15f26d4362d0015729a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#af3c0c833841c15f26d4362d0015729a0">UT_LIST_NODE_T</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a>) dirty_dict_tables</td></tr>
<tr class="memdesc:af3c0c833841c15f26d4362d0015729a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node of the dirty table list of tables, which is protected by dict_persist-&gt;mutex.  <a href="#af3c0c833841c15f26d4362d0015729a0">More...</a><br /></td></tr>
<tr class="separator:af3c0c833841c15f26d4362d0015729a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d1ea6c70cef5d079029d5873a02329"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a83d1ea6c70cef5d079029d5873a02329">first_index</a> () const</td></tr>
<tr class="separator:a83d1ea6c70cef5d079029d5873a02329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ff6caadb6a28de29ba0c7848be8ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a47ff6caadb6a28de29ba0c7848be8ab3">first_index</a> ()</td></tr>
<tr class="separator:a47ff6caadb6a28de29ba0c7848be8ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a3ce8e91b345e7aeb9072b276c93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a012a3ce8e91b345e7aeb9072b276c93e">has_instant_cols</a> () const</td></tr>
<tr class="separator:a012a3ce8e91b345e7aeb9072b276c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4077eb0b002cc2971d5170c841acad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5e4077eb0b002cc2971d5170c841acad">set_instant_cols</a> (uint16_t instant_cols)</td></tr>
<tr class="memdesc:a5e4077eb0b002cc2971d5170c841acad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of columns when the first instant ADD COLUMN happens.  <a href="#a5e4077eb0b002cc2971d5170c841acad">More...</a><br /></td></tr>
<tr class="separator:a5e4077eb0b002cc2971d5170c841acad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d56fc7a298a3c469cfbdd809421295b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5d56fc7a298a3c469cfbdd809421295b">get_instant_cols</a> () const</td></tr>
<tr class="memdesc:a5d56fc7a298a3c469cfbdd809421295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of user columns when the first instant ADD COLUMN happens.  <a href="#a5d56fc7a298a3c469cfbdd809421295b">More...</a><br /></td></tr>
<tr class="separator:a5d56fc7a298a3c469cfbdd809421295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac720f15929eaac1290f869675c13ce6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac720f15929eaac1290f869675c13ce6d">is_corrupted</a> () const</td></tr>
<tr class="memdesc:ac720f15929eaac1290f869675c13ce6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the table is corrupted.  <a href="#ac720f15929eaac1290f869675c13ce6d">More...</a><br /></td></tr>
<tr class="separator:ac720f15929eaac1290f869675c13ce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb1538f4407a5e64218c2b211124c15"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aadb1538f4407a5e64218c2b211124c15">get_col_name</a> (ulint col_nr) const</td></tr>
<tr class="memdesc:aadb1538f4407a5e64218c2b211124c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a column's name.  <a href="#aadb1538f4407a5e64218c2b211124c15">More...</a><br /></td></tr>
<tr class="separator:aadb1538f4407a5e64218c2b211124c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4591e242684f2cc60121358297ab78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a7c4591e242684f2cc60121358297ab78">get_col</a> (ulint <a class="el" href="do__ctype_8cc.html#ab5ad9aa3d3e725ca44ebfa85e0b1020d">pos</a>) const</td></tr>
<tr class="memdesc:a7c4591e242684f2cc60121358297ab78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the nth column of a table.  <a href="#a7c4591e242684f2cc60121358297ab78">More...</a><br /></td></tr>
<tr class="separator:a7c4591e242684f2cc60121358297ab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9624b6907baa4ea7eddb831ab3f0f6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6d9624b6907baa4ea7eddb831ab3f0f6">get_n_user_cols</a> () const</td></tr>
<tr class="memdesc:a6d9624b6907baa4ea7eddb831ab3f0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of user-defined non-virtual columns in a table in the dictionary cache.  <a href="#a6d9624b6907baa4ea7eddb831ab3f0f6">More...</a><br /></td></tr>
<tr class="separator:a6d9624b6907baa4ea7eddb831ab3f0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa024ed331ac0360e3ead3f8d0e5bccaa"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aa024ed331ac0360e3ead3f8d0e5bccaa">get_n_sys_cols</a> () const</td></tr>
<tr class="memdesc:aa024ed331ac0360e3ead3f8d0e5bccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of system columns in a table.  <a href="#aa024ed331ac0360e3ead3f8d0e5bccaa">More...</a><br /></td></tr>
<tr class="separator:aa024ed331ac0360e3ead3f8d0e5bccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace43b41aa24c576d29bd7fb6be865d78"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ace43b41aa24c576d29bd7fb6be865d78">get_n_cols</a> () const</td></tr>
<tr class="memdesc:ace43b41aa24c576d29bd7fb6be865d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all non-virtual columns (also system) in a table in the dictionary cache.  <a href="#ace43b41aa24c576d29bd7fb6be865d78">More...</a><br /></td></tr>
<tr class="separator:ace43b41aa24c576d29bd7fb6be865d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c23469ddef333ab91ff7e4d94163019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a3c23469ddef333ab91ff7e4d94163019">get_sys_col</a> (ulint sys) const</td></tr>
<tr class="memdesc:a3c23469ddef333ab91ff7e4d94163019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the given system column of a table.  <a href="#a3c23469ddef333ab91ff7e4d94163019">More...</a><br /></td></tr>
<tr class="separator:a3c23469ddef333ab91ff7e4d94163019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be12caaa6257be683edbde32b3ec105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6be12caaa6257be683edbde32b3ec105">is_temporary</a> () const</td></tr>
<tr class="memdesc:a6be12caaa6257be683edbde32b3ec105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this is a temporary table.  <a href="#a6be12caaa6257be683edbde32b3ec105">More...</a><br /></td></tr>
<tr class="separator:a6be12caaa6257be683edbde32b3ec105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fb5a7b94b3ad4e9185e35ada151760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae7fb5a7b94b3ad4e9185e35ada151760">is_fts_aux</a> () const</td></tr>
<tr class="memdesc:ae7fb5a7b94b3ad4e9185e35ada151760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this is a FTS AUX table.  <a href="#ae7fb5a7b94b3ad4e9185e35ada151760">More...</a><br /></td></tr>
<tr class="separator:ae7fb5a7b94b3ad4e9185e35ada151760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270b6c1a9126ef6f5e9d64aa8949ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab270b6c1a9126ef6f5e9d64aa8949ef1">is_intrinsic</a> () const</td></tr>
<tr class="memdesc:ab270b6c1a9126ef6f5e9d64aa8949ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the table is intrinsic.  <a href="#ab270b6c1a9126ef6f5e9d64aa8949ef1">More...</a><br /></td></tr>
<tr class="separator:ab270b6c1a9126ef6f5e9d64aa8949ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268ad18627e85ca3ad890f0fae17ef48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a268ad18627e85ca3ad890f0fae17ef48">skip_gap_locks</a> () const</td></tr>
<tr class="separator:a268ad18627e85ca3ad890f0fae17ef48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad35e5c3d98883db45848c9c9192d32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a8ad35e5c3d98883db45848c9c9192d32">support_instant_add</a> () const</td></tr>
<tr class="memdesc:a8ad35e5c3d98883db45848c9c9192d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the table can support instant ADD COLUMN.  <a href="#a8ad35e5c3d98883db45848c9c9192d32">More...</a><br /></td></tr>
<tr class="separator:a8ad35e5c3d98883db45848c9c9192d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7863c8bab208050457665aa97d470247"><td class="memItemLeft" align="right" valign="top">ib_mutex_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a7863c8bab208050457665aa97d470247">mutex</a></td></tr>
<tr class="memdesc:a7863c8bab208050457665aa97d470247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex of the table for concurrency access.  <a href="#a7863c8bab208050457665aa97d470247">More...</a><br /></td></tr>
<tr class="separator:a7863c8bab208050457665aa97d470247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603c7502bc92f7a6161f5743f13d7750"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a603c7502bc92f7a6161f5743f13d7750">mutex_created</a></td></tr>
<tr class="memdesc:a603c7502bc92f7a6161f5743f13d7750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation state of mutex.  <a href="#a603c7502bc92f7a6161f5743f13d7750">More...</a><br /></td></tr>
<tr class="separator:a603c7502bc92f7a6161f5743f13d7750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd834c4e02a708c2c0516b5243ad481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5fd834c4e02a708c2c0516b5243ad481">id</a></td></tr>
<tr class="memdesc:a5fd834c4e02a708c2c0516b5243ad481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Id of the table.  <a href="#a5fd834c4e02a708c2c0516b5243ad481">More...</a><br /></td></tr>
<tr class="separator:a5fd834c4e02a708c2c0516b5243ad481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd49eb87685c3c33dd7ac2251848fb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#abd49eb87685c3c33dd7ac2251848fb2e">heap</a></td></tr>
<tr class="memdesc:abd49eb87685c3c33dd7ac2251848fb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory heap.  <a href="#abd49eb87685c3c33dd7ac2251848fb2e">More...</a><br /></td></tr>
<tr class="separator:abd49eb87685c3c33dd7ac2251848fb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1271c5134aeb93444303e935dde5c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtable__name__t.html">table_name_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ad1271c5134aeb93444303e935dde5c25">name</a></td></tr>
<tr class="memdesc:ad1271c5134aeb93444303e935dde5c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table name.  <a href="#ad1271c5134aeb93444303e935dde5c25">More...</a><br /></td></tr>
<tr class="separator:ad1271c5134aeb93444303e935dde5c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5d31d5f9e4158df1bfda60d89f933b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtable__name__t.html">table_name_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#abe5d31d5f9e4158df1bfda60d89f933b">trunc_name</a></td></tr>
<tr class="memdesc:abe5d31d5f9e4158df1bfda60d89f933b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate name.  <a href="#abe5d31d5f9e4158df1bfda60d89f933b">More...</a><br /></td></tr>
<tr class="separator:abe5d31d5f9e4158df1bfda60d89f933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad316c99317dc28b413182a6d12a88479"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ad316c99317dc28b413182a6d12a88479">data_dir_path</a></td></tr>
<tr class="memdesc:ad316c99317dc28b413182a6d12a88479"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL or the directory path specified by DATA DIRECTORY.  <a href="#ad316c99317dc28b413182a6d12a88479">More...</a><br /></td></tr>
<tr class="separator:ad316c99317dc28b413182a6d12a88479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e118d211e2893e5d976d02ce8767617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classid__name__t.html">id_name_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a2e118d211e2893e5d976d02ce8767617">tablespace</a></td></tr>
<tr class="memdesc:a2e118d211e2893e5d976d02ce8767617"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL or the tablespace name that this table is assigned to, specified by the TABLESPACE option.  <a href="#a2e118d211e2893e5d976d02ce8767617">More...</a><br /></td></tr>
<tr class="separator:a2e118d211e2893e5d976d02ce8767617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8c0d3d32bf0a1dbbbb09aec606f4d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aff8c0d3d32bf0a1dbbbb09aec606f4d0">space</a></td></tr>
<tr class="memdesc:aff8c0d3d32bf0a1dbbbb09aec606f4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space where the clustered index of the table is placed.  <a href="#aff8c0d3d32bf0a1dbbbb09aec606f4d0">More...</a><br /></td></tr>
<tr class="separator:aff8c0d3d32bf0a1dbbbb09aec606f4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70709b5119abaed72e0df37cd13f3a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedd.html#a0b4cee5d24960e48c74e25ae29222757">dd::Object_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a70709b5119abaed72e0df37cd13f3a96">dd_space_id</a></td></tr>
<tr class="memdesc:a70709b5119abaed72e0df37cd13f3a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">dd::Tablespace::id of the table  <a href="#a70709b5119abaed72e0df37cd13f3a96">More...</a><br /></td></tr>
<tr class="separator:a70709b5119abaed72e0df37cd13f3a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e3d4308f670a6b42c3e2039eeed3d8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a51e3d4308f670a6b42c3e2039eeed3d8">flags</a>: <a class="el" href="dict0mem_8h.html#a7dfce6a229c11744deab0809f06fe142">DICT_TF_BITS</a></td></tr>
<tr class="memdesc:a51e3d4308f670a6b42c3e2039eeed3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information about: 1 row format (redundant or compact), 2 compressed page size (zip shift size), 3 whether using atomic blobs, 4 whether the table has been created with the option DATA DIRECTORY.  <a href="#a51e3d4308f670a6b42c3e2039eeed3d8">More...</a><br /></td></tr>
<tr class="separator:a51e3d4308f670a6b42c3e2039eeed3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4598e387bf8d852ef6a7170b15bccc66"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a4598e387bf8d852ef6a7170b15bccc66">flags2</a>: <a class="el" href="dict0mem_8h.html#ab3c09638ef2265f7b22a6d3ca30a3b35">DICT_TF2_BITS</a></td></tr>
<tr class="memdesc:a4598e387bf8d852ef6a7170b15bccc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores information about: 1 whether the table has been created using CREATE TEMPORARY TABLE, 2 whether the table has an internally defined DOC ID column, 3 whether the table has a FTS index, 4 whether DOC ID column need to be added to the FTS index, 5 whether the table is being created its own tablespace, 6 whether the table has been DISCARDed, 7 whether the aux FTS tables names are in hex.  <a href="#a4598e387bf8d852ef6a7170b15bccc66">More...</a><br /></td></tr>
<tr class="separator:a4598e387bf8d852ef6a7170b15bccc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3506803b3cb038e78f302ac4ff051f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a3e3506803b3cb038e78f302ac4ff051f">skip_alter_undo</a>: 1</td></tr>
<tr class="memdesc:a3e3506803b3cb038e78f302ac4ff051f"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if the table is an intermediate table during copy alter operation or a partition/subpartition which is required for copying data and skip the undo log for insertion of row in the table.  <a href="#a3e3506803b3cb038e78f302ac4ff051f">More...</a><br /></td></tr>
<tr class="separator:a3e3506803b3cb038e78f302ac4ff051f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb8d0391a3a1ce361b564556b82d9b5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a2eb8d0391a3a1ce361b564556b82d9b5">ibd_file_missing</a>: 1</td></tr>
<tr class="memdesc:a2eb8d0391a3a1ce361b564556b82d9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if this is in a single-table tablespace and the .ibd file is missing.  <a href="#a2eb8d0391a3a1ce361b564556b82d9b5">More...</a><br /></td></tr>
<tr class="separator:a2eb8d0391a3a1ce361b564556b82d9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c76cfb5862fab3192148ae97c00cc1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a67c76cfb5862fab3192148ae97c00cc1">cached</a>: 1</td></tr>
<tr class="memdesc:a67c76cfb5862fab3192148ae97c00cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if the table object has been added to the dictionary cache.  <a href="#a67c76cfb5862fab3192148ae97c00cc1">More...</a><br /></td></tr>
<tr class="separator:a67c76cfb5862fab3192148ae97c00cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e878692b99a4ea16060ec25144ffa9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a28e878692b99a4ea16060ec25144ffa9">to_be_dropped</a>: 1</td></tr>
<tr class="memdesc:a28e878692b99a4ea16060ec25144ffa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if the table is to be dropped, but not yet actually dropped (could in the background drop list).  <a href="#a28e878692b99a4ea16060ec25144ffa9">More...</a><br /></td></tr>
<tr class="separator:a28e878692b99a4ea16060ec25144ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92082952a3b52c39fd37d2315f1a5cff"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a92082952a3b52c39fd37d2315f1a5cff">n_def</a>: 10</td></tr>
<tr class="memdesc:a92082952a3b52c39fd37d2315f1a5cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of non-virtual columns defined so far.  <a href="#a92082952a3b52c39fd37d2315f1a5cff">More...</a><br /></td></tr>
<tr class="separator:a92082952a3b52c39fd37d2315f1a5cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0c150acb6968737452a440e41ec0c9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a0f0c150acb6968737452a440e41ec0c9">n_cols</a>: 10</td></tr>
<tr class="memdesc:a0f0c150acb6968737452a440e41ec0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of non-virtual columns.  <a href="#a0f0c150acb6968737452a440e41ec0c9">More...</a><br /></td></tr>
<tr class="separator:a0f0c150acb6968737452a440e41ec0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a6c53a6c68399c8fcf014b2c8b7736"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a35a6c53a6c68399c8fcf014b2c8b7736">n_instant_cols</a>: 10</td></tr>
<tr class="memdesc:a35a6c53a6c68399c8fcf014b2c8b7736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of non-virtual columns before first instant ADD COLUMN, including the system columns like n_cols.  <a href="#a35a6c53a6c68399c8fcf014b2c8b7736">More...</a><br /></td></tr>
<tr class="separator:a35a6c53a6c68399c8fcf014b2c8b7736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749d98fb11cb06be07862352c5a3cef5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a749d98fb11cb06be07862352c5a3cef5">n_t_cols</a>: 10</td></tr>
<tr class="memdesc:a749d98fb11cb06be07862352c5a3cef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of total columns (inlcude virtual and non-virtual)  <a href="#a749d98fb11cb06be07862352c5a3cef5">More...</a><br /></td></tr>
<tr class="separator:a749d98fb11cb06be07862352c5a3cef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df5ccb8b0bcfb343baa60e6f8165fc7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a4df5ccb8b0bcfb343baa60e6f8165fc7">n_t_def</a>: 10</td></tr>
<tr class="memdesc:a4df5ccb8b0bcfb343baa60e6f8165fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of total columns defined so far.  <a href="#a4df5ccb8b0bcfb343baa60e6f8165fc7">More...</a><br /></td></tr>
<tr class="separator:a4df5ccb8b0bcfb343baa60e6f8165fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36239163e4353d5a595638496807bacf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a36239163e4353d5a595638496807bacf">n_v_def</a>: 10</td></tr>
<tr class="memdesc:a36239163e4353d5a595638496807bacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of virtual columns defined so far.  <a href="#a36239163e4353d5a595638496807bacf">More...</a><br /></td></tr>
<tr class="separator:a36239163e4353d5a595638496807bacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac349d7f0adf087a2fccb3a414aa8f1a5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac349d7f0adf087a2fccb3a414aa8f1a5">n_v_cols</a>: 10</td></tr>
<tr class="memdesc:ac349d7f0adf087a2fccb3a414aa8f1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of virtual columns.  <a href="#ac349d7f0adf087a2fccb3a414aa8f1a5">More...</a><br /></td></tr>
<tr class="separator:ac349d7f0adf087a2fccb3a414aa8f1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733a1101f418e78a844d7fe04f8fd5fe"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a733a1101f418e78a844d7fe04f8fd5fe">n_m_v_cols</a>: 10</td></tr>
<tr class="memdesc:a733a1101f418e78a844d7fe04f8fd5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of multi-value virtual columns.  <a href="#a733a1101f418e78a844d7fe04f8fd5fe">More...</a><br /></td></tr>
<tr class="separator:a733a1101f418e78a844d7fe04f8fd5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6996f2920d98097205131aad80bb0e1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac6996f2920d98097205131aad80bb0e1">can_be_evicted</a>: 1</td></tr>
<tr class="memdesc:ac6996f2920d98097205131aad80bb0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if this table is expected to be kept in memory.  <a href="#ac6996f2920d98097205131aad80bb0e1">More...</a><br /></td></tr>
<tr class="separator:ac6996f2920d98097205131aad80bb0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc879a4fbd4aeb1ee23f6fb3bcae79c2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#afc879a4fbd4aeb1ee23f6fb3bcae79c2">ddl_not_evictable</a>: 1</td></tr>
<tr class="memdesc:afc879a4fbd4aeb1ee23f6fb3bcae79c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if this table is not evictable(can_be_evicted) and this is because of DDL operation.  <a href="#afc879a4fbd4aeb1ee23f6fb3bcae79c2">More...</a><br /></td></tr>
<tr class="separator:afc879a4fbd4aeb1ee23f6fb3bcae79c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1f35ed4e92acbe220d5e64480e4233"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a1d1f35ed4e92acbe220d5e64480e4233">drop_aborted</a>: 1</td></tr>
<tr class="memdesc:a1d1f35ed4e92acbe220d5e64480e4233"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if some indexes should be dropped after ONLINE_INDEX_ABORTED or ONLINE_INDEX_ABORTED_DROPPED.  <a href="#a1d1f35ed4e92acbe220d5e64480e4233">More...</a><br /></td></tr>
<tr class="separator:a1d1f35ed4e92acbe220d5e64480e4233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee2ac9c1d316d0169d04ca10a2683aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#afee2ac9c1d316d0169d04ca10a2683aa">cols</a></td></tr>
<tr class="memdesc:afee2ac9c1d316d0169d04ca10a2683aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of column descriptions.  <a href="#afee2ac9c1d316d0169d04ca10a2683aa">More...</a><br /></td></tr>
<tr class="separator:afee2ac9c1d316d0169d04ca10a2683aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab690679dafa5bd7e3bd2282163b5e704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__v__col__t.html">dict_v_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab690679dafa5bd7e3bd2282163b5e704">v_cols</a></td></tr>
<tr class="memdesc:ab690679dafa5bd7e3bd2282163b5e704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of virtual column descriptions.  <a href="#ab690679dafa5bd7e3bd2282163b5e704">More...</a><br /></td></tr>
<tr class="separator:ab690679dafa5bd7e3bd2282163b5e704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710a1ffe71306bc4f9b695c973edca01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0mem_8h.html#a8d67f9ff563ed3765b06f1d41b741721">dict_s_col_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a710a1ffe71306bc4f9b695c973edca01">s_cols</a></td></tr>
<tr class="memdesc:a710a1ffe71306bc4f9b695c973edca01"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of stored column descriptions.  <a href="#a710a1ffe71306bc4f9b695c973edca01">More...</a><br /></td></tr>
<tr class="separator:a710a1ffe71306bc4f9b695c973edca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebefe253630ad16e0e099122cfc1bd0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#acebefe253630ad16e0e099122cfc1bd0">col_names</a></td></tr>
<tr class="memdesc:acebefe253630ad16e0e099122cfc1bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column names packed in a character string "name1\0name2\0...nameN\0".  <a href="#acebefe253630ad16e0e099122cfc1bd0">More...</a><br /></td></tr>
<tr class="separator:acebefe253630ad16e0e099122cfc1bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add40e985ef13383678c00c267029a48d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#add40e985ef13383678c00c267029a48d">v_col_names</a></td></tr>
<tr class="memdesc:add40e985ef13383678c00c267029a48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual column names.  <a href="#add40e985ef13383678c00c267029a48d">More...</a><br /></td></tr>
<tr class="separator:add40e985ef13383678c00c267029a48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e91fdb4d7ac438867d9693670ea490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a41e91fdb4d7ac438867d9693670ea490">is_system_table</a></td></tr>
<tr class="memdesc:a41e91fdb4d7ac438867d9693670ea490"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the table belongs to a system database (mysql, information_schema or performance_schema)  <a href="#a41e91fdb4d7ac438867d9693670ea490">More...</a><br /></td></tr>
<tr class="separator:a41e91fdb4d7ac438867d9693670ea490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3202106cc628383de654064f001c0f38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__config_8h.html#a075025242584419523b6e4ee84de9e22">hash_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a3202106cc628383de654064f001c0f38">name_hash</a></td></tr>
<tr class="memdesc:a3202106cc628383de654064f001c0f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash chain node.  <a href="#a3202106cc628383de654064f001c0f38">More...</a><br /></td></tr>
<tr class="separator:a3202106cc628383de654064f001c0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a7a02c5ba461ff2bfd39e4aeeeddb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__config_8h.html#a075025242584419523b6e4ee84de9e22">hash_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae0a7a02c5ba461ff2bfd39e4aeeeddb1">id_hash</a></td></tr>
<tr class="memdesc:ae0a7a02c5ba461ff2bfd39e4aeeeddb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash chain node.  <a href="#ae0a7a02c5ba461ff2bfd39e4aeeeddb1">More...</a><br /></td></tr>
<tr class="separator:ae0a7a02c5ba461ff2bfd39e4aeeeddb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5eec797c3104204a560c1565e0231a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#abd5eec797c3104204a560c1565e0231a">fts_doc_id_index</a></td></tr>
<tr class="memdesc:abd5eec797c3104204a560c1565e0231a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The FTS_DOC_ID_INDEX, or NULL if no fulltext indexes exist.  <a href="#abd5eec797c3104204a560c1565e0231a">More...</a><br /></td></tr>
<tr class="separator:abd5eec797c3104204a560c1565e0231a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7052ca1bb96650c5c0ce9508822a9a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a2d7052ca1bb96650c5c0ce9508822a9a">version</a></td></tr>
<tr class="memdesc:a2d7052ca1bb96650c5c0ce9508822a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">metadata version number of dd::Table::se_private_data()  <a href="#a2d7052ca1bb96650c5c0ce9508822a9a">More...</a><br /></td></tr>
<tr class="separator:a2d7052ca1bb96650c5c0ce9508822a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f81fdcdee342e16ab191a94b055bd3f"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="dict0mem_8h.html#a23454b1ae0661bc41f300c6868af56a7">table_dirty_status</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5f81fdcdee342e16ab191a94b055bd3f">dirty_status</a></td></tr>
<tr class="memdesc:a5f81fdcdee342e16ab191a94b055bd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">table dynamic metadata status, protected by dict_persist-&gt;mutex  <a href="#a5f81fdcdee342e16ab191a94b055bd3f">More...</a><br /></td></tr>
<tr class="separator:a5f81fdcdee342e16ab191a94b055bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37a7e5500f47b5352598faf3e74df71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac37a7e5500f47b5352598faf3e74df71">in_dirty_dict_tables_list</a></td></tr>
<tr class="memdesc:ac37a7e5500f47b5352598faf3e74df71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This field is used to mark if a table is in the dirty_dict_tables_list.  <a href="#ac37a7e5500f47b5352598faf3e74df71">More...</a><br /></td></tr>
<tr class="separator:ac37a7e5500f47b5352598faf3e74df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e532a77039adb3889bb5b091311076"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a98e532a77039adb3889bb5b091311076">fk_max_recusive_level</a>: 8</td></tr>
<tr class="memdesc:a98e532a77039adb3889bb5b091311076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum recursive level we support when loading tables chained together with FK constraints.  <a href="#a98e532a77039adb3889bb5b091311076">More...</a><br /></td></tr>
<tr class="separator:a98e532a77039adb3889bb5b091311076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd457a2582a286c6c7a561ded93dff5"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a7bd457a2582a286c6c7a561ded93dff5">n_foreign_key_checks_running</a></td></tr>
<tr class="memdesc:a7bd457a2582a286c6c7a561ded93dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of how many foreign key check operations are currently being performed on the table.  <a href="#a7bd457a2582a286c6c7a561ded93dff5">More...</a><br /></td></tr>
<tr class="separator:a7bd457a2582a286c6c7a561ded93dff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef3c3974ae8ba1ab208ad3cefea8533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6ef3c3974ae8ba1ab208ad3cefea8533">def_trx_id</a></td></tr>
<tr class="memdesc:a6ef3c3974ae8ba1ab208ad3cefea8533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction id that last touched the table definition.  <a href="#a6ef3c3974ae8ba1ab208ad3cefea8533">More...</a><br /></td></tr>
<tr class="separator:a6ef3c3974ae8ba1ab208ad3cefea8533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21585f145969b36ff7f2830ebe94b2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0mem_8h.html#a3c991a3b3f7a81aa609d0d575e44f61a">dict_foreign_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a21585f145969b36ff7f2830ebe94b2b5">foreign_set</a></td></tr>
<tr class="memdesc:a21585f145969b36ff7f2830ebe94b2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set of foreign key constraints which refer to this table  <a href="#a21585f145969b36ff7f2830ebe94b2b5">More...</a><br /></td></tr>
<tr class="separator:a21585f145969b36ff7f2830ebe94b2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911bf67a965468e083cb116fd877d0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0mem_8h.html#a3c991a3b3f7a81aa609d0d575e44f61a">dict_foreign_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a911bf67a965468e083cb116fd877d0ac">referenced_set</a></td></tr>
<tr class="separator:a911bf67a965468e083cb116fd877d0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38380681b2a7f78b16c20a5ca7e3bb86"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a38380681b2a7f78b16c20a5ca7e3bb86">does_not_fit_in_memory</a></td></tr>
<tr class="memdesc:a38380681b2a7f78b16c20a5ca7e3bb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This field is used to specify in simulations tables which are so big that disk should be accessed.  <a href="#a38380681b2a7f78b16c20a5ca7e3bb86">More...</a><br /></td></tr>
<tr class="separator:a38380681b2a7f78b16c20a5ca7e3bb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a6ab68d71761df5e7f39b88ed0e359"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae0a6ab68d71761df5e7f39b88ed0e359">big_rows</a>: 1</td></tr>
<tr class="memdesc:ae0a6ab68d71761df5e7f39b88ed0e359"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if the maximum length of a single row exceeds BIG_ROW_SIZE.  <a href="#ae0a6ab68d71761df5e7f39b88ed0e359">More...</a><br /></td></tr>
<tr class="separator:ae0a6ab68d71761df5e7f39b88ed0e359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3098bfa56cedf99fd2f6f0e7105cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfts__t.html">fts_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aaf3098bfa56cedf99fd2f6f0e7105cd7">fts</a></td></tr>
<tr class="memdesc:aaf3098bfa56cedf99fd2f6f0e7105cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">FTS specific state variables.  <a href="#aaf3098bfa56cedf99fd2f6f0e7105cd7">More...</a><br /></td></tr>
<tr class="separator:aaf3098bfa56cedf99fd2f6f0e7105cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4794d93beeafa0e2128c226aacf83e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0types_8h.html#ac8fca69819417dbd51226e79c3b890d6">ib_quiesce_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a4794d93beeafa0e2128c226aacf83e80">quiesce</a></td></tr>
<tr class="memdesc:a4794d93beeafa0e2128c226aacf83e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quiescing states, protected by the dict_index_t::lock.  <a href="#a4794d93beeafa0e2128c226aacf83e80">More...</a><br /></td></tr>
<tr class="separator:a4794d93beeafa0e2128c226aacf83e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42001fcb0754dddb64d9c61c2b297bad"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a42001fcb0754dddb64d9c61c2b297bad">n_rec_locks</a></td></tr>
<tr class="memdesc:a42001fcb0754dddb64d9c61c2b297bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of record locks on this table.  <a href="#a42001fcb0754dddb64d9c61c2b297bad">More...</a><br /></td></tr>
<tr class="separator:a42001fcb0754dddb64d9c61c2b297bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19e2316ff889929234888a2124f779d"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac19e2316ff889929234888a2124f779d">n_ref_count</a></td></tr>
<tr class="memdesc:ac19e2316ff889929234888a2124f779d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of how many handles are opened to this table.  <a href="#ac19e2316ff889929234888a2124f779d">More...</a><br /></td></tr>
<tr class="separator:ac19e2316ff889929234888a2124f779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c803abc18b3e1a780f47d2be90af08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0mem_8h.html#a47e92c93f6a5c35342487951b263812d">table_lock_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a26c803abc18b3e1a780f47d2be90af08">locks</a></td></tr>
<tr class="memdesc:a26c803abc18b3e1a780f47d2be90af08"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of locks on the table.  <a href="#a26c803abc18b3e1a780f47d2be90af08">More...</a><br /></td></tr>
<tr class="separator:a26c803abc18b3e1a780f47d2be90af08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6552d1680e9f13d905358b50bc40a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab6552d1680e9f13d905358b50bc40a22">count_by_mode</a> [<a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013ad8224f2b5b02877451e509a5e0a2b9c2">LOCK_NUM</a>]</td></tr>
<tr class="memdesc:ab6552d1680e9f13d905358b50bc40a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">count_by_mode[M] = number of locks in this-&gt;locks with lock-&gt;type_mode&amp;LOCK_MODE_MASK == M.  <a href="#ab6552d1680e9f13d905358b50bc40a22">More...</a><br /></td></tr>
<tr class="separator:ab6552d1680e9f13d905358b50bc40a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35221a94b8a7395289845808c9e35ae"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae35221a94b8a7395289845808c9e35ae">update_time</a></td></tr>
<tr class="memdesc:ae35221a94b8a7395289845808c9e35ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp of the last modification of this table.  <a href="#ae35221a94b8a7395289845808c9e35ae">More...</a><br /></td></tr>
<tr class="separator:ae35221a94b8a7395289845808c9e35ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d90c2d5f6c548a1d9cf4ad6d9b3537c"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6d90c2d5f6c548a1d9cf4ad6d9b3537c">sess_row_id</a></td></tr>
<tr class="memdesc:a6d90c2d5f6c548a1d9cf4ad6d9b3537c"><td class="mdescLeft">&#160;</td><td class="mdescRight">row-id counter for use by intrinsic table for getting row-id.  <a href="#a6d90c2d5f6c548a1d9cf4ad6d9b3537c">More...</a><br /></td></tr>
<tr class="separator:a6d90c2d5f6c548a1d9cf4ad6d9b3537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cf4553166286319f5dde258666855f"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#af1cf4553166286319f5dde258666855f">sess_trx_id</a></td></tr>
<tr class="memdesc:af1cf4553166286319f5dde258666855f"><td class="mdescLeft">&#160;</td><td class="mdescRight">trx_id counter for use by intrinsic table for getting trx-id.  <a href="#af1cf4553166286319f5dde258666855f">More...</a><br /></td></tr>
<tr class="separator:af1cf4553166286319f5dde258666855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c502fc8dc35dd0390a0db72b7cb0ef"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a20c502fc8dc35dd0390a0db72b7cb0ef">magic_n</a></td></tr>
<tr class="memdesc:a20c502fc8dc35dd0390a0db72b7cb0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number.  <a href="#a20c502fc8dc35dd0390a0db72b7cb0ef">More...</a><br /></td></tr>
<tr class="separator:a20c502fc8dc35dd0390a0db72b7cb0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a06dd1c35d029c6a79a94d20e2aaea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__vcol__templ__t.html">dict_vcol_templ_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a0a06dd1c35d029c6a79a94d20e2aaea1">vc_templ</a></td></tr>
<tr class="memdesc:a0a06dd1c35d029c6a79a94d20e2aaea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">mysql_row_templ_t for base columns used for compute the virtual columns  <a href="#a0a06dd1c35d029c6a79a94d20e2aaea1">More...</a><br /></td></tr>
<tr class="separator:a0a06dd1c35d029c6a79a94d20e2aaea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa219399abf43fb0045af8f711216e71f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aa219399abf43fb0045af8f711216e71f">encryption_key</a></td></tr>
<tr class="memdesc:aa219399abf43fb0045af8f711216e71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">encryption key, it's only for export/import  <a href="#aa219399abf43fb0045af8f711216e71f">More...</a><br /></td></tr>
<tr class="separator:aa219399abf43fb0045af8f711216e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc9e01907081efc52e36ee4a02ba9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#accc9e01907081efc52e36ee4a02ba9ea">encryption_iv</a></td></tr>
<tr class="memdesc:accc9e01907081efc52e36ee4a02ba9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">encryption iv, it's only for export/import  <a href="#accc9e01907081efc52e36ee4a02ba9ea">More...</a><br /></td></tr>
<tr class="separator:accc9e01907081efc52e36ee4a02ba9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6b8070fe45da56bf9569e5b1646af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6c6b8070fe45da56bf9569e5b1646af2">discard_after_ddl</a></td></tr>
<tr class="memdesc:a6c6b8070fe45da56bf9569e5b1646af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the dict_table_t from cache after DDL operation  <a href="#a6c6b8070fe45da56bf9569e5b1646af2">More...</a><br /></td></tr>
<tr class="separator:a6c6b8070fe45da56bf9569e5b1646af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05569ad95afed2ce0b920ed36feb532e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a05569ad95afed2ce0b920ed36feb532e">refresh_fk</a></td></tr>
<tr class="memdesc:a05569ad95afed2ce0b920ed36feb532e"><td class="mdescLeft">&#160;</td><td class="mdescRight">refresh/reload FK info  <a href="#a05569ad95afed2ce0b920ed36feb532e">More...</a><br /></td></tr>
<tr class="separator:a05569ad95afed2ce0b920ed36feb532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77b74efd6eabc494d44015389cd3ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0mem_8h.html#a4c2cb9c434c31481aef29ec1b4549423">temp_prebuilt_vec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab77b74efd6eabc494d44015389cd3ece">temp_prebuilt</a></td></tr>
<tr class="memdesc:ab77b74efd6eabc494d44015389cd3ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiple cursors can be active on this temporary table  <a href="#ab77b74efd6eabc494d44015389cd3ece">More...</a><br /></td></tr>
<tr class="separator:ab77b74efd6eabc494d44015389cd3ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffae77e0f09a1505a84cb9d44980d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aeffae77e0f09a1505a84cb9d44980d65">is_dd_table</a></td></tr>
<tr class="memdesc:aeffae77e0f09a1505a84cb9d44980d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE only for dictionary tables like mysql/tables, mysql/columns, mysql/tablespaces, etc.  <a href="#aeffae77e0f09a1505a84cb9d44980d65">More...</a><br /></td></tr>
<tr class="separator:aeffae77e0f09a1505a84cb9d44980d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411e506afbfa49474983b2bd2f35388b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a411e506afbfa49474983b2bd2f35388b">explicitly_non_lru</a></td></tr>
<tr class="memdesc:a411e506afbfa49474983b2bd2f35388b"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if this table is explicitly put to non-LRU list during table creation  <a href="#a411e506afbfa49474983b2bd2f35388b">More...</a><br /></td></tr>
<tr class="separator:a411e506afbfa49474983b2bd2f35388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1faacbf3c7842c55b651facf2f53b713"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a1faacbf3c7842c55b651facf2f53b713">stats_latch_created</a></td></tr>
<tr class="memdesc:a1faacbf3c7842c55b651facf2f53b713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for query optimization.  <a href="#a1faacbf3c7842c55b651facf2f53b713">More...</a><br /></td></tr>
<tr class="separator:a1faacbf3c7842c55b651facf2f53b713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f177330ff4f45c3ec6d088472c5bbe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a0f177330ff4f45c3ec6d088472c5bbe4">stats_latch</a></td></tr>
<tr class="memdesc:a0f177330ff4f45c3ec6d088472c5bbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This latch protects: "dict_table_t::stat_initialized", "dict_table_t::stat_n_rows (*)", "dict_table_t::stat_clustered_index_size", "dict_table_t::stat_sum_of_other_index_sizes", "dict_table_t::stat_modified_counter (*)", "dict_table_t::indexes*::stat_n_diff_key_vals[]", "dict_table_t::indexes*::stat_index_size", "dict_table_t::indexes*::stat_n_leaf_pages".  <a href="#a0f177330ff4f45c3ec6d088472c5bbe4">More...</a><br /></td></tr>
<tr class="separator:a0f177330ff4f45c3ec6d088472c5bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8110ba21eb149e06437aaeb9e9c6e8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#abe8110ba21eb149e06437aaeb9e9c6e8">stat_initialized</a>: 1</td></tr>
<tr class="memdesc:abe8110ba21eb149e06437aaeb9e9c6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if statistics have been calculated the first time after database startup or table creation.  <a href="#abe8110ba21eb149e06437aaeb9e9c6e8">More...</a><br /></td></tr>
<tr class="separator:abe8110ba21eb149e06437aaeb9e9c6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712998bd1733e44639d2d159e6389b95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ut0ut_8h.html#a3d7efb6a0ff993a01dd08a7fa914056a">ib_time_monotonic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a712998bd1733e44639d2d159e6389b95">stats_last_recalc</a></td></tr>
<tr class="memdesc:a712998bd1733e44639d2d159e6389b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp of last recalc of the stats.  <a href="#a712998bd1733e44639d2d159e6389b95">More...</a><br /></td></tr>
<tr class="separator:a712998bd1733e44639d2d159e6389b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70d5e79cd1985a0284bdd4eae19ef7d"><td class="memItemLeft" align="right" valign="top">ib_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab70d5e79cd1985a0284bdd4eae19ef7d">stat_persistent</a></td></tr>
<tr class="memdesc:ab70d5e79cd1985a0284bdd4eae19ef7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the table uses persistent stats or not.  <a href="#ab70d5e79cd1985a0284bdd4eae19ef7d">More...</a><br /></td></tr>
<tr class="separator:ab70d5e79cd1985a0284bdd4eae19ef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab966a60dfd3c2074ec7798a61bc099aa"><td class="memItemLeft" align="right" valign="top">ib_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab966a60dfd3c2074ec7798a61bc099aa">stats_auto_recalc</a></td></tr>
<tr class="memdesc:ab966a60dfd3c2074ec7798a61bc099aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the table uses automatic recalc for persistent stats or not.  <a href="#ab966a60dfd3c2074ec7798a61bc099aa">More...</a><br /></td></tr>
<tr class="separator:ab966a60dfd3c2074ec7798a61bc099aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2a489fd543ade2d791a10a1c5da519"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a3a2a489fd543ade2d791a10a1c5da519">stats_sample_pages</a></td></tr>
<tr class="memdesc:a3a2a489fd543ade2d791a10a1c5da519"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of pages to sample for this table during persistent stats estimation.  <a href="#a3a2a489fd543ade2d791a10a1c5da519">More...</a><br /></td></tr>
<tr class="separator:a3a2a489fd543ade2d791a10a1c5da519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345a3524ef7ec47e9756bf8b0eceb8e9"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a345a3524ef7ec47e9756bf8b0eceb8e9">stat_n_rows</a></td></tr>
<tr class="memdesc:a345a3524ef7ec47e9756bf8b0eceb8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate number of rows in the table.  <a href="#a345a3524ef7ec47e9756bf8b0eceb8e9">More...</a><br /></td></tr>
<tr class="separator:a345a3524ef7ec47e9756bf8b0eceb8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e379354a0d53b2db7534d713b4af85"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a13e379354a0d53b2db7534d713b4af85">stat_clustered_index_size</a></td></tr>
<tr class="memdesc:a13e379354a0d53b2db7534d713b4af85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate clustered index size in database pages.  <a href="#a13e379354a0d53b2db7534d713b4af85">More...</a><br /></td></tr>
<tr class="separator:a13e379354a0d53b2db7534d713b4af85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bf5dd1d0b7a8c7cf3c6763a4ab3145"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a80bf5dd1d0b7a8c7cf3c6763a4ab3145">stat_sum_of_other_index_sizes</a></td></tr>
<tr class="memdesc:a80bf5dd1d0b7a8c7cf3c6763a4ab3145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate size of other indexes in database pages.  <a href="#a80bf5dd1d0b7a8c7cf3c6763a4ab3145">More...</a><br /></td></tr>
<tr class="separator:a80bf5dd1d0b7a8c7cf3c6763a4ab3145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b82e02e0b476ccf0cf71bbf2ec87004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a7b82e02e0b476ccf0cf71bbf2ec87004">parent_id</a></td></tr>
<tr class="memdesc:a7b82e02e0b476ccf0cf71bbf2ec87004"><td class="mdescLeft">&#160;</td><td class="mdescRight">If FTS AUX table, parent table id.  <a href="#a7b82e02e0b476ccf0cf71bbf2ec87004">More...</a><br /></td></tr>
<tr class="separator:a7b82e02e0b476ccf0cf71bbf2ec87004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992be3582ca0a42d73288245101b9679"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a992be3582ca0a42d73288245101b9679">stat_modified_counter</a></td></tr>
<tr class="memdesc:a992be3582ca0a42d73288245101b9679"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many rows are modified since last stats recalc.  <a href="#a992be3582ca0a42d73288245101b9679">More...</a><br /></td></tr>
<tr class="separator:a992be3582ca0a42d73288245101b9679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b54dbe0d80817647fd6bed40d6f420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac0b54dbe0d80817647fd6bed40d6f420">stats_bg_flag</a></td></tr>
<tr class="memdesc:ac0b54dbe0d80817647fd6bed40d6f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of the background stats thread wrt this table.  <a href="#ac0b54dbe0d80817647fd6bed40d6f420">More...</a><br /></td></tr>
<tr class="separator:ac0b54dbe0d80817647fd6bed40d6f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad4bc107da72f1c794c349d12cfea62c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ad4bc107da72f1c794c349d12cfea62c4">autoinc_lock</a></td></tr>
<tr class="memdesc:ad4bc107da72f1c794c349d12cfea62c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTOINC related members.  <a href="#ad4bc107da72f1c794c349d12cfea62c4">More...</a><br /></td></tr>
<tr class="separator:ad4bc107da72f1c794c349d12cfea62c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc9eca688908d401b842857fcf98247"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a9bc9eca688908d401b842857fcf98247">autoinc_mutex_created</a></td></tr>
<tr class="memdesc:a9bc9eca688908d401b842857fcf98247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation state of autoinc_mutex member.  <a href="#a9bc9eca688908d401b842857fcf98247">More...</a><br /></td></tr>
<tr class="separator:a9bc9eca688908d401b842857fcf98247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab493efbfa4d01db7b72621ddaf7f3a5f"><td class="memItemLeft" align="right" valign="top">ib_mutex_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab493efbfa4d01db7b72621ddaf7f3a5f">autoinc_mutex</a></td></tr>
<tr class="memdesc:ab493efbfa4d01db7b72621ddaf7f3a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex protecting the autoincrement counter.  <a href="#ab493efbfa4d01db7b72621ddaf7f3a5f">More...</a><br /></td></tr>
<tr class="separator:ab493efbfa4d01db7b72621ddaf7f3a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6519de514e3ea5fe14635d647f7caaa"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae6519de514e3ea5fe14635d647f7caaa">autoinc</a></td></tr>
<tr class="memdesc:ae6519de514e3ea5fe14635d647f7caaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Autoinc counter value to give to the next inserted row.  <a href="#ae6519de514e3ea5fe14635d647f7caaa">More...</a><br /></td></tr>
<tr class="separator:ae6519de514e3ea5fe14635d647f7caaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93e35ad7c888b0589ee41c637c0b2d9"><td class="memItemLeft" align="right" valign="top">ib_mutex_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#af93e35ad7c888b0589ee41c637c0b2d9">autoinc_persisted_mutex</a></td></tr>
<tr class="memdesc:af93e35ad7c888b0589ee41c637c0b2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex protecting the persisted autoincrement counter.  <a href="#af93e35ad7c888b0589ee41c637c0b2d9">More...</a><br /></td></tr>
<tr class="separator:af93e35ad7c888b0589ee41c637c0b2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e64fe1615e3c893d78d7d4933d3445"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a66e64fe1615e3c893d78d7d4933d3445">autoinc_persisted</a></td></tr>
<tr class="memdesc:a66e64fe1615e3c893d78d7d4933d3445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Autoinc counter value that has been persisted in redo logs or DDTableBuffer.  <a href="#a66e64fe1615e3c893d78d7d4933d3445">More...</a><br /></td></tr>
<tr class="separator:a66e64fe1615e3c893d78d7d4933d3445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520fe6b5422998ea00338d42e81ca323"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a520fe6b5422998ea00338d42e81ca323">autoinc_field_no</a></td></tr>
<tr class="memdesc:a520fe6b5422998ea00338d42e81ca323"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position of autoinc counter field in clustered index.  <a href="#a520fe6b5422998ea00338d42e81ca323">More...</a><br /></td></tr>
<tr class="separator:a520fe6b5422998ea00338d42e81ca323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d8b0f963c131ab424fa81953e3f8d"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; const <a class="el" href="structtrx__t.html">trx_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a129d8b0f963c131ab424fa81953e3f8d">autoinc_trx</a></td></tr>
<tr class="memdesc:a129d8b0f963c131ab424fa81953e3f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transaction that currently holds the the AUTOINC lock on this table.  <a href="#a129d8b0f963c131ab424fa81953e3f8d">More...</a><br /></td></tr>
<tr class="separator:a129d8b0f963c131ab424fa81953e3f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data structure for a database table. </p>
<p>Most fields will be initialized to 0, NULL or FALSE in dict_mem_table_create(). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5c6eed6b6945fb05503b75b68f8d0786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6eed6b6945fb05503b75b68f8d0786">&#9670;&nbsp;</a></span>acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_t::acquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the table handle. </p>

</div>
</div>
<a id="a6e540428610d66a5fe72cedad6623128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e540428610d66a5fe72cedad6623128">&#9670;&nbsp;</a></span>acquire_with_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_t::acquire_with_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the table handle, with lock() and unlock() the table. </p>
<p>This function needs to be called for opening table when the table is in memory and later the stats information would be initialized </p>

</div>
</div>
<a id="a83d1ea6c70cef5d079029d5873a02329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d1ea6c70cef5d079029d5873a02329">&#9670;&nbsp;</a></span>first_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_t::first_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the clustered index </dd></dl>

</div>
</div>
<a id="a47ff6caadb6a28de29ba0c7848be8ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ff6caadb6a28de29ba0c7848be8ab3">&#9670;&nbsp;</a></span>first_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_t::first_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the clustered index </dd></dl>

</div>
</div>
<a id="a7c4591e242684f2cc60121358297ab78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4591e242684f2cc60121358297ab78">&#9670;&nbsp;</a></span>get_col()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__col__t.html">dict_col_t</a>* dict_table_t::get_col </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the nth column of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>position of column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to column object </dd></dl>

</div>
</div>
<a id="aadb1538f4407a5e64218c2b211124c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb1538f4407a5e64218c2b211124c15">&#9670;&nbsp;</a></span>get_col_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_table_t::get_col_name </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_nr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a column's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col_nr</td><td>column number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column name. NOTE: not guaranteed to stay valid if table is modified in any way (columns added, etc.). </dd></dl>

</div>
</div>
<a id="a5d56fc7a298a3c469cfbdd809421295b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d56fc7a298a3c469cfbdd809421295b">&#9670;&nbsp;</a></span>get_instant_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t dict_table_t::get_instant_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of user columns when the first instant ADD COLUMN happens. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of user columns as described above </dd></dl>

</div>
</div>
<a id="ace43b41aa24c576d29bd7fb6be865d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace43b41aa24c576d29bd7fb6be865d78">&#9670;&nbsp;</a></span>get_n_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::get_n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all non-virtual columns (also system) in a table in the dictionary cache. </p>
<dl class="section return"><dt>Returns</dt><dd>number of non-virtual columns of a table </dd></dl>

</div>
</div>
<a id="aa024ed331ac0360e3ead3f8d0e5bccaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa024ed331ac0360e3ead3f8d0e5bccaa">&#9670;&nbsp;</a></span>get_n_sys_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t dict_table_t::get_n_sys_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of system columns in a table. </p>
<p>For intrinsic table on ROW_ID column is added for all other tables TRX_ID and ROLL_PTR are all also appeneded. </p><dl class="section return"><dt>Returns</dt><dd>number of system (e.g., ROW_ID) columns of a table </dd></dl>

</div>
</div>
<a id="a6d9624b6907baa4ea7eddb831ab3f0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9624b6907baa4ea7eddb831ab3f0f6">&#9670;&nbsp;</a></span>get_n_user_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t dict_table_t::get_n_user_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of user-defined non-virtual columns in a table in the dictionary cache. </p>
<dl class="section return"><dt>Returns</dt><dd>number of user-defined (e.g., not ROW_ID) non-virtual columns of a table </dd></dl>

</div>
</div>
<a id="ad3dd2ee137e3fa90e9b566b0f454fec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dd2ee137e3fa90e9b566b0f454fec8">&#9670;&nbsp;</a></span>get_ref_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t dict_table_t::get_ref_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference count. </p>
<dl class="section return"><dt>Returns</dt><dd>current value of n_ref_count </dd></dl>

</div>
</div>
<a id="a3c23469ddef333ab91ff7e4d94163019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c23469ddef333ab91ff7e4d94163019">&#9670;&nbsp;</a></span>get_sys_col()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__col__t.html">dict_col_t</a>* dict_table_t::get_sys_col </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>sys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the given system column of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys</td><td>DATA_ROW_ID, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to column object </dd></dl>

</div>
</div>
<a id="a2cdc13336db5bd8dbb409a3dfeabe86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdc13336db5bd8dbb409a3dfeabe86c">&#9670;&nbsp;</a></span>get_table_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_t::get_table_name </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get schema and table name in system character set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">schema</td><td>schema name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">table</td><td>table name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012a3ce8e91b345e7aeb9072b276c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012a3ce8e91b345e7aeb9072b276c93e">&#9670;&nbsp;</a></span>has_instant_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::has_instant_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if there was any instantly added column. This will be true after one or more instant ADD COLUMN, however, it would become false after ALTER TABLE which rebuilds or copies the old table. If this is true, all instantly added columns should have default values, and records in the table may have REC_INFO_INSTANT_FLAG set. </dd></dl>

</div>
</div>
<a id="a7fae6cef3d665457b58a0faff4279f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fae6cef3d665457b58a0faff4279f30">&#9670;&nbsp;</a></span>is_compressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the table is compressed. </p>
<dl class="section return"><dt>Returns</dt><dd>true if compressed, false otherwise. </dd></dl>

</div>
</div>
<a id="ac720f15929eaac1290f869675c13ce6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac720f15929eaac1290f869675c13ce6d">&#9670;&nbsp;</a></span>is_corrupted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::is_corrupted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the table is corrupted. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the table is corrupted, otherwise false </dd></dl>

</div>
</div>
<a id="ae7fb5a7b94b3ad4e9185e35ada151760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fb5a7b94b3ad4e9185e35ada151760">&#9670;&nbsp;</a></span>is_fts_aux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::is_fts_aux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if this is a FTS AUX table. </p>

</div>
</div>
<a id="ab270b6c1a9126ef6f5e9d64aa8949ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab270b6c1a9126ef6f5e9d64aa8949ef1">&#9670;&nbsp;</a></span>is_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::is_intrinsic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the table is intrinsic. </p>
<p>An intrinsic table is a special kind of temporary table that is invisible to the end user. It can be created internally by InnoDB, the MySQL server layer or other modules connected to InnoDB in order to gather and use data as part of a larger task. Since access to it must be as fast as possible, it does not need UNDO semantics, system fields DB_TRX_ID &amp; DB_ROLL_PTR, doublewrite, checksum, insert buffer, use of the shared data dictionary, locking, or even a transaction. In short, these are not ACID tables at all, just temporary data stored and manipulated during a larger process. </p>

</div>
</div>
<a id="a6be12caaa6257be683edbde32b3ec105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be12caaa6257be683edbde32b3ec105">&#9670;&nbsp;</a></span>is_temporary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::is_temporary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if this is a temporary table. </p>

</div>
</div>
<a id="a47118143cd6d22ccee12d18861f70915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47118143cd6d22ccee12d18861f70915">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_t::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the table handle. </p>

</div>
</div>
<a id="a7f8ad836fdb0a3a96680924d3dd2497d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8ad836fdb0a3a96680924d3dd2497d">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_t::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the table handle. </p>

</div>
</div>
<a id="a5e4077eb0b002cc2971d5170c841acad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4077eb0b002cc2971d5170c841acad">&#9670;&nbsp;</a></span>set_instant_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_t::set_instant_cols </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>instant_cols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of columns when the first instant ADD COLUMN happens. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instant_cols</td><td>number of fields when first instant ADD COLUMN happens, without system columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a268ad18627e85ca3ad890f0fae17ef48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268ad18627e85ca3ad890f0fae17ef48">&#9670;&nbsp;</a></span>skip_gap_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::skip_gap_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ad35e5c3d98883db45848c9c9192d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad35e5c3d98883db45848c9c9192d32">&#9670;&nbsp;</a></span>support_instant_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::support_instant_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the table can support instant ADD COLUMN. </p>

</div>
</div>
<a id="a1a44213d144410d2720a777df71c2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a44213d144410d2720a777df71c2f25">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_t::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock the table handle. </p>

</div>
</div>
<a id="a5db4b878402c1953674932acd1b8df48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db4b878402c1953674932acd1b8df48">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict_table_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of indexes of the table. </p>

</div>
</div>
<a id="aab8089c9339b60883976e93c2b66bdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8089c9339b60883976e93c2b66bdca">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict_table_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of foreign key constraints in the table. </p>
<p>These refer to columns in other tables. </p>

</div>
</div>
<a id="af5b1b47d4685c1d7bac1663083af39b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b1b47d4685c1d7bac1663083af39b1">&#9670;&nbsp;</a></span>UT_LIST_BASE_NODE_T() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict_table_t::UT_LIST_BASE_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of foreign key constraints which refer to this table. </p>

</div>
</div>
<a id="a65384443f4c7eb48945f1432eff479e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65384443f4c7eb48945f1432eff479e0">&#9670;&nbsp;</a></span>UT_LIST_NODE_T() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict_table_t::UT_LIST_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node of the LRU list of tables. </p>

</div>
</div>
<a id="af3c0c833841c15f26d4362d0015729a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c0c833841c15f26d4362d0015729a0">&#9670;&nbsp;</a></span>UT_LIST_NODE_T() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict_table_t::UT_LIST_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node of the dirty table list of tables, which is protected by dict_persist-&gt;mutex. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae6519de514e3ea5fe14635d647f7caaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6519de514e3ea5fe14635d647f7caaa">&#9670;&nbsp;</a></span>autoinc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::autoinc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Autoinc counter value to give to the next inserted row. </p>

</div>
</div>
<a id="a520fe6b5422998ea00338d42e81ca323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520fe6b5422998ea00338d42e81ca323">&#9670;&nbsp;</a></span>autoinc_field_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::autoinc_field_no</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The position of autoinc counter field in clustered index. </p>
<p>This would be set when CREATE/ALTER/OPEN TABLE and IMPORT TABLESPACE, and used in modifications to clustered index, such as INSERT/UPDATE. There should be no conflict to access it, so no protection is needed. </p>

</div>
</div>
<a id="ad4bc107da72f1c794c349d12cfea62c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bc107da72f1c794c349d12cfea62c4">&#9670;&nbsp;</a></span>autoinc_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__t.html">lock_t</a>* dict_table_t::autoinc_lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AUTOINC related members. </p>
<p>A buffer for an AUTOINC lock for this table. We allocate the memory here so that individual transactions can get it and release it without a need to allocate space from the lock heap of the trx: otherwise the lock heap would grow rapidly if we do a large insert from a select. </p>

</div>
</div>
<a id="ab493efbfa4d01db7b72621ddaf7f3a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab493efbfa4d01db7b72621ddaf7f3a5f">&#9670;&nbsp;</a></span>autoinc_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t* dict_table_t::autoinc_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex protecting the autoincrement counter. </p>

</div>
</div>
<a id="a9bc9eca688908d401b842857fcf98247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc9eca688908d401b842857fcf98247">&#9670;&nbsp;</a></span>autoinc_mutex_created</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a> dict_table_t::autoinc_mutex_created</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation state of autoinc_mutex member. </p>

</div>
</div>
<a id="a66e64fe1615e3c893d78d7d4933d3445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e64fe1615e3c893d78d7d4933d3445">&#9670;&nbsp;</a></span>autoinc_persisted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::autoinc_persisted</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Autoinc counter value that has been persisted in redo logs or DDTableBuffer. </p>
<p>It's mainly used when we want to write counter back to DDTableBuffer. This is different from the 'autoinc' above, which could be bigger than this one, because 'autoinc' will get updated right after some counters are allocated, but we will write the counter to redo logs and update this counter later. Once all allocated counters have been written to redo logs, 'autoinc' should be exact the next counter of this persisted one. We want this counter because when we need to write the counter back to DDTableBuffer, we had better keep it consistency with the counter that has been written to redo logs. Besides, we can't read the 'autoinc' directly easily, because the autoinc_lock is required and there could be a deadlock. This variable is protected by autoinc_persisted_mutex. </p>

</div>
</div>
<a id="af93e35ad7c888b0589ee41c637c0b2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93e35ad7c888b0589ee41c637c0b2d9">&#9670;&nbsp;</a></span>autoinc_persisted_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t* dict_table_t::autoinc_persisted_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex protecting the persisted autoincrement counter. </p>

</div>
</div>
<a id="a129d8b0f963c131ab424fa81953e3f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129d8b0f963c131ab424fa81953e3f8d">&#9670;&nbsp;</a></span>autoinc_trx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;const <a class="el" href="structtrx__t.html">trx_t</a> *&gt; dict_table_t::autoinc_trx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The transaction that currently holds the the AUTOINC lock on this table. </p>
<p>Protected by lock_sys table shard latch. To "peek" the current value one can read it without any latch, understanding that in general it may change. Such access pattern is correct if trx thread wants to check if it has the lock granted, as the field can only change to other value when lock is released, which can not happen concurrently to thread executing the trx. </p>

</div>
</div>
<a id="ae0a6ab68d71761df5e7f39b88ed0e359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a6ab68d71761df5e7f39b88ed0e359">&#9670;&nbsp;</a></span>big_rows</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::big_rows</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if the maximum length of a single row exceeds BIG_ROW_SIZE. </p>
<p>Initialized in dict_table_add_to_cache(). </p>

</div>
</div>
<a id="a67c76cfb5862fab3192148ae97c00cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c76cfb5862fab3192148ae97c00cc1">&#9670;&nbsp;</a></span>cached</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::cached</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if the table object has been added to the dictionary cache. </p>

</div>
</div>
<a id="ac6996f2920d98097205131aad80bb0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6996f2920d98097205131aad80bb0e1">&#9670;&nbsp;</a></span>can_be_evicted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::can_be_evicted</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if this table is expected to be kept in memory. </p>
<p>This table could be a table that has FK relationships or is undergoing DDL </p>

</div>
</div>
<a id="acebefe253630ad16e0e099122cfc1bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebefe253630ad16e0e099122cfc1bd0">&#9670;&nbsp;</a></span>col_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_table_t::col_names</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Column names packed in a character string "name1\0name2\0...nameN\0". </p>
<p>Until the string contains n_cols, it will be allocated from a temporary heap. The final string will be allocated from table-&gt;heap. </p>

</div>
</div>
<a id="afee2ac9c1d316d0169d04ca10a2683aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee2ac9c1d316d0169d04ca10a2683aa">&#9670;&nbsp;</a></span>cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__col__t.html">dict_col_t</a>* dict_table_t::cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of column descriptions. </p>

</div>
</div>
<a id="ab6552d1680e9f13d905358b50bc40a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6552d1680e9f13d905358b50bc40a22">&#9670;&nbsp;</a></span>count_by_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> dict_table_t::count_by_mode[<a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013ad8224f2b5b02877451e509a5e0a2b9c2">LOCK_NUM</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count_by_mode[M] = number of locks in this-&gt;locks with lock-&gt;type_mode&amp;LOCK_MODE_MASK == M. </p>
<p>Used to quickly verify that there are no LOCK_S or LOCK_X, which are the only modes incompatible with LOCK_IS and LOCK_IX, to avoid costly iteration over this-&gt;locks when adding LOCK_IS or LOCK_IX. We use count_by_mode[LOCK_AUTO_INC] to track the number of granted and pending autoinc locks on this table. This value is set after acquiring the lock_sys table shard latch, but we peek the contents to determine whether other transactions have acquired the AUTOINC lock or not. Of course only one transaction can be granted the lock but there can be multiple waiters. Protected by lock_sys table shard latch. </p>

</div>
</div>
<a id="ad316c99317dc28b413182a6d12a88479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad316c99317dc28b413182a6d12a88479">&#9670;&nbsp;</a></span>data_dir_path</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* dict_table_t::data_dir_path</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NULL or the directory path specified by DATA DIRECTORY. </p>

</div>
</div>
<a id="a70709b5119abaed72e0df37cd13f3a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70709b5119abaed72e0df37cd13f3a96">&#9670;&nbsp;</a></span>dd_space_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedd.html#a0b4cee5d24960e48c74e25ae29222757">dd::Object_id</a> dict_table_t::dd_space_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dd::Tablespace::id of the table </p>

</div>
</div>
<a id="afc879a4fbd4aeb1ee23f6fb3bcae79c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc879a4fbd4aeb1ee23f6fb3bcae79c2">&#9670;&nbsp;</a></span>ddl_not_evictable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::ddl_not_evictable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if this table is not evictable(can_be_evicted) and this is because of DDL operation. </p>

</div>
</div>
<a id="a6ef3c3974ae8ba1ab208ad3cefea8533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef3c3974ae8ba1ab208ad3cefea8533">&#9670;&nbsp;</a></span>def_trx_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> dict_table_t::def_trx_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transaction id that last touched the table definition. </p>
<p>Either when loading the definition or CREATE TABLE, or ALTER TABLE (prepare, commit, and rollback phases). set of foreign key constraints in the table; these refer to columns in other tables </p>

</div>
</div>
<a id="a5f81fdcdee342e16ab191a94b055bd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f81fdcdee342e16ab191a94b055bd3f">&#9670;&nbsp;</a></span>dirty_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="dict0mem_8h.html#a23454b1ae0661bc41f300c6868af56a7">table_dirty_status</a>&gt; dict_table_t::dirty_status</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>table dynamic metadata status, protected by dict_persist-&gt;mutex </p>

</div>
</div>
<a id="a6c6b8070fe45da56bf9569e5b1646af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6b8070fe45da56bf9569e5b1646af2">&#9670;&nbsp;</a></span>discard_after_ddl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::discard_after_ddl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove the dict_table_t from cache after DDL operation </p>

</div>
</div>
<a id="a38380681b2a7f78b16c20a5ca7e3bb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38380681b2a7f78b16c20a5ca7e3bb86">&#9670;&nbsp;</a></span>does_not_fit_in_memory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool dict_table_t::does_not_fit_in_memory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This field is used to specify in simulations tables which are so big that disk should be accessed. </p>
<p>Disk access is simulated by putting the thread to sleep for a while. NOTE that this flag is not stored to the data dictionary on disk, and the database will forget about value TRUE if it has to reload the table definition from disk. </p>

</div>
</div>
<a id="a1d1f35ed4e92acbe220d5e64480e4233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1f35ed4e92acbe220d5e64480e4233">&#9670;&nbsp;</a></span>drop_aborted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::drop_aborted</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if some indexes should be dropped after ONLINE_INDEX_ABORTED or ONLINE_INDEX_ABORTED_DROPPED. </p>

</div>
</div>
<a id="accc9e01907081efc52e36ee4a02ba9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc9e01907081efc52e36ee4a02ba9ea">&#9670;&nbsp;</a></span>encryption_iv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* dict_table_t::encryption_iv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>encryption iv, it's only for export/import </p>

</div>
</div>
<a id="aa219399abf43fb0045af8f711216e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa219399abf43fb0045af8f711216e71f">&#9670;&nbsp;</a></span>encryption_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* dict_table_t::encryption_key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>encryption key, it's only for export/import </p>

</div>
</div>
<a id="a411e506afbfa49474983b2bd2f35388b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411e506afbfa49474983b2bd2f35388b">&#9670;&nbsp;</a></span>explicitly_non_lru</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::explicitly_non_lru</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true if this table is explicitly put to non-LRU list during table creation </p>

</div>
</div>
<a id="a98e532a77039adb3889bb5b091311076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e532a77039adb3889bb5b091311076">&#9670;&nbsp;</a></span>fk_max_recusive_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::fk_max_recusive_level</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum recursive level we support when loading tables chained together with FK constraints. </p>
<p>If exceeds this level, we will stop loading child table into memory along with its parent table. </p>

</div>
</div>
<a id="a51e3d4308f670a6b42c3e2039eeed3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e3d4308f670a6b42c3e2039eeed3d8">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores information about: 1 row format (redundant or compact), 2 compressed page size (zip shift size), 3 whether using atomic blobs, 4 whether the table has been created with the option DATA DIRECTORY. </p>
<p>Use DICT_TF_GET_COMPACT(), DICT_TF_GET_ZIP_SSIZE(), DICT_TF_HAS_ATOMIC_BLOBS() and DICT_TF_HAS_DATA_DIR() to parse this flag. </p>

</div>
</div>
<a id="a4598e387bf8d852ef6a7170b15bccc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4598e387bf8d852ef6a7170b15bccc66">&#9670;&nbsp;</a></span>flags2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::flags2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores information about: 1 whether the table has been created using CREATE TEMPORARY TABLE, 2 whether the table has an internally defined DOC ID column, 3 whether the table has a FTS index, 4 whether DOC ID column need to be added to the FTS index, 5 whether the table is being created its own tablespace, 6 whether the table has been DISCARDed, 7 whether the aux FTS tables names are in hex. </p>
<p>8 whether the table is instinc table. 9 whether the table has encryption setting. Use DICT_TF2_FLAG_IS_SET() to parse this flag. </p>

</div>
</div>
<a id="a21585f145969b36ff7f2830ebe94b2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21585f145969b36ff7f2830ebe94b2b5">&#9670;&nbsp;</a></span>foreign_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0mem_8h.html#a3c991a3b3f7a81aa609d0d575e44f61a">dict_foreign_set</a> dict_table_t::foreign_set</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set of foreign key constraints which refer to this table </p>

</div>
</div>
<a id="aaf3098bfa56cedf99fd2f6f0e7105cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3098bfa56cedf99fd2f6f0e7105cd7">&#9670;&nbsp;</a></span>fts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfts__t.html">fts_t</a>* dict_table_t::fts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FTS specific state variables. </p>

</div>
</div>
<a id="abd5eec797c3104204a560c1565e0231a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5eec797c3104204a560c1565e0231a">&#9670;&nbsp;</a></span>fts_doc_id_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_t::fts_doc_id_index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The FTS_DOC_ID_INDEX, or NULL if no fulltext indexes exist. </p>

</div>
</div>
<a id="abd49eb87685c3c33dd7ac2251848fb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd49eb87685c3c33dd7ac2251848fb2e">&#9670;&nbsp;</a></span>heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a>* dict_table_t::heap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory heap. </p>
<p>If you allocate from this heap after the table has been created then be sure to account the allocation into dict_sys-&gt;size. When closing the table we do something like dict_sys-&gt;size -= mem_heap_get_size(table-&gt;heap) and if that is going to become negative then we would assert. Something like this should do: old_size = mem_heap_get_size() mem_heap_alloc() new_size = mem_heap_get_size() dict_sys-&gt;size += new_size - old_size. </p>

</div>
</div>
<a id="a2eb8d0391a3a1ce361b564556b82d9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb8d0391a3a1ce361b564556b82d9b5">&#9670;&nbsp;</a></span>ibd_file_missing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::ibd_file_missing</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if this is in a single-table tablespace and the .ibd file is missing. </p>
<p>Then we must return in ha_innodb.cc an error if the user tries to query such an orphaned table. </p>

</div>
</div>
<a id="a5fd834c4e02a708c2c0516b5243ad481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd834c4e02a708c2c0516b5243ad481">&#9670;&nbsp;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a> dict_table_t::id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Id of the table. </p>

</div>
</div>
<a id="ae0a7a02c5ba461ff2bfd39e4aeeeddb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a7a02c5ba461ff2bfd39e4aeeeddb1">&#9670;&nbsp;</a></span>id_hash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__config_8h.html#a075025242584419523b6e4ee84de9e22">hash_node_t</a> dict_table_t::id_hash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash chain node. </p>

</div>
</div>
<a id="ac37a7e5500f47b5352598faf3e74df71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37a7e5500f47b5352598faf3e74df71">&#9670;&nbsp;</a></span>in_dirty_dict_tables_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::in_dirty_dict_tables_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This field is used to mark if a table is in the dirty_dict_tables_list. </p>
<p>if the dirty_status is not of METADATA_CLEAN, the table should be in the list, otherwise not. This field should be protected by dict_persist-&gt;mutex too. </p>

</div>
</div>
<a id="aeffae77e0f09a1505a84cb9d44980d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffae77e0f09a1505a84cb9d44980d65">&#9670;&nbsp;</a></span>is_dd_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::is_dd_table</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE only for dictionary tables like mysql/tables, mysql/columns, mysql/tablespaces, etc. </p>
<p>This flag is used to do non-locking reads on DD tables. </p>

</div>
</div>
<a id="a41e91fdb4d7ac438867d9693670ea490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e91fdb4d7ac438867d9693670ea490">&#9670;&nbsp;</a></span>is_system_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::is_system_table</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the table belongs to a system database (mysql, information_schema or performance_schema) </p>

</div>
</div>
<a id="a26c803abc18b3e1a780f47d2be90af08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c803abc18b3e1a780f47d2be90af08">&#9670;&nbsp;</a></span>locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0mem_8h.html#a47e92c93f6a5c35342487951b263812d">table_lock_list_t</a> dict_table_t::locks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of locks on the table. </p>
<p>Protected by lock_sys shard latch. </p>

</div>
</div>
<a id="a20c502fc8dc35dd0390a0db72b7cb0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c502fc8dc35dd0390a0db72b7cb0ef">&#9670;&nbsp;</a></span>magic_n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::magic_n</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Magic number. </p>

</div>
</div>
<a id="a7863c8bab208050457665aa97d470247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7863c8bab208050457665aa97d470247">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t* dict_table_t::mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex of the table for concurrency access. </p>

</div>
</div>
<a id="a603c7502bc92f7a6161f5743f13d7750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603c7502bc92f7a6161f5743f13d7750">&#9670;&nbsp;</a></span>mutex_created</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a> dict_table_t::mutex_created</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation state of mutex. </p>

</div>
</div>
<a id="a0f0c150acb6968737452a440e41ec0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0c150acb6968737452a440e41ec0c9">&#9670;&nbsp;</a></span>n_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of non-virtual columns. </p>

</div>
</div>
<a id="a92082952a3b52c39fd37d2315f1a5cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92082952a3b52c39fd37d2315f1a5cff">&#9670;&nbsp;</a></span>n_def</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_def</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of non-virtual columns defined so far. </p>

</div>
</div>
<a id="a7bd457a2582a286c6c7a561ded93dff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd457a2582a286c6c7a561ded93dff5">&#9670;&nbsp;</a></span>n_foreign_key_checks_running</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::n_foreign_key_checks_running</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count of how many foreign key check operations are currently being performed on the table. </p>
<p>We cannot drop the table while there are foreign key checks running on it. </p>

</div>
</div>
<a id="a35a6c53a6c68399c8fcf014b2c8b7736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a6c53a6c68399c8fcf014b2c8b7736">&#9670;&nbsp;</a></span>n_instant_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_instant_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of non-virtual columns before first instant ADD COLUMN, including the system columns like n_cols. </p>

</div>
</div>
<a id="a733a1101f418e78a844d7fe04f8fd5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733a1101f418e78a844d7fe04f8fd5fe">&#9670;&nbsp;</a></span>n_m_v_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_m_v_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of multi-value virtual columns. </p>

</div>
</div>
<a id="a42001fcb0754dddb64d9c61c2b297bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42001fcb0754dddb64d9c61c2b297bad">&#9670;&nbsp;</a></span>n_rec_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;size_t&gt; dict_table_t::n_rec_locks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count of the number of record locks on this table. </p>
<p>We use this to determine whether we can evict the table from the dictionary cache. Writes (atomic increments and decrements) are performed when holding a shared latch on lock_sys. (Note that this the table's shard latch is NOT required, as this is field counts <em>record</em> locks, so a page shard is latched instead) Reads should be performed when holding exclusive lock_sys latch, however:</p><ul>
<li>Some places assert this field is zero without holding any latch.</li>
<li>Some places assert this field is positive holding only shared latch. </li>
</ul>

</div>
</div>
<a id="ac19e2316ff889929234888a2124f779d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19e2316ff889929234888a2124f779d">&#9670;&nbsp;</a></span>n_ref_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;uint64_t&gt; dict_table_t::n_ref_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count of how many handles are opened to this table. </p>
<p>Dropping of the table is NOT allowed until this count gets to zero. MySQL does NOT itself check the number of open handles at DROP. </p>

</div>
</div>
<a id="a749d98fb11cb06be07862352c5a3cef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749d98fb11cb06be07862352c5a3cef5">&#9670;&nbsp;</a></span>n_t_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_t_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of total columns (inlcude virtual and non-virtual) </p>

</div>
</div>
<a id="a4df5ccb8b0bcfb343baa60e6f8165fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df5ccb8b0bcfb343baa60e6f8165fc7">&#9670;&nbsp;</a></span>n_t_def</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_t_def</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of total columns defined so far. </p>

</div>
</div>
<a id="ac349d7f0adf087a2fccb3a414aa8f1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac349d7f0adf087a2fccb3a414aa8f1a5">&#9670;&nbsp;</a></span>n_v_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_v_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of virtual columns. </p>

</div>
</div>
<a id="a36239163e4353d5a595638496807bacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36239163e4353d5a595638496807bacf">&#9670;&nbsp;</a></span>n_v_def</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_v_def</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of virtual columns defined so far. </p>

</div>
</div>
<a id="ad1271c5134aeb93444303e935dde5c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1271c5134aeb93444303e935dde5c25">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtable__name__t.html">table_name_t</a> dict_table_t::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Table name. </p>

</div>
</div>
<a id="a3202106cc628383de654064f001c0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3202106cc628383de654064f001c0f38">&#9670;&nbsp;</a></span>name_hash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__config_8h.html#a075025242584419523b6e4ee84de9e22">hash_node_t</a> dict_table_t::name_hash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash chain node. </p>

</div>
</div>
<a id="a7b82e02e0b476ccf0cf71bbf2ec87004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b82e02e0b476ccf0cf71bbf2ec87004">&#9670;&nbsp;</a></span>parent_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a> dict_table_t::parent_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If FTS AUX table, parent table id. </p>

</div>
</div>
<a id="a4794d93beeafa0e2128c226aacf83e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4794d93beeafa0e2128c226aacf83e80">&#9670;&nbsp;</a></span>quiesce</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0types_8h.html#ac8fca69819417dbd51226e79c3b890d6">ib_quiesce_t</a> dict_table_t::quiesce</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quiescing states, protected by the dict_index_t::lock. </p>
<p>ie. we can only change the state if we acquire all the latches (dict_index_t::lock) in X mode of this table's indexes. </p>

</div>
</div>
<a id="a911bf67a965468e083cb116fd877d0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911bf67a965468e083cb116fd877d0ac">&#9670;&nbsp;</a></span>referenced_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0mem_8h.html#a3c991a3b3f7a81aa609d0d575e44f61a">dict_foreign_set</a> dict_table_t::referenced_set</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05569ad95afed2ce0b920ed36feb532e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05569ad95afed2ce0b920ed36feb532e">&#9670;&nbsp;</a></span>refresh_fk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> dict_table_t::refresh_fk</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>refresh/reload FK info </p>

</div>
</div>
<a id="a710a1ffe71306bc4f9b695c973edca01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710a1ffe71306bc4f9b695c973edca01">&#9670;&nbsp;</a></span>s_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0mem_8h.html#a8d67f9ff563ed3765b06f1d41b741721">dict_s_col_list</a>* dict_table_t::s_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of stored column descriptions. </p>
<p>It is used only for foreign key check during create table and copy alter operations. During copy alter, s_cols list is filled during create table operation and need to preserve till rename table operation. That is the reason s_cols is a part of dict_table_t </p>

</div>
</div>
<a id="a6d90c2d5f6c548a1d9cf4ad6d9b3537c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d90c2d5f6c548a1d9cf4ad6d9b3537c">&#9670;&nbsp;</a></span>sess_row_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::sess_row_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>row-id counter for use by intrinsic table for getting row-id. </p>
<p>Given intrinsic table semantics, row-id can be locally maintained instead of getting it from central generator which involves mutex locking. </p>

</div>
</div>
<a id="af1cf4553166286319f5dde258666855f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cf4553166286319f5dde258666855f">&#9670;&nbsp;</a></span>sess_trx_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::sess_trx_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>trx_id counter for use by intrinsic table for getting trx-id. </p>
<p>Intrinsic table are not shared so don't need a central trx-id but just need a increased counter to track consistent view while proceeding SELECT as part of UPDATE. </p>

</div>
</div>
<a id="a3e3506803b3cb038e78f302ac4ff051f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3506803b3cb038e78f302ac4ff051f">&#9670;&nbsp;</a></span>skip_alter_undo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::skip_alter_undo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if the table is an intermediate table during copy alter operation or a partition/subpartition which is required for copying data and skip the undo log for insertion of row in the table. </p>
<p>This variable will be set and unset during extra(), or during the process of altering partitions </p>

</div>
</div>
<a id="aff8c0d3d32bf0a1dbbbb09aec606f4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8c0d3d32bf0a1dbbbb09aec606f4d0">&#9670;&nbsp;</a></span>space</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> dict_table_t::space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Space where the clustered index of the table is placed. </p>

</div>
</div>
<a id="a13e379354a0d53b2db7534d713b4af85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e379354a0d53b2db7534d713b4af85">&#9670;&nbsp;</a></span>stat_clustered_index_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::stat_clustered_index_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximate clustered index size in database pages. </p>

</div>
</div>
<a id="abe8110ba21eb149e06437aaeb9e9c6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8110ba21eb149e06437aaeb9e9c6e8">&#9670;&nbsp;</a></span>stat_initialized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::stat_initialized</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if statistics have been calculated the first time after database startup or table creation. </p>

</div>
</div>
<a id="a992be3582ca0a42d73288245101b9679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992be3582ca0a42d73288245101b9679">&#9670;&nbsp;</a></span>stat_modified_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::stat_modified_counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many rows are modified since last stats recalc. </p>
<p>When a row is inserted, updated, or deleted, we add 1 to this number; we calculate new estimates for the table and the indexes if the table has changed too much, see row_update_statistics_if_needed(). The counter is reset to zero at statistics calculation. This counter is not protected by any latch, because this is only used for heuristics. </p>

</div>
</div>
<a id="a345a3524ef7ec47e9756bf8b0eceb8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345a3524ef7ec47e9756bf8b0eceb8e9">&#9670;&nbsp;</a></span>stat_n_rows</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::stat_n_rows</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximate number of rows in the table. </p>
<p>We periodically calculate new estimates. </p>

</div>
</div>
<a id="ab70d5e79cd1985a0284bdd4eae19ef7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70d5e79cd1985a0284bdd4eae19ef7d">&#9670;&nbsp;</a></span>stat_persistent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint32_t dict_table_t::stat_persistent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the table uses persistent stats or not. </p>
<p>See DICT_STATS_PERSISTENT_ON and DICT_STATS_PERSISTENT_OFF. </p>

</div>
</div>
<a id="a80bf5dd1d0b7a8c7cf3c6763a4ab3145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bf5dd1d0b7a8c7cf3c6763a4ab3145">&#9670;&nbsp;</a></span>stat_sum_of_other_index_sizes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::stat_sum_of_other_index_sizes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximate size of other indexes in database pages. </p>

</div>
</div>
<a id="ab966a60dfd3c2074ec7798a61bc099aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab966a60dfd3c2074ec7798a61bc099aa">&#9670;&nbsp;</a></span>stats_auto_recalc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint32_t dict_table_t::stats_auto_recalc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the table uses automatic recalc for persistent stats or not. </p>
<p>See DICT_STATS_AUTO_RECALC_ON and DICT_STATS_AUTO_RECALC_OFF. </p>

</div>
</div>
<a id="ac0b54dbe0d80817647fd6bed40d6f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b54dbe0d80817647fd6bed40d6f420">&#9670;&nbsp;</a></span>stats_bg_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> dict_table_t::stats_bg_flag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The state of the background stats thread wrt this table. </p>
<p>See BG_STAT_NONE, BG_STAT_IN_PROGRESS and BG_STAT_SHOULD_QUIT. Writes are covered by dict_sys-&gt;mutex. Dirty reads are possible. </p>

</div>
</div>
<a id="a712998bd1733e44639d2d159e6389b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712998bd1733e44639d2d159e6389b95">&#9670;&nbsp;</a></span>stats_last_recalc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ut0ut_8h.html#a3d7efb6a0ff993a01dd08a7fa914056a">ib_time_monotonic_t</a> dict_table_t::stats_last_recalc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timestamp of last recalc of the stats. </p>

</div>
</div>
<a id="a0f177330ff4f45c3ec6d088472c5bbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f177330ff4f45c3ec6d088472c5bbe4">&#9670;&nbsp;</a></span>stats_latch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>* dict_table_t::stats_latch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This latch protects: "dict_table_t::stat_initialized", "dict_table_t::stat_n_rows (*)", "dict_table_t::stat_clustered_index_size", "dict_table_t::stat_sum_of_other_index_sizes", "dict_table_t::stat_modified_counter (*)", "dict_table_t::indexes*::stat_n_diff_key_vals[]", "dict_table_t::indexes*::stat_index_size", "dict_table_t::indexes*::stat_n_leaf_pages". </p>
<p>(*) Those are not always protected for performance reasons. </p>

</div>
</div>
<a id="a1faacbf3c7842c55b651facf2f53b713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faacbf3c7842c55b651facf2f53b713">&#9670;&nbsp;</a></span>stats_latch_created</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a> dict_table_t::stats_latch_created</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statistics for query optimization. </p>
<p>Creation state of 'stats_latch'. </p>

</div>
</div>
<a id="a3a2a489fd543ade2d791a10a1c5da519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2a489fd543ade2d791a10a1c5da519">&#9670;&nbsp;</a></span>stats_sample_pages</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::stats_sample_pages</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of pages to sample for this table during persistent stats estimation. </p>
<p>If this is 0, then the value of the global srv_stats_persistent_sample_pages will be used instead. </p>

</div>
</div>
<a id="a2e118d211e2893e5d976d02ce8767617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e118d211e2893e5d976d02ce8767617">&#9670;&nbsp;</a></span>tablespace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classid__name__t.html">id_name_t</a> dict_table_t::tablespace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NULL or the tablespace name that this table is assigned to, specified by the TABLESPACE option. </p>

</div>
</div>
<a id="ab77b74efd6eabc494d44015389cd3ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77b74efd6eabc494d44015389cd3ece">&#9670;&nbsp;</a></span>temp_prebuilt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0mem_8h.html#a4c2cb9c434c31481aef29ec1b4549423">temp_prebuilt_vec</a>* dict_table_t::temp_prebuilt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiple cursors can be active on this temporary table </p>

</div>
</div>
<a id="a28e878692b99a4ea16060ec25144ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e878692b99a4ea16060ec25144ffa9">&#9670;&nbsp;</a></span>to_be_dropped</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::to_be_dropped</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if the table is to be dropped, but not yet actually dropped (could in the background drop list). </p>
<p>It is turned on at the beginning of row_drop_table_for_mysql() and turned off just before we start to update system tables for the drop. It is protected by dict_operation_lock. </p>

</div>
</div>
<a id="abe5d31d5f9e4158df1bfda60d89f933b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5d31d5f9e4158df1bfda60d89f933b">&#9670;&nbsp;</a></span>trunc_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtable__name__t.html">table_name_t</a> dict_table_t::trunc_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate name. </p>

</div>
</div>
<a id="ae35221a94b8a7395289845808c9e35ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35221a94b8a7395289845808c9e35ae">&#9670;&nbsp;</a></span>update_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t dict_table_t::update_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timestamp of the last modification of this table. </p>

</div>
</div>
<a id="add40e985ef13383678c00c267029a48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add40e985ef13383678c00c267029a48d">&#9670;&nbsp;</a></span>v_col_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_table_t::v_col_names</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual column names. </p>

</div>
</div>
<a id="ab690679dafa5bd7e3bd2282163b5e704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab690679dafa5bd7e3bd2282163b5e704">&#9670;&nbsp;</a></span>v_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__v__col__t.html">dict_v_col_t</a>* dict_table_t::v_cols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of virtual column descriptions. </p>

</div>
</div>
<a id="a0a06dd1c35d029c6a79a94d20e2aaea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a06dd1c35d029c6a79a94d20e2aaea1">&#9670;&nbsp;</a></span>vc_templ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__vcol__templ__t.html">dict_vcol_templ_t</a>* dict_table_t::vc_templ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mysql_row_templ_t for base columns used for compute the virtual columns </p>

</div>
</div>
<a id="a2d7052ca1bb96650c5c0ce9508822a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7052ca1bb96650c5c0ce9508822a9a">&#9670;&nbsp;</a></span>version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t dict_table_t::version</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>metadata version number of dd::Table::se_private_data() </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>storage/innobase/include/<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a></li>
<li>storage/innobase/dict/<a class="el" href="dict0dd_8cc.html">dict0dd.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structdict__table__t.html">dict_table_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
