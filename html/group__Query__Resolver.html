<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Query Resolver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Query__Resolver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Resolver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSemijoin__decorrelation.html">Semijoin_decorrelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context object used by semijoin equality decorrelation code.  <a href="classSemijoin__decorrelation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb44a212437f0255c2f223ad2121fcd9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gacb44a212437f0255c2f223ad2121fcd9">simplify_const_condition</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> **cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> remove_cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *ret_cond_value)</td></tr>
<tr class="memdesc:gacb44a212437f0255c2f223ad2121fcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to replace a const condition with a simple constant.  <a href="#gacb44a212437f0255c2f223ad2121fcd9">More...</a><br /></td></tr>
<tr class="separator:gacb44a212437f0255c2f223ad2121fcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956ea21a963da18fcadab759d770cc84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga956ea21a963da18fcadab759d770cc84">create_rollup_switcher</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex, <a class="el" href="classItem.html">Item</a> *item, int send_group_parts)</td></tr>
<tr class="separator:ga956ea21a963da18fcadab759d770cc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4ea05b0499fff8ebb05c289007552b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gaaa4ea05b0499fff8ebb05c289007552b">update_used_tables_for_join</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *tables)</td></tr>
<tr class="memdesc:gaaa4ea05b0499fff8ebb05c289007552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update used tables information for a JOIN expression.  <a href="#gaaa4ea05b0499fff8ebb05c289007552b">More...</a><br /></td></tr>
<tr class="separator:gaaa4ea05b0499fff8ebb05c289007552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea29ee893a4f166204186c7e23d7876"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga9ea29ee893a4f166204186c7e23d7876">make_leaf_tables</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **<a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">list</a>, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr class="memdesc:ga9ea29ee893a4f166204186c7e23d7876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make list of leaf tables of join table tree.  <a href="#ga9ea29ee893a4f166204186c7e23d7876">More...</a><br /></td></tr>
<tr class="separator:ga9ea29ee893a4f166204186c7e23d7876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c8e6170b900f16b4a9716fab93be8e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga33c8e6170b900f16b4a9716fab93be8e">fix_tables_after_pullout</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *parent_select, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *removed_select, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tr, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> table_adjust, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> lateral_deps)</td></tr>
<tr class="memdesc:ga33c8e6170b900f16b4a9716fab93be8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update table reference information for conditions and expressions due to query blocks having been merged in from derived tables/views and due to semi-join transformation.  <a href="#ga33c8e6170b900f16b4a9716fab93be8e">More...</a><br /></td></tr>
<tr class="separator:ga33c8e6170b900f16b4a9716fab93be8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga892137f6ccc44fb66a0903511053edd3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga892137f6ccc44fb66a0903511053edd3">decorrelate_equality</a> (<a class="el" href="classSemijoin__decorrelation.html">Semijoin_decorrelation</a> &amp;sj_decor, <a class="el" href="classItem__func.html">Item_func</a> *func, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *was_correlated)</td></tr>
<tr class="memdesc:ga892137f6ccc44fb66a0903511053edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to decorrelate an (in)equality node.  <a href="#ga892137f6ccc44fb66a0903511053edd3">More...</a><br /></td></tr>
<tr class="separator:ga892137f6ccc44fb66a0903511053edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f38f1ca240563f52e84cdbcf386389d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga0f38f1ca240563f52e84cdbcf386389d">can_decorrelate_operator</a> (<a class="el" href="classItem__func.html">Item_func</a> *func, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> only_eq)</td></tr>
<tr class="separator:ga0f38f1ca240563f52e84cdbcf386389d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf3e02ae2f5c2fbba6fc82b1bd40a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga9cf3e02ae2f5c2fbba6fc82b1bd40a29">walk_join_list</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; &amp;<a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">list</a>, std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *)&gt; action)</td></tr>
<tr class="separator:ga9cf3e02ae2f5c2fbba6fc82b1bd40a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97c1c5e3436976d1cdf567658b7bef5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab97c1c5e3436976d1cdf567658b7bef5">build_sj_exprs</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *sj_outer_exprs, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *sj_inner_exprs, <a class="el" href="classItem__exists__subselect.html">Item_exists_subselect</a> *subq_pred, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *subq_select)</td></tr>
<tr class="memdesc:gab97c1c5e3436976d1cdf567658b7bef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the list of SJ outer/inner expressions.  <a href="#gab97c1c5e3436976d1cdf567658b7bef5">More...</a><br /></td></tr>
<tr class="separator:gab97c1c5e3436976d1cdf567658b7bef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75fb90f2c229da82ef0c2b32b562391d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga75fb90f2c229da82ef0c2b32b562391d">replace_subcondition</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> **tree, <a class="el" href="classItem.html">Item</a> *old_cond, <a class="el" href="classItem.html">Item</a> *new_cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> do_fix_fields, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *found_ptr=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:ga75fb90f2c229da82ef0c2b32b562391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructively replaces a sub-condition inside a condition tree.  <a href="#ga75fb90f2c229da82ef0c2b32b562391d">More...</a><br /></td></tr>
<tr class="separator:ga75fb90f2c229da82ef0c2b32b562391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23df2771487d13fa777ff40f2a91f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gac23df2771487d13fa777ff40f2a91f03">propagate_nullability</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> nullable)</td></tr>
<tr class="memdesc:gac23df2771487d13fa777ff40f2a91f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate nullability into inner tables of outer join operation.  <a href="#gac23df2771487d13fa777ff40f2a91f03">More...</a><br /></td></tr>
<tr class="separator:gac23df2771487d13fa777ff40f2a91f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d20206b97e71f10cd83790dc107834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga96d20206b97e71f10cd83790dc107834">find_order_in_list</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="structORDER.html">ORDER</a> *order, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_group_field, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_window_order)</td></tr>
<tr class="memdesc:ga96d20206b97e71f10cd83790dc107834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve an ORDER BY or GROUP BY column reference.  <a href="#ga96d20206b97e71f10cd83790dc107834">More...</a><br /></td></tr>
<tr class="separator:ga96d20206b97e71f10cd83790dc107834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3908f32196b05aaea56ee94bf46b420a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga3908f32196b05aaea56ee94bf46b420a">setup_order</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> ref_item_array, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *fields, <a class="el" href="structORDER.html">ORDER</a> *order)</td></tr>
<tr class="memdesc:ga3908f32196b05aaea56ee94bf46b420a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve and setup list of expressions in ORDER BY clause.  <a href="#ga3908f32196b05aaea56ee94bf46b420a">More...</a><br /></td></tr>
<tr class="separator:ga3908f32196b05aaea56ee94bf46b420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ea8dc10fb0c4f69b4757d60831f358"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structReplaceResult.html">ReplaceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga62ea8dc10fb0c4f69b4757d60831f358">wrap_grouped_expressions_for_rollup</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, <a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classItem.html">Item</a> *parent, unsigned argument_idx)</td></tr>
<tr class="memdesc:ga62ea8dc10fb0c4f69b4757d60831f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an item matches a grouped expression, creates an Item_rollup_group_item around it and replaces the reference to it with that item.  <a href="#ga62ea8dc10fb0c4f69b4757d60831f358">More...</a><br /></td></tr>
<tr class="separator:ga62ea8dc10fb0c4f69b4757d60831f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdf996e8d5aa134d338976f355a16ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gafdf996e8d5aa134d338976f355a16ea7">WalkAndReplace</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *item, const function&lt; <a class="el" href="structReplaceResult.html">ReplaceResult</a>(<a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classItem.html">Item</a> *parent, unsigned argument_idx)&gt; &amp;get_new_item)</td></tr>
<tr class="separator:gafdf996e8d5aa134d338976f355a16ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga588a52d801f0875b4d426477c06d4851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga588a52d801f0875b4d426477c06d4851">validate_gc_assignment</a> (const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;fields, const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;values, <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="memdesc:ga588a52d801f0875b4d426477c06d4851"><td class="mdescLeft">&#160;</td><td class="mdescRight">validate_gc_assignment Check whether the other values except DEFAULT are assigned for generated columns.  <a href="#ga588a52d801f0875b4d426477c06d4851">More...</a><br /></td></tr>
<tr class="separator:ga588a52d801f0875b4d426477c06d4851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf0e61ab8ffa138c3ebb9abb037b408"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga6cf0e61ab8ffa138c3ebb9abb037b408">baptize_item</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *item, int *field_no)</td></tr>
<tr class="memdesc:ga6cf0e61ab8ffa138c3ebb9abb037b408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to make names for columns of a derived table replacing a scalar or table subquery.  <a href="#ga6cf0e61ab8ffa138c3ebb9abb037b408">More...</a><br /></td></tr>
<tr class="separator:ga6cf0e61ab8ffa138c3ebb9abb037b408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga664ecb121a8137472b07f25da758e93d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga664ecb121a8137472b07f25da758e93d">update_context_to_derived</a> (<a class="el" href="classItem.html">Item</a> *expr, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *new_derived)</td></tr>
<tr class="memdesc:ga664ecb121a8137472b07f25da758e93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minion of transform_grouped_to_derived.  <a href="#ga664ecb121a8137472b07f25da758e93d">More...</a><br /></td></tr>
<tr class="separator:ga664ecb121a8137472b07f25da758e93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d156b041d3eb35f9f4fbdbe26f831b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga5d156b041d3eb35f9f4fbdbe26f831b4">replace_aggregate_in_list</a> (<a class="el" href="structItem_1_1Aggregate__replacement.html">Item::Aggregate_replacement</a> &amp;<a class="el" href="mysql__ssl__rsa__setup_8cc.html#a5f4e2d00e13f7f971e3fbce0dee76947">info</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> was_hidden, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *<a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">list</a>, <a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> *ref_item_array)</td></tr>
<tr class="memdesc:ga5d156b041d3eb35f9f4fbdbe26f831b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minion of transform_grouped_to_derived.  <a href="#ga5d156b041d3eb35f9f4fbdbe26f831b4">More...</a><br /></td></tr>
<tr class="separator:ga5d156b041d3eb35f9f4fbdbe26f831b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe00266a53cac66e90cbbe78fbfa308c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gabe00266a53cac66e90cbbe78fbfa308c">collect_aggregates</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, <a class="el" href="structItem__sum_1_1Collect__grouped__aggregate__info.html">Item_sum::Collect_grouped_aggregate_info</a> *aggregates)</td></tr>
<tr class="memdesc:gabe00266a53cac66e90cbbe78fbfa308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minion of transform_grouped_to_derived.  <a href="#gabe00266a53cac66e90cbbe78fbfa308c">More...</a><br /></td></tr>
<tr class="separator:gabe00266a53cac66e90cbbe78fbfa308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85b6803cb6287d4419794417a785b0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gaa85b6803cb6287d4419794417a785b0f">query_block_contains_subquery</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select, <a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *slu)</td></tr>
<tr class="memdesc:gaa85b6803cb6287d4419794417a785b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minion of transform_scalar_subqueries_to_join_with_derived.  <a href="#gaa85b6803cb6287d4419794417a785b0f">More...</a><br /></td></tr>
<tr class="separator:gaa85b6803cb6287d4419794417a785b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9768477d146a4e857c6c54c6d0315d36"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga9768477d146a4e857c6c54c6d0315d36">walk_join_conditions</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; &amp;<a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">list</a>, std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(<a class="el" href="classItem.html">Item</a> **expr_p)&gt; action, <a class="el" href="structItem_1_1Collect__scalar__subquery__info.html">Item_singlerow_subselect::Collect_scalar_subquery_info</a> *<a class="el" href="mysql__ssl__rsa__setup_8cc.html#a5f4e2d00e13f7f971e3fbce0dee76947">info</a>)</td></tr>
<tr class="separator:ga9768477d146a4e857c6c54c6d0315d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c036ee90842621066feb4ab662238d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga12c036ee90842621066feb4ab662238d">remember_transform</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select)</td></tr>
<tr class="memdesc:ga12c036ee90842621066feb4ab662238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember if this transform was performed.  <a href="#ga12c036ee90842621066feb4ab662238d">More...</a><br /></td></tr>
<tr class="separator:ga12c036ee90842621066feb4ab662238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00c376fc680198f677019b5db776cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab00c376fc680198f677019b5db776cc0">SELECT_LEX::prepare</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *insert_field_list)</td></tr>
<tr class="memdesc:gab00c376fc680198f677019b5db776cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare query block for optimization.  <a href="#gab00c376fc680198f677019b5db776cc0">More...</a><br /></td></tr>
<tr class="separator:gab00c376fc680198f677019b5db776cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e1a6190e571a9ba5b0083ef94a72bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga85e1a6190e571a9ba5b0083ef94a72bd">SELECT_LEX::push_conditions_to_derived_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga85e1a6190e571a9ba5b0083ef94a72bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes parts of the WHERE condition of this query block to materialized derived tables.  <a href="#ga85e1a6190e571a9ba5b0083ef94a72bd">More...</a><br /></td></tr>
<tr class="separator:ga85e1a6190e571a9ba5b0083ef94a72bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007e1f511d66aaa56caf2b680d9d6ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga007e1f511d66aaa56caf2b680d9d6ca4">SELECT_LEX::prepare_values</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga007e1f511d66aaa56caf2b680d9d6ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a table value constructor query block for optimization.  <a href="#ga007e1f511d66aaa56caf2b680d9d6ca4">More...</a><br /></td></tr>
<tr class="separator:ga007e1f511d66aaa56caf2b680d9d6ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d9965edb79f7fd3a51b5bf2dc8c5847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga1d9965edb79f7fd3a51b5bf2dc8c5847">SELECT_LEX::apply_local_transforms</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> prune)</td></tr>
<tr class="memdesc:ga1d9965edb79f7fd3a51b5bf2dc8c5847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does permanent transformations which are local to a query block (which do not merge it to another block).  <a href="#ga1d9965edb79f7fd3a51b5bf2dc8c5847">More...</a><br /></td></tr>
<tr class="separator:ga1d9965edb79f7fd3a51b5bf2dc8c5847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2cde72e117bc74f09db829bafb6546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gada2cde72e117bc74f09db829bafb6546">SELECT_LEX::update_used_tables</a> ()</td></tr>
<tr class="memdesc:gada2cde72e117bc74f09db829bafb6546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update used tables information for all local expressions.  <a href="#gada2cde72e117bc74f09db829bafb6546">More...</a><br /></td></tr>
<tr class="separator:gada2cde72e117bc74f09db829bafb6546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c69f592ab3290deb79d3e43fc69a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab5c69f592ab3290deb79d3e43fc69a39">SELECT_LEX::resolve_limits</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gab5c69f592ab3290deb79d3e43fc69a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve OFFSET and LIMIT clauses.  <a href="#gab5c69f592ab3290deb79d3e43fc69a39">More...</a><br /></td></tr>
<tr class="separator:gab5c69f592ab3290deb79d3e43fc69a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ee4ab72058e6ae1ea70257b0f767b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga52ee4ab72058e6ae1ea70257b0f767b4">Item_in_subselect::subquery_allows_materialization</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select_lex, const <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *outer)</td></tr>
<tr class="memdesc:ga52ee4ab72058e6ae1ea70257b0f767b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the subquery predicate can be executed via materialization.  <a href="#ga52ee4ab72058e6ae1ea70257b0f767b4">More...</a><br /></td></tr>
<tr class="separator:ga52ee4ab72058e6ae1ea70257b0f767b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4ace215068ab770231a60a1f81eb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga0b4ace215068ab770231a60a1f81eb14">SELECT_LEX::check_view_privileges</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> want_privilege_first, <a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> want_privilege_next)</td></tr>
<tr class="memdesc:ga0b4ace215068ab770231a60a1f81eb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check privileges for views that are merged into query block.  <a href="#ga0b4ace215068ab770231a60a1f81eb14">More...</a><br /></td></tr>
<tr class="separator:ga0b4ace215068ab770231a60a1f81eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b89278da111abc564aa45b95559422b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga0b89278da111abc564aa45b95559422b">SELECT_LEX::setup_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> select_insert)</td></tr>
<tr class="memdesc:ga0b89278da111abc564aa45b95559422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve and prepare information about tables for one query block.  <a href="#ga0b89278da111abc564aa45b95559422b">More...</a><br /></td></tr>
<tr class="separator:ga0b89278da111abc564aa45b95559422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f9bf5300020a533f0b37a77d409e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga53f9bf5300020a533f0b37a77d409e05">SELECT_LEX::remap_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga53f9bf5300020a533f0b37a77d409e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-map table numbers for all tables in a query block.  <a href="#ga53f9bf5300020a533f0b37a77d409e05">More...</a><br /></td></tr>
<tr class="separator:ga53f9bf5300020a533f0b37a77d409e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b320ecec153602b0fa516cee89f47c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga3b320ecec153602b0fa516cee89f47c1">SELECT_LEX::resolve_placeholder_tables</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> apply_semijoin)</td></tr>
<tr class="memdesc:ga3b320ecec153602b0fa516cee89f47c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve derived table, view, table function information for a query block.  <a href="#ga3b320ecec153602b0fa516cee89f47c1">More...</a><br /></td></tr>
<tr class="separator:ga3b320ecec153602b0fa516cee89f47c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8c2c9e2a729cddae1337f6c3c35ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga3f8c2c9e2a729cddae1337f6c3c35ed6">SELECT_LEX::is_row_count_valid_for_semi_join</a> ()</td></tr>
<tr class="memdesc:ga3f8c2c9e2a729cddae1337f6c3c35ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the offset and limit are valid for a semijoin.  <a href="#ga3f8c2c9e2a729cddae1337f6c3c35ed6">More...</a><br /></td></tr>
<tr class="separator:ga3f8c2c9e2a729cddae1337f6c3c35ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02fc7f4d394b3a7e60ad446a89e018e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga02fc7f4d394b3a7e60ad446a89e018e1">SELECT_LEX::resolve_subquery</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga02fc7f4d394b3a7e60ad446a89e018e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve predicate involving subquery.  <a href="#ga02fc7f4d394b3a7e60ad446a89e018e1">More...</a><br /></td></tr>
<tr class="separator:ga02fc7f4d394b3a7e60ad446a89e018e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87c9ecbe9600ae5d51b93de40fc4acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gaf87c9ecbe9600ae5d51b93de40fc4acf">SELECT_LEX::setup_wild</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gaf87c9ecbe9600ae5d51b93de40fc4acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand all '*' in list of expressions with the matching column references.  <a href="#gaf87c9ecbe9600ae5d51b93de40fc4acf">More...</a><br /></td></tr>
<tr class="separator:gaf87c9ecbe9600ae5d51b93de40fc4acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84010d8344698949eb7e533bedc83fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga84010d8344698949eb7e533bedc83fc4">SELECT_LEX::setup_conds</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga84010d8344698949eb7e533bedc83fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve WHERE condition and join conditions.  <a href="#ga84010d8344698949eb7e533bedc83fc4">More...</a><br /></td></tr>
<tr class="separator:ga84010d8344698949eb7e533bedc83fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce084e0bb33ae16cd6480b0e6555dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gacce084e0bb33ae16cd6480b0e6555dfb">SELECT_LEX::setup_join_cond</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> in_update)</td></tr>
<tr class="memdesc:gacce084e0bb33ae16cd6480b0e6555dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve join conditions for a join nest.  <a href="#gacce084e0bb33ae16cd6480b0e6555dfb">More...</a><br /></td></tr>
<tr class="separator:gacce084e0bb33ae16cd6480b0e6555dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7255a73df6040c4c6c86a300147cb2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gae7255a73df6040c4c6c86a300147cb2d">SELECT_LEX::reset_nj_counters</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *<a class="el" href="classSELECT__LEX.html#a691b28786d6c65914c0ffb13f9959e75">join_list</a>=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:gae7255a73df6040c4c6c86a300147cb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set NESTED_JOIN::counter=0 in all nested joins in passed list.  <a href="#gae7255a73df6040c4c6c86a300147cb2d">More...</a><br /></td></tr>
<tr class="separator:gae7255a73df6040c4c6c86a300147cb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d190c423c845ae4ae06a468cb0895fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga8d190c423c845ae4ae06a468cb0895fc">SELECT_LEX::simplify_joins</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *<a class="el" href="classSELECT__LEX.html#a691b28786d6c65914c0ffb13f9959e75">join_list</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> top, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> in_sj, <a class="el" href="classItem.html">Item</a> **new_conds, <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *changelog=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:ga8d190c423c845ae4ae06a468cb0895fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify joins replacing outer joins by inner joins whenever it's possible.  <a href="#ga8d190c423c845ae4ae06a468cb0895fc">More...</a><br /></td></tr>
<tr class="separator:ga8d190c423c845ae4ae06a468cb0895fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2683e4324084327d2173f5e169970f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab2683e4324084327d2173f5e169970f8">SELECT_LEX::record_join_nest_info</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *tables)</td></tr>
<tr class="memdesc:gab2683e4324084327d2173f5e169970f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record join nest info in the select block.  <a href="#gab2683e4324084327d2173f5e169970f8">More...</a><br /></td></tr>
<tr class="separator:gab2683e4324084327d2173f5e169970f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a54069770520d871a999a6d3a4681ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga3a54069770520d871a999a6d3a4681ba">SELECT_LEX_UNIT::fix_after_pullout</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *parent_select, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *removed_select)</td></tr>
<tr class="memdesc:ga3a54069770520d871a999a6d3a4681ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix used tables information for a subquery after query transformations.  <a href="#ga3a54069770520d871a999a6d3a4681ba">More...</a><br /></td></tr>
<tr class="separator:ga3a54069770520d871a999a6d3a4681ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88762aa247c2005bc2c66bacd1eb0f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gac88762aa247c2005bc2c66bacd1eb0f8">SELECT_LEX::fix_after_pullout</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *parent_select, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *removed_select)</td></tr>
<tr class="separator:gac88762aa247c2005bc2c66bacd1eb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897e6cf09ad56bf0e50c19cc7a50161b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga897e6cf09ad56bf0e50c19cc7a50161b">SELECT_LEX::clear_sj_expressions</a> (<a class="el" href="structNESTED__JOIN.html">NESTED_JOIN</a> *nested_join)</td></tr>
<tr class="memdesc:ga897e6cf09ad56bf0e50c19cc7a50161b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove semijoin condition for this query block.  <a href="#ga897e6cf09ad56bf0e50c19cc7a50161b">More...</a><br /></td></tr>
<tr class="separator:ga897e6cf09ad56bf0e50c19cc7a50161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e206bcdfc5e124b4e42d6c038a13830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga7e206bcdfc5e124b4e42d6c038a13830">SELECT_LEX::build_sj_cond</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structNESTED__JOIN.html">NESTED_JOIN</a> *nested_join, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *subq_select, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> outer_tables_map, <a class="el" href="classItem.html">Item</a> **sj_cond)</td></tr>
<tr class="memdesc:ga7e206bcdfc5e124b4e42d6c038a13830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build semijoin condition for th query block.  <a href="#ga7e206bcdfc5e124b4e42d6c038a13830">More...</a><br /></td></tr>
<tr class="separator:ga7e206bcdfc5e124b4e42d6c038a13830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94509e64d2172270748ae98561714b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gad94509e64d2172270748ae98561714b2">SELECT_LEX::decorrelate_condition</a> (<a class="el" href="classSemijoin__decorrelation.html">Semijoin_decorrelation</a> &amp;sj_decor, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *join_nest)</td></tr>
<tr class="memdesc:gad94509e64d2172270748ae98561714b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorrelate the WHERE clause or a join condition of a subquery used in an IN or EXISTS predicate.  <a href="#gad94509e64d2172270748ae98561714b2">More...</a><br /></td></tr>
<tr class="separator:gad94509e64d2172270748ae98561714b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga733ceb7be0e16efcfadf33f18370b264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga733ceb7be0e16efcfadf33f18370b264">SELECT_LEX::convert_subquery_to_semijoin</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem__exists__subselect.html">Item_exists_subselect</a> *subq_pred)</td></tr>
<tr class="memdesc:ga733ceb7be0e16efcfadf33f18370b264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a subquery predicate of this query block into a TABLE_LIST semi-join nest.  <a href="#ga733ceb7be0e16efcfadf33f18370b264">More...</a><br /></td></tr>
<tr class="separator:ga733ceb7be0e16efcfadf33f18370b264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7369c8cabfbba4502ee79d30391adb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab7369c8cabfbba4502ee79d30391adb6">SELECT_LEX::merge_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *derived_table)</td></tr>
<tr class="memdesc:gab7369c8cabfbba4502ee79d30391adb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge derived table into query block.  <a href="#gab7369c8cabfbba4502ee79d30391adb6">More...</a><br /></td></tr>
<tr class="separator:gab7369c8cabfbba4502ee79d30391adb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5982f458294ba69e9f79a9219985a6c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga5982f458294ba69e9f79a9219985a6c4">SELECT_LEX::flatten_subqueries</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga5982f458294ba69e9f79a9219985a6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert semi-join subquery predicates into semi-join join nests.  <a href="#ga5982f458294ba69e9f79a9219985a6c4">More...</a><br /></td></tr>
<tr class="separator:ga5982f458294ba69e9f79a9219985a6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5849f7c2d87f629f169af2b05bfca5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gad5849f7c2d87f629f169af2b05bfca5f">SELECT_LEX::is_in_select_list</a> (<a class="el" href="classItem.html">Item</a> *i)</td></tr>
<tr class="separator:gad5849f7c2d87f629f169af2b05bfca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027e11a56eb53f508f35de88e1d780b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga027e11a56eb53f508f35de88e1d780b9">SELECT_LEX::propagate_unique_test_exclusion</a> ()</td></tr>
<tr class="memdesc:ga027e11a56eb53f508f35de88e1d780b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate exclusion from table uniqueness test into subqueries.  <a href="#ga027e11a56eb53f508f35de88e1d780b9">More...</a><br /></td></tr>
<tr class="separator:ga027e11a56eb53f508f35de88e1d780b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446d2eedaf0564ac78a3a3f4dbb777c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga446d2eedaf0564ac78a3a3f4dbb777c6">SELECT_LEX::add_ftfunc_list</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__func__match.html">Item_func_match</a> &gt; *ftfuncs)</td></tr>
<tr class="memdesc:ga446d2eedaf0564ac78a3a3f4dbb777c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add full-text function elements from a list into this query block.  <a href="#ga446d2eedaf0564ac78a3a3f4dbb777c6">More...</a><br /></td></tr>
<tr class="separator:ga446d2eedaf0564ac78a3a3f4dbb777c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2077984f062da999b6a838f340d45bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga2077984f062da999b6a838f340d45bad">SELECT_LEX::repoint_contexts_of_join_nests</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; <a class="el" href="classSELECT__LEX.html#a691b28786d6c65914c0ffb13f9959e75">join_list</a>)</td></tr>
<tr class="memdesc:ga2077984f062da999b6a838f340d45bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through a list of tables and join nests, recursively, and repoint its select_lex pointer.  <a href="#ga2077984f062da999b6a838f340d45bad">More...</a><br /></td></tr>
<tr class="separator:ga2077984f062da999b6a838f340d45bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5477c6e5acafac963014e5887546d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gad5477c6e5acafac963014e5887546d84">SELECT_LEX::merge_contexts</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *inner)</td></tr>
<tr class="memdesc:gad5477c6e5acafac963014e5887546d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge name resolution context objects of a subquery into its parent.  <a href="#gad5477c6e5acafac963014e5887546d84">More...</a><br /></td></tr>
<tr class="separator:gad5477c6e5acafac963014e5887546d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44cffd351367ad92dc2386800c6fa72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab44cffd351367ad92dc2386800c6fa72">SELECT_LEX::remove_redundant_subquery_clauses</a> (<a class="el" href="classTHD.html">THD</a> *thd, int <a class="el" href="classSELECT__LEX.html#a85ddba9db0dc78a1d229721585a216b4">hidden_group_field_count</a>)</td></tr>
<tr class="memdesc:gab44cffd351367ad92dc2386800c6fa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a table subquery predicate (IN/ANY/ALL/EXISTS/etc): since it does not support LIMIT the following clauses are redundant:  <a href="#gab44cffd351367ad92dc2386800c6fa72">More...</a><br /></td></tr>
<tr class="separator:gab44cffd351367ad92dc2386800c6fa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25eec45e0f11aa76f615858ab3940268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga25eec45e0f11aa76f615858ab3940268">SELECT_LEX::empty_order_list</a> (<a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *sl)</td></tr>
<tr class="memdesc:ga25eec45e0f11aa76f615858ab3940268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the ORDER list.  <a href="#ga25eec45e0f11aa76f615858ab3940268">More...</a><br /></td></tr>
<tr class="separator:ga25eec45e0f11aa76f615858ab3940268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5bf5220417914713a4400dfcac007f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gadc5bf5220417914713a4400dfcac007f">SELECT_LEX::check_only_full_group_by</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gadc5bf5220417914713a4400dfcac007f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs checks mandated by ONLY_FULL_GROUP_BY.  <a href="#gadc5bf5220417914713a4400dfcac007f">More...</a><br /></td></tr>
<tr class="separator:gadc5bf5220417914713a4400dfcac007f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga324abeccb51b4dcfe4c84d0118eb5a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga324abeccb51b4dcfe4c84d0118eb5a03">SELECT_LEX::setup_order_final</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga324abeccb51b4dcfe4c84d0118eb5a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do final setup of ORDER BY clause, after the query block is fully resolved.  <a href="#ga324abeccb51b4dcfe4c84d0118eb5a03">More...</a><br /></td></tr>
<tr class="separator:ga324abeccb51b4dcfe4c84d0118eb5a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a20927f8acb89fcadaa0140f6ee8986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga9a20927f8acb89fcadaa0140f6ee8986">SELECT_LEX::setup_group</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga9a20927f8acb89fcadaa0140f6ee8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve and set up the GROUP BY list.  <a href="#ga9a20927f8acb89fcadaa0140f6ee8986">More...</a><br /></td></tr>
<tr class="separator:ga9a20927f8acb89fcadaa0140f6ee8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1758a9acf5e1cf389124476a7159a49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga1758a9acf5e1cf389124476a7159a49e">SELECT_LEX::find_in_group_list</a> (<a class="el" href="classItem.html">Item</a> *item, int *rollup_level) const</td></tr>
<tr class="memdesc:ga1758a9acf5e1cf389124476a7159a49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a group expression matching the given item, or nullptr if none.  <a href="#ga1758a9acf5e1cf389124476a7159a49e">More...</a><br /></td></tr>
<tr class="separator:ga1758a9acf5e1cf389124476a7159a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82613eb3ef5de00fb0a376c920f109da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga82613eb3ef5de00fb0a376c920f109da">SELECT_LEX::group_list_size</a> () const</td></tr>
<tr class="separator:ga82613eb3ef5de00fb0a376c920f109da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09beb6a36689d47b05b0e5d3a1ec8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab09beb6a36689d47b05b0e5d3a1ec8a5">SELECT_LEX::mark_item_as_maybe_null_if_rollup_item</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:gab09beb6a36689d47b05b0e5d3a1ec8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks occurrences of group by fields in a function's arguments as maybe_null, so that we do not optimize them away before we get to add the rollup wrappers.  <a href="#gab09beb6a36689d47b05b0e5d3a1ec8a5">More...</a><br /></td></tr>
<tr class="separator:gab09beb6a36689d47b05b0e5d3a1ec8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3eff367e4f6d91672f28741381a7450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab3eff367e4f6d91672f28741381a7450">SELECT_LEX::single_visible_field</a> () const</td></tr>
<tr class="separator:gab3eff367e4f6d91672f28741381a7450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464660f516e359dd7ab6577d76641b5c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga464660f516e359dd7ab6577d76641b5c">SELECT_LEX::num_visible_fields</a> () const</td></tr>
<tr class="separator:ga464660f516e359dd7ab6577d76641b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d06fa8691a8cf08960649a015314421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga8d06fa8691a8cf08960649a015314421">SELECT_LEX::field_list_is_empty</a> () const</td></tr>
<tr class="separator:ga8d06fa8691a8cf08960649a015314421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbe4d9794ec1604d4ab83b1790089a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga7cbe4d9794ec1604d4ab83b1790089a9">SELECT_LEX::remove_hidden_fields</a> ()</td></tr>
<tr class="separator:ga7cbe4d9794ec1604d4ab83b1790089a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e696bf85b415c62ee4ec53bd59ee5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga5e696bf85b415c62ee4ec53bd59ee5b0">SELECT_LEX::resolve_rollup_item</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:ga5e696bf85b415c62ee4ec53bd59ee5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve an item (and its tree) for rollup processing by replacing items matching grouped expressions with Item_rollup_group_items and updating properties (maybe_null, PROP_ROLLUP_FIELD).  <a href="#ga5e696bf85b415c62ee4ec53bd59ee5b0">More...</a><br /></td></tr>
<tr class="separator:ga5e696bf85b415c62ee4ec53bd59ee5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae200ff649d7c7e81b67b0ef6d544e0f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gae200ff649d7c7e81b67b0ef6d544e0f9">SELECT_LEX::resolve_rollup</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gae200ff649d7c7e81b67b0ef6d544e0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve items in SELECT list and ORDER BY list for rollup processing.  <a href="#gae200ff649d7c7e81b67b0ef6d544e0f9">More...</a><br /></td></tr>
<tr class="separator:gae200ff649d7c7e81b67b0ef6d544e0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f5892b0f0659d116a0451a04a8ceba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga05f5892b0f0659d116a0451a04a8ceba">SELECT_LEX::resolve_rollup_wfs</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga05f5892b0f0659d116a0451a04a8ceba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace group by field references inside window functions with references in the the presence of ROLLUP.  <a href="#ga05f5892b0f0659d116a0451a04a8ceba">More...</a><br /></td></tr>
<tr class="separator:ga05f5892b0f0659d116a0451a04a8ceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga442db5eafc607d32a94161b3b3704270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga442db5eafc607d32a94161b3b3704270">SELECT_LEX::delete_unused_merged_columns</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *tables)</td></tr>
<tr class="memdesc:ga442db5eafc607d32a94161b3b3704270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete unused columns from merged tables.  <a href="#ga442db5eafc607d32a94161b3b3704270">More...</a><br /></td></tr>
<tr class="separator:ga442db5eafc607d32a94161b3b3704270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648f670e21c49f179409067413b4196f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga648f670e21c49f179409067413b4196f">SELECT_LEX::add_hidden_item</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:ga648f670e21c49f179409067413b4196f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add item to the hidden part of select list.  <a href="#ga648f670e21c49f179409067413b4196f">More...</a><br /></td></tr>
<tr class="separator:ga648f670e21c49f179409067413b4196f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427605dcf22bf2cbb504670590a7fdda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga427605dcf22bf2cbb504670590a7fdda">SELECT_LEX::remove_hidden_items</a> ()</td></tr>
<tr class="memdesc:ga427605dcf22bf2cbb504670590a7fdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove hidden items from select list.  <a href="#ga427605dcf22bf2cbb504670590a7fdda">More...</a><br /></td></tr>
<tr class="separator:ga427605dcf22bf2cbb504670590a7fdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7348b6f26a85ebb98a8a083d729ac55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#gab7348b6f26a85ebb98a8a083d729ac55">SELECT_LEX::resolve_table_value_constructor_values</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:gab7348b6f26a85ebb98a8a083d729ac55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve the rows of a table value constructor and aggregate the type of each column across rows.  <a href="#gab7348b6f26a85ebb98a8a083d729ac55">More...</a><br /></td></tr>
<tr class="separator:gab7348b6f26a85ebb98a8a083d729ac55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589f1ddbbe285907314f87a5bdc0c090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga589f1ddbbe285907314f87a5bdc0c090">SELECT_LEX::transform_table_subquery_to_join_with_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem__exists__subselect.html">Item_exists_subselect</a> *subq_pred)</td></tr>
<tr class="memdesc:ga589f1ddbbe285907314f87a5bdc0c090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a table subquery ([NOT] {IN, EXISTS}) with a join to a derived table.  <a href="#ga589f1ddbbe285907314f87a5bdc0c090">More...</a><br /></td></tr>
<tr class="separator:ga589f1ddbbe285907314f87a5bdc0c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329cee4bc264925a8a42e540d5d7a075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga329cee4bc264925a8a42e540d5d7a075">SELECT_LEX::synthesize_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *unit, <a class="el" href="classItem.html">Item</a> *join_cond, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> left_outer, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_inner_join)</td></tr>
<tr class="memdesc:ga329cee4bc264925a8a42e540d5d7a075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new TABLE_LIST object for this query block, for either: 1) a derived table which will replace the subquery, or 2) an extra derived table for handling grouping, if necessary, cf.  <a href="#ga329cee4bc264925a8a42e540d5d7a075">More...</a><br /></td></tr>
<tr class="separator:ga329cee4bc264925a8a42e540d5d7a075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2355935a856b96d20154f625c270c4a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga2355935a856b96d20154f625c270c4a1">SELECT_LEX::remove_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:ga2355935a856b96d20154f625c270c4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a derived table we added previously as part of transform_scalar_subqueries_to_join_with_derived.  <a href="#ga2355935a856b96d20154f625c270c4a1">More...</a><br /></td></tr>
<tr class="separator:ga2355935a856b96d20154f625c270c4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7125444662147b07d8709d90755d9d18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga7125444662147b07d8709d90755d9d18">SELECT_LEX::remove_aggregates</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *select)</td></tr>
<tr class="memdesc:ga7125444662147b07d8709d90755d9d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minion of transform_grouped_to_derived.  <a href="#ga7125444662147b07d8709d90755d9d18">More...</a><br /></td></tr>
<tr class="separator:ga7125444662147b07d8709d90755d9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67528d173a9e9c588dff8d3820c48ba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga67528d173a9e9c588dff8d3820c48ba8">SELECT_LEX::transform_grouped_to_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *break_off)</td></tr>
<tr class="memdesc:ga67528d173a9e9c588dff8d3820c48ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minion of transform_scalar_subqueries_to_join_with_derived.  <a href="#ga67528d173a9e9c588dff8d3820c48ba8">More...</a><br /></td></tr>
<tr class="separator:ga67528d173a9e9c588dff8d3820c48ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03881e87ddb8f2f363841e9ed0367885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga03881e87ddb8f2f363841e9ed0367885">SELECT_LEX::replace_subquery_in_expr</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem__singlerow__subselect.html">Item_singlerow_subselect</a> *subquery, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tr, <a class="el" href="classItem.html">Item</a> **expr)</td></tr>
<tr class="memdesc:ga03881e87ddb8f2f363841e9ed0367885"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minion of transform_scalar_subqueries_to_join_with_derived.  <a href="#ga03881e87ddb8f2f363841e9ed0367885">More...</a><br /></td></tr>
<tr class="separator:ga03881e87ddb8f2f363841e9ed0367885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ebaa76013b8495ccc3102da02b8f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga31ebaa76013b8495ccc3102da02b8f61">SELECT_LEX::nest_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *join_cond, <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *<a class="el" href="classSELECT__LEX.html#a691b28786d6c65914c0ffb13f9959e75">join_list</a>, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *new_derived_table)</td></tr>
<tr class="memdesc:ga31ebaa76013b8495ccc3102da02b8f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the generated derived table to the correct location inside a join nest.  <a href="#ga31ebaa76013b8495ccc3102da02b8f61">More...</a><br /></td></tr>
<tr class="separator:ga31ebaa76013b8495ccc3102da02b8f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c907b86619ee483f5529a19d920557d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga9c907b86619ee483f5529a19d920557d">SELECT_LEX::transform_subquery_to_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **out_tl, <a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *subs_unit, <a class="el" href="classItem__subselect.html">Item_subselect</a> *subq, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_inner_join, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reject_multiple_rows, <a class="el" href="classItem.html">Item</a> *join_condition)</td></tr>
<tr class="memdesc:ga9c907b86619ee483f5529a19d920557d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a subquery to a derived table and inserts it into the FROM clause of the owning query block.  <a href="#ga9c907b86619ee483f5529a19d920557d">More...</a><br /></td></tr>
<tr class="separator:ga9c907b86619ee483f5529a19d920557d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3fc372c4e39b2668e29223a0f4687b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Resolver.html#ga3e3fc372c4e39b2668e29223a0f4687b">SELECT_LEX::transform_scalar_subqueries_to_join_with_derived</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga3e3fc372c4e39b2668e29223a0f4687b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform eligible scalar subqueries in the SELECT list, WHERE condition, HAVING condition or JOIN conditions of a query block[*] to an equivalent derived table of a LEFT OUTER join, e.g.  <a href="#ga3e3fc372c4e39b2668e29223a0f4687b">More...</a><br /></td></tr>
<tr class="separator:ga3e3fc372c4e39b2668e29223a0f4687b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga446d2eedaf0564ac78a3a3f4dbb777c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga446d2eedaf0564ac78a3a3f4dbb777c6">&#9670;&nbsp;</a></span>add_ftfunc_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::add_ftfunc_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__func__match.html">Item_func_match</a> &gt; *&#160;</td>
          <td class="paramname"><em>ftfuncs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add full-text function elements from a list into this query block. </p>
<p>Add a list of full-text function elements into a query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ftfuncs</td><td>List of full-text function elements to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga648f670e21c49f179409067413b4196f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648f670e21c49f179409067413b4196f">&#9670;&nbsp;</a></span>add_hidden_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a> ** SELECT_LEX::add_hidden_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add item to the hidden part of select list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to reference of the added item</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to reference to the added item </dd></dl>

</div>
</div>
<a id="ga1d9965edb79f7fd3a51b5bf2dc8c5847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d9965edb79f7fd3a51b5bf2dc8c5847">&#9670;&nbsp;</a></span>apply_local_transforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::apply_local_transforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>prune</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does permanent transformations which are local to a query block (which do not merge it to another block). </p>
<p>Apply local transformations, such as join nest simplification.</p>
<p>'Local' means that each transformation happens on one single query block. Also perform partition pruning, which is most effective after transformations have been done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">prune</td><td>if true, then prune partitions based on const conditions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>Since this is called after flattening of query blocks, call this function while traversing the query block hierarchy top-down. </p>

</div>
</div>
<a id="ga6cf0e61ab8ffa138c3ebb9abb037b408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cf0e61ab8ffa138c3ebb9abb037b408">&#9670;&nbsp;</a></span>baptize_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> baptize_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>field_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to make names for columns of a derived table replacing a scalar or table subquery. </p>
<p>Fields from the query block containing the scalar subquery are moved to the new derived table. We give them synthetic unique names here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>current session context </td></tr>
    <tr><td class="paramname">item</td><td>the item we want to name </td></tr>
    <tr><td class="paramname">field_no</td><td>the field number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error </dd></dl>

</div>
</div>
<a id="ga7e206bcdfc5e124b4e42d6c038a13830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e206bcdfc5e124b4e42d6c038a13830">&#9670;&nbsp;</a></span>build_sj_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::build_sj_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNESTED__JOIN.html">NESTED_JOIN</a> *&#160;</td>
          <td class="paramname"><em>nested_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>subq_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>outer_tables_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>sj_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build semijoin condition for th query block. </p>
<p>Build equality conditions using outer expressions and inner expressions.</p>
<p>If the equality condition is not constant, add it to the semi-join condition. Otherwise, evaluate it and remove the constant expressions from the outer/inner expressions list if the result is true. If the result is false, remove all the expressions in outer/inner expression list and attach an always false condition to semijoin condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nested_join</td><td>Join nest </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">subq_select</td><td>Query block for the subquery </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">outer_tables_map</td><td>Map of tables from original outer query block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sj_cond</td><td>Semi-join condition to be constructed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gab97c1c5e3436976d1cdf567658b7bef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97c1c5e3436976d1cdf567658b7bef5">&#9670;&nbsp;</a></span>build_sj_exprs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> build_sj_exprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>sj_outer_exprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>sj_inner_exprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__exists__subselect.html">Item_exists_subselect</a> *&#160;</td>
          <td class="paramname"><em>subq_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>subq_select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the list of SJ outer/inner expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Connection handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sj_outer_exprs</td><td>Will add outer expressions here </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sj_inner_exprs</td><td>Will add inner expressions here </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">subq_pred</td><td>Item for the subquery </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">subq_select</td><td>Single query block for the subquery</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error </dd></dl>

</div>
</div>
<a id="ga0f38f1ca240563f52e84cdbcf386389d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f38f1ca240563f52e84cdbcf386389d">&#9670;&nbsp;</a></span>can_decorrelate_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> can_decorrelate_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>only_eq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gadc5bf5220417914713a4400dfcac007f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc5bf5220417914713a4400dfcac007f">&#9670;&nbsp;</a></span>check_only_full_group_by()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::check_only_full_group_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs checks mandated by ONLY_FULL_GROUP_BY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if ONLY_FULL_GROUP_BY is violated. </dd></dl>

</div>
</div>
<a id="ga0b4ace215068ab770231a60a1f81eb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4ace215068ab770231a60a1f81eb14">&#9670;&nbsp;</a></span>check_view_privileges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::check_view_privileges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>want_privilege_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td>
          <td class="paramname"><em>want_privilege_next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check privileges for views that are merged into query block. </p>
<p>Check privileges for the view tables merged into a query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">want_privilege_first</td><td>Privileges requested for the first leaf. </td></tr>
    <tr><td class="paramname">want_privilege_next</td><td>Privileges requested for the remaining leaves.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Beware that it can't properly check privileges in cases when table being changed is not the first table in the list of leaf tables (for example, for multi-UPDATE).</dd>
<dd>
The inner loop is slightly inefficient. A view will have its privileges checked once for every base table that it refers to.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error. </dd></dl>

</div>
</div>
<a id="ga897e6cf09ad56bf0e50c19cc7a50161b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga897e6cf09ad56bf0e50c19cc7a50161b">&#9670;&nbsp;</a></span>clear_sj_expressions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::clear_sj_expressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structNESTED__JOIN.html">NESTED_JOIN</a> *&#160;</td>
          <td class="paramname"><em>nested_join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove semijoin condition for this query block. </p>
<p>Remove SJ outer/inner expressions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nested_join</td><td>join nest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe00266a53cac66e90cbbe78fbfa308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe00266a53cac66e90cbbe78fbfa308c">&#9670;&nbsp;</a></span>collect_aggregates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> collect_aggregates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structItem__sum_1_1Collect__grouped__aggregate__info.html">Item_sum::Collect_grouped_aggregate_info</a> *&#160;</td>
          <td class="paramname"><em>aggregates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A minion of transform_grouped_to_derived. </p>
<p>Collect a unique list of aggregate functions used in the transformed query block, which will need to be replaced with fields from the derived table containing the grouping during transform_grouped_to_derived.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>the query block </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aggregates</td><td>the accumulator which wll contain the aggregates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error </dd></dl>

</div>
</div>
<a id="ga733ceb7be0e16efcfadf33f18370b264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga733ceb7be0e16efcfadf33f18370b264">&#9670;&nbsp;</a></span>convert_subquery_to_semijoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::convert_subquery_to_semijoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__exists__subselect.html">Item_exists_subselect</a> *&#160;</td>
          <td class="paramname"><em>subq_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a subquery predicate of this query block into a TABLE_LIST semi-join nest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">subq_pred</td><td>Subquery predicate to be converted. This is either an IN, =ANY or EXISTS predicate, possibly negated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>The following transformations are performed:</p>
<ol type="1">
<li>IN/=ANY predicates on the form:</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM ot1 ... otN</div><div class="line"><a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> (oe1, ... oeM) IN (<a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ie1, ..., ieM</div><div class="line">                         <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> it1 ... itK</div><div class="line">                        [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> inner-cond])</div><div class="line"> [AND outer-cond]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><p>are transformed into:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM (ot1 ... otN) SJ (it1 ... itK)</div><div class="line">                   <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> (oe1, ... oeM) = (ie1, ..., ieM)</div><div class="line">                      [AND inner-cond]</div><div class="line">[<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> outer-cond]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><p>Notice that the inner-cond may contain correlated and non-correlated expressions. Further transformations will analyze and break up such expressions.</p>
<ol type="1">
<li>EXISTS predicates on the form:</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM ot1 ... otN</div><div class="line"><a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a3197625a1bb2264943f5a95f236d9973">EXISTS</a> (<a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> expressions</div><div class="line">              <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> it1 ... itK</div><div class="line">              [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> inner-cond])</div><div class="line"> [AND outer-cond]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><p>are transformed into:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM (ot1 ... otN) SJ (it1 ... itK)</div><div class="line">                   [<a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> inner-cond]</div><div class="line">[<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> outer-cond]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><ol type="1">
<li>Negated EXISTS predicates on the form:</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM ot1 ... otN</div><div class="line"><a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> NOT <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a3197625a1bb2264943f5a95f236d9973">EXISTS</a> (<a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> expressions</div><div class="line">              <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> it1 ... itK</div><div class="line">              [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> inner-cond])</div><div class="line"> [AND outer-cond]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><p>are transformed into:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM (ot1 ... otN) AJ (it1 ... itK)</div><div class="line">                   [<a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> inner-cond]</div><div class="line">[<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> outer-cond AND is-null-cond(it1)]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><p>where AJ means "antijoin" and is like a LEFT JOIN; and is-null-cond is false if the row of it1 is "found" and "not_null_compl" (i.e. matches inner-cond).</p>
<ol type="1">
<li>Negated IN predicates on the form:</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM ot1 ... otN</div><div class="line"><a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> (oe1, ... oeM) NOT IN (<a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ie1, ..., ieM</div><div class="line">                             <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> it1 ... itK</div><div class="line">                             [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> inner-cond])</div><div class="line"> [AND outer-cond]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><p>are transformed into:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM (ot1 ... otN) AJ (it1 ... itK)</div><div class="line">                   <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> (oe1, ... oeM) = (ie1, ..., ieM)</div><div class="line">                      [AND inner-cond]</div><div class="line">[<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> outer-cond]</div><div class="line">[GROUP <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...] [<a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a676aa1a12d99de7b8eede877acf0c644">HAVING</a> ...] [<a class="code" href="structORDER.html">ORDER</a> <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a8a7f2ff9fd0ff128eb1a14b98d95b4e6">BY</a> ...]</div></div><!-- fragment --><ol type="1">
<li>The cases 1/2 (respectively 3/4) above also apply when the predicate is decorated with IS TRUE or IS NOT FALSE (respectively IS NOT TRUE or IS FALSE). </li>
</ol>

</div>
</div>
<a id="ga956ea21a963da18fcadab759d770cc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga956ea21a963da18fcadab759d770cc84">&#9670;&nbsp;</a></span>create_rollup_switcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a> * create_rollup_switcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>send_group_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad94509e64d2172270748ae98561714b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad94509e64d2172270748ae98561714b2">&#9670;&nbsp;</a></span>decorrelate_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::decorrelate_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSemijoin__decorrelation.html">Semijoin_decorrelation</a> &amp;&#160;</td>
          <td class="paramname"><em>sj_decor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>join_nest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decorrelate the WHERE clause or a join condition of a subquery used in an IN or EXISTS predicate. </p>
<p>Correlated predicates are removed from the condition and added to the supplied semi-join nest. The predicate must be either a simple (in)equality, or an AND condition that contains one or more simple equalities, in order for decorrelation to be possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sj_decor</td><td>Object for recording the decorrelated expressions </td></tr>
    <tr><td class="paramname">join_nest</td><td>Nest containing join condition to be decorrelated =NULL: decorrelate the WHERE condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<h2>Decorrelation for subqueries containing non-deterministic components: </h2>
<p>There are two types of IN and EXISTS queries with non-deterministic functions that may be meaningful (the EXISTS queries below are correlated equivalents of the respective IN queries):</p>
<ol type="1">
<li>Non-deterministic function as substitute for expression from outer query block:</li>
</ol>
<p>A SELECT * FROM t1 WHERE RAND() IN (SELECT t2.x FROM t2)</p>
<p>B SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE RAND() = t2.x);</p>
<p>Pick a set of random rows that matches against a fixed set (the subquery).</p>
<p>The intuitive interpretation of the IN subquery is that the random function is evaluated per row of the outer query block, whereas in the EXISTS subquery, it should be evaluated per row of the inner query block, and the subquery is evaluated once per row of the outer query block.</p>
<ol type="1">
<li>Non-deterministic function as substitute for expression from inner query block:</li>
</ol>
<p>A SELECT * FROM t1 WHERE t1.x IN (SELECT RAND() FROM t2)</p>
<p>B SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE RAND() = t1.x);</p>
<p>This is another way of picking a random row, but now the non-determinism occurs in the inner query block.</p>
<p>The user will expect that only query 1A has the evaluation of non-deterministic functions being performed in the outer query block. Using decorrelation for query 1B would change the apparent semantics of the query.</p>
<p>The purpose of decorrelation is to be able to use more execution strategies. Without decorrelation, EXISTS is limited to FirstMatch and DupsWeedout strategies. Decorrelation enables LooseScan and Materialization. We can rule out LooseScan for case 2B, since it requires an indexed column from the subquery, and for case 1B, since it requires that the outer table is partitioned according to the distinct values of the index, and random values do not fulfill that partitioning requirement.</p>
<p>The only strategy left is Materialization. With decorrelation, 1B would be evaluated like 1A, which is not the intuitive way. 2B would also be implemented like 2A, meaning that evaluation of non-deterministic functions would move to the materialization function.</p>
<p>Thus, the intuitive interpretation is to avoid materialization for subqueries with non-deterministic components in the inner query block, and hence such predicates will not be decorrelated. </p>

</div>
</div>
<a id="ga892137f6ccc44fb66a0903511053edd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga892137f6ccc44fb66a0903511053edd3">&#9670;&nbsp;</a></span>decorrelate_equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> decorrelate_equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSemijoin__decorrelation.html">Semijoin_decorrelation</a> &amp;&#160;</td>
          <td class="paramname"><em>sj_decor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>was_correlated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to decorrelate an (in)equality node. </p>
<p>The node can be decorrelated if one argument contains only outer references and the other argument contains references only to local tables. Both arguments should be deterministic. const-for-execution values are accepted in both arguments.</p>
<dl class="section note"><dt>Note</dt><dd>that a predicate like '(a,b) IN ((c,d))' is changed to two equalities only during optimization, so at the present stage it isn't decorrelate-able.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sj_decor</td><td>Object for recording the decorrelated expressions </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">func</td><td>The query function node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">was_correlated</td><td>= true if comparison is correlated and the the expressions are added to sj_nest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga442db5eafc607d32a94161b3b3704270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga442db5eafc607d32a94161b3b3704270">&#9670;&nbsp;</a></span>delete_unused_merged_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::delete_unused_merged_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete unused columns from merged tables. </p>
<p>This function is called recursively for each join nest and/or table in the query block. For each merged table that it finds, each column that contains a subquery and is not marked as used is removed and the translation item is set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables</td><td>List of tables and join nests </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25eec45e0f11aa76f615858ab3940268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25eec45e0f11aa76f615858ab3940268">&#9670;&nbsp;</a></span>empty_order_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::empty_order_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>sl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the ORDER list. </p>
<p>Delete corresponding elements from fields and base_ref_items too. If ORDER list contain any subqueries, delete them from the query block list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>Query block that possible subquery blocks in the ORDER BY clause are attached to (may be different from "this" when query block has been merged into an outer query block). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d06fa8691a8cf08960649a015314421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d06fa8691a8cf08960649a015314421">&#9670;&nbsp;</a></span>field_list_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::field_list_is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1758a9acf5e1cf389124476a7159a49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1758a9acf5e1cf389124476a7159a49e">&#9670;&nbsp;</a></span>find_in_group_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structORDER.html">ORDER</a> * SELECT_LEX::find_in_group_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rollup_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a group expression matching the given item, or nullptr if none. </p>
<p>When there are multiple candidates, ones that match in name are given priority (such that a AS c GROUP BY a,b,c resolves to c, not a); if there is still a tie, the leftmost is given priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">item</td><td>The item to search for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rollup_level</td><td>If not nullptr, will be set to the group expression's index (0-based). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96d20206b97e71f10cd83790dc107834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96d20206b97e71f10cd83790dc107834">&#9670;&nbsp;</a></span>find_order_in_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> find_order_in_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_group_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_window_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve an ORDER BY or GROUP BY column reference. </p>
<p>Given a column reference (represented by 'order') from a GROUP BY or ORDER BY clause, find the actual column it represents. If the column being resolved is from the GROUP BY clause, the procedure searches the SELECT list 'fields' and the columns in the FROM list 'tables'. If 'order' is from the ORDER BY clause, only the SELECT list is being searched.</p>
<p>If 'order' is resolved to an Item, then order-&gt;item is set to the found Item. If there is no item for the found column (that is, it was resolved into a table field), order-&gt;item is 'fixed' and is added to fields and ref_item_array.</p>
<p>ref_item_array and fields are updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Pointer to current thread structure </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref_item_array</td><td>All select, group and order by fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tables</td><td>List of tables to search in (usually FROM clause) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Column reference to be resolved </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fields</td><td>List of fields to search in (usually SELECT list; hidden items are ignored) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_group_field</td><td>True if order is a GROUP field, false if ORDER by field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_window_order</td><td>True if order is a Window function's PARTITION BY or ORDER BY field</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if OK </td></tr>
    <tr><td class="paramname">true</td><td>if error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a54069770520d871a999a6d3a4681ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a54069770520d871a999a6d3a4681ba">&#9670;&nbsp;</a></span>fix_after_pullout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX_UNIT::fix_after_pullout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>parent_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>removed_select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fix used tables information for a subquery after query transformations. </p>
<p>This is for transformations where the subquery remains a subquery - it is not merged, it merely moves up by effect of a transformation on a containing query block. Most actions here involve re-resolving information for conditions and items belonging to the subquery. If the subquery contains an outer reference into removed_select or parent_select, the relevant information is updated by Item_ident::fix_after_pullout(). </p>

</div>
</div>
<a id="gac88762aa247c2005bc2c66bacd1eb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac88762aa247c2005bc2c66bacd1eb0f8">&#9670;&nbsp;</a></span>fix_after_pullout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::fix_after_pullout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>parent_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>removed_select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>SELECT_LEX_UNIT::fix_after_pullout </dd></dl>

</div>
</div>
<a id="ga33c8e6170b900f16b4a9716fab93be8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33c8e6170b900f16b4a9716fab93be8e">&#9670;&nbsp;</a></span>fix_tables_after_pullout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fix_tables_after_pullout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>parent_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>removed_select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>table_adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>lateral_deps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update table reference information for conditions and expressions due to query blocks having been merged in from derived tables/views and due to semi-join transformation. </p>
<p>This is needed for two reasons:</p>
<ol type="1">
<li>Since table numbers are changed, we need to update used_tables information for all conditions and expressions that are possibly touched.</li>
<li>For semi-join, some column references are changed from outer references to local references.</li>
</ol>
<p>The function needs to recursively walk down into join nests, in order to cover all conditions and expressions.</p>
<p>For a semi-join, tables from the subquery are added last in the query block. This means that conditions and expressions from the outer query block are unaffected. But all conditions inside the semi-join nest, including join conditions, must have their table numbers changed.</p>
<p>For a derived table/view, tables from the subquery are merged into the outer query, and this function is called for every derived table that is merged in. This algorithm only works when derived tables are merged in the order of their original table numbers.</p>
<p>A hypothetical example with a triple self-join over a mergeable view:</p>
<p>CREATE VIEW v AS SELECT t1.a, t2.b FROM t1 JOIN t2 USING (a); SELECT v1.a, v1.b, v2.b, v3.b FROM v AS v1 JOIN v AS v2 ON ... JOIN v AS v3 ON ...;</p>
<p>The analysis starts with three tables v1, v2 and v3 having numbers 0, 1, 2. First we merge in v1, so we get (t1, t2, v2, v3). v2 and v3 are shifted up. Tables from v1 need to have their table numbers altered (actually they do not since both old and new numbers are 0 and 1, but this is a special case). v2 and v3 are not merged in yet, so we delay pullout on them until they are merged. Conditions and expressions from the outer query are not resolved yet, so regular resolving will take of them later. Then we merge in v2, so we get (t1, t2, t1, t2, v3). The tables from this view gets numbers 2 and 3, and v3 gets number 4. Because v2 had a higher number than the tables from v1, the join nest representing v1 is unaffected. And v3 is still not merged, so the only join nest we need to consider is v2. Finally we merge in v3, and then we have tables (t1, t2, t1, t2, t1, t2), with numbers 0 through 5. Again, since v3 has higher number than any of the already merged in views, only this join nest needs the pullout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_select</td><td>Query block being merged into </td></tr>
    <tr><td class="paramname">removed_select</td><td>Query block that is removed (subquery) </td></tr>
    <tr><td class="paramname">tr</td><td>Table object this pullout is applied to </td></tr>
    <tr><td class="paramname">table_adjust</td><td>Number of positions that a derived table nest is adjusted, used to fix up semi-join related fields. Tables are adjusted from position N to N+table_adjust </td></tr>
    <tr><td class="paramname">lateral_deps</td><td>Lateral dependencies of the unit owning removed_select </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5982f458294ba69e9f79a9219985a6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5982f458294ba69e9f79a9219985a6c4">&#9670;&nbsp;</a></span>flatten_subqueries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::flatten_subqueries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert semi-join subquery predicates into semi-join join nests. </p>
<p>Convert candidate subquery predicates into semi-join join nests. This transformation is performed once in query lifetime and is irreversible.</p>
<h2>Conversion of one subquery predicate </h2>
<p>We start with a query block that has a semi-join subquery predicate:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM ot, ...</div><div class="line">WHERE oe IN (<a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ie <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> it1 ... itN <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> subq_where) AND outer_where</div></div><!-- fragment --><p>and convert the predicate and subquery into a semi-join nest:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> ...</div><div class="line">FROM ot <a class="code" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395da69465caf22e5d212cbe4bbc87b1bf770">SEMI</a> <a class="code" href="classJOIN.html">JOIN</a> (it1 ... itN), ...</div><div class="line">WHERE outer_where AND subq_where AND oe=ie</div></div><!-- fragment --><p>that is, in order to do the conversion, we need to</p>
<p>Create the "SEMI JOIN (it1 .. itN)" part and add it into the parent query block's FROM structure. Add "AND subq_where AND oe=ie" into parent query block's WHERE (or ON if the subquery predicate was in an ON condition) Remove the subquery predicate from the parent query block's WHERE</p>
<h2>Considerations when converting many predicates </h2>
<p>A join may have at most MAX_TABLES tables. This may prevent us from flattening all subqueries when the total number of tables in parent and child selects exceeds MAX_TABLES. In addition, one slot is reserved per semi-join nest, in case the subquery needs to be materialized in a temporary table. We deal with this problem by flattening children's subqueries first and then using a heuristic rule to determine each subquery predicate's priority, which is calculated in this order:</p>
<ol type="1">
<li>Prefer dependent subqueries over non-dependent ones</li>
<li>Prefer subqueries with many tables over those with fewer tables</li>
<li>Prefer early subqueries over later ones (to make sort deterministic)</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga82613eb3ef5de00fb0a376c920f109da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82613eb3ef5de00fb0a376c920f109da">&#9670;&nbsp;</a></span>group_list_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SELECT_LEX::group_list_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad5849f7c2d87f629f169af2b05bfca5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5849f7c2d87f629f169af2b05bfca5f">&#9670;&nbsp;</a></span>is_in_select_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::is_in_select_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3f8c2c9e2a729cddae1337f6c3c35ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8c2c9e2a729cddae1337f6c3c35ed6">&#9670;&nbsp;</a></span>is_row_count_valid_for_semi_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::is_row_count_valid_for_semi_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the offset and limit are valid for a semijoin. </p>
<p>A semijoin can be used only if OFFSET is 0 and select LIMIT is not 0.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if OFFSET and LIMIT does not permit a semijoin, </td></tr>
    <tr><td class="paramname">true</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ea29ee893a4f166204186c7e23d7876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea29ee893a4f166204186c7e23d7876">&#9670;&nbsp;</a></span>make_leaf_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>** make_leaf_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make list of leaf tables of join table tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to pointer on list first element Must be set to NULL before first (recursive) call </td></tr>
    <tr><td class="paramname">tables</td><td>table list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer on pointer to next_leaf of last element </dd></dl>

</div>
</div>
<a id="gab09beb6a36689d47b05b0e5d3a1ec8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09beb6a36689d47b05b0e5d3a1ec8a5">&#9670;&nbsp;</a></span>mark_item_as_maybe_null_if_rollup_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::mark_item_as_maybe_null_if_rollup_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks occurrences of group by fields in a function's arguments as maybe_null, so that we do not optimize them away before we get to add the rollup wrappers. </p>

</div>
</div>
<a id="gad5477c6e5acafac963014e5887546d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5477c6e5acafac963014e5887546d84">&#9670;&nbsp;</a></span>merge_contexts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::merge_contexts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>inner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge name resolution context objects of a subquery into its parent. </p>
<p>Merge name resolution context objects belonging to an inner subquery to parent query block.</p>
<p>Update all context objects to have this base query block. Used when a subquery's query block is merged into its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inner</td><td>Subquery for which context objects are to be merged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7369c8cabfbba4502ee79d30391adb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7369c8cabfbba4502ee79d30391adb6">&#9670;&nbsp;</a></span>merge_derived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::merge_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>derived_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge derived table into query block. </p>
<p>Merge a derived table or view into a query block.</p>
<p>If some constraint prevents the derived table from being merged then do nothing, which means the table will be prepared for materialization later.</p>
<p>After this call, check is_merged() to see if the table was really merged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">derived_table</td><td>Derived table which is to be merged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>
<p>A view is updatable if any underlying table is updatable. A view is insertable-into if all underlying tables are insertable. A view is not updatable nor insertable if it contains an outer join </p><dl class="section see"><dt>See also</dt><dd>mysql_register_view()</dd></dl>

</div>
</div>
<a id="ga31ebaa76013b8495ccc3102da02b8f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ebaa76013b8495ccc3102da02b8f61">&#9670;&nbsp;</a></span>nest_derived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::nest_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>join_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>nested_join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>derived_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the generated derived table to the correct location inside a join nest. </p>
<p>It will be nested in a new nest along with the outer table to the join which owns the search condition in which we found the scalar subquery. For example: </p><pre class="fragment">select t1.i,
       t2.i
from t1
     left outer join
     t2 on
     (t1.i &lt; (select max(t2.i) from t2));

in transformed to

select t1.i,
       t2.i
from t1
     left join
     (select max(t2.i) AS `max(t2.i)` from t2) derived_1_0   [*]
     on(true)
     left join
     t2
     on((t1.i &lt; derived_1_0.`max(t2.i)`))
</pre><p>[*]: the derived table is nested in here, just ahead of the inner table t2 to which the join condition is attached.</p>
<p>In the original join nest before transformation may look like this (the join order list is reversed relative to the logical order):</p>
<p>(nest_join) t2 LEFT OUTER ON .. = .. (inner table) t1 (outer table)</p>
<p>After the transformation we have this nest structure:</p>
<p>(nest_join) t2 LEFT OUTER ON .. = .. (nest_last_join) derived_1_0 LEFT OUTER ON true t1</p>
<p>The method will recursively inspect and rebuild join nests as needed since the join with the condition may be deeply nested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the session context </td></tr>
    <tr><td class="paramname">join_cond</td><td>the join condition which identifies the join we want to nest into </td></tr>
    <tr><td class="paramname">nested_join_list</td><td>the join list at the current nesting level </td></tr>
    <tr><td class="paramname">derived_table</td><td>the table we want to nest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error </dd></dl>

</div>
</div>
<a id="ga464660f516e359dd7ab6577d76641b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464660f516e359dd7ab6577d76641b5c">&#9670;&nbsp;</a></span>num_visible_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SELECT_LEX::num_visible_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab00c376fc680198f677019b5db776cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab00c376fc680198f677019b5db776cc0">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>insert_field_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare query block for optimization. </p>
<p>Resolve table and column information. Resolve all expressions (item trees), ie WHERE clause, join conditions, GROUP BY clause, HAVING clause, ORDER BY clause, LIMIT clause. Prepare all subqueries recursively as part of resolving the expressions. Apply permanent transformations to the abstract syntax tree, such as semi-join transformation, derived table transformation, elimination of constant values and redundant clauses (e.g ORDER BY, GROUP BY).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">insert_field_list</td><td>List of fields when used in INSERT, otherwise NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>on privilege checking for SELECT query that possibly contains view or derived table references:</dd></dl>
<ul>
<li>When this function is called, it is assumed that the precheck() function has been called. precheck() ensures that the user has some SELECT privileges to the tables involved in the query. When resolving views it has also been established that the user has some privileges for them. To prepare a view for privilege checking, it is also needed to call check_view_privileges() after views have been merged into the query. This is not necessary for unnamed derived tables since it has already been established that we have SELECT privileges for the underlying tables by the precheck functions. (precheck() checks a query without resolved views, ie. before tables are opened, so underlying tables of views are not yet available).</li>
<li>When a query block is resolved, always ensure that the user has SELECT privileges to the columns referenced in the WHERE clause, the join conditions, the GROUP BY clause, the HAVING clause and the ORDER BY clause.</li>
<li>When resolving the outer-most query block, ensure that the user also has SELECT privileges to the columns in the selected expressions.</li>
<li>When setting up a derived table or view for materialization, ensure that the user has SELECT privileges to the columns in the selected expressions</li>
<li>Column privileges are normally checked by Item_field::fix_fields(). Exceptions are select list of derived tables/views which are checked in TABLE_LIST::setup_materialized_derived(), and natural/using join conditions that are checked in mark_common_columns().</li>
<li>As far as INSERT, UPDATE and DELETE statements have the same expressions as a SELECT statement, this note applies to those statements as well. </li>
</ul>

</div>
</div>
<a id="ga007e1f511d66aaa56caf2b680d9d6ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007e1f511d66aaa56caf2b680d9d6ca4">&#9670;&nbsp;</a></span>prepare_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::prepare_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare a table value constructor query block for optimization. </p>
<p>In the case of a table value constructor SELECT_LEX, we return the result of this function from SELECT_LEX::prepare, instead of doing the standard prepare routine.</p>
<p>For a table value constructor block, most preparation of a standard SELECT_LEX becomes irrelevant (in particular INTO, FROM, WHERE, GROUP, HAVING and WINDOW). We therefore substitute the standard resolving routine with this one, which is simply responsible for resolving the expressions contained in VALUES, as well as the query result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gac23df2771487d13fa777ff40f2a91f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23df2771487d13fa777ff40f2a91f03">&#9670;&nbsp;</a></span>propagate_nullability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void propagate_nullability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>nullable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate nullability into inner tables of outer join operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables</td><td>List of tables and join nests, start at top_join_list </td></tr>
    <tr><td class="paramname">nullable</td><td>true: Set all underlying tables as nullable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga027e11a56eb53f508f35de88e1d780b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga027e11a56eb53f508f35de88e1d780b9">&#9670;&nbsp;</a></span>propagate_unique_test_exclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::propagate_unique_test_exclusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate exclusion from table uniqueness test into subqueries. </p>
<p>Propagate exclusion from unique table check into all subqueries belonging to this query block.</p>
<p>This function can be applied to all subqueries of a materialized derived table or view. </p>

</div>
</div>
<a id="ga85e1a6190e571a9ba5b0083ef94a72bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e1a6190e571a9ba5b0083ef94a72bd">&#9670;&nbsp;</a></span>push_conditions_to_derived_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::push_conditions_to_derived_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes parts of the WHERE condition of this query block to materialized derived tables. </p>

</div>
</div>
<a id="gaa85b6803cb6287d4419794417a785b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85b6803cb6287d4419794417a785b0f">&#9670;&nbsp;</a></span>query_block_contains_subquery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> query_block_contains_subquery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *&#160;</td>
          <td class="paramname"><em>slu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A minion of transform_scalar_subqueries_to_join_with_derived. </p>
<p>Determine if the query expression is directly contained in the query block, i.e. it is a subquery.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select</td><td>the query block </td></tr>
    <tr><td class="paramname">slu</td><td>the query expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if slu is directly contained in select, else false </dd></dl>

</div>
</div>
<a id="gab2683e4324084327d2173f5e169970f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2683e4324084327d2173f5e169970f8">&#9670;&nbsp;</a></span>record_join_nest_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::record_join_nest_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record join nest info in the select block. </p>
<p>After simplification of inner join, outer join and semi-join structures:</p><ul>
<li>record the remaining semi-join structures in the enclosing query block.</li>
<li>record transformed join conditions in TABLE_LIST objects.</li>
</ul>
<p>This function is called recursively for each join nest and/or table in the query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables</td><td>List of tables and join nests</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if successful, True if failure </dd></dl>

</div>
</div>
<a id="ga53f9bf5300020a533f0b37a77d409e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f9bf5300020a533f0b37a77d409e05">&#9670;&nbsp;</a></span>remap_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::remap_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-map table numbers for all tables in a query block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function needs to be called after setup_tables() has been called, and after a query block for a subquery has been merged into a parent quary block. </dd></dl>

</div>
</div>
<a id="ga12c036ee90842621066feb4ab662238d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c036ee90842621066feb4ab662238d">&#9670;&nbsp;</a></span>remember_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void remember_transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remember if this transform was performed. </p>
<p>It it was done by a secondary engine, it may need to be rolled back before falling back on primary engine execution. </p>

</div>
</div>
<a id="ga7125444662147b07d8709d90755d9d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7125444662147b07d8709d90755d9d18">&#9670;&nbsp;</a></span>remove_aggregates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::remove_aggregates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A minion of transform_grouped_to_derived. </p>
<p>"Remove" any non-window aggregate functions from fields unconditionally. If such an aggregate is found, the query block should have a HAVING clause. This is asserted in debug mode. We "remove" them by replacing them with an Item_int, which should have no adverse effects. This avoids creating trouble for SELECT_LEX::add_hidden_item which would otherwise need to keep track of removed items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>session context </td></tr>
    <tr><td class="paramname">select</td><td>the query block whose aggregates are being moved into a derived table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error, else false </dd></dl>

</div>
</div>
<a id="ga2355935a856b96d20154f625c270c4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2355935a856b96d20154f625c270c4a1">&#9670;&nbsp;</a></span>remove_derived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::remove_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a derived table we added previously as part of transform_scalar_subqueries_to_join_with_derived. </p>
<p>This can happen when the transformed scalar subquery is part of a view that is not used in a query block referencing the view, e.g. if the view has a scalar subquery in the select list and this field is not referenced by the query invoking the view.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session state </td></tr>
    <tr><td class="paramname">tl</td><td>The derived table that should be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7cbe4d9794ec1604d4ab83b1790089a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cbe4d9794ec1604d4ab83b1790089a9">&#9670;&nbsp;</a></span>remove_hidden_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::remove_hidden_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga427605dcf22bf2cbb504670590a7fdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga427605dcf22bf2cbb504670590a7fdda">&#9670;&nbsp;</a></span>remove_hidden_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::remove_hidden_items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove hidden items from select list. </p>

</div>
</div>
<a id="gab44cffd351367ad92dc2386800c6fa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab44cffd351367ad92dc2386800c6fa72">&#9670;&nbsp;</a></span>remove_redundant_subquery_clauses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::remove_redundant_subquery_clauses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hidden_group_field_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a table subquery predicate (IN/ANY/ALL/EXISTS/etc): since it does not support LIMIT the following clauses are redundant: </p>
<p>ORDER BY DISTINCT GROUP BY if there are no aggregate functions and no HAVING clause</p>
<p>For a scalar subquery without LIMIT: ORDER BY is redundant, as the number of rows to order must be 1.</p>
<p>This removal is permanent. Thus, it only makes sense to call this function for regular queries and on first execution of SP/PS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">hidden_group_field_count</td><td>Number of hidden group fields added by setup_group(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d156b041d3eb35f9f4fbdbe26f831b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d156b041d3eb35f9f4fbdbe26f831b4">&#9670;&nbsp;</a></span>replace_aggregate_in_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> replace_aggregate_in_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structItem_1_1Aggregate__replacement.html">Item::Aggregate_replacement</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>was_hidden</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a> *&#160;</td>
          <td class="paramname"><em>ref_item_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A minion of transform_grouped_to_derived. </p>
<p>Replace occurrences of the aggregate function identified in info.m_target with the the field info.m_replacement in the expressions contained in list. Note that since this is part of a permanent transformation, we use the extra m_permanent_transform flag in the THD</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>a tuple containing {aggregate, replacement field} </td></tr>
    <tr><td class="paramname">was_hidden</td><td>true if the aggregate was originally hidden </td></tr>
    <tr><td class="paramname">list</td><td>the list of expressions </td></tr>
    <tr><td class="paramname">ref_item_array</td><td>to be kept in sync with any changes in 'list'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error (can not happen currently unless replacement field is empty) </dd></dl>

</div>
</div>
<a id="ga75fb90f2c229da82ef0c2b32b562391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75fb90f2c229da82ef0c2b32b562391d">&#9670;&nbsp;</a></span>replace_subcondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> replace_subcondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>old_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>new_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>do_fix_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>found_ptr</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructively replaces a sub-condition inside a condition tree. </p>
<p>The parse tree is also altered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tree</td><td>Must be the handle to the top level condition. This is needed when the top-level condition changes.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">old_cond</td><td>The condition to be replaced.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_cond</td><td>The condition to be substituted.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">do_fix_fields</td><td>If true, Item::fix_fields(THD*, Item**) is called for the new condition.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found_ptr</td><td>Pointer to boolean; used only in recursive sub-calls; top call must not specify this argument. Function deposits there if it found the searched Item or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If there was an error. </td></tr>
    <tr><td class="paramname">false</td><td>If successful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03881e87ddb8f2f363841e9ed0367885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03881e87ddb8f2f363841e9ed0367885">&#9670;&nbsp;</a></span>replace_subquery_in_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::replace_subquery_in_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__singlerow__subselect.html">Item_singlerow_subselect</a> *&#160;</td>
          <td class="paramname"><em>subquery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A minion of transform_scalar_subqueries_to_join_with_derived. </p>
<p>A transform creates a field representing the value of the derived table and adds it as a hidden field to the select list. Next, it replaces the subquery in the item tree with this field. If we replace in a HAVING condition, we build an Item_ref, cf. PTI_simple_ident_ident::itemize which also creates a Item_ref for a field reference in HAVING, because we may need to access the field in a tmp table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The session context </td></tr>
    <tr><td class="paramname">subquery</td><td>The scalar subquery </td></tr>
    <tr><td class="paramname">tr</td><td>The table reference for the derived table </td></tr>
    <tr><td class="paramname">expr</td><td>The expression we are replacing (in) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2077984f062da999b6a838f340d45bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2077984f062da999b6a838f340d45bad">&#9670;&nbsp;</a></span>repoint_contexts_of_join_nests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::repoint_contexts_of_join_nests </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt;&#160;</td>
          <td class="paramname"><em>join_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go through a list of tables and join nests, recursively, and repoint its select_lex pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td>List of tables and join nests </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7255a73df6040c4c6c86a300147cb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7255a73df6040c4c6c86a300147cb2d">&#9670;&nbsp;</a></span>reset_nj_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::reset_nj_counters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_list</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set NESTED_JOIN::counter=0 in all nested joins in passed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td>Pass NULL. Non-NULL is reserved for recursive inner calls, then it is a list of nested joins to process, and may also contain base tables which will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5c69f592ab3290deb79d3e43fc69a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c69f592ab3290deb79d3e43fc69a39">&#9670;&nbsp;</a></span>resolve_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::resolve_limits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve OFFSET and LIMIT clauses. </p>
<p>Resolve OFFSET and LIMIT clauses for a query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>OFFSET and LIMIT clauses may be attached to query blocks that make up a query expression. OFFSET and LIMIT clauses that apply to a whole query expression are attached to the fake_select_lex, hence we can use this interface to resolve them as well.</p>
<p>OFFSET and LIMIT may be unsigned integer literal values or parameters. If parameters, ensure that the type is unsigned integer. </p>

</div>
</div>
<a id="ga3b320ecec153602b0fa516cee89f47c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b320ecec153602b0fa516cee89f47c1">&#9670;&nbsp;</a></span>resolve_placeholder_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::resolve_placeholder_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>apply_semijoin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve derived table, view, table function information for a query block. </p>
<p>Resolve derived table, view or table function references in query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD. </td></tr>
    <tr><td class="paramname">apply_semijoin</td><td>if true, apply semi-join transform when possible</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gae200ff649d7c7e81b67b0ef6d544e0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae200ff649d7c7e81b67b0ef6d544e0f9">&#9670;&nbsp;</a></span>resolve_rollup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::resolve_rollup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve items in SELECT list and ORDER BY list for rollup processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>session context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga5e696bf85b415c62ee4ec53bd59ee5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e696bf85b415c62ee4ec53bd59ee5b0">&#9670;&nbsp;</a></span>resolve_rollup_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a> * SELECT_LEX::resolve_rollup_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve an item (and its tree) for rollup processing by replacing items matching grouped expressions with Item_rollup_group_items and updating properties (maybe_null, PROP_ROLLUP_FIELD). </p>
<p>Also check any GROUPING function for incorrect column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>session context </td></tr>
    <tr><td class="paramname">item</td><td>the item to be processed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new item, or nullptr on error </dd></dl>

</div>
</div>
<a id="ga05f5892b0f0659d116a0451a04a8ceba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05f5892b0f0659d116a0451a04a8ceba">&#9670;&nbsp;</a></span>resolve_rollup_wfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::resolve_rollup_wfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace group by field references inside window functions with references in the the presence of ROLLUP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>session context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga02fc7f4d394b3a7e60ad446a89e018e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02fc7f4d394b3a7e60ad446a89e018e1">&#9670;&nbsp;</a></span>resolve_subquery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::resolve_subquery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve predicate involving subquery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Error.</td></tr>
  </table>
  </dd>
</dl>
<p>Perform early unconditional subquery transformations:</p><ul>
<li>Convert subquery predicate into semi-join, or</li>
<li>Mark the subquery for execution using materialization, or</li>
<li>Perform IN-&gt;EXISTS transformation, or</li>
<li>Perform more/less ALL/ANY -&gt; MIN/MAX rewrite</li>
<li>Substitute trivial scalar-context subquery with its value</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In this case: IN (SELECT ... UNION SELECT ...), SELECT_LEX::prepare() is called for each of the two UNION members, and in those two calls, subq_predicate is the same, not sure this is desired (double work?).</dd></dl>

</div>
</div>
<a id="gab7348b6f26a85ebb98a8a083d729ac55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7348b6f26a85ebb98a8a083d729ac55">&#9670;&nbsp;</a></span>resolve_table_value_constructor_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::resolve_table_value_constructor_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve the rows of a table value constructor and aggregate the type of each column across rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga84010d8344698949eb7e533bedc83fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84010d8344698949eb7e533bedc83fc4">&#9670;&nbsp;</a></span>setup_conds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::setup_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve WHERE condition and join conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga9a20927f8acb89fcadaa0140f6ee8986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a20927f8acb89fcadaa0140f6ee8986">&#9670;&nbsp;</a></span>setup_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::setup_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve and set up the GROUP BY list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gacce084e0bb33ae16cd6480b0e6555dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce084e0bb33ae16cd6480b0e6555dfb">&#9670;&nbsp;</a></span>setup_join_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::setup_join_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>in_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve join conditions for a join nest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>List of tables with join conditions </td></tr>
    <tr><td class="paramname">in_update</td><td>True if used in update command that may have CHECK OPTION</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga3908f32196b05aaea56ee94bf46b420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3908f32196b05aaea56ee94bf46b420a">&#9670;&nbsp;</a></span>setup_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> setup_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="item_8h.html#a392729560d867373048ed76e4dfff81e">Ref_item_array</a>&#160;</td>
          <td class="paramname"><em>ref_item_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structORDER.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve and setup list of expressions in ORDER BY clause. </p>
<p>Change order to point at item in select list. If item isn't a number and doesn't exists in the select list, add it to the the field list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Current session. </td></tr>
    <tr><td class="paramname">ref_item_array</td><td>The Ref_item_array for this query block. </td></tr>
    <tr><td class="paramname">tables</td><td>From clause of the query. </td></tr>
    <tr><td class="paramname">fields</td><td>All columns, including hidden ones. </td></tr>
    <tr><td class="paramname">order</td><td>The query block's order clause.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error. </dd></dl>

</div>
</div>
<a id="ga324abeccb51b4dcfe4c84d0118eb5a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga324abeccb51b4dcfe4c84d0118eb5a03">&#9670;&nbsp;</a></span>setup_order_final()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::setup_order_final </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do final setup of ORDER BY clause, after the query block is fully resolved. </p>
<p>Check that ORDER BY clause is not redundant. Split any aggregate functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga0b89278da111abc564aa45b95559422b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b89278da111abc564aa45b95559422b">&#9670;&nbsp;</a></span>setup_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::setup_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>select_insert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve and prepare information about tables for one query block. </p>
<p>Set up table leaves in the query block based on list of tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>List of tables to handle </td></tr>
    <tr><td class="paramname">select_insert</td><td>It is SELECT ... INSERT command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Check also that the 'used keys' and 'ignored keys' exists and set up the table structure accordingly. Create a list of leaf tables.</dd></dl>
<p>This function has to be called for all tables that are used by items, as otherwise table-&gt;map is not set and all Item_field will be regarded as const items.</p>
<dl class="section return"><dt>Returns</dt><dd>False on success, true on error </dd></dl>

</div>
</div>
<a id="gaf87c9ecbe9600ae5d51b93de40fc4acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf87c9ecbe9600ae5d51b93de40fc4acf">&#9670;&nbsp;</a></span>setup_wild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::setup_wild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand all '*' in list of expressions with the matching column references. </p>
<p>Function should not be called with no wild cards in select list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if OK, true if error </dd></dl>

</div>
</div>
<a id="gacb44a212437f0255c2f223ad2121fcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb44a212437f0255c2f223ad2121fcd9">&#9670;&nbsp;</a></span>simplify_const_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> simplify_const_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>remove_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>ret_cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to replace a const condition with a simple constant. </p>
<p>A true condition is replaced with an empty item pointer if remove_cond is true. Else it is replaced witha a constant TRUE. A false condition is replaced with the constant FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cond</td><td>Address of condition, may be substituted with a literal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove_cond</td><td>If true removes a "true" condition. Else replaces it with a constant TRUE. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ret_cond_value</td><td>Store the result of the evaluated const condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga8d190c423c845ae4ae06a468cb0895fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d190c423c845ae4ae06a468cb0895fc">&#9670;&nbsp;</a></span>simplify_joins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::simplify_joins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>in_sj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> *&#160;</td>
          <td class="paramname"><em>changelog</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify joins replacing outer joins by inner joins whenever it's possible. </p>
<p>The function, during a retrieval of join_list, eliminates those outer joins that can be converted into inner join, possibly nested. It also moves the join conditions for the converted outer joins and from inner joins to conds. The function also calculates some attributes for nested joins:</p>
<ol type="1">
<li>used_tables</li>
<li>not_null_tables</li>
<li>dep_tables.</li>
<li>join_cond_dep_tables</li>
</ol>
<p>The first two attributes are used to test whether an outer join can be substituted by an inner join. The third attribute represents the relation 'to be dependent on' for tables. If table t2 is dependent on table t1, then in any evaluated execution plan table access to table t2 must precede access to table t2. This relation is used also to check whether the query contains invalid cross-references. The fourth attribute is an auxiliary one and is used to calculate dep_tables. As the attribute dep_tables qualifies possibles orders of tables in the execution plan, the dependencies required by the straight join modifiers are reflected in this attribute as well. The function also removes all parentheses that can be removed from the join expression without changing its meaning.</p>
<dl class="section note"><dt>Note</dt><dd>An outer join can be replaced by an inner join if the where condition or the join condition for an embedding nested join contains a conjunctive predicate rejecting null values for some attribute of the inner tables.</dd></dl>
<p>E.g. in the query: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t2 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t1.a <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t2.b &lt; 5</div></div><!-- fragment --><p> the predicate t2.b &lt; 5 rejects nulls. The query is converted first to: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="row__iterator_8h.html#aef400c43b34e3ecc3f7b342aa821395dac4540d3222d43c398e55b47cb3846a40">INNER</a> <a class="code" href="classJOIN.html">JOIN</a> t2 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t1.a <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t2.b &lt; 5</div></div><!-- fragment --><p> then to the equivalent form: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1, t2 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t1.a <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t2.b &lt; 5 AND t2.a=t1.a</div></div><!-- fragment --><p>Similarly the following query: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * from t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> (t2, t3) <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t1.a t3.b=t1.b</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t2.c &lt; 5</div></div><!-- fragment --><p> is converted to: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1, (t2, t3) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t2.c &lt; 5 AND t2.a=t1.a t3.b=t1.b</div></div><!-- fragment --><p>One conversion might trigger another: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t2 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t1.a</div><div class="line">                 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t3 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t3.b=t2.b</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t3 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a6cc1972e6d9d37556d516f78205a682b">IS</a> NOT <a class="code" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> =&gt;</div><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t2 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t1.a, t3</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t3 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a6cc1972e6d9d37556d516f78205a682b">IS</a> NOT NULL AND t3.b=t2.b =&gt;</div><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1, t2, t3</div><div class="line">  <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t3 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a6cc1972e6d9d37556d516f78205a682b">IS</a> NOT NULL AND t3.b=t2.b AND t2.a=t1.a</div></div><!-- fragment --><p>The function removes all unnecessary parentheses from the expression produced by the conversions. E.g. </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1, (t2, t3) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t2.c &lt; 5 AND t2.a=t1.a AND t3.b=t1.b</div></div><!-- fragment --><p> finally is converted to: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1, t2, t3 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t2.c &lt; 5 AND t2.a=t1.a AND t3.b=t1.b</div></div><!-- fragment --><p>It also will remove parentheses from the following queries: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * from (t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t2 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t1.a) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t3 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t3.b=t2.b</div><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * from (t1, (t2,t3)) <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a0116b78582fbf1fd6e069fde8dd308c4">WHERE</a> t1.a=t2.a AND t2.b=t3.b.</div></div><!-- fragment --><p>The benefit of this simplification procedure is that it might return a query for which the optimizer can evaluate execution plans with more join orders. With a left join operation the optimizer does not consider any plan where one of the inner tables is before some of outer tables.</p>
<p>IMPLEMENTATION The function is implemented by a recursive procedure. On the recursive ascent all attributes are calculated, all outer joins that can be converted are replaced and then all unnecessary parentheses are removed. As join list contains join tables in the reverse order sequential elimination of outer joins does not require extra recursive calls.</p>
<p>SEMI-JOIN NOTES Remove all semi-joins that have are within another semi-join (i.e. have an "ancestor" semi-join nest)</p>
<p>EXAMPLES Here is an example of a join query with invalid cross references: </p><div class="fragment"><div class="line"><a class="code" href="namespaceconsts.html#ae42e6bb9561cb112c8df234e2d9ed34a">SELECT</a> * <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9a60efb85363b2afd235602dc0aee155f0">FROM</a> t1 <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t2 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t2.a=t3.a <a class="code" href="sql__yacc_8h.html#a15c9f7bd2f0e9686df5d9df4f3314aa9adb45120aafd37a973140edee24708065">LEFT</a> <a class="code" href="classJOIN.html">JOIN</a> t3 <a class="code" href="parser__yystype_8h.html#ad0344805671d4ba5d3bae46f501e4defa90651ebea9a35ec4e018c8157492e17c">ON</a> t3.b=t1.b</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list representation of the join to be converted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">top</td><td>true &lt;=&gt; cond is the where condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_sj</td><td>true &lt;=&gt; processing semi-join nest's children </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cond</td><td>In: condition to which the join condition for converted outer joins is to be added; Out: new condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">changelog</td><td>Don't specify this parameter, it is reserved for recursive calls inside this function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for error, false for success </dd></dl>

</div>
</div>
<a id="gab3eff367e4f6d91672f28741381a7450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3eff367e4f6d91672f28741381a7450">&#9670;&nbsp;</a></span>single_visible_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a> * SELECT_LEX::single_visible_field </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga52ee4ab72058e6ae1ea70257b0f767b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ee4ab72058e6ae1ea70257b0f767b4">&#9670;&nbsp;</a></span>subquery_allows_materialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Item_in_subselect::subquery_allows_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>outer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the subquery predicate can be executed via materialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD </td></tr>
    <tr><td class="paramname">select_lex</td><td>SELECT_LEX of the subquery </td></tr>
    <tr><td class="paramname">outer</td><td>Parent SELECT_LEX (outer to subquery)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if subquery allows materialization, false otherwise. </dd></dl>

</div>
</div>
<a id="ga329cee4bc264925a8a42e540d5d7a075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329cee4bc264925a8a42e540d5d7a075">&#9670;&nbsp;</a></span>synthesize_derived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> * SELECT_LEX::synthesize_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>join_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>left_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_inner_join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new TABLE_LIST object for this query block, for either: 1) a derived table which will replace the subquery, or 2) an extra derived table for handling grouping, if necessary, cf. </p>
<p>transform_grouped_to_derived.</p>
<p>The derived table is added to the list of used tables for the query block ("outer").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the session context </td></tr>
    <tr><td class="paramname">unit</td><td>the query expression for subquery (case 1), or a new query expression for (case 2) </td></tr>
    <tr><td class="paramname">join_cond</td><td>!= nullptr: we are synthesizing a derived table for a subquery within this join condition = nullptr: synthesizing a derived table for a subquery where the subquery is not contained in a join condition </td></tr>
    <tr><td class="paramname">left_outer</td><td>true for case (1), false for (2) </td></tr>
    <tr><td class="paramname">use_inner_join</td><td>for case (1): if true/false use INNER/LEFT JOIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived table object, or nullptr on error. </dd></dl>

</div>
</div>
<a id="ga67528d173a9e9c588dff8d3820c48ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67528d173a9e9c588dff8d3820c48ba8">&#9670;&nbsp;</a></span>transform_grouped_to_derived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::transform_grouped_to_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> *&#160;</td>
          <td class="paramname"><em>break_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minion of transform_scalar_subqueries_to_join_with_derived. </p>
<p>Moves implicit grouping down into a derived table to prepare for transform_scalar_subqueries_to_join_with_derived.</p>
<p>Example:</p>
<pre class="fragment">  SELECT (SELECT COUNT(*)
          FROM t1) AS tot,
         IFNULL(MAX(t2.b), 0) + 6 AS mx
  FROM t2
  WHERE expr-2;

is transformed to -&gt;

  SELECT derived_1_1.`COUNT(*)` AS tot,
         (IFNULL(derived_1_0.`MAX(t2.b)`,0) + 6) AS mx
  FROM (SELECT MAX(t2.b) AS `MAX(t2.b)`
        FROM t2
        WHERE expr-2) derived_1_0
       LEFT JOIN
       (SELECT COUNT(0) AS `COUNT(*)`
        FROM t1) derived_1_1
       ON TRUE;</pre><p>Create a new query expression object and query block object to represent the contents of a derived table ("new_derived" in the code below, "derived1" in the example above), with a select list which only contains the aggregate functions lifted out of the transformed query block ("MAX(b) AS mx" above) and any fields referenced ("i" above).</p>
<p>The transformed query block retains the original select list except aggregates and fields are replaced by fields ("derived1.mx", "derived1.i" above) from the new subquery, but it loses its FROM list, replaced by the new derived table ("derived1" above) and its WHERE and HAVING clauses which all go to the derived table's query block.</p>
<p>Any DISTINCT, WINDOW clauses and LIMITs stay in place at the transformed query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>session context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">break_off</td><td>set to true of transformation could not be performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error </dd></dl>

</div>
</div>
<a id="ga3e3fc372c4e39b2668e29223a0f4687b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e3fc372c4e39b2668e29223a0f4687b">&#9670;&nbsp;</a></span>transform_scalar_subqueries_to_join_with_derived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::transform_scalar_subqueries_to_join_with_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform eligible scalar subqueries in the SELECT list, WHERE condition, HAVING condition or JOIN conditions of a query block[*] to an equivalent derived table of a LEFT OUTER join, e.g. </p>
<p>as shown in this uncorrelated subquery:</p>
<p>[*] a.k.a "transformed query block" throughout this method and its minions.</p>
<pre>
  SELECT * FROM t1
    WHERE t1.a &gt; (SELECT COUNT(a) AS cnt FROM t2);  -&gt;</pre><pre>  SELECT t1.* FROM t1 LEFT OUTER JOIN
                   (SELECT COUNT(a) AS cnt FROM t2) AS derived
    ON TRUE WHERE t1.a &gt; derived.cnt;
</pre><p>Grouping in the transformed query block may necessitate the grouping to be moved down to another derived table, cf. transform_grouped_to_derived.</p>
<p>Limitations:</p><ul>
<li>only implicitly grouped subqueries (guaranteed to have cardinality one) are identified as scalar subqueries. _ Correlated subqueries are not handled</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thd</td><td>the session context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error </dd></dl>

</div>
</div>
<a id="ga9c907b86619ee483f5529a19d920557d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c907b86619ee483f5529a19d920557d">&#9670;&nbsp;</a></span>transform_subquery_to_derived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::transform_subquery_to_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>out_tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *&#160;</td>
          <td class="paramname"><em>subs_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__subselect.html">Item_subselect</a> *&#160;</td>
          <td class="paramname"><em>subq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_inner_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reject_multiple_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>join_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a subquery to a derived table and inserts it into the FROM clause of the owning query block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Connection handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_tl</td><td>The created derived table will be stored in this. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">subs_unit</td><td>Unit for the subquery </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">subq</td><td>Item for the subquery </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">use_inner_join</td><td>Insert with INNER JOIN, or with LEFT JOIN </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">reject_multiple_rows</td><td>For scalar subqueries where we need run-time cardinality check: true, else false </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_condition</td><td>See join_cond in synthesize_derived() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga589f1ddbbe285907314f87a5bdc0c090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga589f1ddbbe285907314f87a5bdc0c090">&#9670;&nbsp;</a></span>transform_table_subquery_to_join_with_derived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> SELECT_LEX::transform_table_subquery_to_join_with_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__exists__subselect.html">Item_exists_subselect</a> *&#160;</td>
          <td class="paramname"><em>subq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a table subquery ([NOT] {IN, EXISTS}) with a join to a derived table. </p>
<p>The principle of this transformation is: FROM [tables] WHERE ... AND/OR oe IN (SELECT ie FROM it) ... becomes FROM (tables) LEFT JOIN (SELECT DISTINCT ie FROM it) AS derived ON oe = derived.ie WHERE ... AND/OR derived.ie IS NOT NULL ... If the subquery predicate is top-level in WHERE, and not negated, we use JOIN instead of LEFT JOIN, and use TRUE instead of IS NOT NULL. If the subquery predicate is negated, we use IS NULL instead of IS NOT NULL. If the subquery predicate is without aggregation(etc), we decorrelate any equality from it, and, if negated, we also decorrelate '&lt;&gt;,&lt;,&lt;=,&gt;,&gt;='; thus we handle EXISTS too. If the subquery cannot be decorrelated, the derived table could be made LATERAL, but as a certain secondary engine doesn't support that we just return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Connection handle </td></tr>
    <tr><td class="paramname">subq</td><td>Item for subquery </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if error </dd></dl>

</div>
</div>
<a id="ga664ecb121a8137472b07f25da758e93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga664ecb121a8137472b07f25da758e93d">&#9670;&nbsp;</a></span>update_context_to_derived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> update_context_to_derived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>new_derived</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A minion of transform_grouped_to_derived. </p>
<p>This updates the name resolution contexts in expr to that of new_derived permanently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to be updated </td></tr>
    <tr><td class="paramname">new_derived</td><td>the query block of the new derived table which now holds the expression after it has been moved down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on error </dd></dl>

</div>
</div>
<a id="gada2cde72e117bc74f09db829bafb6546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2cde72e117bc74f09db829bafb6546">&#9670;&nbsp;</a></span>update_used_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SELECT_LEX::update_used_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update used tables information for all local expressions. </p>

</div>
</div>
<a id="gaaa4ea05b0499fff8ebb05c289007552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa4ea05b0499fff8ebb05c289007552b">&#9670;&nbsp;</a></span>update_used_tables_for_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void update_used_tables_for_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update used tables information for a JOIN expression. </p>

</div>
</div>
<a id="ga588a52d801f0875b4d426477c06d4851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga588a52d801f0875b4d426477c06d4851">&#9670;&nbsp;</a></span>validate_gc_assignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> validate_gc_assignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="classItem.html">Item</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>validate_gc_assignment Check whether the other values except DEFAULT are assigned for generated columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields</td><td>Item_fields list to be filled </td></tr>
    <tr><td class="paramname">values</td><td>values to fill with </td></tr>
    <tr><td class="paramname">table</td><td>table to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occurred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called after table-&gt;write_set has been filled. </dd></dl>

</div>
</div>
<a id="ga9768477d146a4e857c6c54c6d0315d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9768477d146a4e857c6c54c6d0315d36">&#9670;&nbsp;</a></span>walk_join_conditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> walk_join_conditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(<a class="el" href="classItem.html">Item</a> **expr_p)&gt;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structItem_1_1Collect__scalar__subquery__info.html">Item_singlerow_subselect::Collect_scalar_subquery_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9cf3e02ae2f5c2fbba6fc82b1bd40a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cf3e02ae2f5c2fbba6fc82b1bd40a29">&#9670;&nbsp;</a></span>walk_join_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> walk_join_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>(<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *)&gt;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafdf996e8d5aa134d338976f355a16ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdf996e8d5aa134d338976f355a16ea7">&#9670;&nbsp;</a></span>WalkAndReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> WalkAndReplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; <a class="el" href="structReplaceResult.html">ReplaceResult</a>(<a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classItem.html">Item</a> *parent, unsigned argument_idx)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_new_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga62ea8dc10fb0c4f69b4757d60831f358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62ea8dc10fb0c4f69b4757d60831f358">&#9670;&nbsp;</a></span>wrap_grouped_expressions_for_rollup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structReplaceResult.html">ReplaceResult</a> wrap_grouped_expressions_for_rollup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX.html">SELECT_LEX</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>argument_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether an item matches a grouped expression, creates an Item_rollup_group_item around it and replaces the reference to it with that item. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
