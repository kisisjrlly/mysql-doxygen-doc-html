<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Gcs_xcom_communication_protocol_changer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classGcs__xcom__communication__protocol__changer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classGcs__xcom__communication__protocol__changer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gcs_xcom_communication_protocol_changer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the communication protocol change logic.  
 <a href="classGcs__xcom__communication__protocol__changer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gcs__xcom__communication__protocol__changer_8h_source.html">gcs_xcom_communication_protocol_changer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac75e1351aee54f4c54d83dc022aaf90f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#ac75e1351aee54f4c54d83dc022aaf90f">Gcs_xcom_communication_protocol_changer</a> (<a class="el" href="classGcs__xcom__engine.html">Gcs_xcom_engine</a> &amp;<a class="el" href="gcs__xcom__interface_8cc.html#a897387842df558f1c11cde161999cb2b">gcs_engine</a>, <a class="el" href="classGcs__message__pipeline.html">Gcs_message_pipeline</a> &amp;pipeline)</td></tr>
<tr class="separator:ac75e1351aee54f4c54d83dc022aaf90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3efad3b7038ae9242673fef4d68319"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a8f3efad3b7038ae9242673fef4d68319">Gcs_xcom_communication_protocol_changer</a> (<a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> const &amp;)=delete</td></tr>
<tr class="separator:a8f3efad3b7038ae9242673fef4d68319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3093e4e82b41e5ca27a19869a75b413e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a3093e4e82b41e5ca27a19869a75b413e">Gcs_xcom_communication_protocol_changer</a> (<a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3093e4e82b41e5ca27a19869a75b413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a303ba4def04e12b1f4cb282856e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a23a303ba4def04e12b1f4cb282856e5c">operator=</a> (<a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> const &amp;)=delete</td></tr>
<tr class="separator:a23a303ba4def04e12b1f4cb282856e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48341dc1ca7b950b41510a99c33720e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a48341dc1ca7b950b41510a99c33720e1">operator=</a> (<a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a48341dc1ca7b950b41510a99c33720e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceeedafb9a4a886119758a6ae2f65e00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#aceeedafb9a4a886119758a6ae2f65e00">get_protocol_version</a> () const</td></tr>
<tr class="memdesc:aceeedafb9a4a886119758a6ae2f65e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current protocol version in use.  <a href="#aceeedafb9a4a886119758a6ae2f65e00">More...</a><br /></td></tr>
<tr class="separator:aceeedafb9a4a886119758a6ae2f65e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac188d1a8c2e9ec98222396b4d3097110"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, std::future&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#ac188d1a8c2e9ec98222396b4d3097110">set_protocol_version</a> (<a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a> new_version)</td></tr>
<tr class="memdesc:ac188d1a8c2e9ec98222396b4d3097110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a protocol change.  <a href="#ac188d1a8c2e9ec98222396b4d3097110">More...</a><br /></td></tr>
<tr class="separator:ac188d1a8c2e9ec98222396b4d3097110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaff4b243d14f7f6dcf53e1b74b5d9a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#abaff4b243d14f7f6dcf53e1b74b5d9a6">get_maximum_supported_protocol_version</a> () const</td></tr>
<tr class="memdesc:abaff4b243d14f7f6dcf53e1b74b5d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the greatest protocol version currently supported by the group.  <a href="#abaff4b243d14f7f6dcf53e1b74b5d9a6">More...</a><br /></td></tr>
<tr class="separator:abaff4b243d14f7f6dcf53e1b74b5d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acdfe91032a2274c2f8bfb07f0c7296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a9acdfe91032a2274c2f8bfb07f0c7296">set_maximum_supported_protocol_version</a> (<a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a> <a class="el" href="persisted__variable_8cc.html#a7b9a5d15d5aee3e2250719b5fcd930cc">version</a>)</td></tr>
<tr class="memdesc:a9acdfe91032a2274c2f8bfb07f0c7296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the greatest protocol version currently supported by the group.  <a href="#a9acdfe91032a2274c2f8bfb07f0c7296">More...</a><br /></td></tr>
<tr class="separator:a9acdfe91032a2274c2f8bfb07f0c7296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a099b9b683c2c249a7af812ca51a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a25a099b9b683c2c249a7af812ca51a66">is_protocol_change_ongoing</a> () const</td></tr>
<tr class="memdesc:a25a099b9b683c2c249a7af812ca51a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a protocol change is ongoing.  <a href="#a25a099b9b683c2c249a7af812ca51a66">More...</a><br /></td></tr>
<tr class="separator:a25a099b9b683c2c249a7af812ca51a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b69498d27a45273621ab63c6b386c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#ad7b69498d27a45273621ab63c6b386c3">atomically_increment_nr_packets_in_transit</a> (<a class="el" href="gcs__internal__message__headers_8h.html#a97f49ed4714e185b87ca9ab82286c836">Cargo_type</a> const &amp;cargo)</td></tr>
<tr class="memdesc:ad7b69498d27a45273621ab63c6b386c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronises user threads, which send messages, with the GCS thread, which performs protocol changes.  <a href="#ad7b69498d27a45273621ab63c6b386c3">More...</a><br /></td></tr>
<tr class="separator:ad7b69498d27a45273621ab63c6b386c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6df6b93075d034246cbb40a5430df57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#ae6df6b93075d034246cbb40a5430df57">adjust_nr_packets_in_transit</a> (<a class="el" href="gcs__internal__message__headers_8h.html#a97f49ed4714e185b87ca9ab82286c836">Cargo_type</a> const &amp;cargo, std::size_t const &amp;nr_additional_packets_to_send)</td></tr>
<tr class="memdesc:ae6df6b93075d034246cbb40a5430df57"><td class="mdescLeft">&#160;</td><td class="mdescRight">After an outgoing message goes through the pipeline, it may produce more than one packet.  <a href="#ae6df6b93075d034246cbb40a5430df57">More...</a><br /></td></tr>
<tr class="separator:ae6df6b93075d034246cbb40a5430df57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89f7b1de30c3d3fb0b34f2df81e32f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#af89f7b1de30c3d3fb0b34f2df81e32f7">decrement_nr_packets_in_transit</a> (<a class="el" href="classGcs__packet.html">Gcs_packet</a> const &amp;packet, <a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> const &amp;xcom_nodes)</td></tr>
<tr class="memdesc:af89f7b1de30c3d3fb0b34f2df81e32f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the number of my in-transit packets.  <a href="#af89f7b1de30c3d3fb0b34f2df81e32f7">More...</a><br /></td></tr>
<tr class="separator:af89f7b1de30c3d3fb0b34f2df81e32f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017c5dfcd28dba25643c05b2c327c1b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a017c5dfcd28dba25643c05b2c327c1b1">finish_protocol_version_change</a> (<a class="el" href="classGcs__tagged__lock.html#a00e568903a62e49c88380e210e599867">Gcs_tagged_lock::Tag</a> const caller_tag)</td></tr>
<tr class="memdesc:a017c5dfcd28dba25643c05b2c327c1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Due to the synchronisation protocol used between user threads, which send messages, and the GCS thread, which performs protocol changes, a user thread may be the one to hit the condition that triggers the protocol change to finish.  <a href="#a017c5dfcd28dba25643c05b2c327c1b1">More...</a><br /></td></tr>
<tr class="separator:a017c5dfcd28dba25643c05b2c327c1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2002252907a346a0cb132ca1fa8715ce"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a2002252907a346a0cb132ca1fa8715ce">get_nr_packets_in_transit</a> () const</td></tr>
<tr class="separator:a2002252907a346a0cb132ca1fa8715ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad912ecb262db9145a17c34a5269f333d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#ad912ecb262db9145a17c34a5269f333d">begin_protocol_version_change</a> (<a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a> new_version)</td></tr>
<tr class="separator:ad912ecb262db9145a17c34a5269f333d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96105cf42dbd0a9f16ee8e758cdbab47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a96105cf42dbd0a9f16ee8e758cdbab47">commit_protocol_version_change</a> ()</td></tr>
<tr class="separator:a96105cf42dbd0a9f16ee8e758cdbab47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0822f7829247a277b3eba454877fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#ab1c0822f7829247a277b3eba454877fb">release_tagged_lock_and_notify_waiters</a> ()</td></tr>
<tr class="separator:ab1c0822f7829247a277b3eba454877fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bed4e5c7198c58a44dab20241dc0e6e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="classGcs__tagged__lock.html#a00e568903a62e49c88380e210e599867">Gcs_tagged_lock::Tag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a0bed4e5c7198c58a44dab20241dc0e6e">optimistically_increment_nr_packets_in_transit</a> ()</td></tr>
<tr class="separator:a0bed4e5c7198c58a44dab20241dc0e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5eff6c2f470e81f6b80a9c7993956c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#aad5eff6c2f470e81f6b80a9c7993956c">rollback_increment_nr_packets_in_transit</a> (<a class="el" href="classGcs__tagged__lock.html#a00e568903a62e49c88380e210e599867">Gcs_tagged_lock::Tag</a> const &amp;tag)</td></tr>
<tr class="separator:aad5eff6c2f470e81f6b80a9c7993956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f10e980423123812129e2f15edf4e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a5f10e980423123812129e2f15edf4e69">wait_for_protocol_change_to_finish</a> ()</td></tr>
<tr class="separator:a5f10e980423123812129e2f15edf4e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a32bf68acfbd50686b9d86e24fee01d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGcs__tagged__lock.html">Gcs_tagged_lock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a32bf68acfbd50686b9d86e24fee01d66">m_tagged_lock</a></td></tr>
<tr class="memdesc:a32bf68acfbd50686b9d86e24fee01d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tagged lock used for the optimistic synchronisation protocol between user threads, which send messages, and the GCS thread, which performs protocol changes.  <a href="#a32bf68acfbd50686b9d86e24fee01d66">More...</a><br /></td></tr>
<tr class="separator:a32bf68acfbd50686b9d86e24fee01d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca4fb6c7a9f97d19fe256c8b47e3760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">std::mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a6ca4fb6c7a9f97d19fe256c8b47e3760">m_mutex</a></td></tr>
<tr class="memdesc:a6ca4fb6c7a9f97d19fe256c8b47e3760"><td class="mdescLeft">&#160;</td><td class="mdescRight">For user threads to wait for an ongoing protocol change to finish.  <a href="#a6ca4fb6c7a9f97d19fe256c8b47e3760">More...</a><br /></td></tr>
<tr class="separator:a6ca4fb6c7a9f97d19fe256c8b47e3760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6238d598e0e59c2e413041aae99889af"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a6238d598e0e59c2e413041aae99889af">m_protocol_change_finished</a></td></tr>
<tr class="separator:a6238d598e0e59c2e413041aae99889af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced02375b555274628135e36ca535a06"><td class="memItemLeft" align="right" valign="top">std::promise&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#aced02375b555274628135e36ca535a06">m_promise</a></td></tr>
<tr class="memdesc:aced02375b555274628135e36ca535a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the outcome of the protocol change operation.  <a href="#aced02375b555274628135e36ca535a06">More...</a><br /></td></tr>
<tr class="separator:aced02375b555274628135e36ca535a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f5f615d5d1b5cfbd280788b8cf71d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a85f5f615d5d1b5cfbd280788b8cf71d1">m_tentative_new_protocol</a></td></tr>
<tr class="memdesc:a85f5f615d5d1b5cfbd280788b8cf71d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol version we are going to change to when we start a protocol change.  <a href="#a85f5f615d5d1b5cfbd280788b8cf71d1">More...</a><br /></td></tr>
<tr class="separator:a85f5f615d5d1b5cfbd280788b8cf71d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bd61ea7aed570ff936382b85eb3b30"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a80bd61ea7aed570ff936382b85eb3b30">m_max_supported_protocol</a></td></tr>
<tr class="separator:a80bd61ea7aed570ff936382b85eb3b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1585ea11e0f407984bef393307d9214d"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a1585ea11e0f407984bef393307d9214d">m_nr_packets_in_transit</a></td></tr>
<tr class="separator:a1585ea11e0f407984bef393307d9214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9cf26aa521d9951417c0e493a66707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGcs__xcom__engine.html">Gcs_xcom_engine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a9f9cf26aa521d9951417c0e493a66707">m_gcs_engine</a></td></tr>
<tr class="separator:a9f9cf26aa521d9951417c0e493a66707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f24f23180a69264d56d79c2d72cd551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGcs__message__pipeline.html">Gcs_message_pipeline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGcs__xcom__communication__protocol__changer.html#a0f24f23180a69264d56d79c2d72cd551">m_msg_pipeline</a></td></tr>
<tr class="separator:a0f24f23180a69264d56d79c2d72cd551"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the communication protocol change logic. </p>
<h1>Design </h1>
<p>The algorithm to change the communication protocol is roughly as follows: </p><pre class="fragment">1. Start buffering the node's outgoing messages.
2. Wait until all the node's outgoing messages have been delivered.
3. Modify the node's communication protocol version.
4. Stop buffering the node's outgoing messages and send any messages
   buffered in step (1).
</pre><p>Implementing the algorithm requires synchronising user threads, which send messages, with the GCS thread, which performs communication protocol changes.</p>
<p>The high level view of the synchronisation protocol between the user and GCS threads is the following: </p><pre class="fragment">when send-message(m) from user thread:
  atomically:
    if protocol_changing:
      wait until protocol_changing = false
    nr_msgs_in_transit++
  ...

when change-protocol(v) from GCS thread:
  atomically:
    protocol_changing := true
  wait until nr_msgs_in_transit = 0
  ...
</pre><p>We expect that communication protocol changes are rare events, especially when compared to sending messages. As such, the actual implementation strives to minimise the overhead on the code path that sends messages.</p>
<p>To do this, we use an optimistic synchronisation protocol on the send message side, that works as follows:</p>
<p>Algorithm #0, User thread:</p><ol type="1">
<li>If no protocol change is ongoing, the user thread will optimistically increment the number of messages in transit. 2.a If a protocol change did not start meanwhile, we are good to go. 2.b If a protocol change started meanwhile: 2.b.1. Rollback the increment to the number of messages in transit 2.b.2. Wait for the protocol change to finish.</li>
</ol>
<p>There is an additional action that needs to be performed on step (2.b), but we will describe that action when we have the necessary context to understand it.</p>
<p>On the protocol change side, it works as follows:</p>
<p>Algorithm #1, GCS thread:</p><ol type="1">
<li>Store that a protocol change is ongoing.</li>
<li>When the number of messages in transit is zero: 2.1. Change the protocol version 2.2. Wake up any user threads waiting for the protocol change 2.3. Deem the protocol change finished</li>
</ol>
<p>The central part of the Algorithm #1 is step (2). The question is: who triggers, and where, step (2)'s condition, i.e. the number of in-transit messages is zero? Well, the obvious place is that it is the GCS thread itself, when it is processing an incoming message. If that message comes from us, then we decrease the number of in-transit messages, which may set it to zero.</p>
<p>However, recall that the user threads employ an optimistic synchronisation protocol that "acts first, and asks for forgiveness later." If the user thread rolls back its increment to the number of in-transit messages, it may be the one to set it to zero&mdash;see Algorithm #0, step (2.b). In this situation, it is the user thread that hits the condition required by the GCS thread in Algorithm #1, step (2). In order for the GCS thread to finish the protocol change, the user thread must somehow signal the GCS thread to trigger its step (2). This is the missing action of Algorithm #0, step (2.b).</p>
<p>So, the final synchronisation protocol of the user thread's side looks like this:</p>
<p>Algorithm #2, User thread:</p><ol type="1">
<li>If no protocol change is ongoing, the user thread will optimistically increment the number of messages in transit. 2.a If a protocol change did not start meanwhile, we are good to go. 2.b If a protocol change started meanwhile: 2.b.1. Rollback the the increment to the number of messages in transit 2.b.2. If our rollback set the number of messages in transit to zero, signal the GCS thread 2.b.3. Wait for the protocol change to finish.</li>
</ol>
<h1>Implementation </h1>
<p>The implementation attempts to add as little overhead as possible to the common case, which is that no protocol change is ongoing. This is the fast path of Algorithm #2, step (2.a). To achieve this goal, it employs a tagged lock. For more details on the tagged lock implementation, see <code>Gcs_tagged_lock</code>.</p>
<p>In a nutshell, the tagged lock is a read-write spin lock which offers the following API: </p><pre class="fragment">try_lock() -&gt; bool
unlock()
optimistic_read() -&gt; tag
validate_optimistic_read(tag) -&gt; bool
</pre><p>For the write-side section, one uses it as a typical spin lock, e.g.: </p><pre class="fragment">do:
  lock_acquired := try_lock()
while (not lock_acquired)
write-side section
unlock()
</pre><p>For the read-side section, one can use it as follows: </p><pre class="fragment">done := false
while (not done):
  tag := optimistic_read()
  unsynchronised read-side section
  done := validate_optimistic_read(tag)
  if (not done):
    rollback unsynchronized read-side section
</pre><p>The idea is to allow an optimistic read-side section that does not perform any memory stores. This is in contrast with a typical read-write lock, where the read side performs some memory stores to account for the reader, e.g. keeping a reader counter. The trade off is that:</p>
<p>a. the execution of the read-side of a tagged lock may be concurrent with the write-side section if meanwhile the tagged lock is acquired b. the read-side of a tagged lock may fail if meanwhile the tagged lock is acquired, in which case one may want to rollback the effects of the failed read-side section</p>
<p>The algorithms of the design are implemented as follows:</p>
<p>Algorithm #1 implementation, GCS thread:</p><ol type="1">
<li>Lock the tagged lock</li>
<li>When the number of messages in transit is zero: 2.1. Change the protocol version 2.2. Unlock the tagged lock, signal a condition variable to wake up any user threads waiting for the protocol change 2.3. Deem the protocol change finished</li>
</ol>
<p>Algorithm #2 implementation, User thread:</p><ol type="1">
<li>If the tagged lock is unlocked: 1.1. Start an optimistic read-side section 1.2. Atomically increment the number of messages in transit 2.a If the optimistic read-side section validates, we are good to go. 2.b If the optimistic read-side section fails validation: 2.b.1. Atomically rollback the increment to the number of messages in transit 2.b.2. If our rollback set the number of messages in transit to zero, signal the GCS thread 2.b.3. Wait on a condition variable for the protocol change to finish.</li>
</ol>
<p>Note that we have concurrent access to the number of messages in transit which needs to be synchronised. This is done by using an std::atomic to implement the number of messages in transit.</p>
<p>Some final implementation pointers:</p>
<p>a. Algorithm #1: see the code path that starts on <code>set_protocol_version</code> and <code>finish_protocol_version_change</code>. b. Algorithm #2: see the code paths that start on <code>atomically_increment_nr_packets_in_transit</code>, <code>adjust_nr_packets_in_transit</code>, and <code>decrement_nr_packets_in_transit</code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac75e1351aee54f4c54d83dc022aaf90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75e1351aee54f4c54d83dc022aaf90f">&#9670;&nbsp;</a></span>Gcs_xcom_communication_protocol_changer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gcs_xcom_communication_protocol_changer::Gcs_xcom_communication_protocol_changer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__engine.html">Gcs_xcom_engine</a> &amp;&#160;</td>
          <td class="paramname"><em>gcs_engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGcs__message__pipeline.html">Gcs_message_pipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f3efad3b7038ae9242673fef4d68319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3efad3b7038ae9242673fef4d68319">&#9670;&nbsp;</a></span>Gcs_xcom_communication_protocol_changer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gcs_xcom_communication_protocol_changer::Gcs_xcom_communication_protocol_changer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3093e4e82b41e5ca27a19869a75b413e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3093e4e82b41e5ca27a19869a75b413e">&#9670;&nbsp;</a></span>Gcs_xcom_communication_protocol_changer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gcs_xcom_communication_protocol_changer::Gcs_xcom_communication_protocol_changer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae6df6b93075d034246cbb40a5430df57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6df6b93075d034246cbb40a5430df57">&#9670;&nbsp;</a></span>adjust_nr_packets_in_transit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::adjust_nr_packets_in_transit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gcs__internal__message__headers_8h.html#a97f49ed4714e185b87ca9ab82286c836">Cargo_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>cargo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t const &amp;&#160;</td>
          <td class="paramname"><em>nr_additional_packets_to_send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After an outgoing message goes through the pipeline, it may produce more than one packet. </p>
<p>This method adjusts the increment done by atomically_increment_nr_packets_in_transit to take into account the additional packets produced by the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cargo</td><td>The type of message that will be sent </td></tr>
    <tr><td class="paramname">nr_additional_packets_to_send</td><td>The number of additional packets that will actually be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7b69498d27a45273621ab63c6b386c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b69498d27a45273621ab63c6b386c3">&#9670;&nbsp;</a></span>atomically_increment_nr_packets_in_transit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::atomically_increment_nr_packets_in_transit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gcs__internal__message__headers_8h.html#a97f49ed4714e185b87ca9ab82286c836">Cargo_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>cargo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronises user threads, which send messages, with the GCS thread, which performs protocol changes. </p>
<p>This method should be called by user threads when sending a message, before the message goes through the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cargo</td><td>The type of message that will be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad912ecb262db9145a17c34a5269f333d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad912ecb262db9145a17c34a5269f333d">&#9670;&nbsp;</a></span>begin_protocol_version_change()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::begin_protocol_version_change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a>&#160;</td>
          <td class="paramname"><em>new_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96105cf42dbd0a9f16ee8e758cdbab47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96105cf42dbd0a9f16ee8e758cdbab47">&#9670;&nbsp;</a></span>commit_protocol_version_change()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::commit_protocol_version_change </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af89f7b1de30c3d3fb0b34f2df81e32f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89f7b1de30c3d3fb0b34f2df81e32f7">&#9670;&nbsp;</a></span>decrement_nr_packets_in_transit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::decrement_nr_packets_in_transit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__packet.html">Gcs_packet</a> const &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__nodes.html">Gcs_xcom_nodes</a> const &amp;&#160;</td>
          <td class="paramname"><em>xcom_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the number of my in-transit packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>The incoming packet </td></tr>
    <tr><td class="paramname">xcom_nodes</td><td>The XCom membership at the time of delivery </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a017c5dfcd28dba25643c05b2c327c1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017c5dfcd28dba25643c05b2c327c1b1">&#9670;&nbsp;</a></span>finish_protocol_version_change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::finish_protocol_version_change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__tagged__lock.html#a00e568903a62e49c88380e210e599867">Gcs_tagged_lock::Tag</a> const&#160;</td>
          <td class="paramname"><em>caller_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Due to the synchronisation protocol used between user threads, which send messages, and the GCS thread, which performs protocol changes, a user thread may be the one to hit the condition that triggers the protocol change to finish. </p>
<p>This function should be called by the user thread when it hits the condition, to signal the GCS thread that the protocol change should finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller_tag</td><td>Identifier of the protocol change </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaff4b243d14f7f6dcf53e1b74b5d9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaff4b243d14f7f6dcf53e1b74b5d9a6">&#9670;&nbsp;</a></span>get_maximum_supported_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a> Gcs_xcom_communication_protocol_changer::get_maximum_supported_protocol_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the greatest protocol version currently supported by the group. </p>
<dl class="section return"><dt>Returns</dt><dd>the greatest protocol version currently supported by the group </dd></dl>

</div>
</div>
<a id="a2002252907a346a0cb132ca1fa8715ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2002252907a346a0cb132ca1fa8715ce">&#9670;&nbsp;</a></span>get_nr_packets_in_transit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Gcs_xcom_communication_protocol_changer::get_nr_packets_in_transit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aceeedafb9a4a886119758a6ae2f65e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceeedafb9a4a886119758a6ae2f65e00">&#9670;&nbsp;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a> Gcs_xcom_communication_protocol_changer::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current protocol version in use. </p>
<dl class="section return"><dt>Returns</dt><dd>the current protocol version in use </dd></dl>

</div>
</div>
<a id="a25a099b9b683c2c249a7af812ca51a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a099b9b683c2c249a7af812ca51a66">&#9670;&nbsp;</a></span>is_protocol_change_ongoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Gcs_xcom_communication_protocol_changer::is_protocol_change_ongoing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a protocol change is ongoing. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a protocol change is ongoing, false otherwise </dd></dl>

</div>
</div>
<a id="a23a303ba4def04e12b1f4cb282856e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a303ba4def04e12b1f4cb282856e5c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a>&amp; Gcs_xcom_communication_protocol_changer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48341dc1ca7b950b41510a99c33720e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48341dc1ca7b950b41510a99c33720e1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a>&amp; Gcs_xcom_communication_protocol_changer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bed4e5c7198c58a44dab20241dc0e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bed4e5c7198c58a44dab20241dc0e6e">&#9670;&nbsp;</a></span>optimistically_increment_nr_packets_in_transit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="classGcs__tagged__lock.html#a00e568903a62e49c88380e210e599867">Gcs_tagged_lock::Tag</a> &gt; Gcs_xcom_communication_protocol_changer::optimistically_increment_nr_packets_in_transit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1c0822f7829247a277b3eba454877fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c0822f7829247a277b3eba454877fb">&#9670;&nbsp;</a></span>release_tagged_lock_and_notify_waiters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::release_tagged_lock_and_notify_waiters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad5eff6c2f470e81f6b80a9c7993956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5eff6c2f470e81f6b80a9c7993956c">&#9670;&nbsp;</a></span>rollback_increment_nr_packets_in_transit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::rollback_increment_nr_packets_in_transit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGcs__tagged__lock.html#a00e568903a62e49c88380e210e599867">Gcs_tagged_lock::Tag</a> const &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9acdfe91032a2274c2f8bfb07f0c7296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acdfe91032a2274c2f8bfb07f0c7296">&#9670;&nbsp;</a></span>set_maximum_supported_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::set_maximum_supported_protocol_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the greatest protocol version currently supported by the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>protocol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac188d1a8c2e9ec98222396b4d3097110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac188d1a8c2e9ec98222396b4d3097110">&#9670;&nbsp;</a></span>set_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>, std::future&lt; void &gt; &gt; Gcs_xcom_communication_protocol_changer::set_protocol_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a>&#160;</td>
          <td class="paramname"><em>new_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a protocol change. </p>
<p>The protocol change is asynchronous, the caller can wait for the change to finish using the returned future.</p>
<p>Note that for safety this method <em>must only</em> be called by the GCS engine thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_version</td><td>The desired protocol version to change to </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">{true,future}</td><td>If successful </td></tr>
    <tr><td class="paramname">{false,_}</td><td>If the group does not support the requested protocol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f10e980423123812129e2f15edf4e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f10e980423123812129e2f15edf4e69">&#9670;&nbsp;</a></span>wait_for_protocol_change_to_finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gcs_xcom_communication_protocol_changer::wait_for_protocol_change_to_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9f9cf26aa521d9951417c0e493a66707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9cf26aa521d9951417c0e493a66707">&#9670;&nbsp;</a></span>m_gcs_engine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGcs__xcom__engine.html">Gcs_xcom_engine</a>&amp; Gcs_xcom_communication_protocol_changer::m_gcs_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80bd61ea7aed570ff936382b85eb3b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bd61ea7aed570ff936382b85eb3b30">&#9670;&nbsp;</a></span>m_max_supported_protocol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a>&gt; Gcs_xcom_communication_protocol_changer::m_max_supported_protocol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f24f23180a69264d56d79c2d72cd551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f24f23180a69264d56d79c2d72cd551">&#9670;&nbsp;</a></span>m_msg_pipeline</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGcs__message__pipeline.html">Gcs_message_pipeline</a>&amp; Gcs_xcom_communication_protocol_changer::m_msg_pipeline</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ca4fb6c7a9f97d19fe256c8b47e3760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca4fb6c7a9f97d19fe256c8b47e3760">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="memcached_8c.html#a4acff8232e4aec9cd5c6dc200ac55ef3">std::mutex</a> Gcs_xcom_communication_protocol_changer::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For user threads to wait for an ongoing protocol change to finish. </p>

</div>
</div>
<a id="a1585ea11e0f407984bef393307d9214d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1585ea11e0f407984bef393307d9214d">&#9670;&nbsp;</a></span>m_nr_packets_in_transit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;unsigned long&gt; Gcs_xcom_communication_protocol_changer::m_nr_packets_in_transit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aced02375b555274628135e36ca535a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced02375b555274628135e36ca535a06">&#9670;&nbsp;</a></span>m_promise</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::promise&lt;void&gt; Gcs_xcom_communication_protocol_changer::m_promise</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the outcome of the protocol change operation. </p>

</div>
</div>
<a id="a6238d598e0e59c2e413041aae99889af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6238d598e0e59c2e413041aae99889af">&#9670;&nbsp;</a></span>m_protocol_change_finished</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable Gcs_xcom_communication_protocol_changer::m_protocol_change_finished</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32bf68acfbd50686b9d86e24fee01d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf68acfbd50686b9d86e24fee01d66">&#9670;&nbsp;</a></span>m_tagged_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGcs__tagged__lock.html">Gcs_tagged_lock</a> Gcs_xcom_communication_protocol_changer::m_tagged_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tagged lock used for the optimistic synchronisation protocol between user threads, which send messages, and the GCS thread, which performs protocol changes. </p>

</div>
</div>
<a id="a85f5f615d5d1b5cfbd280788b8cf71d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f5f615d5d1b5cfbd280788b8cf71d1">&#9670;&nbsp;</a></span>m_tentative_new_protocol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gcs__types_8h.html#ae715da8d58f9bc393566e42448d17260">Gcs_protocol_version</a> Gcs_xcom_communication_protocol_changer::m_tentative_new_protocol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The protocol version we are going to change to when we start a protocol change. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>plugin/group_replication/libmysqlgcs/src/bindings/xcom/<a class="el" href="gcs__xcom__communication__protocol__changer_8h_source.html">gcs_xcom_communication_protocol_changer.h</a></li>
<li>plugin/group_replication/libmysqlgcs/src/bindings/xcom/<a class="el" href="gcs__xcom__communication__protocol__changer_8cc.html">gcs_xcom_communication_protocol_changer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classGcs__xcom__communication__protocol__changer.html">Gcs_xcom_communication_protocol_changer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
