<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: MEM_ROOT Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structMEM__ROOT.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="structMEM__ROOT-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MEM_ROOT Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The MEM_ROOT is a simple arena, where allocations are carved out of larger blocks.  
 <a href="structMEM__ROOT.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="my__alloc_8h_source.html">my_alloc.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT_1_1Block.html">Block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a59a1cd8a1e8b6b0b9e53b6369f177b93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a59a1cd8a1e8b6b0b9e53b6369f177b93">MEM_ROOT</a> ()</td></tr>
<tr class="separator:a59a1cd8a1e8b6b0b9e53b6369f177b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69570bef9d4ce4c1769a872fad7cd3ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a69570bef9d4ce4c1769a872fad7cd3ee">MEM_ROOT</a> (<a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> <a class="el" href="mi__test2_8cc.html#a30b3e7be7739a55bdf3f9c82becb1903">key</a>, size_t block_size)</td></tr>
<tr class="separator:a69570bef9d4ce4c1769a872fad7cd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6edc23379cdf57e813cf7868badeb81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#ad6edc23379cdf57e813cf7868badeb81">MEM_ROOT</a> (const <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;)=delete</td></tr>
<tr class="separator:ad6edc23379cdf57e813cf7868badeb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7985d7b2bfb41a18d12c29ee5026049a"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a7985d7b2bfb41a18d12c29ee5026049a">m_current_free_start</a> (other.m_current_free_start)</td></tr>
<tr class="separator:a7985d7b2bfb41a18d12c29ee5026049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cf9394e784969fd30f1b377b11eef5"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#af6cf9394e784969fd30f1b377b11eef5">m_current_free_end</a> (other.m_current_free_end)</td></tr>
<tr class="separator:af6cf9394e784969fd30f1b377b11eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca932af7371856d782e1d7808e69c5"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#adfca932af7371856d782e1d7808e69c5">m_block_size</a> (other.m_block_size)</td></tr>
<tr class="separator:adfca932af7371856d782e1d7808e69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bad0088db40f666bd99c837c03c7fc"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a21bad0088db40f666bd99c837c03c7fc">m_orig_block_size</a> (other.m_orig_block_size)</td></tr>
<tr class="separator:a21bad0088db40f666bd99c837c03c7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22d839b3d197485e635227692fcda04"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#ae22d839b3d197485e635227692fcda04">m_max_capacity</a> (other.m_max_capacity)</td></tr>
<tr class="separator:ae22d839b3d197485e635227692fcda04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175662de28129abb830660d2c26be960"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a175662de28129abb830660d2c26be960">m_allocated_size</a> (other.m_allocated_size)</td></tr>
<tr class="separator:a175662de28129abb830660d2c26be960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317154bfa1b9ba90245620fed09ea8d7"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a317154bfa1b9ba90245620fed09ea8d7">m_error_for_capacity_exceeded</a> (other.m_error_for_capacity_exceeded)</td></tr>
<tr class="separator:a317154bfa1b9ba90245620fed09ea8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92ff6bde5a3eaa0ee960243524900e2"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#ad92ff6bde5a3eaa0ee960243524900e2">m_error_handler</a> (other.m_error_handler)</td></tr>
<tr class="separator:ad92ff6bde5a3eaa0ee960243524900e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a338c055133f5b2863d74c666194d"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a153a338c055133f5b2863d74c666194d">m_psi_key</a> (other.m_psi_key)</td></tr>
<tr class="separator:a153a338c055133f5b2863d74c666194d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0262957f7f8a6d24383031a05c8a4b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a0262957f7f8a6d24383031a05c8a4b1b">operator=</a> (const <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;)=delete</td></tr>
<tr class="separator:a0262957f7f8a6d24383031a05c8a4b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451cb30c5f328f4317683c4e593c5ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a451cb30c5f328f4317683c4e593c5ac6">operator=</a> (<a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a451cb30c5f328f4317683c4e593c5ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974da616dea3afe99ba86a5d6e9c7a0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a974da616dea3afe99ba86a5d6e9c7a0f">~MEM_ROOT</a> ()</td></tr>
<tr class="separator:a974da616dea3afe99ba86a5d6e9c7a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1762b39f7ab09bb12891f445d6bbcda2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a1762b39f7ab09bb12891f445d6bbcda2">Alloc</a> (size_t length)</td></tr>
<tr class="memdesc:a1762b39f7ab09bb12891f445d6bbcda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory.  <a href="#a1762b39f7ab09bb12891f445d6bbcda2">More...</a><br /></td></tr>
<tr class="separator:a1762b39f7ab09bb12891f445d6bbcda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66c098f8dd1550bbaa43381f3c7715"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a2e66c098f8dd1550bbaa43381f3c7715"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a2e66c098f8dd1550bbaa43381f3c7715">ArrayAlloc</a> (size_t num, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2e66c098f8dd1550bbaa43381f3c7715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate “num” objects of type T, and default-construct them.  <a href="#a2e66c098f8dd1550bbaa43381f3c7715">More...</a><br /></td></tr>
<tr class="separator:a2e66c098f8dd1550bbaa43381f3c7715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de5add37c561acd75d3f011580f269b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a0de5add37c561acd75d3f011580f269b">Claim</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> claim)</td></tr>
<tr class="memdesc:a0de5add37c561acd75d3f011580f269b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim all the allocated memory for the current thread in the performance schema.  <a href="#a0de5add37c561acd75d3f011580f269b">More...</a><br /></td></tr>
<tr class="separator:a0de5add37c561acd75d3f011580f269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592e4f09cd0170c2c92228bc154a23ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a592e4f09cd0170c2c92228bc154a23ef">Clear</a> ()</td></tr>
<tr class="memdesc:a592e4f09cd0170c2c92228bc154a23ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate all the RAM used.  <a href="#a592e4f09cd0170c2c92228bc154a23ef">More...</a><br /></td></tr>
<tr class="separator:a592e4f09cd0170c2c92228bc154a23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b823bd5aab8fa6531f0900aa84f988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a71b823bd5aab8fa6531f0900aa84f988">ClearForReuse</a> ()</td></tr>
<tr class="memdesc:a71b823bd5aab8fa6531f0900aa84f988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to Clear(), but anticipates that the block will be reused for further allocations.  <a href="#a71b823bd5aab8fa6531f0900aa84f988">More...</a><br /></td></tr>
<tr class="separator:a71b823bd5aab8fa6531f0900aa84f988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf168d9a9dfbd52f4880041b9d969024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#acf168d9a9dfbd52f4880041b9d969024">inited</a> () const</td></tr>
<tr class="memdesc:acf168d9a9dfbd52f4880041b9d969024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the constructor has run or not.  <a href="#acf168d9a9dfbd52f4880041b9d969024">More...</a><br /></td></tr>
<tr class="separator:acf168d9a9dfbd52f4880041b9d969024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ff9e411e2ec2033a84a05fb5a23de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#ad9ff9e411e2ec2033a84a05fb5a23de2">set_max_capacity</a> (size_t max_capacity)</td></tr>
<tr class="memdesc:ad9ff9e411e2ec2033a84a05fb5a23de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum capacity for this MEM_ROOT.  <a href="#ad9ff9e411e2ec2033a84a05fb5a23de2">More...</a><br /></td></tr>
<tr class="separator:ad9ff9e411e2ec2033a84a05fb5a23de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a223e677dae4a615502db20a287fa41"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a2a223e677dae4a615502db20a287fa41">get_max_capacity</a> () const</td></tr>
<tr class="memdesc:a2a223e677dae4a615502db20a287fa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum capacity for this MEM_ROOT.  <a href="#a2a223e677dae4a615502db20a287fa41">More...</a><br /></td></tr>
<tr class="separator:a2a223e677dae4a615502db20a287fa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35c65b37faf2f2d965439020f3ae492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#ab35c65b37faf2f2d965439020f3ae492">set_error_for_capacity_exceeded</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="sql__plugin_8cc.html#af55751b4db2d8bdaafbfae001f3f108f">report_error</a>)</td></tr>
<tr class="memdesc:ab35c65b37faf2f2d965439020f3ae492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable error reporting for exceeding the maximum capacity.  <a href="#ab35c65b37faf2f2d965439020f3ae492">More...</a><br /></td></tr>
<tr class="separator:ab35c65b37faf2f2d965439020f3ae492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9828a7804ed68b998083cf5e1b16dc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a9828a7804ed68b998083cf5e1b16dc90">get_error_for_capacity_exceeded</a> () const</td></tr>
<tr class="memdesc:a9828a7804ed68b998083cf5e1b16dc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether error is to be reported when maximum capacity exceeds for MEM_ROOT.  <a href="#a9828a7804ed68b998083cf5e1b16dc90">More...</a><br /></td></tr>
<tr class="separator:a9828a7804ed68b998083cf5e1b16dc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df4f04352aa961cfd84acd697258cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a7df4f04352aa961cfd84acd697258cf4">set_error_handler</a> (void(*error_handler)(void))</td></tr>
<tr class="memdesc:a7df4f04352aa961cfd84acd697258cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error handler on memory allocation failure (or nullptr for none).  <a href="#a7df4f04352aa961cfd84acd697258cf4">More...</a><br /></td></tr>
<tr class="separator:a7df4f04352aa961cfd84acd697258cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b91e821cd28d1ec4ebe977b3d6ab7f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a34b91e821cd28d1ec4ebe977b3d6ab7f">allocated_size</a> () const</td></tr>
<tr class="memdesc:a34b91e821cd28d1ec4ebe977b3d6ab7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of memory we have allocated from the operating system, not including overhead.  <a href="#a34b91e821cd28d1ec4ebe977b3d6ab7f">More...</a><br /></td></tr>
<tr class="separator:a34b91e821cd28d1ec4ebe977b3d6ab7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e088cb260b6817544b9d3ccbb3f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a184e088cb260b6817544b9d3ccbb3f17">set_block_size</a> (size_t block_size)</td></tr>
<tr class="memdesc:a184e088cb260b6817544b9d3ccbb3f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the desired size of the next block to be allocated.  <a href="#a184e088cb260b6817544b9d3ccbb3f17">More...</a><br /></td></tr>
<tr class="separator:a184e088cb260b6817544b9d3ccbb3f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a511cbf6481677e85fc8e5142bd307e63"><td class="memItemLeft" align="right" valign="top">noexcept&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a511cbf6481677e85fc8e5142bd307e63">__pad0__</a>: <a class="el" href="structMEM__ROOT.html#a3c5b47eb88d6b82ea14d7db53cdddff8">m_current_block</a>(other.m_current_block)</td></tr>
<tr class="separator:a511cbf6481677e85fc8e5142bd307e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a537776cb39a71dbb193e81563dc27cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMEM__ROOT_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a537776cb39a71dbb193e81563dc27cb4">AllocBlock</a> (size_t length)</td></tr>
<tr class="memdesc:a537776cb39a71dbb193e81563dc27cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new block of the given length (plus overhead for the block header).  <a href="#a537776cb39a71dbb193e81563dc27cb4">More...</a><br /></td></tr>
<tr class="separator:a537776cb39a71dbb193e81563dc27cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78de4c6265c8382d82a33dd62aee405e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a78de4c6265c8382d82a33dd62aee405e">AllocSlow</a> (size_t length)</td></tr>
<tr class="memdesc:a78de4c6265c8382d82a33dd62aee405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory that doesn't fit into the current free block.  <a href="#a78de4c6265c8382d82a33dd62aee405e">More...</a><br /></td></tr>
<tr class="separator:a78de4c6265c8382d82a33dd62aee405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ab9295580ef1443a773c4b7cd71ad7433"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#ab9295580ef1443a773c4b7cd71ad7433">FreeBlocks</a> (<a class="el" href="structMEM__ROOT_1_1Block.html">Block</a> *<a class="el" href="routing__plugin_8cc.html#aee70c8416f705726100824ba89f1e090">start</a>)</td></tr>
<tr class="memdesc:ab9295580ef1443a773c4b7cd71ad7433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all blocks in a linked list, starting at the given block.  <a href="#ab9295580ef1443a773c4b7cd71ad7433">More...</a><br /></td></tr>
<tr class="separator:ab9295580ef1443a773c4b7cd71ad7433"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3c5b47eb88d6b82ea14d7db53cdddff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMEM__ROOT_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a3c5b47eb88d6b82ea14d7db53cdddff8">m_current_block</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="memdesc:a3c5b47eb88d6b82ea14d7db53cdddff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current block we are giving out memory from.  <a href="#a3c5b47eb88d6b82ea14d7db53cdddff8">More...</a><br /></td></tr>
<tr class="separator:a3c5b47eb88d6b82ea14d7db53cdddff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50b886f9024b39570e7d38003ca587a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#aa50b886f9024b39570e7d38003ca587a">m_current_free_start</a> = &amp;<a class="el" href="structMEM__ROOT.html#acd0819bdd7cd5d771e7d14a6939dcb80">s_dummy_target</a></td></tr>
<tr class="memdesc:aa50b886f9024b39570e7d38003ca587a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start (inclusive) of the current free block.  <a href="#aa50b886f9024b39570e7d38003ca587a">More...</a><br /></td></tr>
<tr class="separator:aa50b886f9024b39570e7d38003ca587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ab2bbb83e0518182ebeb90ad4a2c71"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a12ab2bbb83e0518182ebeb90ad4a2c71">m_current_free_end</a> = &amp;<a class="el" href="structMEM__ROOT.html#acd0819bdd7cd5d771e7d14a6939dcb80">s_dummy_target</a></td></tr>
<tr class="memdesc:a12ab2bbb83e0518182ebeb90ad4a2c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">End (exclusive) of the current free block.  <a href="#a12ab2bbb83e0518182ebeb90ad4a2c71">More...</a><br /></td></tr>
<tr class="separator:a12ab2bbb83e0518182ebeb90ad4a2c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1274d0ed741d9c2c2672fbea6fbe5bca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a1274d0ed741d9c2c2672fbea6fbe5bca">m_block_size</a></td></tr>
<tr class="memdesc:a1274d0ed741d9c2c2672fbea6fbe5bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the <em>next</em> block we intend to allocate.  <a href="#a1274d0ed741d9c2c2672fbea6fbe5bca">More...</a><br /></td></tr>
<tr class="separator:a1274d0ed741d9c2c2672fbea6fbe5bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b8add34ae0864ed1699cd3e83b970b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a74b8add34ae0864ed1699cd3e83b970b">m_orig_block_size</a></td></tr>
<tr class="memdesc:a74b8add34ae0864ed1699cd3e83b970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original block size the user asked for on construction.  <a href="#a74b8add34ae0864ed1699cd3e83b970b">More...</a><br /></td></tr>
<tr class="separator:a74b8add34ae0864ed1699cd3e83b970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967f4f207cbb5c02ee11f19f811db797"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a967f4f207cbb5c02ee11f19f811db797">m_max_capacity</a> = 0</td></tr>
<tr class="memdesc:a967f4f207cbb5c02ee11f19f811db797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum amount of memory this MEM_ROOT can hold.  <a href="#a967f4f207cbb5c02ee11f19f811db797">More...</a><br /></td></tr>
<tr class="separator:a967f4f207cbb5c02ee11f19f811db797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806aa942de064032523f06ac7f160383"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a806aa942de064032523f06ac7f160383">m_allocated_size</a> = 0</td></tr>
<tr class="memdesc:a806aa942de064032523f06ac7f160383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total allocated size for this MEM_ROOT.  <a href="#a806aa942de064032523f06ac7f160383">More...</a><br /></td></tr>
<tr class="separator:a806aa942de064032523f06ac7f160383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fabe7c7f81e52ba469ed13658299073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a9fabe7c7f81e52ba469ed13658299073">m_error_for_capacity_exceeded</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:a9fabe7c7f81e52ba469ed13658299073"><td class="mdescLeft">&#160;</td><td class="mdescRight">If enabled, exceeding the capacity will lead to a my_error() call.  <a href="#a9fabe7c7f81e52ba469ed13658299073">More...</a><br /></td></tr>
<tr class="separator:a9fabe7c7f81e52ba469ed13658299073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01c2c317f03e96046c65c1e00b3028a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#ae01c2c317f03e96046c65c1e00b3028a">m_error_handler</a> )(void) = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="separator:ae01c2c317f03e96046c65c1e00b3028a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e4b875f10b5836d9246ec383fab03d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#a69e4b875f10b5836d9246ec383fab03d">m_psi_key</a> = 0</td></tr>
<tr class="separator:a69e4b875f10b5836d9246ec383fab03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:acd0819bdd7cd5d771e7d14a6939dcb80"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMEM__ROOT.html#acd0819bdd7cd5d771e7d14a6939dcb80">s_dummy_target</a></td></tr>
<tr class="memdesc:acd0819bdd7cd5d771e7d14a6939dcb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Something to point on that exists solely to never return nullptr from Alloc(0).  <a href="#acd0819bdd7cd5d771e7d14a6939dcb80">More...</a><br /></td></tr>
<tr class="separator:acd0819bdd7cd5d771e7d14a6939dcb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The MEM_ROOT is a simple arena, where allocations are carved out of larger blocks. </p>
<p>Using an arena over plain malloc gives you two main advantages:</p>
<ul>
<li>Allocation is very cheap (only a few CPU cycles on the fast path).</li>
<li>You do not need to keep track of which memory you have allocated, as it will all be freed when the arena is destroyed.</li>
</ul>
<p>Thus, if you need to do many small allocations that all are to have roughly the same lifetime, the MEM_ROOT is probably a good choice. The flip side is that <em>no</em> memory is freed until the arena is destroyed, and no destructors are run (although you can run them manually yourself).</p>
<p>This specific implementation works by allocating exponentially larger blocks each time it needs more memory (generally increasing them by 50%), which guarantees O(1) total calls to malloc and free. Only one free block is ever used; as soon as there's an allocation that comes in that doesn't fit, that block is stored away and never allocated from again. (There's an exception for allocations larger than the block size; see AllocSlow for details.)</p>
<p>The MEM_ROOT is thread-compatible but not thread-safe. This means you cannot use the same instance from multiple threads at the same time without external synchronization, but you can use different MEM_ROOTs concurrently in different threads.</p>
<p>For C compatibility reasons, MEM_ROOT is a struct, even though it is logically a class and follows the style guide for classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a59a1cd8a1e8b6b0b9e53b6369f177b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a1cd8a1e8b6b0b9e53b6369f177b93">&#9670;&nbsp;</a></span>MEM_ROOT() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MEM_ROOT::MEM_ROOT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69570bef9d4ce4c1769a872fad7cd3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69570bef9d4ce4c1769a872fad7cd3ee">&#9670;&nbsp;</a></span>MEM_ROOT() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MEM_ROOT::MEM_ROOT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6edc23379cdf57e813cf7868badeb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6edc23379cdf57e813cf7868badeb81">&#9670;&nbsp;</a></span>MEM_ROOT() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MEM_ROOT::MEM_ROOT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a974da616dea3afe99ba86a5d6e9c7a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974da616dea3afe99ba86a5d6e9c7a0f">&#9670;&nbsp;</a></span>~MEM_ROOT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MEM_ROOT::~MEM_ROOT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1762b39f7ab09bb12891f445d6bbcda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1762b39f7ab09bb12891f445d6bbcda2">&#9670;&nbsp;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* MEM_ROOT::Alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory. </p>
<p>Will return nullptr if there's not enough memory, or if the maximum capacity is reached.</p>
<p>Note that a zero-length allocation can return <em>any</em> pointer, including nullptr or a pointer that has been given out before. The current implementation takes some pains to make sure we never return nullptr (although it might return a bogus pointer), since there is code that assumes nullptr always means “out of memory”, but you should not rely on it, as it may change in the future.</p>
<p>The returned pointer will always be 8-aligned. </p>

</div>
</div>
<a id="a34b91e821cd28d1ec4ebe977b3d6ab7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b91e821cd28d1ec4ebe977b3d6ab7f">&#9670;&nbsp;</a></span>allocated_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MEM_ROOT::allocated_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of memory we have allocated from the operating system, not including overhead. </p>

</div>
</div>
<a id="a537776cb39a71dbb193e81563dc27cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537776cb39a71dbb193e81563dc27cb4">&#9670;&nbsp;</a></span>AllocBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMEM__ROOT_1_1Block.html">MEM_ROOT::Block</a> * MEM_ROOT::AllocBlock </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new block of the given length (plus overhead for the block header). </p>

</div>
</div>
<a id="a78de4c6265c8382d82a33dd62aee405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78de4c6265c8382d82a33dd62aee405e">&#9670;&nbsp;</a></span>AllocSlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * MEM_ROOT::AllocSlow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory that doesn't fit into the current free block. </p>

</div>
</div>
<a id="a2e66c098f8dd1550bbaa43381f3c7715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66c098f8dd1550bbaa43381f3c7715">&#9670;&nbsp;</a></span>ArrayAlloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* MEM_ROOT::ArrayAlloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate “num” objects of type T, and default-construct them. </p>
<p>If the constructor throws an exception, behavior is undefined.</p>
<p>We don't use new[], as it can put extra data in front of the array. </p>

</div>
</div>
<a id="a0de5add37c561acd75d3f011580f269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de5add37c561acd75d3f011580f269b">&#9670;&nbsp;</a></span>Claim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::Claim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>claim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim all the allocated memory for the current thread in the performance schema. </p>
<p>Use when transferring responsibility for a MEM_ROOT from one thread to another. </p>

</div>
</div>
<a id="a592e4f09cd0170c2c92228bc154a23ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592e4f09cd0170c2c92228bc154a23ef">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate all the RAM used. </p>
<p>The MEM_ROOT itself continues to be valid, so you can make new calls to Alloc() afterwards.</p>
<dl class="section note"><dt>Note</dt><dd>One can call this function either with a MEM_ROOT initialized with the constructor, or with one that's memset() to all zeros. It's also safe to call this multiple times with the same mem_root. </dd></dl>

</div>
</div>
<a id="a71b823bd5aab8fa6531f0900aa84f988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b823bd5aab8fa6531f0900aa84f988">&#9670;&nbsp;</a></span>ClearForReuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::ClearForReuse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to Clear(), but anticipates that the block will be reused for further allocations. </p>
<p>This means that even though all the data is gone, one memory block (typically the largest allocated) will be kept and made immediately available for calls to Alloc() without having to go to the OS for new memory. This can yield performance gains if you use the same MEM_ROOT many times. Also, the block size is not reset. </p>

</div>
</div>
<a id="ab9295580ef1443a773c4b7cd71ad7433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9295580ef1443a773c4b7cd71ad7433">&#9670;&nbsp;</a></span>FreeBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::FreeBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all blocks in a linked list, starting at the given block. </p>

</div>
</div>
<a id="a9828a7804ed68b998083cf5e1b16dc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9828a7804ed68b998083cf5e1b16dc90">&#9670;&nbsp;</a></span>get_error_for_capacity_exceeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MEM_ROOT::get_error_for_capacity_exceeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether error is to be reported when maximum capacity exceeds for MEM_ROOT. </p>

</div>
</div>
<a id="a2a223e677dae4a615502db20a287fa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a223e677dae4a615502db20a287fa41">&#9670;&nbsp;</a></span>get_max_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MEM_ROOT::get_max_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum capacity for this MEM_ROOT. </p>

</div>
</div>
<a id="acf168d9a9dfbd52f4880041b9d969024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf168d9a9dfbd52f4880041b9d969024">&#9670;&nbsp;</a></span>inited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MEM_ROOT::inited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the constructor has run or not. </p>
<p>This exists solely to support legacy code that memset()s the MEM_ROOT to all zeros, which wants to distinguish between that state and a properly initialized MEM_ROOT. If you do not run the constructor <em>nor</em> do memset(), you are invoking undefined behavior. </p>

</div>
</div>
<a id="a175662de28129abb830660d2c26be960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175662de28129abb830660d2c26be960">&#9670;&nbsp;</a></span>m_allocated_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_allocated_size </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_allocated_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfca932af7371856d782e1d7808e69c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfca932af7371856d782e1d7808e69c5">&#9670;&nbsp;</a></span>m_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_block_size </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_block_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6cf9394e784969fd30f1b377b11eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cf9394e784969fd30f1b377b11eef5">&#9670;&nbsp;</a></span>m_current_free_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_current_free_end </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_current_free_end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7985d7b2bfb41a18d12c29ee5026049a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7985d7b2bfb41a18d12c29ee5026049a">&#9670;&nbsp;</a></span>m_current_free_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_current_free_start </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_current_free_start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a317154bfa1b9ba90245620fed09ea8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317154bfa1b9ba90245620fed09ea8d7">&#9670;&nbsp;</a></span>m_error_for_capacity_exceeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_error_for_capacity_exceeded </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_error_for_capacity_exceeded</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad92ff6bde5a3eaa0ee960243524900e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92ff6bde5a3eaa0ee960243524900e2">&#9670;&nbsp;</a></span>m_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_error_handler </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_error_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae22d839b3d197485e635227692fcda04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22d839b3d197485e635227692fcda04">&#9670;&nbsp;</a></span>m_max_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_max_capacity </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_max_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21bad0088db40f666bd99c837c03c7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bad0088db40f666bd99c837c03c7fc">&#9670;&nbsp;</a></span>m_orig_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_orig_block_size </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_orig_block_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a153a338c055133f5b2863d74c666194d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153a338c055133f5b2863d74c666194d">&#9670;&nbsp;</a></span>m_psi_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::m_psi_key </td>
          <td>(</td>
          <td class="paramtype">other.&#160;</td>
          <td class="paramname"><em>m_psi_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0262957f7f8a6d24383031a05c8a4b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0262957f7f8a6d24383031a05c8a4b1b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a>&amp; MEM_ROOT::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a451cb30c5f328f4317683c4e593c5ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451cb30c5f328f4317683c4e593c5ac6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a>&amp; MEM_ROOT::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a184e088cb260b6817544b9d3ccbb3f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184e088cb260b6817544b9d3ccbb3f17">&#9670;&nbsp;</a></span>set_block_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::set_block_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the desired size of the next block to be allocated. </p>
<p>Note that future allocations will grow in size over this, although a Clear() will reset the size again. </p>

</div>
</div>
<a id="ab35c65b37faf2f2d965439020f3ae492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35c65b37faf2f2d965439020f3ae492">&#9670;&nbsp;</a></span>set_error_for_capacity_exceeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::set_error_for_capacity_exceeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>report_error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/disable error reporting for exceeding the maximum capacity. </p>
<p>If error reporting is enabled, an error is flagged to indicate that the capacity is exceeded. However, allocation will still happen for the requested memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">report_error</td><td>whether the error should be reported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7df4f04352aa961cfd84acd697258cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df4f04352aa961cfd84acd697258cf4">&#9670;&nbsp;</a></span>set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::set_error_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>error_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the error handler on memory allocation failure (or nullptr for none). </p>
<p>The error handler is called called whenever my_malloc() failed to allocate more memory from the OS (which causes my_alloc() to return nullptr). </p>

</div>
</div>
<a id="ad9ff9e411e2ec2033a84a05fb5a23de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ff9e411e2ec2033a84a05fb5a23de2">&#9670;&nbsp;</a></span>set_max_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MEM_ROOT::set_max_capacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum capacity for this MEM_ROOT. </p>
<p>Whenever the MEM_ROOT has allocated more than this (not including overhead), and the free block is empty, future allocations will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_capacity</td><td>Maximum capacity this mem_root can hold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a511cbf6481677e85fc8e5142bd307e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511cbf6481677e85fc8e5142bd307e63">&#9670;&nbsp;</a></span>__pad0__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">noexcept MEM_ROOT::__pad0__</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a806aa942de064032523f06ac7f160383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806aa942de064032523f06ac7f160383">&#9670;&nbsp;</a></span>m_allocated_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MEM_ROOT::m_allocated_size = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total allocated size for this MEM_ROOT. </p>
<p>Does not include overhead for block headers or malloc overhead, since especially the latter is impossible to quantify portably. </p>

</div>
</div>
<a id="a1274d0ed741d9c2c2672fbea6fbe5bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1274d0ed741d9c2c2672fbea6fbe5bca">&#9670;&nbsp;</a></span>m_block_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MEM_ROOT::m_block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the <em>next</em> block we intend to allocate. </p>

</div>
</div>
<a id="a3c5b47eb88d6b82ea14d7db53cdddff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5b47eb88d6b82ea14d7db53cdddff8">&#9670;&nbsp;</a></span>m_current_block</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMEM__ROOT_1_1Block.html">Block</a>* MEM_ROOT::m_current_block = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current block we are giving out memory from. </p>
<p>nullptr if none. </p>

</div>
</div>
<a id="a12ab2bbb83e0518182ebeb90ad4a2c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ab2bbb83e0518182ebeb90ad4a2c71">&#9670;&nbsp;</a></span>m_current_free_end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* MEM_ROOT::m_current_free_end = &amp;<a class="el" href="structMEM__ROOT.html#acd0819bdd7cd5d771e7d14a6939dcb80">s_dummy_target</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End (exclusive) of the current free block. </p>

</div>
</div>
<a id="aa50b886f9024b39570e7d38003ca587a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50b886f9024b39570e7d38003ca587a">&#9670;&nbsp;</a></span>m_current_free_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* MEM_ROOT::m_current_free_start = &amp;<a class="el" href="structMEM__ROOT.html#acd0819bdd7cd5d771e7d14a6939dcb80">s_dummy_target</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start (inclusive) of the current free block. </p>

</div>
</div>
<a id="a9fabe7c7f81e52ba469ed13658299073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fabe7c7f81e52ba469ed13658299073">&#9670;&nbsp;</a></span>m_error_for_capacity_exceeded</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MEM_ROOT::m_error_for_capacity_exceeded = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If enabled, exceeding the capacity will lead to a my_error() call. </p>

</div>
</div>
<a id="ae01c2c317f03e96046c65c1e00b3028a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01c2c317f03e96046c65c1e00b3028a">&#9670;&nbsp;</a></span>m_error_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void(* MEM_ROOT::m_error_handler) (void) = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a967f4f207cbb5c02ee11f19f811db797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967f4f207cbb5c02ee11f19f811db797">&#9670;&nbsp;</a></span>m_max_capacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MEM_ROOT::m_max_capacity = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum amount of memory this MEM_ROOT can hold. </p>
<p>A value of 0 implies there is no limit. </p>

</div>
</div>
<a id="a74b8add34ae0864ed1699cd3e83b970b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b8add34ae0864ed1699cd3e83b970b">&#9670;&nbsp;</a></span>m_orig_block_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MEM_ROOT::m_orig_block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The original block size the user asked for on construction. </p>

</div>
</div>
<a id="a69e4b875f10b5836d9246ec383fab03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e4b875f10b5836d9246ec383fab03d">&#9670;&nbsp;</a></span>m_psi_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__psi__abi__memory.html#ga902dd5c9fe51b8cbdd7438a30e43fdd0">PSI_memory_key</a> MEM_ROOT::m_psi_key = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd0819bdd7cd5d771e7d14a6939dcb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0819bdd7cd5d771e7d14a6939dcb80">&#9670;&nbsp;</a></span>s_dummy_target</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char MEM_ROOT::s_dummy_target</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Something to point on that exists solely to never return nullptr from Alloc(0). </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/<a class="el" href="my__alloc_8h_source.html">my_alloc.h</a></li>
<li>mysys/<a class="el" href="my__alloc_8cc.html">my_alloc.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structMEM__ROOT.html">MEM_ROOT</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
