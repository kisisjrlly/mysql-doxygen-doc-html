<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: binary_log::Event_reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classbinary__log_1_1Event__reader.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classbinary__log_1_1Event__reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">binary_log::Event_reader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Event_reader class purpose is to avoid out-of-buffer reads when deserializing binary log events and increase robustness when dealing with corrupted event buffers.  
 <a href="classbinary__log_1_1Event__reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="event__reader_8h_source.html">event_reader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aace47b7d90af02b278d0ce73fb5fdd11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#aace47b7d90af02b278d0ce73fb5fdd11">Event_reader</a> (const char *<a class="el" href="classbinary__log_1_1Event__reader.html#a780b78e076840cc53603bceb0a4424cb">buffer</a>, unsigned long long <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>)</td></tr>
<tr class="memdesc:aace47b7d90af02b278d0ce73fb5fdd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event_reader constructor.  <a href="#aace47b7d90af02b278d0ce73fb5fdd11">More...</a><br /></td></tr>
<tr class="separator:aace47b7d90af02b278d0ce73fb5fdd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f83894d12e6c40bdb3d4d572eb1ff6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a7f83894d12e6c40bdb3d4d572eb1ff6e">has_error</a> ()</td></tr>
<tr class="memdesc:a7f83894d12e6c40bdb3d4d572eb1ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Event_reader is in an error state or not.  <a href="#a7f83894d12e6c40bdb3d4d572eb1ff6e">More...</a><br /></td></tr>
<tr class="separator:a7f83894d12e6c40bdb3d4d572eb1ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad909a42e0b0ad82ba8d823aecfb1638c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ad909a42e0b0ad82ba8d823aecfb1638c">get_error</a> ()</td></tr>
<tr class="memdesc:ad909a42e0b0ad82ba8d823aecfb1638c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the error message.  <a href="#ad909a42e0b0ad82ba8d823aecfb1638c">More...</a><br /></td></tr>
<tr class="separator:ad909a42e0b0ad82ba8d823aecfb1638c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf3109d0e3f92dabc50df0138eed078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#adaf3109d0e3f92dabc50df0138eed078">set_error</a> (const char *error)</td></tr>
<tr class="memdesc:adaf3109d0e3f92dabc50df0138eed078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Event_reader error state by setting the error message.  <a href="#adaf3109d0e3f92dabc50df0138eed078">More...</a><br /></td></tr>
<tr class="separator:adaf3109d0e3f92dabc50df0138eed078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901cdaa05c51098bf375b5c6ab8b1111"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a> ()</td></tr>
<tr class="memdesc:a901cdaa05c51098bf375b5c6ab8b1111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Event_reader buffer length.  <a href="#a901cdaa05c51098bf375b5c6ab8b1111">More...</a><br /></td></tr>
<tr class="separator:a901cdaa05c51098bf375b5c6ab8b1111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad901a4f6be046e08ceedefb4c8f71aa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ad901a4f6be046e08ceedefb4c8f71aa7">set_length</a> (unsigned long long <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>)</td></tr>
<tr class="memdesc:ad901a4f6be046e08ceedefb4c8f71aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Event_reader buffer length and limit.  <a href="#ad901a4f6be046e08ceedefb4c8f71aa7">More...</a><br /></td></tr>
<tr class="separator:ad901a4f6be046e08ceedefb4c8f71aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13efeabd93338b90867f722e87b02d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#af13efeabd93338b90867f722e87b02d4">shrink_limit</a> (unsigned long long bytes)</td></tr>
<tr class="memdesc:af13efeabd93338b90867f722e87b02d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the Event_reader buffer limit.  <a href="#af13efeabd93338b90867f722e87b02d4">More...</a><br /></td></tr>
<tr class="separator:af13efeabd93338b90867f722e87b02d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780b78e076840cc53603bceb0a4424cb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a780b78e076840cc53603bceb0a4424cb">buffer</a> ()</td></tr>
<tr class="memdesc:a780b78e076840cc53603bceb0a4424cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Event_reader buffer pointer.  <a href="#a780b78e076840cc53603bceb0a4424cb">More...</a><br /></td></tr>
<tr class="separator:a780b78e076840cc53603bceb0a4424cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d24322de4eee9a95b9e4fea8608840"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ab2d24322de4eee9a95b9e4fea8608840">ptr</a> ()</td></tr>
<tr class="memdesc:ab2d24322de4eee9a95b9e4fea8608840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Event_reader cursor (next position to be read by the Event_reader functions).  <a href="#ab2d24322de4eee9a95b9e4fea8608840">More...</a><br /></td></tr>
<tr class="separator:ab2d24322de4eee9a95b9e4fea8608840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6b29df75e126a45e38a325ea48c94"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#afbe6b29df75e126a45e38a325ea48c94">ptr</a> (unsigned long long <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>)</td></tr>
<tr class="memdesc:afbe6b29df75e126a45e38a325ea48c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Event_reader cursor (next position to be read) and moves the cursor forward.  <a href="#afbe6b29df75e126a45e38a325ea48c94">More...</a><br /></td></tr>
<tr class="separator:afbe6b29df75e126a45e38a325ea48c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cd4a7b484a4786f62ba9a29abbf18f"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a72cd4a7b484a4786f62ba9a29abbf18f">position</a> ()</td></tr>
<tr class="memdesc:a72cd4a7b484a4786f62ba9a29abbf18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current Event_reader cursor position in bytes.  <a href="#a72cd4a7b484a4786f62ba9a29abbf18f">More...</a><br /></td></tr>
<tr class="separator:a72cd4a7b484a4786f62ba9a29abbf18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9857198c819207b55ded768bdcc96f25"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a9857198c819207b55ded768bdcc96f25">available_to_read</a> ()</td></tr>
<tr class="memdesc:a9857198c819207b55ded768bdcc96f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of bytes still available to read from cursor position.  <a href="#a9857198c819207b55ded768bdcc96f25">More...</a><br /></td></tr>
<tr class="separator:a9857198c819207b55ded768bdcc96f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f447ab6b3d9aae2295cba780a6ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a8b4f447ab6b3d9aae2295cba780a6ab2">can_read</a> (unsigned long long bytes)</td></tr>
<tr class="memdesc:a8b4f447ab6b3d9aae2295cba780a6ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Event_reader can read a given amount of bytes from cursor position.  <a href="#a8b4f447ab6b3d9aae2295cba780a6ab2">More...</a><br /></td></tr>
<tr class="separator:a8b4f447ab6b3d9aae2295cba780a6ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a5c9a1ebb32be763858345676c056a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a58a5c9a1ebb32be763858345676c056a">go_to</a> (unsigned long long <a class="el" href="classbinary__log_1_1Event__reader.html#a72cd4a7b484a4786f62ba9a29abbf18f">position</a>)</td></tr>
<tr class="memdesc:a58a5c9a1ebb32be763858345676c056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves cursor to a given absolute buffer position and returns the pointer to the cursor.  <a href="#a58a5c9a1ebb32be763858345676c056a">More...</a><br /></td></tr>
<tr class="separator:a58a5c9a1ebb32be763858345676c056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3adece34ebffdd9b2512c2e517a3e6a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ae3adece34ebffdd9b2512c2e517a3e6a">forward</a> (unsigned long long bytes)</td></tr>
<tr class="memdesc:ae3adece34ebffdd9b2512c2e517a3e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the buffer position forward to a given relative position and returns the pointer to the buffer on the specified position.  <a href="#ae3adece34ebffdd9b2512c2e517a3e6a">More...</a><br /></td></tr>
<tr class="separator:ae3adece34ebffdd9b2512c2e517a3e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad615e10879f58ed9721312aaf6dc1d7a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad615e10879f58ed9721312aaf6dc1d7a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ad615e10879f58ed9721312aaf6dc1d7a">read</a> ()</td></tr>
<tr class="memdesc:ad615e10879f58ed9721312aaf6dc1d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a basic type - bool, char, int, long, double, etc - from the buffer, moves the cursor forward the number of bytes returned by sizeof(T)) and returns the read value.  <a href="#ad615e10879f58ed9721312aaf6dc1d7a">More...</a><br /></td></tr>
<tr class="separator:ad615e10879f58ed9721312aaf6dc1d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1255676184b10a1bac1169d37c9a27"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acd1255676184b10a1bac1169d37c9a27"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#acd1255676184b10a1bac1169d37c9a27">memcpy</a> ()</td></tr>
<tr class="memdesc:acd1255676184b10a1bac1169d37c9a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a basic type - bool, char, int, long, double, etc - from the buffer, moves the cursor forward the number of bytes returned by sizeof(T)) and returns the copied value.  <a href="#acd1255676184b10a1bac1169d37c9a27">More...</a><br /></td></tr>
<tr class="separator:acd1255676184b10a1bac1169d37c9a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b78ded595d9a9c04d3ba4c4673d3a2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b78ded595d9a9c04d3ba4c4673d3a2a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a0b78ded595d9a9c04d3ba4c4673d3a2a">read_and_letoh</a> (unsigned char bytes=sizeof(T))</td></tr>
<tr class="memdesc:a0b78ded595d9a9c04d3ba4c4673d3a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a basic arithmetic type - uint8_t, [u]int16_t, [u]int32_t, [u]int64_t - from the buffer, moves the cursor forward using specified bytes parameter (or the number of bytes returned by sizeof(T) when not specified) and returns the copied value transformed from little endian if necessary).  <a href="#a0b78ded595d9a9c04d3ba4c4673d3a2a">More...</a><br /></td></tr>
<tr class="separator:a0b78ded595d9a9c04d3ba4c4673d3a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd595b5ed2bcf5f62cca85284248a27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfd595b5ed2bcf5f62cca85284248a27"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#abfd595b5ed2bcf5f62cca85284248a27">strndup</a> (size_t <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>)</td></tr>
<tr class="memdesc:abfd595b5ed2bcf5f62cca85284248a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a new string which is a duplicate of the input string.  <a href="#abfd595b5ed2bcf5f62cca85284248a27">More...</a><br /></td></tr>
<tr class="separator:abfd595b5ed2bcf5f62cca85284248a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b60fbe51dfa7f9c8b9885cf5fad4855"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b60fbe51dfa7f9c8b9885cf5fad4855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a5b60fbe51dfa7f9c8b9885cf5fad4855">memcpy</a> (T destination, size_t <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>)</td></tr>
<tr class="memdesc:a5b60fbe51dfa7f9c8b9885cf5fad4855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from the cursor to an already existent (and allocated) buffer and moves forward the cursor.  <a href="#a5b60fbe51dfa7f9c8b9885cf5fad4855">More...</a><br /></td></tr>
<tr class="separator:a5b60fbe51dfa7f9c8b9885cf5fad4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df558cff3503d61e882df7ef54b16c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a4df558cff3503d61e882df7ef54b16c8">alloc_and_memcpy</a> (unsigned char **destination, size_t <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>, int <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:a4df558cff3503d61e882df7ef54b16c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to a destination buffer, copies from the cursor to the destination buffer using memcpy() and moves forward the cursor.  <a href="#a4df558cff3503d61e882df7ef54b16c8">More...</a><br /></td></tr>
<tr class="separator:a4df558cff3503d61e882df7ef54b16c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2e73858ceab78029a3fc90bf3883f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a0e2e73858ceab78029a3fc90bf3883f0">alloc_and_strncpy</a> (char **destination, size_t <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>, int <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>)</td></tr>
<tr class="memdesc:a0e2e73858ceab78029a3fc90bf3883f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to a destination buffer, copies from the cursor to the destination buffer using strncpy() and moves forward the cursor.  <a href="#a0e2e73858ceab78029a3fc90bf3883f0">More...</a><br /></td></tr>
<tr class="separator:a0e2e73858ceab78029a3fc90bf3883f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554a33ed9269f452014547a5d9f726b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a554a33ed9269f452014547a5d9f726b4">read_str_at_most_255_bytes</a> (const char **destination, uint8_t *<a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>)</td></tr>
<tr class="memdesc:a554a33ed9269f452014547a5d9f726b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads string from cursor.  <a href="#a554a33ed9269f452014547a5d9f726b4">More...</a><br /></td></tr>
<tr class="separator:a554a33ed9269f452014547a5d9f726b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8cc5cfc87679b2eed8db2e85d0d90"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a92a8cc5cfc87679b2eed8db2e85d0d90">net_field_length_ll</a> ()</td></tr>
<tr class="memdesc:a92a8cc5cfc87679b2eed8db2e85d0d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a packed value.  <a href="#a92a8cc5cfc87679b2eed8db2e85d0d90">More...</a><br /></td></tr>
<tr class="separator:a92a8cc5cfc87679b2eed8db2e85d0d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad925c6c4f24e28a3ce35cf46db9e1201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ad925c6c4f24e28a3ce35cf46db9e1201">read_data_set</a> (uint32_t set_len, <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt; const char *&gt; *<a class="el" href="suite__stubs_8h.html#ad287d8e71b971be7d1c8998b3284340c">set</a>)</td></tr>
<tr class="memdesc:ad925c6c4f24e28a3ce35cf46db9e1201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a transaction context data set.  <a href="#ad925c6c4f24e28a3ce35cf46db9e1201">More...</a><br /></td></tr>
<tr class="separator:ad925c6c4f24e28a3ce35cf46db9e1201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a59bf0e5798801a0361422003bbe8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ab2a59bf0e5798801a0361422003bbe8e">read_data_map</a> (uint32_t map_len, std::map&lt; std::string, std::string &gt; *map)</td></tr>
<tr class="memdesc:ab2a59bf0e5798801a0361422003bbe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a view change certification map.  <a href="#ab2a59bf0e5798801a0361422003bbe8e">More...</a><br /></td></tr>
<tr class="separator:ab2a59bf0e5798801a0361422003bbe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a34eccd6e285f4fba7955e67a259d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a00a34eccd6e285f4fba7955e67a259d2">strncpyz</a> (char *destination, size_t max_length, size_t dest_length)</td></tr>
<tr class="memdesc:a00a34eccd6e285f4fba7955e67a259d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string into the destination buffer up to a max length.  <a href="#a00a34eccd6e285f4fba7955e67a259d2">More...</a><br /></td></tr>
<tr class="separator:a00a34eccd6e285f4fba7955e67a259d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a80f3301293e68f4fd68b438d79c5b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a0a80f3301293e68f4fd68b438d79c5b3">assign</a> (std::vector&lt; uint8_t &gt; *destination, size_t <a class="el" href="classbinary__log_1_1Event__reader.html#a901cdaa05c51098bf375b5c6ab8b1111">length</a>)</td></tr>
<tr class="memdesc:a0a80f3301293e68f4fd68b438d79c5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a sequence of bytes from the cursor.  <a href="#a0a80f3301293e68f4fd68b438d79c5b3">More...</a><br /></td></tr>
<tr class="separator:a0a80f3301293e68f4fd68b438d79c5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9d25ef763fbfad21b970eafccd3c978f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a9d25ef763fbfad21b970eafccd3c978f">letoh</a> (uint16_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a9d25ef763fbfad21b970eafccd3c978f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to le16toh to be used by read_and_letoh function.  <a href="#a9d25ef763fbfad21b970eafccd3c978f">More...</a><br /></td></tr>
<tr class="separator:a9d25ef763fbfad21b970eafccd3c978f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616ea779daf971efe6421e98358aca65"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a616ea779daf971efe6421e98358aca65">letoh</a> (int32_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a616ea779daf971efe6421e98358aca65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to le32toh to be used by read_and_letoh function.  <a href="#a616ea779daf971efe6421e98358aca65">More...</a><br /></td></tr>
<tr class="separator:a616ea779daf971efe6421e98358aca65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6aa94625e8d68f4a98553efd5a2b12b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ab6aa94625e8d68f4a98553efd5a2b12b">letoh</a> (uint32_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:ab6aa94625e8d68f4a98553efd5a2b12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to le32toh to be used by read_and_letoh function.  <a href="#ab6aa94625e8d68f4a98553efd5a2b12b">More...</a><br /></td></tr>
<tr class="separator:ab6aa94625e8d68f4a98553efd5a2b12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2d25e6d62204dfae49e141d3fe095"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a7ea2d25e6d62204dfae49e141d3fe095">letoh</a> (int64_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a7ea2d25e6d62204dfae49e141d3fe095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to le64toh to be used by read_and_letoh function.  <a href="#a7ea2d25e6d62204dfae49e141d3fe095">More...</a><br /></td></tr>
<tr class="separator:a7ea2d25e6d62204dfae49e141d3fe095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3428f871598346a092b92e2727cc301e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a3428f871598346a092b92e2727cc301e">letoh</a> (uint64_t <a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a3428f871598346a092b92e2727cc301e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to le64toh to be used by read_and_letoh function.  <a href="#a3428f871598346a092b92e2727cc301e">More...</a><br /></td></tr>
<tr class="separator:a3428f871598346a092b92e2727cc301e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac7a8d28fc90f686becfb6cf0f83766ac"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ac7a8d28fc90f686becfb6cf0f83766ac">m_buffer</a></td></tr>
<tr class="separator:ac7a8d28fc90f686becfb6cf0f83766ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad146db23ac7fb046535145ce474b2836"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#ad146db23ac7fb046535145ce474b2836">m_ptr</a></td></tr>
<tr class="separator:ad146db23ac7fb046535145ce474b2836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28d0f12ca9634799ab47102492aaf93"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#af28d0f12ca9634799ab47102492aaf93">m_length</a></td></tr>
<tr class="separator:af28d0f12ca9634799ab47102492aaf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2ca5d81562231e7fc6de083c5846d7"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a3f2ca5d81562231e7fc6de083c5846d7">m_limit</a></td></tr>
<tr class="separator:a3f2ca5d81562231e7fc6de083c5846d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094bb0e627da79f4e65779d98e4b3899"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinary__log_1_1Event__reader.html#a094bb0e627da79f4e65779d98e4b3899">m_error</a></td></tr>
<tr class="separator:a094bb0e627da79f4e65779d98e4b3899"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Event_reader class purpose is to avoid out-of-buffer reads when deserializing binary log events and increase robustness when dealing with corrupted event buffers. </p>
<p>The Event_reader is composed by a pointer to the beginning of the serialized event buffer (m_buffer), a variable containing the buffer length (m_length), a cursor pointer that tells the current position to be read from the buffer (m_ptr) and the buffer limit the reader shall respect (m_limit &lt;= m_length).</p>
<p>All buffer reading functions shall move the cursor forward.</p>
<p>Before reading from the buffer, the Event_reader will check if the amount of bytes expected to be read are less or equal to the remaining bytes to read:</p>
<p>remaining = m_limit - (m_ptr - m_buffer)</p>
<p>When there are no enough bytes to read from the buffer, Event_reader enters in error state, so its owner can take an action. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aace47b7d90af02b278d0ce73fb5fdd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace47b7d90af02b278d0ce73fb5fdd11">&#9670;&nbsp;</a></span>Event_reader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">binary_log::Event_reader::Event_reader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event_reader constructor. </p>
<p>It sets the cursor to the first position of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>buffer holding a serialized event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>known buffer length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4df558cff3503d61e882df7ef54b16c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df558cff3503d61e882df7ef54b16c8">&#9670;&nbsp;</a></span>alloc_and_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::alloc_and_memcpy </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory to a destination buffer, copies from the cursor to the destination buffer using memcpy() and moves forward the cursor. </p>
<p>This function is useful for pairs of fields when a first field describes the second field size and the deserialization procedure must allocate a buffer for the second field and then copy the event buffer content to the new allocated buffer.</p>
<p>Before implementing this function and the Event_reader, the deserialization process did like:</p>
<p>memcpy(length, ptr, sizeof(length); ptr+=sizeof(length); field = malloc(length); memcpy(field, ptr, length);</p>
<p>Allocating the memory for the field before knowing if the content can be read from the event buffer is a mistake, as it might allocate a very large amount of memory that will not be used.</p>
<p>So, alloc_and_memcpy ensures that it will only allocate memory for the field if it can be read from the event buffer, avoiding allocating a memory that will not be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the amount of bytes to allocate and read from the buffer (and to move forward). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>flags to pass to MySQL server my_malloc() function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2e73858ceab78029a3fc90bf3883f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2e73858ceab78029a3fc90bf3883f0">&#9670;&nbsp;</a></span>alloc_and_strncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::alloc_and_strncpy </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory to a destination buffer, copies from the cursor to the destination buffer using strncpy() and moves forward the cursor. </p>
<p>See comments on alloc_and_memcpy() for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the amount of bytes to allocate and read from the buffer (and to forward). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>flags to pass to MySQL server my_malloc() function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a80f3301293e68f4fd68b438d79c5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a80f3301293e68f4fd68b438d79c5b3">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::assign </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a vector with a sequence of bytes from the cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>the vector be filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the amount of bytes to read from the cursor (and to move forward). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9857198c819207b55ded768bdcc96f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9857198c819207b55ded768bdcc96f25">&#9670;&nbsp;</a></span>available_to_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long binary_log::Event_reader::available_to_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of bytes still available to read from cursor position. </p>
<dl class="section return"><dt>Returns</dt><dd>the amount of bytes still available to read. </dd></dl>

</div>
</div>
<a id="a780b78e076840cc53603bceb0a4424cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780b78e076840cc53603bceb0a4424cb">&#9670;&nbsp;</a></span>buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* binary_log::Event_reader::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Event_reader buffer pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>the Event_reader buffer pointer. </dd></dl>

</div>
</div>
<a id="a8b4f447ab6b3d9aae2295cba780a6ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f447ab6b3d9aae2295cba780a6ab2">&#9670;&nbsp;</a></span>can_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> binary_log::Event_reader::can_read </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the Event_reader can read a given amount of bytes from cursor position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the amount of bytes expected to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the Event_reader can read the specified amount of bytes. </td></tr>
    <tr><td class="paramname">false</td><td>if the Event_reader cannot read the specified amount of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3adece34ebffdd9b2512c2e517a3e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3adece34ebffdd9b2512c2e517a3e6a">&#9670;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* binary_log::Event_reader::forward </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the buffer position forward to a given relative position and returns the pointer to the buffer on the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the amount of bytes to move forward.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>a pointer to the new buffer position. </td></tr>
    <tr><td class="paramname">nullptr</td><td>if the cursor is out of buffer boundaries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad909a42e0b0ad82ba8d823aecfb1638c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad909a42e0b0ad82ba8d823aecfb1638c">&#9670;&nbsp;</a></span>get_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* binary_log::Event_reader::get_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the error message. </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the error message when Event_reader is in error state, or a nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a58a5c9a1ebb32be763858345676c056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a5c9a1ebb32be763858345676c056a">&#9670;&nbsp;</a></span>go_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * binary_log::Event_reader::go_to </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves cursor to a given absolute buffer position and returns the pointer to the cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>the position to jump to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>a pointer to the new cursor position. </td></tr>
    <tr><td class="paramname">nullptr</td><td>if the position is out of buffer boundaries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f83894d12e6c40bdb3d4d572eb1ff6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f83894d12e6c40bdb3d4d572eb1ff6e">&#9670;&nbsp;</a></span>has_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> binary_log::Event_reader::has_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the Event_reader is in an error state or not. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the Event_reader is in error state. </td></tr>
    <tr><td class="paramname">false</td><td>if the Event_reader is not in error state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a901cdaa05c51098bf375b5c6ab8b1111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901cdaa05c51098bf375b5c6ab8b1111">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long binary_log::Event_reader::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Event_reader buffer length. </p>
<p>Note: the buffer length might be larger than reader allowed buffer limit, but the Event_reader will enter error state when trying to read above the limit.</p>
<p>Example: an event buffer may contain the serialized event + checksum. The event reader object will be configured with a buffer length that contains both the serialized event and the checksum information, but once Log_event_footer is instantiated, it shall adjust the event reader buffer limit to the buffer position right before the checksum. This will avoid some event deserialization relying on event buffer size to assume the checksum as serialized event content.</p>
<dl class="section return"><dt>Returns</dt><dd>the Event_reader buffer length. </dd></dl>

</div>
</div>
<a id="a9d25ef763fbfad21b970eafccd3c978f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d25ef763fbfad21b970eafccd3c978f">&#9670;&nbsp;</a></span>letoh() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t binary_log::Event_reader::letoh </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to le16toh to be used by read_and_letoh function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value. </dd></dl>

</div>
</div>
<a id="a616ea779daf971efe6421e98358aca65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616ea779daf971efe6421e98358aca65">&#9670;&nbsp;</a></span>letoh() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t binary_log::Event_reader::letoh </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to le32toh to be used by read_and_letoh function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value. </dd></dl>

</div>
</div>
<a id="ab6aa94625e8d68f4a98553efd5a2b12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6aa94625e8d68f4a98553efd5a2b12b">&#9670;&nbsp;</a></span>letoh() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t binary_log::Event_reader::letoh </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to le32toh to be used by read_and_letoh function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value. </dd></dl>

</div>
</div>
<a id="a7ea2d25e6d62204dfae49e141d3fe095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea2d25e6d62204dfae49e141d3fe095">&#9670;&nbsp;</a></span>letoh() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t binary_log::Event_reader::letoh </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to le64toh to be used by read_and_letoh function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value. </dd></dl>

</div>
</div>
<a id="a3428f871598346a092b92e2727cc301e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3428f871598346a092b92e2727cc301e">&#9670;&nbsp;</a></span>letoh() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t binary_log::Event_reader::letoh </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to le64toh to be used by read_and_letoh function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>the value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted value. </dd></dl>

</div>
</div>
<a id="acd1255676184b10a1bac1169d37c9a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1255676184b10a1bac1169d37c9a27">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T binary_log::Event_reader::memcpy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a basic type - bool, char, int, long, double, etc - from the buffer, moves the cursor forward the number of bytes returned by sizeof(T)) and returns the copied value. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">value</td><td>the T copied from the cursor position. </td></tr>
    <tr><td class="paramname">0</td><td>if the cursor was out of buffer boundaries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b60fbe51dfa7f9c8b9885cf5fad4855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b60fbe51dfa7f9c8b9885cf5fad4855">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::memcpy </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies from the cursor to an already existent (and allocated) buffer and moves forward the cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>a pointer to the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the amount of bytes to read from the buffer (and to move forward). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92a8cc5cfc87679b2eed8db2e85d0d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a8cc5cfc87679b2eed8db2e85d0d90">&#9670;&nbsp;</a></span>net_field_length_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t binary_log::Event_reader::net_field_length_ll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a packed value. </p>
<p>This function can move the cursor forward by 1, 3, 4 or 9 bytes depending on the value to be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the packed value. </dd></dl>

</div>
</div>
<a id="a72cd4a7b484a4786f62ba9a29abbf18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cd4a7b484a4786f62ba9a29abbf18f">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long binary_log::Event_reader::position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current Event_reader cursor position in bytes. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">m_limit</td><td>if cursor position is invalid. </td></tr>
    <tr><td class="paramname">position</td><td>current Event_reader cursor position (if valid). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2d24322de4eee9a95b9e4fea8608840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d24322de4eee9a95b9e4fea8608840">&#9670;&nbsp;</a></span>ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* binary_log::Event_reader::ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the Event_reader cursor (next position to be read by the Event_reader functions). </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the Event_reader cursor. </dd></dl>

</div>
</div>
<a id="afbe6b29df75e126a45e38a325ea48c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe6b29df75e126a45e38a325ea48c94">&#9670;&nbsp;</a></span>ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * binary_log::Event_reader::ptr </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Event_reader cursor (next position to be read) and moves the cursor forward. </p>
<p>This function is used when the buffer contains a field of a known size and the deserialization procedure must keep the pointer to the field but moving the cursor to after it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the amount of bytes to move the cursor forward.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the Event_reader cursor before forwarding it. </dd></dl>

</div>
</div>
<a id="ad615e10879f58ed9721312aaf6dc1d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad615e10879f58ed9721312aaf6dc1d7a">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T binary_log::Event_reader::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a basic type - bool, char, int, long, double, etc - from the buffer, moves the cursor forward the number of bytes returned by sizeof(T)) and returns the read value. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">value</td><td>the T read from the cursor position. </td></tr>
    <tr><td class="paramname">0</td><td>if the cursor was out of buffer boundaries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b78ded595d9a9c04d3ba4c4673d3a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b78ded595d9a9c04d3ba4c4673d3a2a">&#9670;&nbsp;</a></span>read_and_letoh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T binary_log::Event_reader::read_and_letoh </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>bytes</em> = <code>sizeof(T)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a basic arithmetic type - uint8_t, [u]int16_t, [u]int32_t, [u]int64_t - from the buffer, moves the cursor forward using specified bytes parameter (or the number of bytes returned by sizeof(T) when not specified) and returns the copied value transformed from little endian if necessary). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>the amount of bytes to read from the buffer (and to move forward). When not specified, will use sizeof(T).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">value</td><td>the T copied from the cursor position. </td></tr>
    <tr><td class="paramname">0</td><td>if the cursor was out of buffer boundaries or there was no memory to allocate to the new string.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2a59bf0e5798801a0361422003bbe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a59bf0e5798801a0361422003bbe8e">&#9670;&nbsp;</a></span>read_data_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::read_data_map </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>map_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; *&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a view change certification map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map_len</td><td>the length of the certification info map (and to move forward). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">map</td><td>the certification info map to be filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad925c6c4f24e28a3ce35cf46db9e1201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad925c6c4f24e28a3ce35cf46db9e1201">&#9670;&nbsp;</a></span>read_data_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::read_data_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>set_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt; const char *&gt; *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a transaction context data set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">set_len</td><td>length of the set object (and to move forward). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>pointer to the set object to be filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a554a33ed9269f452014547a5d9f726b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554a33ed9269f452014547a5d9f726b4">&#9670;&nbsp;</a></span>read_str_at_most_255_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::read_str_at_most_255_bytes </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads string from cursor. </p>
<p>Reads in the following format: 1) Reads length stored on cursor first index. Moves cursor forward 1 byte. 2) Set destination pointer to the cursor. Moves cursor forward length bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>the destination pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>the amount of bytes to allocate and read from the buffer (and to move forward). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaf3109d0e3f92dabc50df0138eed078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf3109d0e3f92dabc50df0138eed078">&#9670;&nbsp;</a></span>set_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::set_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Event_reader error state by setting the error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>pointer to the error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad901a4f6be046e08ceedefb4c8f71aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad901a4f6be046e08ceedefb4c8f71aa7">&#9670;&nbsp;</a></span>set_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::set_length </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Event_reader buffer length and limit. </p>
<p>The length of the buffer should only be set to values greater or equal to the current buffer length. Trying to set the length to less than current buffer length will make the Event_buffer to enter error state.</p>
<p>The length is initially set in Event_reader constructor to LOG_EVENT_MINIMAL_HEADER_LEN by the Log_event_header when instantiating it. This should be enough to read the event header and determine the correct buffer length. The Log_event_header will adjust the Event_reader length by calling this function based on the value of event data_written header field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the new Event_reader buffer length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af13efeabd93338b90867f722e87b02d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13efeabd93338b90867f722e87b02d4">&#9670;&nbsp;</a></span>shrink_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::shrink_limit </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the Event_reader buffer limit. </p>
<p>This function is used by Log_event_footer to remove the checksum payload (if necessary) from the serialized event size, as many event types rely on the serialized event size to determine the size of some fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>the amount of bytes to shrink the Event_reader buffer length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00a34eccd6e285f4fba7955e67a259d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a34eccd6e285f4fba7955e67a259d2">&#9670;&nbsp;</a></span>strncpyz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binary_log::Event_reader::strncpyz </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string into the destination buffer up to a max length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_length</td><td>the max length to copy from the cursor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_length</td><td>the max length supported by the destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfd595b5ed2bcf5f62cca85284248a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd595b5ed2bcf5f62cca85284248a27">&#9670;&nbsp;</a></span>strndup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T binary_log::Event_reader::strndup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to a new string which is a duplicate of the input string. </p>
<p>The terminating null character is added. See: bapi_strndup().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the amount of bytes to read from the buffer (and to move forward).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>the T pointer from the cursor position. </td></tr>
    <tr><td class="paramname">nullptr</td><td>if the cursor was out of buffer boundaries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac7a8d28fc90f686becfb6cf0f83766ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a8d28fc90f686becfb6cf0f83766ac">&#9670;&nbsp;</a></span>m_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* binary_log::Event_reader::m_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a094bb0e627da79f4e65779d98e4b3899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094bb0e627da79f4e65779d98e4b3899">&#9670;&nbsp;</a></span>m_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* binary_log::Event_reader::m_error</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af28d0f12ca9634799ab47102492aaf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28d0f12ca9634799ab47102492aaf93">&#9670;&nbsp;</a></span>m_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long binary_log::Event_reader::m_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f2ca5d81562231e7fc6de083c5846d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2ca5d81562231e7fc6de083c5846d7">&#9670;&nbsp;</a></span>m_limit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long binary_log::Event_reader::m_limit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad146db23ac7fb046535145ce474b2836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad146db23ac7fb046535145ce474b2836">&#9670;&nbsp;</a></span>m_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* binary_log::Event_reader::m_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libbinlogevents/include/<a class="el" href="event__reader_8h_source.html">event_reader.h</a></li>
<li>libbinlogevents/src/<a class="el" href="event__reader_8cpp.html">event_reader.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebinary__log.html">binary_log</a></li><li class="navelem"><a class="el" href="classbinary__log_1_1Event__reader.html">Event_reader</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
