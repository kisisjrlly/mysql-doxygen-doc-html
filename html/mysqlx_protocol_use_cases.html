<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Use Cases</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mysqlx_protocol_use_cases.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Use Cases </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Topics in this section:</p>
<ul>
<li><a class="el" href="mysqlx_protocol_use_cases.html#use_cases_Prepared_Statements_with_Single_Round_Trip">Prepared Statements with Single Round-Trip </a></li>
<li><a class="el" href="mysqlx_protocol_use_cases.html#use_cases_Streaming_Inserts">Streaming Inserts </a></li>
<li><a class="el" href="mysqlx_protocol_use_cases.html#use_cases_SQL_with_Multiple_Resultsets">SQL with Multiple Resultsets </a></li>
<li><a class="el" href="mysqlx_protocol_use_cases.html#use_cases_Inserting_CRUD_Data_in_a_Batch">Inserting CRUD Data in a Batch </a></li>
<li><a class="el" href="mysqlx_protocol_use_cases.html#use_cases_Cross_Collection_Update_and_Delete">Cross-Collection Update and Delete </a></li>
</ul>
<h1><a class="anchor" id="use_cases_Prepared_Statements_with_Single_Round_Trip"></a>
Prepared Statements with Single Round-Trip </h1>
<p>In the MySQL Client/Server Protocol, a <code>PREPARE</code>/<code>EXECUTE</code> cycle required two round-trips as the <code>COM_STMT_EXECUTE</code> requires data from the <code>COM_STMT_PREPARE-ok</code> packet.</p>
<p>The X Protocol is designed in a way that the <code>EXECUTE</code> stage doesn't depend on the response of the <code>PREPARE</code> stage.</p>
<p>That allows the client to send both <code>PREPARE</code> and <code>EXECUTE</code> after each other without waiting for the server's response.</p>
<dl class="section note"><dt>Note</dt><dd>See the <a class="el" href="mysqlx_protocol_implementation.html">Implementation Notes</a> about how to efficiently implement pipelining.</dd></dl>
<h1><a class="anchor" id="use_cases_Streaming_Inserts"></a>
Streaming Inserts </h1>
<p>When inserting a large set of data (data import), make a trade-off among:</p>
<ul>
<li>memory usage on client and server side</li>
<li>network round-trips</li>
<li>error reporting</li>
</ul>
<p>For this example it is assumed that 1 million rows, each 1024 bytes in size have to be transferred to the server.</p>
<p>Optimizing for Network Round-Trips**</p>
<p>(Assuming the MySQL Client/Server Protocol in this case) Network round-trips can be minimized by creating a huge SQL statements of up to 1Gbyte in chunks of 16Mbyte (the protocol's maximum frame size) and sending it over the wire and letting the server execute it.</p>
<div class="fragment"><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span></div><div class="line">  ( <span class="stringliteral">1</span>, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span> ),</div><div class="line">  ( <span class="stringliteral">2</span>, <span class="stringliteral">&quot;baz&quot;</span>, <span class="stringliteral">&quot;fuz&quot;</span> ),</div><div class="line">  ...;</div></div><!-- fragment --><p>In this case:</p>
<ul>
<li>the client can generate the SQL statement in chunks of 16Mbyte and write them to the network</li>
<li>*(memory usage)* the server waits until the full 1GByte is received</li>
<li>*(execution delay)* before it can start parsing and executing it</li>
<li>*(error-reporting)* in case an error (parse-error, duplicate key error, ...) the whole 1Gbyte message will be denied without any good way to know where the error in that big message happened</li>
</ul>
<p>The <em>Execution Time</em> for inserting all rows in one batch is:</p>
<div class="fragment"><div class="line">1 * RTT +</div><div class="line">(num_rows * Row Size / Network Bandwidth) +</div><div class="line">num_rows * Row Parse Time +</div><div class="line">num_rows * Row Execution Time</div></div><!-- fragment --><p>Optimizing for Memory Usage and Error-Reporting**</p>
<p>The other extreme is using single row <code>INSERT</code> statements:</p>
<div class="fragment"><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span></div><div class="line">  ( <span class="stringliteral">1</span>, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span> );</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl <span class="keyword">VALUES</span></div><div class="line">  ( <span class="stringliteral">2</span>, <span class="stringliteral">&quot;baz&quot;</span>, <span class="stringliteral">&quot;fuz&quot;</span> );</div><div class="line"></div><div class="line">  ...</div></div><!-- fragment --><ul>
<li>client can generate statements as it receives data</li>
<li>streams it to the server</li>
<li>*(execution delay)* server starts executing statements as soon as it receives the first row</li>
<li>*(memory usage)* server only has to buffer a single row</li>
<li>*(error-reporting)* if inserting one row fails, the client knows about it when it happens</li>
<li>as each statement results in its own round-trip, the network-latency is applied for each row instead of once</li>
<li>each statement has to be parsed and executed in the server</li>
</ul>
<p>Using Prepared Statements solves the last bullet point:</p>
<p>The <em>Execution Time</em> for inserting all rows using prepared statements and the MySQL Client/Server Protocol is:</p>
<div class="fragment"><div class="line">num_rows * RTT +</div><div class="line">(num_rows * Row Size / Network Bandwidth) +</div><div class="line">1 * Row Parse Time +</div><div class="line">num_rows * Row Execution Time</div></div><!-- fragment --><p>Optimizing for Execution Time and Error-Reporting**</p>
<p>In the X Protocol, a pipeline can be used to stream messages to the server while the server is executing the previous message.</p>
<p>The <em>Execution Time</em> for inserting all rows using prepared statements and using pipelining is (assuming that the network is not saturated):</p>
<div class="fragment"><div class="line">1 * RTT +</div><div class="line">(1 * Row Size / Network Bandwidth) +</div><div class="line">1 * Row Parse Time +</div><div class="line">num_rows * Row Execution Time</div></div><!-- fragment --><ul>
<li><code>one</code> <em>network latency</em> to get the initial <code>prepare</code>/<code>execute</code> across the wire</li>
<li><code>one</code> <em>network bandwith</em> to get the initial <code>prepare</code>/<code>execute</code> across the wire. All further commands arrive at the server before the executor needs them thanks to pipelining.</li>
<li><code>one</code> <em>row parse time</em> to parse the <code>prepare</code></li>
<li><code>num_rows</code> <em>row execution time</em> stays as before</li>
</ul>
<p>In case <em>error reporting</em> isn't a major topic one can combine <code>multi-row INSERT</code> with pipelining and reduce the per-row network overhead. This is important in case the network is saturated.</p>
<h1><a class="anchor" id="use_cases_SQL_with_Multiple_Resultsets"></a>
SQL with Multiple Resultsets </h1>
<h1><a class="anchor" id="use_cases_Inserting_CRUD_Data_in_a_Batch"></a>
Inserting CRUD Data in a Batch </h1>
<p>Inserting multiple documents into a collection <code>col1</code> is a two-step process:.</p>
<ol type="1">
<li>prepare the insert</li>
<li>pipeline the execute messages</li>
</ol>
<p>By utilizing pipelining the <code>execute</code> message can be batched without waiting for the corresponding <code>executeOk</code> message to be returned.</p>
<h1><a class="anchor" id="use_cases_Cross_Collection_Update_and_Delete"></a>
Cross-Collection Update and Delete </h1>
<p>Deleting documents from collection <code>col2</code> based on data from collection <code>col1</code>.</p>
<p>Instead of fetching all rows from <code>col1</code> first to construct a big <code>delete</code> message it can also be run in nested loop:</p>
<div class="fragment"><div class="line">Crud.PrepareDelete(stmt_id=2, Collection(name=&quot;col2&quot;), filter={ id=? })</div><div class="line">Crud.PrepareFind(stmt_id=1, Collection(name=&quot;col1&quot;), filter={ ... })</div><div class="line"></div><div class="line">Sql.PreparedStmtExecute(stmt_id=1, cursor_id=2)</div><div class="line"></div><div class="line">while ((rows = Sql.CursorFetch(cursor_id=2))):</div><div class="line">  Sql.PreparedStmtExecute(stmt_id=2, values = [ rows.col2_id ])</div><div class="line"></div><div class="line">Sql.PreparedStmtClose(stmt_id=2)</div><div class="line">Sql.PreparedStmtClose(stmt_id=1)</div></div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="mysqlx_protocol.html">X %Protocol</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
