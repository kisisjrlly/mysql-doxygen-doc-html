<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Parallel_reader_adapter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classParallel__reader__adapter.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classParallel__reader__adapter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Parallel_reader_adapter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Traverse an index in the leaf page block list order and send records to adapter.  
 <a href="classParallel__reader__adapter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="row0pread-adapter_8h_source.html">row0pread-adapter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel__reader__adapter_1_1MySQL__row.html">MySQL_row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL row meta data.  <a href="structParallel__reader__adapter_1_1MySQL__row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel__reader__adapter_1_1Thread__ctx.html">Thread_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback thread context for each of the spawned threads.  <a href="structParallel__reader__adapter_1_1Thread__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aad6fcaac320623ea3f682b08178df9e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Load_fn</a> = <a class="el" href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">handler::Load_cbk</a></td></tr>
<tr class="separator:aad6fcaac320623ea3f682b08178df9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa757b9e4ec4605e11f70f332c23775e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">End_fn</a> = <a class="el" href="classhandler.html#a24e65d325f0e08107186740bcb248756">handler::Load_end_cbk</a></td></tr>
<tr class="separator:aa757b9e4ec4605e11f70f332c23775e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c565baaa1b962867200f2897c410f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Init_fn</a> = <a class="el" href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">handler::Load_init_cbk</a></td></tr>
<tr class="separator:a71c565baaa1b962867200f2897c410f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e53cebc59f4449673c4810b078c5cfc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a3e53cebc59f4449673c4810b078c5cfc">Parallel_reader_adapter</a> (size_t max_threads, ulint rowlen)</td></tr>
<tr class="memdesc:a3e53cebc59f4449673c4810b078c5cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a3e53cebc59f4449673c4810b078c5cfc">More...</a><br /></td></tr>
<tr class="separator:a3e53cebc59f4449673c4810b078c5cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701c92aeb46745e547f35ee49c27e404"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a701c92aeb46745e547f35ee49c27e404">~Parallel_reader_adapter</a> ()=default</td></tr>
<tr class="memdesc:a701c92aeb46745e547f35ee49c27e404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a701c92aeb46745e547f35ee49c27e404">More...</a><br /></td></tr>
<tr class="separator:a701c92aeb46745e547f35ee49c27e404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff138cfc91bbe2b50b7291f03ed96515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#aff138cfc91bbe2b50b7291f03ed96515">add_scan</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structParallel__reader_1_1Config.html">Parallel_reader::Config</a> &amp;<a class="el" href="structconfig.html">config</a>, <a class="el" href="classParallel__reader.html#afb76966c3a4f93141e5c586a98b82845">Parallel_reader::F</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:aff138cfc91bbe2b50b7291f03ed96515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add scan context.  <a href="#aff138cfc91bbe2b50b7291f03ed96515">More...</a><br /></td></tr>
<tr class="separator:aff138cfc91bbe2b50b7291f03ed96515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac8122fc90cfb61ef9bdda538d380d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#aeac8122fc90cfb61ef9bdda538d380d8">run</a> (void **thread_contexts, <a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Init_fn</a> init_fn, <a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Load_fn</a> load_fn, <a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">End_fn</a> end_fn)</td></tr>
<tr class="memdesc:aeac8122fc90cfb61ef9bdda538d380d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the parallel scan.  <a href="#aeac8122fc90cfb61ef9bdda538d380d8">More...</a><br /></td></tr>
<tr class="separator:aeac8122fc90cfb61ef9bdda538d380d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e31861f8a9ffd4e0240a2aedad3dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a43e31861f8a9ffd4e0240a2aedad3dbd">process_rows</a> (const <a class="el" href="classParallel__reader_1_1Ctx.html">Parallel_reader::Ctx</a> *reader_ctx)</td></tr>
<tr class="memdesc:a43e31861f8a9ffd4e0240a2aedad3dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the record in InnoDB format to MySQL format and send them.  <a href="#a43e31861f8a9ffd4e0240a2aedad3dbd">More...</a><br /></td></tr>
<tr class="separator:a43e31861f8a9ffd4e0240a2aedad3dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fe8213720845da80fea091a92ae469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a69fe8213720845da80fea091a92ae469">set</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt)</td></tr>
<tr class="memdesc:a69fe8213720845da80fea091a92ae469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the query processing state cache.  <a href="#a69fe8213720845da80fea091a92ae469">More...</a><br /></td></tr>
<tr class="separator:a69fe8213720845da80fea091a92ae469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac977338cbd5f745f92ce8e537b18c19c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#ac977338cbd5f745f92ce8e537b18c19c">init</a> (<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Parallel_reader::Thread_ctx</a> *reader_thread_ctx)</td></tr>
<tr class="memdesc:ac977338cbd5f745f92ce8e537b18c19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each parallel reader thread's init function.  <a href="#ac977338cbd5f745f92ce8e537b18c19c">More...</a><br /></td></tr>
<tr class="separator:ac977338cbd5f745f92ce8e537b18c19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a06ff82664e9cf94ea333db2cbc7201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a5a06ff82664e9cf94ea333db2cbc7201">end</a> (<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Parallel_reader::Thread_ctx</a> *reader_thread_ctx)</td></tr>
<tr class="memdesc:a5a06ff82664e9cf94ea333db2cbc7201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each parallel reader thread's end function.  <a href="#a5a06ff82664e9cf94ea333db2cbc7201">More...</a><br /></td></tr>
<tr class="separator:a5a06ff82664e9cf94ea333db2cbc7201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa7796944f445c2c74add42a913b65d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#abaa7796944f445c2c74add42a913b65d">send_batch</a> (<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Parallel_reader::Thread_ctx</a> *reader_thread_ctx, size_t partition_id, uint64_t n_recs)</td></tr>
<tr class="memdesc:abaa7796944f445c2c74add42a913b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a batch of records.  <a href="#abaa7796944f445c2c74add42a913b65d">More...</a><br /></td></tr>
<tr class="separator:abaa7796944f445c2c74add42a913b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9883b3fef38057254ca86ca841fdf6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a4e9883b3fef38057254ca86ca841fdf6">pending</a> (<a class="el" href="structParallel__reader__adapter_1_1Thread__ctx.html">Thread_ctx</a> *ctx) const</td></tr>
<tr class="memdesc:a4e9883b3fef38057254ca86ca841fdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of rows buffered but not sent.  <a href="#a4e9883b3fef38057254ca86ca841fdf6">More...</a><br /></td></tr>
<tr class="separator:a4e9883b3fef38057254ca86ca841fdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff099e4c9ee4850f1726b97577f4b88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a6ff099e4c9ee4850f1726b97577f4b88">is_buffer_full</a> (<a class="el" href="structParallel__reader__adapter_1_1Thread__ctx.html">Thread_ctx</a> *ctx) const</td></tr>
<tr class="memdesc:a6ff099e4c9ee4850f1726b97577f4b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is full.  <a href="#a6ff099e4c9ee4850f1726b97577f4b88">More...</a><br /></td></tr>
<tr class="separator:a6ff099e4c9ee4850f1726b97577f4b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aee25a5e3046bd5be9043d1fad0a2b364"><td class="memItemLeft" align="right" valign="top">void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#aee25a5e3046bd5be9043d1fad0a2b364">m_thread_ctxs</a> {}</td></tr>
<tr class="memdesc:aee25a5e3046bd5be9043d1fad0a2b364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter context for each of the spawned threads.  <a href="#aee25a5e3046bd5be9043d1fad0a2b364">More...</a><br /></td></tr>
<tr class="separator:aee25a5e3046bd5be9043d1fad0a2b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb1a06e64161316c4cd8605a1a1013e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Init_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a5cb1a06e64161316c4cd8605a1a1013e">m_init_fn</a> {}</td></tr>
<tr class="memdesc:a5cb1a06e64161316c4cd8605a1a1013e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called by each parallel load thread at the beginning of the parallel load for the scan.  <a href="#a5cb1a06e64161316c4cd8605a1a1013e">More...</a><br /></td></tr>
<tr class="separator:a5cb1a06e64161316c4cd8605a1a1013e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c49a6ba83cc5600b60a079565f3a412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Load_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a9c49a6ba83cc5600b60a079565f3a412">m_load_fn</a> {}</td></tr>
<tr class="memdesc:a9c49a6ba83cc5600b60a079565f3a412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called by each parallel load thread when processing of rows is required for the scan.  <a href="#a9c49a6ba83cc5600b60a079565f3a412">More...</a><br /></td></tr>
<tr class="separator:a9c49a6ba83cc5600b60a079565f3a412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3e35be4cbbbaec5c5b7999c7c465ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">End_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#afb3e35be4cbbbaec5c5b7999c7c465ff">m_end_fn</a> {}</td></tr>
<tr class="memdesc:afb3e35be4cbbbaec5c5b7999c7c465ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called by each parallel load thread when processing of rows has ended for the scan.  <a href="#afb3e35be4cbbbaec5c5b7999c7c465ff">More...</a><br /></td></tr>
<tr class="separator:afb3e35be4cbbbaec5c5b7999c7c465ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8eaa687560de6b923ab15699468daf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a3a8eaa687560de6b923ab15699468daf">m_batch_size</a> {}</td></tr>
<tr class="memdesc:a3a8eaa687560de6b923ab15699468daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of records to be sent across to the caller in a batch.  <a href="#a3a8eaa687560de6b923ab15699468daf">More...</a><br /></td></tr>
<tr class="separator:a3a8eaa687560de6b923ab15699468daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c51a4c427fc7d96b4c4c65bbe6678d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structParallel__reader__adapter_1_1MySQL__row.html">MySQL_row</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#ad6c51a4c427fc7d96b4c4c65bbe6678d">m_mysql_row</a> {}</td></tr>
<tr class="memdesc:ad6c51a4c427fc7d96b4c4c65bbe6678d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row meta data per scan context.  <a href="#ad6c51a4c427fc7d96b4c4c65bbe6678d">More...</a><br /></td></tr>
<tr class="separator:ad6c51a4c427fc7d96b4c4c65bbe6678d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994366571853eb55b0be6bc24b981877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#a994366571853eb55b0be6bc24b981877">m_prebuilt</a> {}</td></tr>
<tr class="memdesc:a994366571853eb55b0be6bc24b981877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prebuilt to use for conversion to MySQL row format.  <a href="#a994366571853eb55b0be6bc24b981877">More...</a><br /></td></tr>
<tr class="separator:a994366571853eb55b0be6bc24b981877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e985db2d826c9b87ed9121cc895dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader.html">Parallel_reader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#ac8e985db2d826c9b87ed9121cc895dd8">m_parallel_reader</a></td></tr>
<tr class="memdesc:ac8e985db2d826c9b87ed9121cc895dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel reader to use.  <a href="#ac8e985db2d826c9b87ed9121cc895dd8">More...</a><br /></td></tr>
<tr class="separator:ac8e985db2d826c9b87ed9121cc895dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:acf52b41d48666b315acf73892924a141"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader__adapter.html#acf52b41d48666b315acf73892924a141">ADAPTER_SEND_BUFFER_SIZE</a> = 2 * 1024 * 1024</td></tr>
<tr class="memdesc:acf52b41d48666b315acf73892924a141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the buffer used to store InnoDB records and sent to the adapter.  <a href="#acf52b41d48666b315acf73892924a141">More...</a><br /></td></tr>
<tr class="separator:acf52b41d48666b315acf73892924a141"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Traverse an index in the leaf page block list order and send records to adapter. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa757b9e4ec4605e11f70f332c23775e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa757b9e4ec4605e11f70f332c23775e8">&#9670;&nbsp;</a></span>End_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">Parallel_reader_adapter::End_fn</a> =  <a class="el" href="classhandler.html#a24e65d325f0e08107186740bcb248756">handler::Load_end_cbk</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71c565baaa1b962867200f2897c410f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c565baaa1b962867200f2897c410f6">&#9670;&nbsp;</a></span>Init_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Parallel_reader_adapter::Init_fn</a> =  <a class="el" href="classhandler.html#a6aa6c4d02e61680defa11a4081f1e24b">handler::Load_init_cbk</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad6fcaac320623ea3f682b08178df9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6fcaac320623ea3f682b08178df9e2">&#9670;&nbsp;</a></span>Load_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Parallel_reader_adapter::Load_fn</a> =  <a class="el" href="classhandler.html#af9d8794466270fec22f8a676eaa0c90a">handler::Load_cbk</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e53cebc59f4449673c4810b078c5cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e53cebc59f4449673c4810b078c5cfc">&#9670;&nbsp;</a></span>Parallel_reader_adapter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parallel_reader_adapter::Parallel_reader_adapter </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rowlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_threads</td><td>Maximum threads to use for all scan contexts. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowlen</td><td>Row length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a701c92aeb46745e547f35ee49c27e404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701c92aeb46745e547f35ee49c27e404">&#9670;&nbsp;</a></span>~Parallel_reader_adapter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parallel_reader_adapter::~Parallel_reader_adapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff138cfc91bbe2b50b7291f03ed96515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff138cfc91bbe2b50b7291f03ed96515">&#9670;&nbsp;</a></span>add_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader_adapter::add_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structParallel__reader_1_1Config.html">Parallel_reader::Config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader.html#afb76966c3a4f93141e5c586a98b82845">Parallel_reader::F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add scan context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>Transaction used for parallel read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>(Cluster) Index scan configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a06ff82664e9cf94ea333db2cbc7201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a06ff82664e9cf94ea333db2cbc7201">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader_adapter::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel__reader_1_1Thread__ctx.html">Parallel_reader::Thread_ctx</a> *&#160;</td>
          <td class="paramname"><em>reader_thread_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each parallel reader thread's end function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader_thread_ctx</td><td>context info related to the current thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code. </dd></dl>

</div>
</div>
<a id="ac977338cbd5f745f92ce8e537b18c19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac977338cbd5f745f92ce8e537b18c19c">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader_adapter::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel__reader_1_1Thread__ctx.html">Parallel_reader::Thread_ctx</a> *&#160;</td>
          <td class="paramname"><em>reader_thread_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each parallel reader thread's init function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader_thread_ctx</td><td>context info related to the current thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code. </dd></dl>
<p>There are data members in row_prebuilt_t that cannot be accessed in multi-threaded mode e.g., blob_heap.</p>
<p>row_prebuilt_t is designed for single threaded access and to share it among threads is not recommended unless "you know what you are doing". This is very fragile code as it stands.</p>
<p>To solve the blob heap issue in prebuilt we request parallel reader thread to use blob heap per thread and we pass this blob heap to the InnoDB to MySQL row format conversion function. </p>

</div>
</div>
<a id="a6ff099e4c9ee4850f1726b97577f4b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff099e4c9ee4850f1726b97577f4b88">&#9670;&nbsp;</a></span>is_buffer_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Parallel_reader_adapter::is_buffer_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel__reader__adapter_1_1Thread__ctx.html">Thread_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>adapter related thread context information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer is full. </dd></dl>

</div>
</div>
<a id="a4e9883b3fef38057254ca86ca841fdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9883b3fef38057254ca86ca841fdf6">&#9670;&nbsp;</a></span>pending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Parallel_reader_adapter::pending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel__reader__adapter_1_1Thread__ctx.html">Thread_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of rows buffered but not sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>adapter related thread context information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of buffered items. </dd></dl>

</div>
</div>
<a id="a43e31861f8a9ffd4e0240a2aedad3dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e31861f8a9ffd4e0240a2aedad3dbd">&#9670;&nbsp;</a></span>process_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader_adapter::process_rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel__reader_1_1Ctx.html">Parallel_reader::Ctx</a> *&#160;</td>
          <td class="paramname"><em>reader_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the record in InnoDB format to MySQL format and send them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader_ctx</td><td>Parallel read context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a id="aeac8122fc90cfb61ef9bdda538d380d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac8122fc90cfb61ef9bdda538d380d8">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader_adapter::run </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>thread_contexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Init_fn</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Load_fn</a>&#160;</td>
          <td class="paramname"><em>load_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">End_fn</a>&#160;</td>
          <td class="paramname"><em>end_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the parallel scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_contexts</td><td>Context for each of the spawned threads </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback called by each parallel load thread at the beginning of the parallel load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_fn</td><td>Callback called by each parallel load thread when processing of rows is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_fn</td><td>Callback called by each parallel load thread when processing of rows has ended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code. </dd></dl>

</div>
</div>
<a id="abaa7796944f445c2c74add42a913b65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa7796944f445c2c74add42a913b65d">&#9670;&nbsp;</a></span>send_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader_adapter::send_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel__reader_1_1Thread__ctx.html">Parallel_reader::Thread_ctx</a> *&#160;</td>
          <td class="paramname"><em>reader_thread_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>partition_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n_recs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a batch of records. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader_thread_ctx</td><td>reader threads related thread context info </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partition_id</td><td>partition ID of the index the record belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_recs</td><td>Number of records to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code. </dd></dl>

</div>
</div>
<a id="a69fe8213720845da80fea091a92ae469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fe8213720845da80fea091a92ae469">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader_adapter::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the query processing state cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt</td><td>The prebuilt cache for the query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acf52b41d48666b315acf73892924a141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf52b41d48666b315acf73892924a141">&#9670;&nbsp;</a></span>ADAPTER_SEND_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Parallel_reader_adapter::ADAPTER_SEND_BUFFER_SIZE = 2 * 1024 * 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the buffer used to store InnoDB records and sent to the adapter. </p>

</div>
</div>
<a id="a3a8eaa687560de6b923ab15699468daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8eaa687560de6b923ab15699468daf">&#9670;&nbsp;</a></span>m_batch_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Parallel_reader_adapter::m_batch_size {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of records to be sent across to the caller in a batch. </p>

</div>
</div>
<a id="afb3e35be4cbbbaec5c5b7999c7c465ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3e35be4cbbbaec5c5b7999c7c465ff">&#9670;&nbsp;</a></span>m_end_fn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader__adapter.html#aa757b9e4ec4605e11f70f332c23775e8">End_fn</a> Parallel_reader_adapter::m_end_fn {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback called by each parallel load thread when processing of rows has ended for the scan. </p>

</div>
</div>
<a id="a5cb1a06e64161316c4cd8605a1a1013e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb1a06e64161316c4cd8605a1a1013e">&#9670;&nbsp;</a></span>m_init_fn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader__adapter.html#a71c565baaa1b962867200f2897c410f6">Init_fn</a> Parallel_reader_adapter::m_init_fn {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback called by each parallel load thread at the beginning of the parallel load for the scan. </p>

</div>
</div>
<a id="a9c49a6ba83cc5600b60a079565f3a412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c49a6ba83cc5600b60a079565f3a412">&#9670;&nbsp;</a></span>m_load_fn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader__adapter.html#aad6fcaac320623ea3f682b08178df9e2">Load_fn</a> Parallel_reader_adapter::m_load_fn {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback called by each parallel load thread when processing of rows is required for the scan. </p>

</div>
</div>
<a id="ad6c51a4c427fc7d96b4c4c65bbe6678d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c51a4c427fc7d96b4c4c65bbe6678d">&#9670;&nbsp;</a></span>m_mysql_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structParallel__reader__adapter_1_1MySQL__row.html">MySQL_row</a> Parallel_reader_adapter::m_mysql_row {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Row meta data per scan context. </p>

</div>
</div>
<a id="ac8e985db2d826c9b87ed9121cc895dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e985db2d826c9b87ed9121cc895dd8">&#9670;&nbsp;</a></span>m_parallel_reader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader.html">Parallel_reader</a> Parallel_reader_adapter::m_parallel_reader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel reader to use. </p>

</div>
</div>
<a id="a994366571853eb55b0be6bc24b981877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994366571853eb55b0be6bc24b981877">&#9670;&nbsp;</a></span>m_prebuilt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a>* Parallel_reader_adapter::m_prebuilt {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prebuilt to use for conversion to MySQL row format. </p>
<p>NOTE: We are sharing this because we don't convert BLOBs yet. There are data members in row_prebuilt_t that cannot be accessed in multi-threaded mode e.g., blob_heap.</p>
<p>row_prebuilt_t is designed for single threaded access and to share it among threads is not recommended unless "you know what you are doing". This is very fragile code as it stands.</p>
<p>To solve the blob heap issue in prebuilt we use per thread m_blob_heaps. Pass the blob heap to the InnoDB to MySQL row format conversion function. </p>

</div>
</div>
<a id="aee25a5e3046bd5be9043d1fad0a2b364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee25a5e3046bd5be9043d1fad0a2b364">&#9670;&nbsp;</a></span>m_thread_ctxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void** Parallel_reader_adapter::m_thread_ctxs {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adapter context for each of the spawned threads. </p>
<p>We don't know the type of the context it's passed to us as a void *. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>storage/innobase/include/<a class="el" href="row0pread-adapter_8h_source.html">row0pread-adapter.h</a></li>
<li>storage/innobase/row/<a class="el" href="row0pread-adapter_8cc.html">row0pread-adapter.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classParallel__reader__adapter.html">Parallel_reader_adapter</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
